{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"利用hexo搭建个人博客","text":"基于hexo搭建个人博客1.安装nodejs 2.添加淘宝源 1npm install -g cnpm --registry=https://registry.npm.taobao.org 3.安装hexo 1cnpm install -g hexo-cli 4.创建空文件夹 5.切换到空文件夹 6.生成 1sudo hexo init 7.新建github仓库 仓库名必须为 用户名.github.io 8. cnpm install –save hexo-deployer-git 9.设置_config.yml 配置(repo为仓库地址，使用ssh可能会提示权限错误，更改https地址后，删除./deploygit文件夹，重新部署。) 1234deploy: type: git repo: https://github.com/sjtu-xx/sjtu-xx.github.io.git branch: master 1hexo d #部署 10.更换主题 将主题下载到theme文件夹下，然后更改_config.yml中的theme文件 123hexo cleanhexo generatehexo deploy 遇到的问题： 插入图片： https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/ icarus主题详细配置： https://cloudy-liu.github.io/2019/06/23/Hexo%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB%E5%88%B0icarus/","link":"/2019/11/18/%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"C++ Primer读书笔记(第一部分：C++基础)","text":"3.字符串、向量和数组命名空间using声明 每个名字都需要独立的using声明 头文件不应该使用using声明 string类型 string对象会自动忽略开头的空白，从第一个非空的字符开始读起，直到另一个空白为止。 读取整行：getline(cin,line) size()函数返回的是size_type类型，是一个无符号整型，避免与有符号类型混用（如果一个表达式有size()就不要用int了，避免问题） 不能把字面值直接相加：“1”+“2” //错误 vector vector是一个类模版 尽量使用vector而不是数组+指针 vector中能存放绝大多数对象，引用不是对象，不能存放到vector中 添加元素：push_back() vector能实现高速的增长，因此没必要在定义时初始化vector大小 迭代器 *iter 返回迭代器所指元素的引用 Iter-&gt;mem 解引用iter并获取该元素的名为mem的成员等价于(*iter).mem ++iter 令iter指向下一个元素 –iter 令iter指向上一个元素 iter1!=iter2 指向同一个元素时两者相等 Iter1==iter2 所有标准库和迭代器都定义了==和!=，有些没定义&lt;，因此使用迭代器时要习惯使用!= v.begin()，v.end()返回第一个元素的指针，尾后元素 Iter1-iter2返回difference_type，为带符号整数 数组 数组大小固定 数组的下标最好定义为size_t类型 std::begin(a) 返回第一个元素 多维数组 int *p[4]; //整形指针的数组 int (*p)[4]; //指向含有4个指针的数组 别名： 123typedef double wages;typedef int int_array[4]; //using int_array = int[4]; //别名声明 4.表达式基础 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内容中的位置） 在需要右值的时候可以使用左值来代替，但是不能把右值当成左值使用。当一个左值被当成右值使用时，实际使用的是他的内容（值）。 布尔值不应该参与运算。（如：bool b = true; bool b2=-b,此时b2为true） 赋值运算符满足右结合率（a=b=0,ab均为0） 除非必须，否则不用递增递减运算符的后置版本（++i，将+后的值返回） （*pbeg++）等价于*(pbeg++)将返回pbeg处的值，同时将指向的位置加一 几个特殊的运算符 成员访问运算符 p-&gt;size()等价于(*p).size() 条件运算符 ？： cond?expr1:expr2; 嵌套条件运算符 cond1?expr1:cond2?expr2:expr3; sizeof运算符，返回表达式或类型名字所占的字节数,类型为size_t sizeof（type） sizeof expr vector&lt;int&gt;::size_type ix=0 逗号运算符，首先对左边的表达式求值，然后将求值结果丢弃，逗号运算符真正的结果是右侧表达式的值。 隐式类型转换 整型提升 无符号类型转换 无符号数与有符号数运算，如果无符号类型不小于有符号类型，则将有符号对象转换为无符号对象。 数组转换成指针 指针的转换 常量整数值0或者字面值nullptr能转换成任意指针类型 指向任意非常量的指针能转换成void* 指向任意对象的指针能转换成const void * 转换成布尔类型 存在一种从算数类型或指针类型向布尔类型自动转换的机制 转换成常量 允许将指向非常量类型的指针转换成指向相应常量类型的指针。 类类型的转换 显式转换static_cast/dynamic_cast/const_cast/reinterpret_cast static_cast 定义明确的类型转换double slope = static_cast&lt;double&gt;(j)/i 找回void*指针 12void *p = &amp;d;double *dp = static_cast&lt;double*&gt;(p) const_cast 只能改变运算对象底层的const，不能改变变量的类型 12const char *pc;char *p=const_cast&lt;char*&gt;(pc); 5.语句简单语句 使用空语句应当加上注释 switch语句case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式。 break语句负责终止离他最近的while、do while、for或switch语句，并从这些语句之后的第一条语句开始执行。 不要在程序中使用goto语句。 异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char * 6.函数函数基础 可以使用void表示函数没有形参 12void f1(){}void f2(void){} 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。 局部对象 自动对象（在块末尾销毁） 局部静态对象（在程序的执行路径第一次经过对象定义的语句时初始化，并且直到程序终止时才被销毁，在此期间，即使对象所在的函数结束执行也不会对他有影响） 12345678910size_t count_calls(){ static size_t ctr = 0; return ++ctr;}int main(){ for (size_t i=0;i!=10;++i){ cout&lt;&lt;count_calls()&lt;&lt;endl; } return 0;} 函数声明 函数的声明和函数的定义类似，唯一的区别是函数声明无需函数体，用一个分号替代即可 1int sum(const int &amp;a, const int &amp;b); 变量为头文件中声明，源文件中定义 函数在头文件中声明，源文件中定义 含有函数声明的头文件应该被包含到定义函数的源文件中 分离式编译 1g++ main.cpp func.cpp -o mian //func函数在main中调用 分离式编译 123cc -c main.cpp # main编译到mian.occ -c func.cpp #func编译到func.occ main.o func.o -o main #生成main.exe 参数传递 如果函数无需改变引用形参的值，最好将其声明为常量引用 当用实参初始化形参时会忽略掉顶层的const。换句话说，形参的顶层const被忽略掉了。 不能将普通引用绑定到const对象上。 不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。 int main(int argc, char argv[]){} 等价int main(int argc, char *argv){} 数组形参 const int ia[]等价于const int *ia matrix指向数组的首元素，该数组的元素是由10个整数构成的数组 12void print(int (*matrix)[10], int rowsize){}void print(int matrix[][10], int rowsize){} 含有可变形参的函数 为了能够编写处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模版。 initializer_list&lt;string&gt; a 向initializer_list中传递一个值的序列，必须把序列放在花括号内。 不要返回局部对象的引用或指针 调用一个返回引用的函数得到左值。可以像使用其他左值那样来使用返回引用的函数的调用 123456789char &amp;get_val(string &amp;str, string::size_type ix){ return str[ix];}int main(){ string s(\"a value\"); cout &lt;&lt; s&lt;&lt;endl; //输出为a value get_val(s,0)='A'; //将s[0]改为A cout &lt;&lt; s &lt;&lt; endl; //输出为A value} 返回数组的指针 123456int (*func(int i))[10]; //使用别名typedef int arrT[10];using arrT=int[10]; //与上句等价arrT* func(int i ); 重载和const形参 1Record lookup(Phone); 对于接受引用或指针的函数来说，对象是常量还是非常量对应形参不同。 123456//四个独立的重载函数Record lookup(Account&amp;); //函数作用于Account的引用Record lookup(const Account&amp;); //新函数，作用于常量引用Record lookup(Account*); //新函数，作用于指向Account的指针Record lookup(const Account*); //新函数，作用于指向常量的指针 一旦某个形参被赋予了默认值，他后面的所有形参必须有默认值 对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。在给定的作用域中，一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参后侧的所有形参必须有默认值。 内联inline只是向编译器发出一个请求，编译器可以选择忽略这个请求。 内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数。 constexpr函数 定义constexpr与其他函数类似，但是要注意：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体必须有且仅有一条return语句。 1constexpr int new_sz(){return 42;} constexpr被隐式的指定为内联函数。 constexpr函数体也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。 constexpr函数不一定返回常量表达式。 对于某个给定的内联函数或者constexpr函数来说，他的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。 调试帮助 assert预处理宏 assert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此可以直接使用预处理名字而无需提供using声明。 NDEBUG预处理变量 我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。 命令行关闭 1CC -D NDEBUG main.c 函数指针 声明指向函数的指针 1bool (*pf)(const string &amp;); 当把函数名作为一个值使用时，函数自动的转换成指针。 使用重载函数的指针时，指针类型必须与重载函数中的一个精确匹配。 1234void ff(int*);void ff(unsigned int);void (*pf1)(unsigned int) = ff; 形参可以是指向函数的指针 123456//第三个参数是函数类型，他会自动转换成函数指针void useBigger(const string &amp;s1,const string &amp;s2, bool pf(const stirng &amp;,const string &amp;));//等价的声明void useBigger(const string &amp;s1,const string &amp;s2, bool （*pf）(const stirng &amp;,const string &amp;)); 简化使用了函数指针的代码 1234567//Func和Func2是函数类型typedef bool Func(const string &amp;, const string &amp;);typedef decltype(lengthCompare) Func2;//FuncP和FuncP2是函数指针typedef bool(*FuncP)(const sting &amp;, const string &amp;);typedef decltype(lengthCompare) *FuncP2; 返回指向函数的指针 1234567using F = int(int*,int); //F是函数类型，不是指针using PF = int (*)(int*, int); //PF是指针F *f1(int);PF f1(int);int (*f1(int))(int*,int); 7.类 成员函数的声明必须在类的内部，他的定义则既可以在类的内部，也可以在类的外部。 12//这里const的作用是修改隐式this指针的类型string isbn() const {return this-&gt;bookNo;} 类外部定义的成员的名字必须包含他所属的类名。 class和struct的唯一区别是默认访问权限不同。struct中，定义在第一个访问说明符之前的成员是public的。class是private。 构造函数 编译器只有在类没有任何构造函数的情况下替我们生成一个默认的构造函数。 编译器不能为某些类合成默认的构造函数。 在C++11标准中如果我们需要默认的构造函数，可以在函数列表后面写上=default来要求编译器生成构造函数。 友元 类可以允许其他类或者函数访问他的非公有成员，方法是令其他类或者函数成为他们的友元。 最好在类定义开始或结束前的位置集中声明友元。 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 类的其他特性 定义在类内部的成员函数自动是inline的。 定义在类外部的成员函数如果要设定为inline的，最好只在类外部定义的地方说明。 inline成员函数也应该与相应的类定义在同一个头文件中。 可变数据成员 我们以往能改变类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。 1mutable int a; 当我们提供一个类内初始值时，必须以符号=或或括号表示。 一个const 成员函数如果以引用的形式返回*this，那么他的返回类型将是一个常量引用。 类的声明 12Sales_data item1;class Sales_data item1; //等价的声明 一个类的成员类型不能是类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了，因此类允许包含指向他自身类型的引用或指针。 12345class Link_screen{ Screen window; Link_screen *next; Link_screen *prev;} 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。 当把一个成员函数声明为友元时，必须明确指出该成员函数属于哪个类。 如果一个类想把一组重载函数声明为他的友元，他需要对这组函数中的每一个进行分别声明； 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义后。 使用全局作用域中的变量 ::a 再探构造函数 成员的初始化顺序与他们在类定义中出现的顺序一致。构造函数初始值列表中初始值的先后位置关系不会影响实际的初始化顺序。 最好令构造函数的初始值的顺序与成员声明的顺序一致。而且如果可能的话，尽量避免使用某些成员初始化另一些成员。 委托构造函数 12345678910class Sales_data{ public: //非委托构造函数使用对应的实参初始化成员 Sales_data(std::string s, unsigned cnt, double price): bookNo(s),units_sold(cnt),revenue(cnt * price){} //其余构造函数全部委托给另一个构造函数 Sales_data():Sales_data(\"\", 0, 0){} Sales_data(std::string s):Sales_data(s, 0, 0){} Sales_data(std:istream &amp;is):Sales_data(){read(is,*this);}} 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。 如果定义了其他构造函数，最好也提供一个默认的构造函数。 使用默认构造函数 12Sales_data obj; //正确Sales_data obj(); //错误，实际上定义了一个函数 抑制构造函数定义的隐式转换 使用explicit 关键字 explicit构造函数只能直接初始化不能使用拷贝形式的初始化。 聚合类 类的静态成员 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。 静态成员函数不能声明称const 的，而且我们也不能在static函数体内使用this指针。 虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或指针来访问静态成员。 12345Account ac1;Account &amp;ac2;r = ac1.rate();r = ac2-&gt;rate(); 当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句： 要想确保对象只定义一次，最好的办法是把静态的数据成员的定义与其他非内联函数的定义放在同一个文件中。 通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成他所属的类的指针或饮用。 12345678class Bar{ public: //... private: static Bar mem1; //正确：静态成员可以是不完全类型 Bar *mem2; //正确：指针成员可以是不完全类型 Bar mem3; //错误：数据成员必须是完全类型} 可以使用静态成员作为默认实参 123456class Screen{ public: screen&amp; clear(char = bkground); private: static const char bkground;} 非静态数据成员不能作为默认实参，因为他的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。","link":"/2019/11/19/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9AC-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"个人博客","slug":"个人博客","link":"/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]}