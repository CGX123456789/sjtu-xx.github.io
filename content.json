{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Abaqus后处理常用技术","text":"后处理 保存图片File -&gt; Print -&gt; 查看指定增量步的结果Result -&gt; Step/Frame 创建显示组Tools-&gt; Display Group -&gt; Create 显示窗口widget设置Viewport-&gt;Viewport Annotion options-&gt; 后处理不显示网格Options -&gt; Common -&gt; 设置透明背景 View-&gt;graphic options 设置超出设定范围的colorbar颜色Options-&gt; Contour -&gt;Spectrum-&gt;Greater than max;","link":"/2019/11/28/Abaqus%E5%90%8E%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"title":"C++ Primer读书笔记(第一部分：C++基础)","text":"1.开始 输出运算符和输入运算符类似，都返回其左侧运算对象作为其计算结果 从键盘输入文件结束符 在windows系统中，Ctrl+Z，然后按Enter或Return键 在Unix系统中，文件结束符是Ctrl+D 使用文件重定向12# addItems.exe是可执行文件，下面的命令将从一个infile的文件读取销售记录到cin，并将结果（cout）写入到一个名为outfile的文件中。addItems &lt;infile &gt;outfile 2.变量和基本类型 寻址的最小单元为byte 存储的基本单元为字 通常float以1个字（32比特）表示，double为2个字（64比特），long double以3/4个字表示。 char类型会表现为带符号或者无符号的，具体视编译器而定。 当我们给带符号类型一个超出他表示范围的值时，结果是未定义的。此时，可能可以继续工作也可能崩溃或产生垃圾数据。 变量初始化 1234int unit_sold = 0;int unit_sold = {0}; //列表初始化int unit_sold{0}; //列表初始化int unit_sold(0); 在函数体内部，如果试图初始化一个extern关键字标记的变量，将引发错误。 变量只能被定义一次，但可以被多次声明 12extern int i; //声明iint i; //声明并定义i 在内层作用域中访问外层作用域可以使用操作域符::value 复合类型 一条声明语句由一个基本数据类型和一个紧随其后的声明符列表组成。 &amp;和*符号12345678//&amp;和*的上下文决定了符号的意义//在声明语句中，&amp;和*用于组成复合类型；在表达式中，他们的角色有转变成运算符。 int i = 42; int &amp;r = i; //&amp;紧随类型名出现，因此是声明的一部分，r是一个引用 int *p; //*紧随类型名出现，因此是声明的一部分，p是一个指针 p = &amp;i; //&amp;出现在表达式中，是一个取地址符 *p = i; //*出现在表达式中，是一个解引用符 int &amp;r2 = *p; //&amp;是声明的一部分，*是解引用符。 引用 引用必须被初始化，一旦初始化完成，引用将和他的初始值对象一直绑定在一在。 因为引用本身不是一个对象，所以不能定义引用的引用。 指针 建议初始化所有指针。 指向指针的引用123int i = 42;int *p;int *&amp;r = p; //离变量名最近的符号对变量的类型由最直接的影响，因此，r是一个引用 const限定符 const对象必须初始化 建议：对于const变量，不管是声明还是定义，都添加extern关键字，这样只需定义一次就可以了。 指针和const 12const double pi = 3.14;const double *cptr = &amp;pi; //指向常量的指针 顶层const 顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量。 一般的，顶层const可以表示任意的对象是常量，这点对任意数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是指针类型既可以是顶层const，也可以是底层const。 当执行对象的拷贝操作时，顶层const不受什么影响。底层const能忽视，非常量可以转换成常量，反之则不行。123456789101112131415int i = 0;int *const p1 = &amp;i; //不能改变p1的值，这是一个顶层constconst int ci = 42; //不能改变ci的值，这是一个顶层constconst int *p2 = &amp;ci; //允许改变p2的值，这是一个底层constconst int *const p3 = p2; //靠右的const是顶层const，靠左的是底层constconst int &amp;r = ci; //用于引用的const都是底层const// 拷贝ci的值i = ci; //正确，拷贝ci的值，ci是一个顶层constp2 = p3; //正确：p2和p3指向的对象类型相同，p3顶层const部分不受影响// 底层const不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。int *p = p3; //错误：p3包含底层const的定义，而p没有p2 = p3; //正确：p2和p3都是底层constp2 = &amp;i； //正确：int*能转换成const int *int &amp;r = ci; //错误：不同的int&amp;不能绑定到int常量上const int &amp;r2 = i; //正确：const int&amp;可以绑定到一个普通int上 字面值类型 常量表达式的值在编译时就得到类型，因此对声明constexpr时用到的类型必须有所限制。算术类型、指针和引用都属于字面值类型。自定义类型，IO库和string类型不属于字面值类型 auto类型说明符 auto一般会忽略顶层const，底层const会保留下来。 decltype和引用 如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上一层或多层括号，编译器就会把他当成一个表达式。123//decltype((variable))的结果永远是引用，而decltype(variable)的结果只有当variable本身是引用时才是引用。decltype((i)) &amp;d; //错误d是一个int&amp;, 必须初始化decltype(i) e; //e是一个未初始化的int 自定义数据结构struct 和 class定义时花括号后面要加分号 1struct Sales{}; 类内初始化或者放在花括号里，或者放在等号右边，记住不能使用圆括号。 头文件保护符1234#ifndef SALES_DATA_H#define SALES_DATA_Hstruct sales{};#endif 3.字符串、向量和数组命名空间using声明 每个名字都需要独立的using声明 头文件不应该使用using声明 string类型 string对象会自动忽略开头的空白，从第一个非空的字符开始读起，直到另一个空白为止。 读取整行：getline(cin,line) size()函数返回的是size_type类型，是一个无符号整型，避免与有符号类型混用（如果一个表达式有size()就不要用int了，避免问题） 不能把字面值直接相加：“1”+“2” //错误 vector vector是一个类模版 尽量使用vector而不是数组+指针 vector中能存放绝大多数对象，引用不是对象，不能存放到vector中 添加元素：push_back() vector能实现高速的增长，因此没必要在定义时初始化vector大小 迭代器 *iter 返回迭代器所指元素的引用 Iter-&gt;mem 解引用iter并获取该元素的名为mem的成员等价于(*iter).mem ++iter 令iter指向下一个元素 –iter 令iter指向上一个元素 iter1!=iter2 指向同一个元素时两者相等 Iter1==iter2 12345vector&lt;int&gt;::iterator it; //读写元素string::iterator s; //读写字符vector&lt;int&gt;::const_iterator cit; //读元素string::const_iterator cs; //读字符 所有标准库和迭代器都定义了==和!=，有些没定义&lt;，因此使用迭代器时要习惯使用!= 养成使用!=的习惯 v.begin()，v.end()返回第一个元素的指针，尾后元素 v.cbegin(), v.cend()返回const_iterator Iter1-iter2返回difference_type，为带符号整数 数组 数组大小固定 数组的下标最好定义为size_t类型 std::begin(a) 返回第一个元素 多维数组 int *p[4]; //整形指针的数组 int (*p)[4]; //指向含有4个指针的数组 别名： 123typedef double wages;typedef int int_array[4]; //using int_array = int[4]; //别名声明 4.表达式基础 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内容中的位置） 在需要右值的时候可以使用左值来代替，但是不能把右值当成左值使用。当一个左值被当成右值使用时，实际使用的是他的内容（值）。 布尔值不应该参与运算。（如：bool b = true; bool b2=-b,此时b2为true） 赋值运算符满足右结合率（a=b=0,ab均为0） 除非必须，否则不用递增递减运算符的后置版本（++i，将+后的值返回） （*pbeg++）等价于*(pbeg++)将返回pbeg处的值，同时将指向的位置加一 几个特殊的运算符 成员访问运算符 p-&gt;size()等价于(*p).size() 条件运算符 ？： cond?expr1:expr2; 嵌套条件运算符 cond1?expr1:cond2?expr2:expr3; sizeof运算符，返回表达式或类型名字所占的字节数,类型为size_t sizeof（type） sizeof expr vector&lt;int&gt;::size_type ix=0 逗号运算符，首先对左边的表达式求值，然后将求值结果丢弃，逗号运算符真正的结果是右侧表达式的值。 隐式类型转换 整型提升 无符号类型转换 无符号数与有符号数运算，如果无符号类型不小于有符号类型，则将有符号对象转换为无符号对象。 数组转换成指针 指针的转换 常量整数值0或者字面值nullptr能转换成任意指针类型 指向任意非常量的指针能转换成void* 指向任意对象的指针能转换成const void * 转换成布尔类型 存在一种从算数类型或指针类型向布尔类型自动转换的机制 转换成常量 允许将指向非常量类型的指针转换成指向相应常量类型的指针。 类类型的转换 显式转换static_cast/dynamic_cast/const_cast/reinterpret_cast static_cast 定义明确的类型转换double slope = static_cast&lt;double&gt;(j)/i 找回void*指针 12void *p = &amp;d;double *dp = static_cast&lt;double*&gt;(p) const_cast 只能改变运算对象底层的const，不能改变变量的类型 12const char *pc;char *p=const_cast&lt;char*&gt;(pc); 5.语句简单语句 使用空语句应当加上注释 switch语句case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式。 每一个case都要加break;包括default。 break语句负责终止离他最近的while、do while、for或switch语句，并从这些语句之后的第一条语句开始执行。 不要在程序中使用goto语句。 异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char * 标准异常4个异常相关的头文件 exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外的信息。 stdexcept头文件定义了几种常用的异常类。 new头文件定义了bad_alloc异常类型。 type_info头文件定义了bad_cast异常类型。 stdexcept头文件定义的异常列表 exception 最常见的问题 runtime_error 只有在运行时才能检测出来的问题 range_error 运行时错误：生成的结果超出了范围 overflow_error 运行时错误：计算上溢 underflow_error 运行时错误：计算下溢 logic_error 程序逻辑错误 domain_error 逻辑错误：参数对应的值不存在 incalid_argument 逻辑错误：无效参数 length_error 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range 逻辑错误：使用超出范围的值 异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char *（内容为异常对象的字符串初始值） 6.函数函数基础 可以使用void表示函数没有形参 12void f1(){}void f2(void){} 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。 局部对象 自动对象（在块末尾销毁） 局部静态对象（在程序的执行路径第一次经过对象定义的语句时初始化，并且直到程序终止时才被销毁，在此期间，即使对象所在的函数结束执行也不会对他有影响） 12345678910size_t count_calls(){ static size_t ctr = 0; return ++ctr;}int main(){ for (size_t i=0;i!=10;++i){ cout&lt;&lt;count_calls()&lt;&lt;endl; } return 0;} 函数声明 函数的声明和函数的定义类似，唯一的区别是函数声明无需函数体，用一个分号替代即可 1int sum(const int &amp;a, const int &amp;b); 变量为头文件中声明，源文件中定义 函数在头文件中声明，源文件中定义 含有函数声明的头文件应该被包含到定义函数的源文件中 分离式编译 1g++ main.cpp func.cpp -o mian //func函数在main中调用 分离式编译 123cc -c main.cpp # main编译到mian.occ -c func.cpp #func编译到func.occ main.o func.o -o main #生成main.exe 参数传递 如果函数无需改变引用形参的值，最好将其声明为常量引用 当用实参初始化形参时会忽略掉顶层的const。换句话说，形参的顶层const被忽略掉了。 不能将普通引用绑定到const对象上。 不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。 int main(int argc, char argv[]){} 等价int main(int argc, char *argv){} 数组形参 const int ia[]等价于const int *ia matrix指向数组的首元素，该数组的元素是由10个整数构成的数组 12void print(int (*matrix)[10], int rowsize){}void print(int matrix[][10], int rowsize){} 含有可变形参的函数 为了能够编写处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模版。 initializer_list&lt;string&gt; a 向initializer_list中传递一个值的序列，必须把序列放在花括号内。12345void error_msg(initializer_list&lt;string&gt; il){ for (auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; end; cout &lt;&lt; endl;} 不要返回局部对象的引用或指针 调用一个返回引用的函数得到左值。可以像使用其他左值那样来使用返回引用的函数的调用 123456789char &amp;get_val(string &amp;str, string::size_type ix){ return str[ix];}int main(){ string s(\"a value\"); cout &lt;&lt; s&lt;&lt;endl; //输出为a value get_val(s,0)='A'; //将s[0]改为A cout &lt;&lt; s &lt;&lt; endl; //输出为A value} 返回数组的指针 123456int (*func(int i))[10]; //使用别名typedef int arrT[10];using arrT=int[10]; //与上句等价arrT* func(int i ); 重载和const形参 1Record lookup(Phone); 对于接受引用或指针的函数来说，对象是常量还是非常量对应形参不同。 123456//四个独立的重载函数Record lookup(Account&amp;); //函数作用于Account的引用Record lookup(const Account&amp;); //新函数，作用于常量引用Record lookup(Account*); //新函数，作用于指向Account的指针Record lookup(const Account*); //新函数，作用于指向常量的指针 一旦某个形参被赋予了默认值，他后面的所有形参必须有默认值 对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。在给定的作用域中，一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参后侧的所有形参必须有默认值。 内联inline只是向编译器发出一个请求，编译器可以选择忽略这个请求。 内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数。 constexpr函数 定义constexpr与其他函数类似，但是要注意：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体必须有且仅有一条return语句。 1constexpr int new_sz(){return 42;} constexpr被隐式的指定为内联函数。 constexpr函数体也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。 constexpr函数不一定返回常量表达式。 对于某个给定的内联函数或者constexpr函数来说，他的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。 调试帮助 assert预处理宏 assert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此可以直接使用预处理名字而无需提供using声明。 NDEBUG预处理变量 我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。 命令行关闭 1CC -D NDEBUG main.c 函数指针 声明指向函数的指针 1bool (*pf)(const string &amp;); 当把函数名作为一个值使用时，函数自动的转换成指针。 使用重载函数的指针时，指针类型必须与重载函数中的一个精确匹配。 1234void ff(int*);void ff(unsigned int);void (*pf1)(unsigned int) = ff; 形参可以是指向函数的指针 123456//第三个参数是函数类型，他会自动转换成函数指针void useBigger(const string &amp;s1,const string &amp;s2, bool pf(const stirng &amp;,const string &amp;));//等价的声明void useBigger(const string &amp;s1,const string &amp;s2, bool （*pf）(const stirng &amp;,const string &amp;)); 简化使用了函数指针的代码 1234567//Func和Func2是函数类型typedef bool Func(const string &amp;, const string &amp;);typedef decltype(lengthCompare) Func2;//FuncP和FuncP2是函数指针typedef bool(*FuncP)(const sting &amp;, const string &amp;);typedef decltype(lengthCompare) *FuncP2; 返回指向函数的指针 1234567using F = int(int*,int); //F是函数类型，不是指针using PF = int (*)(int*, int); //PF是指针F *f1(int);PF f1(int);int (*f1(int))(int*,int); 7.类 成员函数的声明必须在类的内部，他的定义则既可以在类的内部，也可以在类的外部。 12//这里const的作用是修改隐式this指针的类型string isbn() const {return this-&gt;bookNo;} 类外部定义的成员的名字必须包含他所属的类名。 class和struct的唯一区别是默认访问权限不同。struct中，定义在第一个访问说明符之前的成员是public的。class是private。 构造函数 编译器只有在类没有任何构造函数的情况下替我们生成一个默认的构造函数。 编译器不能为某些类合成默认的构造函数。 在C++11标准中如果我们需要默认的构造函数，可以在函数列表后面写上=default来要求编译器生成构造函数。 友元 类可以允许其他类或者函数访问他的非公有成员，方法是令其他类或者函数成为他们的友元。 最好在类定义开始或结束前的位置集中声明友元。 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 类的其他特性 定义在类内部的成员函数自动是inline的。 定义在类外部的成员函数如果要设定为inline的，最好只在类外部定义的地方说明。 inline成员函数也应该与相应的类定义在同一个头文件中。 可变数据成员 我们以往能改变类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。 1mutable int a; 当我们提供一个类内初始值时，必须以符号=或或括号表示。 一个const 成员函数如果以引用的形式返回*this，那么他的返回类型将是一个常量引用。 类的声明 12Sales_data item1;class Sales_data item1; //等价的声明 一个类的成员类型不能是类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了，因此类允许包含指向他自身类型的引用或指针。 12345class Link_screen{ Screen window; Link_screen *next; Link_screen *prev;} 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。 当把一个成员函数声明为友元时，必须明确指出该成员函数属于哪个类。 如果一个类想把一组重载函数声明为他的友元，他需要对这组函数中的每一个进行分别声明； 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义后。 使用全局作用域中的变量 ::a 再探构造函数 成员的初始化顺序与他们在类定义中出现的顺序一致。构造函数初始值列表中初始值的先后位置关系不会影响实际的初始化顺序。 最好令构造函数的初始值的顺序与成员声明的顺序一致。而且如果可能的话，尽量避免使用某些成员初始化另一些成员。 委托构造函数 12345678910class Sales_data{ public: //非委托构造函数使用对应的实参初始化成员 Sales_data(std::string s, unsigned cnt, double price): bookNo(s),units_sold(cnt),revenue(cnt * price){} //其余构造函数全部委托给另一个构造函数 Sales_data():Sales_data(\"\", 0, 0){} Sales_data(std::string s):Sales_data(s, 0, 0){} Sales_data(std:istream &amp;is):Sales_data(){read(is,*this);}} 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。 如果定义了其他构造函数，最好也提供一个默认的构造函数。 使用默认构造函数 12Sales_data obj; //正确Sales_data obj(); //错误，实际上定义了一个函数 抑制构造函数定义的隐式转换 使用explicit 关键字 explicit构造函数只能直接初始化不能使用拷贝形式的初始化。 聚合类 类的静态成员 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。 静态成员函数不能声明称const 的，而且我们也不能在static函数体内使用this指针。 虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或指针来访问静态成员。 12345Account ac1;Account &amp;ac2;r = ac1.rate();r = ac2-&gt;rate(); 当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句： 要想确保对象只定义一次，最好的办法是把静态的数据成员的定义与其他非内联函数的定义放在同一个文件中。 通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成他所属的类的指针或饮用。 12345678class Bar{ public: //... private: static Bar mem1; //正确：静态成员可以是不完全类型 Bar *mem2; //正确：指针成员可以是不完全类型 Bar mem3; //错误：数据成员必须是完全类型} 可以使用静态成员作为默认实参 123456class Screen{ public: screen&amp; clear(char = bkground); private: static const char bkground;} 非静态数据成员不能作为默认实参，因为他的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。","link":"/2019/11/19/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9AC-%E5%9F%BA%E7%A1%80/"},{"title":"Matplotlib绘图案例","text":"绘图数据处理绘图时对数据进行三次样条插值： 123456789import matplotlib.pyplot as pltfrom scipy.interpolate import BSpline,make_interp_spline#....省略数据读取xnew = np.linspace(np.min(x_data), np.max(x_data), 300)spl = make_interp_spline(x_data, y_data, k=3) # type: BSplineynew = spl(xnew)plt.plot(xnew,ynew) 一般折线图的绘制123456789101112131415161718import matplotlib.pyplot as plt# 省略读取部分fig,ax = plt.subplots()ax.plot(x_data,y_data,label=\"线标签\") #添加标签ax.set_title(r\"$\\sigma-\\epsilon$\") #设置图表名称 latex设置在r‘’中ax.set_xlabel(r\"$\\varepsilon$/%\") #设置x轴标签ax.set_ylabel(r\"$\\sigma$/MPa\") #设置y轴标签ax.set_xlim(0,8) #设置x轴范围ax.set_xticks([]) #关闭x坐标tickax.tick_params(direction='in',colors='black') #设置tick的参数 plt.rcParams['font.sans-serif']=['SimHei'] #中文plt.rcParams['axes.unicode_minus']=False #负号plt.legend() #显示标签（绘图时的label）plt.xticks(x,labels,rotation=70) #tick显示#plt.xticks([]) #关闭tickplt.axis(\"off\") #关闭坐标轴plt.savefig(result_name,dpi=600,bbox_inches='tight',format=\"png\") #保存图片plt.show() #显示图片 直方图的绘制123456789101112131415# 对于dataframe中的数据，直接使用下面的代码df[\"column_name\"].hist(bins=20) # 对于pyplot，使用时存在nan值可能会报错# 方法1,选择非nanimport numpy as npimport matplotlib.pyplot as pltdata = [1,23,4214,12,4,124,1,24,np.nan]plt.hist(data[data is not np.nan])# 方法2，删除nanimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltdata = pd.Series([1,23,4214,12,4,124,1,24,np.nan])plt.hist(data.dropna()) 内置的colorbar官方网站内置颜色 绘制网格图12345678910111213141516171819import matplotlib.pyplot as pltimport numpy as npfrom matplotlib.colors import LinearSegmentedColormapimage_array = np.eye(4) fig = plt.figure()ax = fig.gca() # Get the current axes, creating one if necessary.# 自定义colorbarcmap = LinearSegmentedColormap.from_list('mycmap', ['red', 'blue', 'green']) # colorbar为过渡渐变im = ax.imshow(image_array, cmap=cmap, vmin=0, vmax=2)plt.setp(ax.spines.values(), linewidth=2) # 设置上下左右边框的宽度plt.grid(True, color='black', linestyle='-', linewidth=2, axis=\"both\") #设置网格的属性（颜色和宽度等）plt.tick_params(direction='in') # 将tick朝内，隐藏plt.xticks([i + 0.5 for i in range(3)], visible=False) #设置网格线的位置plt.yticks([i + 0.5 for i in range(3)], visible=False)plt.savefig(\"grid1.png\", bbox_inches=\"tight\", dpi=600, transparent=True, format=\"png\") #保存图片plt.show() 执行结果：","link":"/2019/11/27/Matplotlib%E7%BB%98%E5%9B%BE%E6%A1%88%E4%BE%8B/"},{"title":"C-Primer读书笔记-第二部分：标准库","text":"8.IO库IO类IO库类型和头文件 头文件 类型 iostream istream,wistream从流读取数据 &nbsp; ostream,wostream向流写入数据 &nbsp; iostream，wiostream读写流 fstream ifstream,wiftream从文件读取数据 &nbsp; ofstream,wofstream向文件写入数据 &nbsp; fstream，wfstream读写文件 sstream istringstream,wistringstream从string读取数据 &nbsp; ostringstream,wostringstream向string写入数据 &nbsp; stringstream，wstringstream读写流 - 我们不能拷贝或者对IO对象赋值。 1234ofstream out1,out2;out1 = out2; //错误：不能赋值ofstream print(ofstream); //错误不能初始化ofstream参数out2 = print(out2); //错误：不能拷贝对象 12//将流当作条件使用if (cin &gt;&gt; word); 流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。 带参数的clear接受一个iostate值，表示流的新状态。为了抚慰单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。 12//复位failbit和badbit，保持其他标识位不变cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit) 在每个输出操作后，我们可以使用操作符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。 刷新输出缓冲区 操作符endl完成换行并刷新缓冲区的工作。 操作符ends向缓冲区插入一个空字符，然后刷新缓冲区。 操作符flush刷新缓冲区，不输出任何额外的字符。 如果想在每次输出操作后都刷新缓冲区，可以使用unitbuf操作符。他告诉流在接下来的每次写操作后都进行一次flush操作。而nounitbuf操作符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制： 12cout &lt;&lt; unitbuf; //所有输出操作后都会立即刷新缓冲区cout &lt;&lt; nounitbuff; //回到正常的缓冲方式 关联输入和输出流 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。 1cin.tie(&amp;cout); //将cin和cout关联在一起（默认情况下这两者是关联的） 每个流同事最多关联到一个流，但多个流可以同时关联到同一个ostream 文件输入输出 使用文件流对象 创建文件流对象时，可以提供文件名。如果提供文件名，则open会被自动调用； 12ifstream in(ifile); //构造ifstream并打开给定文件ofstream out; //输出文件流out 当一个fstream对象离开其作用域，与之关联的文件会自动关闭。（当一个fstream对象被销毁时，close会被自动调用） 文件模式 只可以对ofstream或fstream设定out模式。 只可以对ifstream或fstream设定in模式。 只有当out也被设定，才可以设定trunct模式 只要trunc没被设定，就可以设定app模式。 string流 sstream特有的操作 例子 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include \"PersonInfo.h\"int main(){ std::vector&lt;PersonInfo&gt; personInfos; std::string line,data; std::ifstream inputFile; inputFile.open(\"/Users/xuexuan/Desktop/tmp/test/123\"); while(std::getline(inputFile,line)){ PersonInfo person; std::istringstream record(line); record &gt;&gt; person.name; while (record &gt;&gt; data){ person.phones.push_back(data); } personInfos.push_back(person); } for (const auto &amp;item:personInfos){ std::ostringstream formatted, badNums; for (const auto &amp;nums:item.phones){ if(valid(nums)){ formatted &lt;&lt; \" \"&lt;&lt;nums; } else{ badNums &lt;&lt; \" \"&lt;&lt;nums; } } if (badNums.str().empty()){ std::cout &lt;&lt; item.name &lt;&lt;\" \"&lt;&lt;formatted.str()&lt;&lt;std::endl; } else{ std::cout &lt;&lt; item.name &lt;&lt;\" invalid:\"&lt;&lt; badNums.str() &lt;&lt;std::endl; } }} 9.顺序容器顺序容器的类型vector\\deque\\list\\forward_list\\array\\stringarray是一种比内置数组更安全，更容易使用的数组类型。 array支持拷贝与赋值操作。forward_list没有没有size操作。 选择容器的基本原则 除非有很好的理由选择其他容器，否则选择vector 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list. 如果程序要求随机访问元素，应使用vector或deque 如果程序要求在容器中间插入或删除元素，应使用list或forward_list. 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素。则： 。。。 如果你不确定应该使用哪种容器，呢么可以在程序中只使用vector和list公共的操作：迭代器，不使用下标操作，避免随机访问。这样，在必要时选择vector和list都很方便。 容器操作 新标准库中容器既提供成员版本的swap，也提供非成员版本的swap。统一使用非成员版本的swap是一个好习惯。 c.insert(p,t) 在p指向的元素之前创建一个值为t的元素，返回指向新添加元素的迭代器。 改变容器大小 c .resize() 容器操作可能使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。 管理容量的成员函数 c.shrink_to_fit() 将capacity()减小为与size()相同大小 c.capacity() 不重新分配内存的话，c可以保存多少元素 c.reserve() 分配至少能容纳n个元素的内存空间 容器适配器 stack/queue/priority_queue 栈默认基于deque实现。 10.范型算法大多数算法定义在algorithm中。标准库还在numeric头文件中定义了一组数值范型算法。","link":"/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/"},{"title":"c++内联函数","text":"参考链接：https://blog.csdn.net/BjarneCpp/article/details/76044493 1.内联函数在C++中我们通常定义以下函数来求两个整数的最大值： 1234int max(int a, int b){ return a &gt; b ? a : b;}1234 为这么一个小的操作定义一个函数的好处有： ① 阅读和理解函数 max 的调用，要比读一条等价的条件表达式并解释它的含义要容易得多 ② 如果需要做任何修改，修改函数要比找出并修改每一处等价表达式容易得多 ③ 使用函数可以确保统一的行为，每个测试都保证以相同的方式实现 ④ 函数可以重用，不必为其他应用程序重写代码 虽然有这么多好处，但是写成函数有一个潜在的缺点：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行 C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数： 1234inline int max(int a, int b){ return a &gt; b ? a : b;}1234 则调用：cout &lt;&lt; max(a, b) &lt;&lt; endl; 在编译时展开为：cout &lt;&lt; (a &gt; b ? a : b) &lt;&lt; endl; 从而消除了把 max写成函数的额外执行开销。 2. 内联函数和宏无论是《Effective C++》中的 “Prefer consts，enums，and inlines to #defines” 条款，还是《高质量程序设计指南——C++/C语言》中的“用函数内联取代宏”，宏在C++中基本是被废了，在书《高质量程序设计指南——C++/c语言》中这样解释到： 3. 将内联函数放入头文件关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。 如下风格的函数 Foo 不能成为内联函数： 12345inline void Foo(int x, int y); // inline 仅与函数声明放在一起 void Foo(int x, int y){ //...} 12345 而如下风格的函数 Foo 则成为内联函数： 12345void Foo(int x, int y); inline void Foo(int x, int y) // inline 与函数定义体放在一起{ //...} 12345 所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但我认为 inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。 定义在类声明之中的成员函数将自动地成为内联函数，例如： 12345class A{ public: void Foo(int x, int y) { ... } // 自动地成为内联函数 } 12345 但是编译器是否将它真正内联则要看 Foo函数如何定义 内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。 当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。 但是你会很奇怪，重复定义那么多次，不会产生链接错误？ 我们来看一个例子： 1234567891011121314151617181920212223242526272829303132333435// 文件A.h 代码如下:class A{public: A(int a, int b) : a(a),b(b){} int max();private: int a; int b;};1234567891011// 文件A.cpp 代码如下:#include \"A.h\"inline int A::max(){ return a &gt; b ? a : b;}12345678// 文件Main.cpp 代码如下:#include &lt;iostream&gt;#include \"A.h\"using namespace std;inline int A::max(){ return a &gt; b ? a : b;}int main(){ A a(3, 5); cout &lt;&lt; a.max() &lt;&lt; endl; return 0;}12345678910111213141516 一切正常编译，输出结果：5 倘若你在Main.cpp中没有定义max内联函数，那么会出现链接错误：error LNK2001: unresolved external symbol &quot;public: int __thiscall A::max(void)&quot; (?max@A@@QAEHXZ)main.obj找不到函数的定义，所以内联函数可以在程序中定义不止一次，只要 inline 函数的定义在某个源文件中只出现一次，而且在所有源文件中，其定义必须是完全相同的就可以。 在头文件中加入或修改 inline 函数时，使用了该头文件的所有源文件都必须重新编译。 4. 慎用内联内联虽有它的好处，但是也要慎用，以下摘自*《高质量程序设计指南——C++/C语言》*： 而在Google C++编码规范中则规定得更加明确和详细： 内联函数：Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数. -inl.h文件： Tip： 复杂的内联函数的定义, 应放在后缀名为 -inl.h 的头文件中.内联函数的定义必须放在头文件中, 编译器才能在调用点内联展开定义. 然而, 实现代码理论上应该放在 .cc 文件中, 我们不希望 .h 文件中有太多实现代码, 除非在可读性和性能上有明显优势. 如果内联函数的定义比较短小, 逻辑比较简单, 实现代码放在 .h 文件里没有任何问题. 比如, 存取函数的实现理所当然都应该放在类定义内. 出于编写者和调用者的方便, 较复杂的内联函数也可以放到 .h 文件中, 如果你觉得这样会使头文件显得笨重, 也可以把它萃取到单独的 -inl.h 中. 这样把实现和类定义分离开来, 当需要时包含对应的 -inl.h 即可。","link":"/2019/11/19/c-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"title":"c++头文件和源文件","text":"头文件(.h)：​ 写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。 .h文件中能包含： 类成员数据的声明，但不能赋值 类静态数据成员的定义和赋值，但不建议，只是个声明就好。 类的成员函数的声明 非类成员函数的声明 常数的定义：如：const int a=5; 静态函数的定义 类的内联函数的定义 不能包含： 1． 所有非静态变量（不是类的数据成员）的声明 2。 默认命名空间声明不要放在头文件，using namespace std;等应放在.cpp中，在 .h 文件中使用 std::string 特别注意 一，头文件中可以写 const 对象的定义。因为全局的 const 对象默认是没有 extern 的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个 .cpp 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同时，因为这些 .cpp 文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些 .cpp 文件中的这个 const 对象的值是相同的，可谓一举两得。同理，static 对象的定义也可以放进头文件。 二，头文件中可以写内联函数（inline）的定义。因为inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义；但是，如果我在其他的文件中还使用到了这个函数那怎么办呢？这几乎没什么太好的解决办法，因此 C++ 规定，内联函数可以在程序中定义多次，只要内联函数在一个 .cpp 文件中只出现一次，并且在所有的 .cpp 文件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。 三，头文件中可以写类（class）的定义。因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的。所以把类的定义放进头文件，在使用到这个类的 .cpp 文件中去包含这个头文件，是一个很好的做法。在这里，值得一提的是，类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。一般，我们的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个 .cpp 文件中。这是可以的，也是很好的办法。不过，还有另一种办法。那就是直接把函数成员的实现代码也写进类定义里面。在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被重定义了。 源文件（.cpp）：源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。那么当你需要用到自己写的头文件中的类时，只需要#include进来就行了。","link":"/2019/11/19/c-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6/"},{"title":"cmake基础（搬运）","text":"原链接 ref 1. 编译单目录工程1.创建工程文件夹 1234mkdir hello #工程目录cd hellomkdir src # 存放源代码的目录mkdir build # 存放编译中间代码和目标代码的目录 2.进入src目录，编写一个main.c文件 1234567#include &lt;stdio.h&gt;int main(int argc, char **argv){ printf(\"hello world\\n\"); return 0;} 3.编写工程顶层目录的CMakeLists.txt 1234567cmake_minumum_required(VERSION 2.6)#指定项目名project(hello)#指定子目录add_subdirectory(src) 4.编写子目录src的CMakeLists.txt 123aux_source_directory(. SRC_LIST)add_executable(hello ${SRC_LIST}) 5.编译工程 1.进入build 目录 2.执行命令cmake ..创建Makefile 3.执行命令make编译工程 4.在build的子目录src生成了执行文件 2. 编译多目录工程1.创建工程目录 1234567mkdir hello # 工程目录cd hellomkdir src # 存放源码目录mkdir build # 存放编译产生的中间文件cd src mkdir hello # 存放hello 模块mkdir world # 存放world 模块 2.编写hello模块 进入hello目录 编写hello.h文件 123456#ifndef HELLO_H#define HELLO_Hvoid Hello_Print(void);#endif 编写hello.c文件 12345678#include \"hello.h\"#include &lt;stdio.h&gt;void Hello_Print(void){ printf(\"hello \");} 编写CMakeLists.txt 文件 123aux_source_directory(. DIR_HELLO_SRC)add_library(hello_lib ${DIR_HELLO_SRC}) 3.编写world模块 进入world目录 编写world.h文件 123456#ifndef WORLD_H#define WORLD_Hvoid World_Print(void);#endif 编写world.c文件 12345678#include \"world.h\"#include &lt;stdio.h&gt;void World_Print(void){ printf(\"world\");} 编写CMakeLists.txt 文件 123aux_source_directory(. DIR_WORLD_SRC)add_library(world_lib ${DIR_WORLD_SRC}) 4.编写主模块 进入src目录 编写main.c 文件 12345678910#include \"hello/hello.h\"#include \"world/world.h\"int main(int argc, char **argv){ Hello_Print(); World_Print(); return 0} 编写CMakeLists.txt 文件 123456789add_source_directory(. DIR_SRC)# 添加子目录add_subdirectory(hello)add_subdirectory(world)# 执行文件add_executable(hello_prj ${DIR_SRC})target_link_libraries(hello_prj ello_lib world_lib) 5.编写顶层目录的CMakeLists.txt文件 12345cmake_minumum_required(VERSION 2.6)project(hello_prj)add_subdirectory(src) 3. 动态库和静态库的构建和使用1.使用一个hello world工程来展开说明 项目结构 12345678910111213141516|-- CMakeLists.txt|-- build|-- include| |-- hello| | `-- hello.h| `-- world| `-- world.h|-- src| |-- CMakeLists.txt| |-- hello| | `-- hello.c| `-- world| `-- world.c`-- test |-- CMakeLists.txt `-- mytest.c 2.顶层目录CMakeLists.txt 123456789101112131415161718192021222324252627282930313233343536373839cmake_minimum_required(VERSION 2.6)project(helloworld)#设置库文件存放路径set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/build/lib)#设置执行文件存放路径set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/build/bin)#获取当前目录及子目录(递归获取),添加到头文件搜索路径function(include_sub_directories_recursively root_dir) if (IS_DIRECTORY ${root_dir}) # 当前路径是一个目录吗，是的话就加入到包含目录 message(\"include dir: \" ${root_dir}) include_directories(${root_dir}) endif() file(GLOB ALL_SUB RELATIVE ${root_dir} ${root_dir}/*) # 获得当前目录下的所有文件，让如ALL_SUB列表中 foreach(sub ${ALL_SUB}) if (IS_DIRECTORY ${root_dir}/${sub}) include_sub_directories_recursively(${root_dir}/${sub}) # 对子目录递归调用，包含 endif() endforeach()endfunction()#项目的所有目录都为头文件搜索路径include_sub_directories_recursively(${PROJECT_SOURCE_DIR})#添加库文件搜索路径link_directories( ${PROJECT_SOURCE_DIR}/build/lib )#添加子目录add_subdirectory(src)add_subdirectory(test)#设置安装目录set(CMAKE_INSTALL_PREFIX ${PROJECT_SOURCE_DIR}/install) 3.helloworld库的源代码 hello.h文件 123456#ifndef HELLO_H#define HELLO_Hvoid Hello_Print(void);#endif hello.c文件 12345678#include \"hello/hello.h\"#include &lt;stdio.h&gt;void Hello_Print(void){ printf(\"hello \");} world.h文件 123456#ifndef WORLD_H#define WORLD_Hvoid World_Print(void);#endif world.c文件 12345678#include \"world/world.h\"#include &lt;stdio.h&gt;void World_Print(void){ printf(\"world\");} 4.子目录src下的CMakeLists.txt 123456789101112131415161718192021#递归获取当前目录及子目录下的所有c文件file(GLOB_RECURSE c_files \"*.c\")#生成动态库和静态库add_library(helloworld_lib_shared SHARED ${c_files})add_library(helloworld_lib_static STATIC ${c_files})#将动态库和静态库的名字设置为一致set_target_properties(helloworld_lib_shared PROPERTIES OUTPUT_NAME \"helloworld\")set_target_properties(helloworld_lib_static PROPERTIES OUTPUT_NAME \"helloworld\")#设置动态库版本set_target_properties(helloworld_lib_shared PROPERTIES VERSION 1.2 SOVERSION 1)#安装动态库和静态库INSTALL(TARGETS helloworld_lib_shared helloworld_lib_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)#安装头文件INSTALL(DIRECTORY ${PROJECT_SOURCE_DIR}/include/ DESTINATION include) 5.mytest.c文件测试生成的库文件 mytest.c文件 12345678910111213#include \"hello/hello.h\"#include \"world/world.h\"#include &lt;stdio.h&gt;int main(int argc, char **argv){ Hello_Print(); World_Print(); printf(\"\\n\"); return 0;} CMakeLists.txt文件 12345678#递归获取所有当前目录及子目录下的C文件file(GLOB_RECURSE c_files ./*.c) #生成执行文件add_executable(mytest ${c_files}) #链接外部库target_link_libraries(mytest libhelloworld.so) 6.构建工程 12341.进入目录build2.执行命令: cmake ..3.执行命令: make4.执行命令: make install 4. 指定编译器和编译选项1.CMAKE_C_COMPILER: 指定C编译器 2.CMAKE_CXX_COMPILTER:指定C++编译器 3.CMAKE_C_FLAGS: 指定C编译选项 4.CMAKE_CXX_FLAGS:指定C++编译选项 5.EXECUTABLE_OUTPUT_PATH: 指定执行文件存放目录 6.LIBRARY_OUTPUT_PATH: 指定库文件存放目录 7.CMAKE_BUILD_TYPE:指定build类型[Debug|Release] 8.BUILD_SHARED_LIBS: 指定默认库编译方式[OFF|ON] 上述内部变量使用说明: 1.CMakeLists.txt文件上使用set命令 2.cmake 命令中指定，如: cmake -DCMAKE_C_COMPILER=gcc add_definitions:添加编译参数 5. 配置编译模块6. CMake 常用变量和语句1.include_directories:指定头文件搜索路径 2.link_directories:指定库文件搜索路径 3.add_subdirectory:添加子目录 4.target_link_libraries:指定文件链接库文件","link":"/2019/11/26/cmake%E5%9F%BA%E7%A1%80%EF%BC%88%E6%90%AC%E8%BF%90%EF%BC%89/"},{"title":"github中的快速查找","text":"根据CodeSheep的视频进行总结： 123456789in:name example //名字中有“example”in:readme example //readme中有“example”in:description example //描述中有“example”stars:&gt;1000 star&gt;1000forks:&gt;1000 fork&gt;1000pushed:&gt;2019-09-01 //2019年9月1日后有更新的language:java //用Java编写的项目","link":"/2019/11/26/github%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE/"},{"title":"cmake官方教程（搬运）","text":"原链接 ref 起点（Step 1）参看下面的CMakeLists.txt文件，最简单的一个工程需要有一个这样的cmake文件，一共就这么两行 123cmake_minimum_required (VERSION 2.6)project (Tutorial) add_executable (Tutorial tutorial.cxx) 注意到这里都是用的小写的命令，在cmake文件里面大小写不严格区分，都可以用。 add_executable添加一个可编译的目标到工程里面 123add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...]) name: 工程所要构建的目标名称 WIN32/..: 目标app运行的平台 source1：构建目标App的源文件 tutorial.cxx的源代码计算一个数的平方根。第一版的代码很简单，参看如下： 123456789101112131415161718// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int main (int argc, char *argv[]){ if (argc &lt; 2) { fprintf(stdout, \"Uage: %s number\\n\", argv[0]); return 1; } double inputValue = atof(argv[1]); double outputValue = sqrt(inputValue); fprintf(stdout, \"The square root of %g is %g\\n\", inputValue, outputValue); return 0;} 编写完上面两个文件以后，在根目录下新建一个build目录 . ├── build ├── CMakeLists.txt └── tutorial.cxx 然后运行如下命令 123$ cd buld$ CMake ..$ make CMake会自动加载上级目录里面的CMakeLists.txt文件，编译所需的文件都会生成在build目录下 make之后会生成可执行文件Tutorial 添加一个版本号和配置的头文件修改CMakeList.txt来添加version number： 1234567891011121314151617cmake_minimum_required (VERSION 2.6)project (Tutorial)# 版本号.set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0) # 配置一个头文件来传递一些CMake设置到源代码configure_file ( \"${PROJECT_SOURCE_DIR}/TutorialConfig.h.in\" \"${PROJECT_BINARY_DIR}/TutorialConfig.h\" ) # 添加TutorialConfig.h的路径到头文件的搜索路径include_directories(\"${PROJECT_BINARY_DIR}\") # 添加目标可执行文件add_executable(Tutorial tutorial.cxx) configure_file会拷贝一个文件到另一个目录并修改文件内容: 123configure_file(&lt;input&gt; &lt;output&gt; [COPYONLY] [ESCAPE_QUOTES] [@ONLY] [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ]) cmake会自动定义两个变量 ${PROJECT_SOURCE_DIR}： 当前工程最上层的目录 ${PROJECT_BINARY_DIR}： 当前工程的构建目录（本例中新建的build目录） 在这个例子里，configure_file命令的源文件是TutorialConfig.h.in，手动创建这个文件： 123// Tutorial工程的配置选项和设置#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ 调用CMake的时候会在build目录下新的头文件，并且使用CMakeList.txt中定义的值来替换@Tutorial_VERSION_MAJOR@和@Tutorial_VERSION_MINOR@这两个变量。 下一步要在源文件tutorial.cxx中包含这个配置的头文件，就能使用这些版本信息了。 1234567891011121314151617181920212223// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include \"TutorialConfig.h\"int main (int argc, char *argv[]){ if (argc &lt; 2) { fprintf(stdout, \"%s Version %d.%d\\n\", argv[0], Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR) fprintf(stdout, \"Uage: %s number\\n\", argv[0]); return 1; } double inputValue = atof(argv[1]); double outputValue = sqrt(inputValue); fprintf(stdout, \"The square root of %g is %g\\n\", inputValue, outputValue); return 0;} 运行如下命令查看结果 123$ cmake ..$ make$ ./Tutorial 这个时候控制台会打印出来版本号 12./Tutorial Version 1.0Uage: ./Tutorial number 添加Library（Step 2）现在我们尝试添加一个library到我们的工程。这个lib提供一个自定义的计算平方根的函数，用来替换编译器提供的函数。 lib的源文件放到一个叫MathFunctions的子目录中，在目录下新建CMakeList.txt文件，添加如下的一行 1add_library(MathFunctions mysqrt.cxx) 源文件mysqrt.cxx包含一个函数mysqrt用于计算平方根。代码如下 1234567891011121314151617181920212223242526#include \"MathFunctions.h\"#include &lt;stdio.h&gt;// a hack square root calculation using simple operationsdouble mysqrt(double x){ if (x &lt;= 0) { return 0; } double result; double delta; result = x; // do ten iterations int i; for (i = 0; i &lt; 10; ++i) { if (result &lt;= 0) { result = 0.1; } delta = x - (result * result); result = result + 0.5 * delta / result; fprintf(stdout, \"Computing sqrt of %g to be %g\\n\", x, result); } return result;} 还需要添加一个头文件MathFunctions.h以提供接口给main函数调用 1double mysqrt(double x); 现在的目录结构 . ├── build ├── CMakeLists.txt ├── MathFunctions │ ├── CMakeLists.txt │ ├── MathFunctions.h │ └── mysqrt.cxx ├── TutorialConfig.h.in └── tutorial.cxx CMakeLists.txt文件需要相应做如下改动 添加一行add_subdirectory来保证新加的library在工程构建过程中被编译。 添加新的头文件搜索路径MathFunction/MathFunctions.h。 添加新的library到executable。 CMakeList.txt的最后几行变成了这样： 123456include_directories (\"${PROJECT_SOURCE_DIR}/MathFunctions\")add_subdirectory (MathFunctions)# 添加executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Turorial MathFunctions) 最后要修改tutorial.cxx文件来调用自定义的mysqrt函数 最后编译一下试试 123$ cmake ..$ make$ ./Tutorial 看一下编译的log 12345678Scanning dependencies of target MathFunctions[ 50%] Building CXX object MathFunctions/CMakeFiles/MathFunctions.dir/mysqrt.cxx.oLinking CXX static library libMathFunctions.a[ 50%] Built target MathFunctionsScanning dependencies of target Tutorial[100%] Building CXX object CMakeFiles/Tutorial.dir/tutorial.cxx.oLinking CXX executable Tutorial[100%] Built target Tutorial 这里编译生成了新的库libMathFunctions.a 现在我们考虑把MathFunctions库配置成可选的首先在最顶层的CMakeList.txt文件添加一个option 123#需要用自定义的数学函数么？option (USE_MYMATH \"Use tutorial provided math implementation\" ON) 运行ccmake ..会跳出来配置的GUI，在GUi中会看到新添加的这个选项，用户可以根据需要进行修改。 下一个改变是依据配置来判断是否编译和链接MathFunctions库。按照如下所示的修改CMakeList.txt的末尾几行： 12345678910# add the MathFunctions library?if (USE_MYMATH) include_directories (\"${PROJECT_SOURCE_DIR}/MathFunctions\") add_subdirectory (MathFunctions) SET (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)endif (USE_MYMATH)# add executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Turorial ${EXTRA_LIBS}) 这个例子里还是用了变量（EXTRA_LIBS）来收集后面link进可执行文件的时候任意可选的库。这是一个常用的方法，在工程非常大有很多optional的组件的时候，可以让这个编译文件保持干净。 代码的修改就更直接了(用宏定义隔离开)： 1234567891011121314151617181920212223242526272829303132// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include \"TutorialConfig.h\"#ifdef USE_MYMATH#include \"MathFunctions.h\"#endif int main (int argc, char *argv[]){ if (argc &lt; 2) { fprintf(stdout,\"%s Version %d.%d\\n\", argv[0], Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR); fprintf(stdout,\"Usage: %s number\\n\",argv[0]); return 1; } double inputValue = atof(argv[1]); #ifdef USE_MYMATH double outputValue = mysqrt(inputValue);#else double outputValue = sqrt(inputValue);#endif fprintf(stdout,\"The square root of %g is %g\\n\", inputValue, outputValue); return 0;} 在源代码里面同样可以使用USE_MYMATH，只要在TutorialConfig.h.in里面添加一行 1#cmakedefine USE_MYMATH 安装测试 (Step 3)下一步我们会添加install规则和testing到工程。install规则非常直接。对于MathFunctions库，我们通过在MathFunctions的CMakeList文件中添加如下两行来安装库和头文件。 12install (TARGETS MathFunctions DESTINATION bin)install(FILES MathFunctions.h DESTINATION include) 对于应用程序，为了安装executable和配置头文件，需要在最上层的CMakeList.txt文件中添加下面几行 123# add the install targetsinstall (TARGETS Tutorial DESTINATION bin)install (FILES \"${PROJECT_BINARY_DIR}/TutorialConfig.h\" DESTINATION include) 到了这里你就可以构建整个tutorial了，通过命令make install，系统会自动安装对应的头文件，库以及可执行文件。CMake变量CMAKE_INSTALL_PREFIX用来指定这些文件需要安装到哪个根目录。 添加测试用例也很直接，只要在最上层的CMakeList.txt文件添加一系列的基础测试来验证应用程序是否正常工作。 1234567891011121314151617181920include(CTest)# does the application runadd_test (TutorialRuns Tutorial 25)# does it sqrt of 25add_test (TutorialComp25 Tutorial 25)set_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION \"25 is 5\")# does it handle negative numbersadd_test (TutorialNegative Tutorial -25)set_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION \"-25 is 0\")# does it handle small numbersadd_test (TutorialSmall Tutorial 0.0001)set_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION \"0.0001 is 0.01\")# does the usage message work?add_test (TutorialUsage Tutorial)set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage:.*number\") 编译完成后可以通过在命令行运行ctest来执行这些测试用例。如果你希望添加很多测试用例来测试不同的输入值，这个时候推荐你创建一个宏，这样添加新的case会更轻松： 12345678910#define a macro to simplify adding tests, then use itmacro (do_test arg result) add_test (TutorialComp${arg} Tutorial ${arg}) set_tests_properties (TutorialComp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result})endmacro (do_test) # do a bunch of result based testsdo_test (25 \"25 is 5\")do_test (-25 \"-25 is 0\") 每次调用do_test，都会添加一个新的test case到工程。 添加系统回顾 (Step 4)下一步我们考虑在工程中添加一些代码，这些代码会依赖的某些特性在运行的目标平台上可能没有。比如说，我们添加了一些代码，这些代码需要用到log和exp函数，但某些目标平台上可能没有这些库函数。如果平台有log函数那么我们就是用log来计算平方根，我们首先通过CheckFunctionExists.cmake来测试一下是否有这些函数，在最上层的CMakeList文件中添加如下内容 1234# does this system provide the log and exp functions?include (CheckFunctionExists)check_function_exists (log HAVE_LOG)check_function_exists (exp HAVE_EXP) Next we modify the TutorialConfig.h.in to define those values if CMake found them on the platform as follows: 下一步，如果CMake发现平台有我们需要的这些函数，则需要修改TutorialConfig.h.in来定义这些值 123// does the platform provide exp and log functions?#cmakedefine HAVE_LOG#cmakedefine HAVE_EXP 有一点很重要，就是log和exp的测试工作需要在配置TutorialConfig.h前完成。最后在mysqrt函数中我们可以提供一个可选的实现方式： 12345// if we have both log and exp then use them#if defined (HAVE_LOG) &amp;&amp; defined (HAVE_EXP) result = exp(log(x)*0.5);#else // otherwise use an iterative approach . . . 添加生成文件和生成器 (Step 5)这一节中我们会演示一下怎么添加一个生成的源文件到引用程序的构建过程中。例如说，我们希望在构建过程中创建一个预先计算好的平方根表，然后把这个表格编译进我们的应用程序。首先我们需要一个能生成这张表的程序。在MathFunctions子目录中，定义一个新的源文件MakeTable.cxx: 123456789101112131415161718192021222324252627282930313233343536// A simple program that builds a sqrt table #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt; int main (int argc, char *argv[]){ int i; double result; // make sure we have enough arguments if (argc &lt; 2) { return 1; } // open the output file FILE *fout = fopen(argv[1],\"w\"); if (!fout) { return 1; } // create a source file with a table of square roots fprintf(fout,\"double sqrtTable[] = {\\n\"); for (i = 0; i &lt; 10; ++i) { result = sqrt(static_cast&lt;double&gt;(i)); fprintf(fout,\"%g,\\n\",result); } // close the table with a zero fprintf(fout,\"0};\\n\"); fclose(fout); return 0;} 注意到这里的需要传递正确的输出文件给app，然后才会生成table。下一步是在MathFunctions的CMakeList.txt添加相应的命令来编译生成可执行文件MakeTable，然后在编译过程中运行这个程序。如下所示的添加一些命令： 12345678910111213141516# first we add the executable that generates the tableadd_executable(MakeTable MakeTable.cxx) # add the command to generate the source codeadd_custom_command ( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) # add the binary tree directory to the search path for # include filesinclude_directories( ${CMAKE_CURRENT_BINARY_DIR} ) # add the main libraryadd_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) 首先添加可执行的MakeTable。 然后我们添加一个用户命令指定怎么通过允许MakeTable来生成Table.h。 下一步需要让CMAKE知道mysqrt.cxx依赖生成的Table.h。把生成的Table.h添加到MathFunctions库的资源列表中。 还需要添加当前的bin的目录添加到include的list中，这样mysqrt.cxx编译时候可以找到Table.h。 最后编译包含Table.h的mysqrt.cxx来生成MathFunctions库 到这儿最上层的CMakeList.txt文件就如下面所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657cmake_minimum_required (VERSION 2.6)project (Tutorial)include(CTest) # The version number.set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0) # does this system provide the log and exp functions?include (${CMAKE_ROOT}/Modules/CheckFunctionExists.cmake) check_function_exists (log HAVE_LOG)check_function_exists (exp HAVE_EXP) # should we use our own math functionsoption(USE_MYMATH \"Use tutorial provided math implementation\" ON) # configure a header file to pass some of the CMake settings# to the source codeconfigure_file ( \"${PROJECT_SOURCE_DIR}/TutorialConfig.h.in\" \"${PROJECT_BINARY_DIR}/TutorialConfig.h\" ) # add the binary tree to the search path for include files# so that we will find TutorialConfig.hinclude_directories (\"${PROJECT_BINARY_DIR}\")# add the MathFunctions library?if (USE_MYMATH) include_directories (\"${PROJECT_SOURCE_DIR}/MathFunctions\") add_subdirectory (MathFunctions) set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)endif (USE_MYMATH) # add the executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Tutorial ${EXTRA_LIBS}) # add the install targetsinstall (TARGETS Tutorial DESTINATION bin)install (FILES \"${PROJECT_BINARY_DIR}/TutorialConfig.h\" DESTINATION include) # does the application runadd_test (TutorialRuns Tutorial 25) # does the usage message work?add_test (TutorialUsage Tutorial)set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage:.*number\" ) #define a macro to simplify adding testsmacro (do_test arg result) add_test (TutorialComp${arg} Tutorial ${arg}) set_tests_properties (TutorialComp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endmacro (do_test) # do a bunch of result based testsdo_test (4 \"4 is 2\")do_test (9 \"9 is 3\")do_test (5 \"5 is 2.236\")do_test (7 \"7 is 2.645\")do_test (25 \"25 is 5\")do_test (-25 \"-25 is 0\")do_test (0.0001 \"0.0001 is 0.01\") TutorialConfig.h.in 文件如下: 1234567// the configured options and settings for Tutorial#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@#cmakedefine USE_MYMATH // does the platform provide exp and log functions?#cmakedefine HAVE_LOG#cmakedefine HAVE_EXP MathFunctions的文件CMakeLists.txt如下: 12345678910111213# first we add the executable that generates the tableadd_executable(MakeTable MakeTable.cxx)# add the command to generate the source codeadd_custom_command ( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h )# add the binary tree directory to the search path # for include filesinclude_directories( ${CMAKE_CURRENT_BINARY_DIR} ) # add the main libraryadd_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h) install (TARGETS MathFunctions DESTINATION bin)install (FILES MathFunctions.h DESTINATION include)","link":"/2019/11/26/cmake%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%EF%BC%88%E6%90%AC%E8%BF%90%EF%BC%89/"},{"title":"mac/linux常用命令","text":"查看指定端口占用，并杀死对应进程 12lsof: -i:80 #-i表示网络连接，80指明端口号，该命令会同时列出PIDkill -9 1863 # 杀掉pid=1863的进程","link":"/2019/11/29/mac-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"mac下的c++库安装","text":"1.qt的安装安装步骤命令行执行 1brew install qt 记录执行结果 2.vtk的安装ref 安装步骤 命令行执行ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 命令行执行brew install vtk 3.oce（OpenCASCADE）的安装ref命令行执行brew tap brewsci/science &amp;&amp; brew install oce执行结果 4.opencv的安装命令行执行brew install opencv执行结果 Clion+QT+VTK环+OpenCV环境搭建 注意：在clion中编译时，不要使用gcc，将编译器设置为系统默认的clang。（由于brew install默认识别系统自带的编译器）Perferences-&gt;Toolchains-&gt;System(default) (如果之前修改过，新建一个设置为默认) clion中cmakelist配置123456789101112131415161718192021cmake_minimum_required(VERSION 3.15)project(test)set(CMAKE_CXX_STANDARD 14)set(Qt5_DIR /usr/local/opt/qt/lib/)#set(OCE_DIR /usr/local/Cellar/oce/0.18.2/OCE.framework)find_package(VTK REQUIRED)find_package(Qt5Widgets REQUIRED)find_package(Qt5Gui REQUIRED)find_package(Qt5Core REQUIRED)find_package(Qt5OpenGL REQUIRED)#find_package(OCE REQUIRED COMPONENTS TKPrim)#include_directories(${OCE_INCLUDE_DIRS})find_package(OpenCV REQUIRED)include_directories(${OpenCV_INCLUDE_DIRS})include(${VTK_USE_FILE})add_executable(test main.cpp)link_directories(${OpenCV_LIBRARY_DIRS})target_link_libraries(${PROJECT_NAME} Qt5::Widgets Qt5::Widgets Qt5::Core Qt5::Gui Qt5::OpenGL ${VTK_LIBRARIES} ${OpenCV_LIBS}) 由于vtk,opencv等会自动调用qt，不对qt进行单独测试测试文件:（opencv）： 123456789101112131415161718192021222324252627282930#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main( int argc, char** argv ){ if( argc != 2) { cout &lt;&lt;\" Usage: display_image ImageToLoadAndDisplay\" &lt;&lt; endl; return -1; } Mat image; image = imread(argv[1], 1); // Read the file if(! image.data ) // Check for invalid input { cout &lt;&lt; \"Could not open or find the image\" &lt;&lt; std::endl ; return -1; } namedWindow( \"Display window\", WINDOW_AUTOSIZE );// Create a window for display. imshow( \"Display window\", image ); // Show our image inside it. waitKey(0); // Wait for a keystroke in the window return 0;} 测试文件（vtk）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/*========================================================================= Program: Visualization Toolkit Module: Cube.cxx Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen All rights reserved. See Copyright.txt or http://www.kitware.com/Copyright.htm for details. This software is distributed WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the above copyright notice for more information.=========================================================================*/// This example shows how to manually create vtkPolyData.// For a python version, please see:// [Cube](https://lorensen.github.io/VTKExamples/site/Python/GeometricObjects/Cube/)#include &lt;vtkActor.h&gt;#include &lt;vtkCamera.h&gt;#include &lt;vtkCellArray.h&gt;#include &lt;vtkFloatArray.h&gt;#include &lt;vtkNamedColors.h&gt;#include &lt;vtkNew.h&gt;#include &lt;vtkPointData.h&gt;#include &lt;vtkPoints.h&gt;#include &lt;vtkPolyData.h&gt;#include &lt;vtkPolyDataMapper.h&gt;#include &lt;vtkRenderWindow.h&gt;#include &lt;vtkRenderWindowInteractor.h&gt;#include &lt;vtkRenderer.h&gt;#include &lt;array&gt;int main(int, char *[]){ vtkNew&lt;vtkNamedColors&gt; colors; std::array&lt;std::array&lt;double, 3&gt;, 8&gt; pts = {{{{0, 0, 0}}, {{1, 0, 0}}, {{1, 1, 0}}, {{0, 1, 0}}, {{0, 0, 1}}, {{1, 0, 1}}, {{1, 1, 1}}, {{0, 1, 1}}}}; // The ordering of the corner points on each face. std::array&lt;std::array&lt;vtkIdType, 4&gt;, 6&gt; ordering = {{{{0, 1, 2, 3}}, {{4, 5, 6, 7}}, {{0, 1, 5, 4}}, {{1, 2, 6, 5}}, {{2, 3, 7, 6}}, {{3, 0, 4, 7}}}}; // We'll create the building blocks of polydata including data attributes. vtkNew&lt;vtkPolyData&gt; cube; vtkNew&lt;vtkPoints&gt; points; vtkNew&lt;vtkCellArray&gt; polys; vtkNew&lt;vtkFloatArray&gt; scalars; // Load the point, cell, and data attributes. for (auto i = 0ul; i &lt; pts.size(); ++i) { points-&gt;InsertPoint(i, pts[i].data()); scalars-&gt;InsertTuple1(i, i); } for (auto&amp;&amp; i : ordering) { polys-&gt;InsertNextCell(vtkIdType(i.size()), i.data()); } // We now assign the pieces to the vtkPolyData. cube-&gt;SetPoints(points); cube-&gt;SetPolys(polys); cube-&gt;GetPointData()-&gt;SetScalars(scalars); // Now we'll look at it. vtkNew&lt;vtkPolyDataMapper&gt; cubeMapper; cubeMapper-&gt;SetInputData(cube); cubeMapper-&gt;SetScalarRange(cube-&gt;GetScalarRange()); vtkNew&lt;vtkActor&gt; cubeActor; cubeActor-&gt;SetMapper(cubeMapper); // The usual rendering stuff. vtkNew&lt;vtkCamera&gt; camera; camera-&gt;SetPosition(1, 1, 1); camera-&gt;SetFocalPoint(0, 0, 0); vtkNew&lt;vtkRenderer&gt; renderer; vtkNew&lt;vtkRenderWindow&gt; renWin; renWin-&gt;AddRenderer(renderer); vtkNew&lt;vtkRenderWindowInteractor&gt; iren; iren-&gt;SetRenderWindow(renWin); renderer-&gt;AddActor(cubeActor); renderer-&gt;SetActiveCamera(camera); renderer-&gt;ResetCamera(); renderer-&gt;SetBackground(colors-&gt;GetColor3d(\"Cornsilk\").GetData()); renWin-&gt;SetSize(600, 600); // interact with data renWin-&gt;Render(); iren-&gt;Start(); return EXIT_SUCCESS;} 测试文件（oce/opencascade） 12","link":"/2019/11/25/mac%E4%B8%8B%E7%9A%84c-%E5%BA%93%E5%AE%89%E8%A3%85/"},{"title":"数据库基础","text":"最近组里要求做一个材料数据库，因此对之前数据库的知识进行复习，简单记录。 数据库基础设计原则 更小通常更好 一般来说，要试着使用正确地存储和表示数据的最小类型。更小的数据类型通常更快，因为它们使用了更少的磁盘空间、内存和CPU缓存，而且需要的CPU周期也更少。 简单就好 越简单的数据类型，需要的CPU周期就越少。例如：比较整数的代价小于比较字符，因为字符集和排序规则使字符比较更复杂。 尽量避免空 要尽可地把字段定义为NOT NULL 。即使应用程序无须保存NULL，也有许多表包含了可为空的列，这仅仅是因为它为默认选项，除非真的要保存NULL，否则就把列定义为NOT NULL。 需要注意：虽然把NULL列改为NOT NULL 带来的性能提升很小，所以除非确定它引入了问题，否则就不要把它当成优先的优化措施。但如果计划对列进行索引，就要尽量避免把它设置为可为空（NULL） 数据类型整数 TINYINT——这个类型最多可容纳三位数。 SMALLINT——最多可容纳五位数。 MEDIUMINT——最多可容纳八位数。 INT——可以容纳十位数。 BIGINT——最多可容纳二十位数。 整数类型有可选的unsigned（无符号）属性，它表示不允许为负数，并大致把正上限提高了一倍，例如：tinyint unsigned保存的翻围为0到255，而不是-127到128。 实数 由于需要额外的空间和计算开销，\\只有在需要对小数进行精确的时候才使用decimal**，比如保存金融数据。 DECIMAL最适合保存那些将被用于计算的数据。在MySQL中，我们可以指定保存一些正当的数字。还可以指定是否允许存在负值。 指定DECIMAL类型的长度会有些棘手。例如，如果你需要在小数点前面保存五位数，且小数点后只保留三位，那么在数据库中其适当的长度将是：Decimal(5+3,3)或 Decimal(8,3)，可以使用的数据包括：12345.678，56872.690，11.6和12.568等。而这些数字则会引发出错信息：128781.1，8972865.231。 字符串 varchar：保存了可变长度的字符串，是使用得最多的字符串类型，它能比固定类型占用更少的存储空间，因为它只占用了自已需要的空间（也就是说较短的值占用的空间更小）。它使用额外的1-2个字节来存储值的长度。Varchar能节约空间，所以对性能有帮助。然而，由于行的长度是可变的，它们在更新的时候可能会发生变化，这会引起额外的工作。当最大长度远大于平均长度，并且很少发生更新的时候，通常适合用varchar。这时候碎片就不会成为问题，还有你使用复杂的字符集，如utf-8时，它的每个字符都可能会占用不同的存储空间。Varchar存取值时候，MySQL不会去掉字符串末尾的空格。 char：固定长度，char存取值时候，MySQL会去掉末尾的空格。Char在存储很短的字符串或长度近似相同的字符的时候很有用。例如,char适用于存储密码的MD5哈希值，它的长度总是一样的。对于经常改变的值，char也好于varchar，因为固定长度的行不容易产生碎片，对于很短的列，char的效率也高于varchar。Char(1)字符串对于单字节字符集只会占用1个字节，而varchar(1)则会占用2个字节，因为有一个字节用来存储其长度。 Char和varchar的兄弟类型为binary和varbinary，它们用于保存二进制的字符串，二进制字符串的传统的字符串很类似，但是它们保存的是字节而不是字符。填充也有所不同，MySQL使用\\0（0字节）填充binary值，而不是空格，并且不会在获取数据的时候把填充的值截掉。 BLOB和TEXT类型 BLOB和TEXT分别用二进制和字符形式保存大量数据。 日期和时间类型DATETIME 和 TIMESTAMP的区别： MySQL提供两种相似的数据类型：DATETIME 和 TIMESTAMP，对于很多应用程序，它们都能正常工作，但是在某些情况下，一种会好于另外一种。 DATETIME：能够保存大范围的值，从1001年到9999年，精度为秒，它把日期和时间封装到一个格式为yyyy:MM:dd:HH:mm:ss的整数当中，与时区无关。它使用了8个字节存储空间。 TIMESTAMP：保持了自1970年1月1日午夜（格林尼治标准时间）以来的秒数，它和Unix的时间戳相同。它只使用了4个字节存储空间。因此它比DATETIME的范围小得多。它表示自能从1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。 但是，TIMESTAMP显示的值依赖于时区，MySQL服务器、操作系统及客户端连接都有时区设置。因此，保存0值的TIMESTAMP实际显示的时间是美国东部的时间1969-12-31 19:00:00，与格林尼治标准时间（GMT）相差5小时。 MYSQL数据库命名与其设计规范标准化和规范化数据的标准化有助于消除数据库中的数据冗余。标准化有好几种形式，但Third Normal Form（3NF）通常被认为在性能、扩展性和数据完整性方面达到了最好平衡。简单来说，遵守3NF 标准的数据库的表设计原则是： “One Fact in One Place”即某个表只包括其本身基本的属性，当不是它们本身所具有的属性时需进行分解。表之间的关系通过外键相连接。它具有以下特点：有一组表专门存放通过键连接起来的关联数据。 举例：某个存放客户及其有关定单的3NF 数据库就可能有两个表：Customer和Order。Order表不包含定单关联客户的任何信息，但表内会存放一个键值，该键指向Customer表里包含该客户信息的那一行。 事实上，为了效率的缘故，对表不进行标准化有时也是必要的。 数据库涉及字符规范 采用26个英文字母(区分大小写)和0-9这十个自然数,加上下划线’_’组成,共63个字符.不能出现其他字符(注释除外). 注意事项: 1) 以上MYSQL数据库命名都不得超过30个字符的系统限制.变量名的长度限制为29(不包括标识字符@). 2) 数据对象、变量的命名都采用英文字符,禁止使用中文命名.绝对不要在对象名的字符之间留空格. 3) 小心保留词,要保证你的字段名没有和保留词、数据库系统或者常用访问方法冲突 5) 保持字段名和类型的一致性,在命名字段并为其指定数据类型的时候一定要保证一致性.假如数据类型在一个表里是整数,那在另一个表里可就别变成字符型了.命名规范 数据表名使用小写英文以及下划线组成,尽量说明是那个应用或者系统在使用的. 相关应用的数据表使用同一前缀,如论坛的表使用cdb_前缀,博客的数据表使用supe_前缀,前缀名称一般不超过5字 。备份数据表名使用正式表名加上备份时间组成 字段名称使用单词组合完成,首字母小写,后面单词的首字母大写,最好是带表名前缀. 如 web_user 表的字段: 1231. userId 2. userName 3. userPassword 索引使用原则1) 逻辑主键使用唯一的成组索引,对系统键(作为存储过程)采用唯一的非成组索引,对任何外键列采用非成组索引.考虑数据库的空间有多大,表如何进行访问,还有这些访问是否主要用作读写. 2) 大多数数据库都索引自动创建的主键字段,但是可别忘了索引外键,它们也是经常使用的键,比如运行查询显示主表和所有关联表的某条记录就用得上. 3) 不要索引blob/text等字段,不要索引大型字段(有很多字符),这样作会让索引占用太多的存储空间. 4) 不要索引常用的小型表 不要为小型数据表设置任何键,假如它们经常有插入和删除操作就更别这样作了.对这些插入和删除操作的索引维护可能比扫描表空间消耗更多的时间. 多对多的关系若两个实体之间存在多对多的关系，则应消除这种关系。消除的办法是，在两者之间增加第三个实体。这样，原来一个多对多的关系，现在变为两个一对多的关系。要将原来两个实体的属性合理地分配到三个实体中去。这里的第三个实体，实质上是一个较复杂的关系，它对应一张基本表。一般来讲，数据库设计工具不能识别多对多的关系，但能处理多对多的关系。 主键与外键在多表中的重复出现, 不属于数据冗余非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的重复出现，而是字段的派生出现。〖例4〗：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。因此，我们提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。 主键 选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。 常见的可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。 SQLSQL语句规范所有sql关键词全部大写,比如SELECT,UPDATE,FROM,ORDER,BY等,所有的表名和库名都要用包含 如: SELECT COUNT(*) FROM cdb_members WHERE userName = ‘aeolus’; 基本表的定义删除与修改数据类型空值的处理空值NULL","link":"/2019/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"title":"leetcode(1-10)记录","text":"题目1-7为之前做过的题目，这里不再记录 8. 字符串转换整数 (atoi) 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: “42”输出: 42示例 2: 输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3: 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。示例 4: 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。示例 5: 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解决思路由于python中不存在字符限制，可以使用正则表达式进行解决 解决方法123class Solution: def myAtoi(self, s: str) -&gt; int: return max(min(int(*re.findall('^[\\+\\-]?\\d+', s.lstrip())), 2**31 - 1), -2**31)","link":"/2019/11/27/leetcode-1-10-%E8%AE%B0%E5%BD%95/"},{"title":"利用hexo搭建个人博客","text":"基于hexo搭建个人博客1.安装nodejs 2.添加淘宝源 1npm install -g cnpm --registry=https://registry.npm.taobao.org 3.安装hexo 1cnpm install -g hexo-cli 4.创建空文件夹 5.切换到空文件夹 6.生成 1sudo hexo init 7.新建github仓库 仓库名必须为 用户名.github.io 8. cnpm install –save hexo-deployer-git 9.设置_config.yml 配置(repo为仓库地址，使用ssh可能会提示权限错误，更改https地址后，删除./deploygit文件夹，重新部署。) 1234deploy: type: git repo: https://github.com/sjtu-xx/sjtu-xx.github.io.git branch: master 1hexo d #部署 10.更换主题 将主题下载到theme文件夹下，然后更改_config.yml中的theme文件 123hexo cleanhexo generatehexo deploy 遇到的问题： 插入图片： https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/ icarus主题详细配置： https://cloudy-liu.github.io/2019/06/23/Hexo%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB%E5%88%B0icarus/","link":"/2019/11/18/%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"abaqus","slug":"abaqus","link":"/tags/abaqus/"},{"name":"cae","slug":"cae","link":"/tags/cae/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"latex","slug":"latex","link":"/tags/latex/"},{"name":"绘图","slug":"绘图","link":"/tags/%E7%BB%98%E5%9B%BE/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"cmake","slug":"cmake","link":"/tags/cmake/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"命令","slug":"命令","link":"/tags/%E5%91%BD%E4%BB%A4/"},{"name":"qt","slug":"qt","link":"/tags/qt/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"}],"categories":[{"name":"材料","slug":"材料","link":"/categories/%E6%9D%90%E6%96%99/"},{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"CAE","slug":"材料/CAE","link":"/categories/%E6%9D%90%E6%96%99/CAE/"},{"name":"知识点","slug":"c/知识点","link":"/categories/c/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"学习笔记","slug":"c/学习笔记","link":"/categories/c/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"cmake","slug":"c/cmake","link":"/categories/c/cmake/"},{"name":"github","slug":"github","link":"/categories/github/"},{"name":"数据处理","slug":"python/数据处理","link":"/categories/python/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"shell","slug":"shell","link":"/categories/shell/"},{"name":"库","slug":"c/库","link":"/categories/c/%E5%BA%93/"},{"name":"编程竞赛","slug":"编程竞赛","link":"/categories/%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B/"},{"name":"个人博客","slug":"个人博客","link":"/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"leetcode","slug":"编程竞赛/leetcode","link":"/categories/%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B/leetcode/"}]}