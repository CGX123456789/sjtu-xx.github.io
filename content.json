{"meta":{"title":"薛轩的个人博客","subtitle":"XueXuan's blog","description":"","author":"Xue Xuan","url":"https://sjtu-xx.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-11-18T15:25:47.000Z","updated":"2021-02-03T15:59:46.513Z","comments":true,"path":"categories/index.html","permalink":"https://sjtu-xx.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-18T15:27:06.000Z","updated":"2021-02-03T15:59:46.514Z","comments":true,"path":"tags/index.html","permalink":"https://sjtu-xx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"github_clone慢","slug":"github-clone慢","date":"2021-02-03T16:13:03.000Z","updated":"2021-02-19T02:26:06.413Z","comments":true,"path":"2021/02/04/github-clone慢/","link":"","permalink":"https://sjtu-xx.github.io/2021/02/04/github-clone%E6%85%A2/","excerpt":"最近在使用github时，发现从服务器clone到本地非常慢，查找了很多解决方案，最终决定使用配置git代理的方式来进行实现。","text":"最近在使用github时，发现从服务器clone到本地非常慢，查找了很多解决方案，最终决定使用配置git代理的方式来进行实现。 git clone慢： 12345678git config --global --unset http.proxygit config --global --unset https.proxygit config --global http.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:10809git config --global https.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:10809git config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:10808git config --global https.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:10808","categories":[{"name":"CODE工具","slug":"CODE工具","permalink":"https://sjtu-xx.github.io/categories/CODE%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"hexo博客多设备同步","slug":"hexo博客多设备同步","date":"2021-02-03T16:09:35.000Z","updated":"2021-02-19T02:26:06.417Z","comments":true,"path":"2021/02/04/hexo博客多设备同步/","link":"","permalink":"https://sjtu-xx.github.io/2021/02/04/hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5/","excerpt":"之前的hexo博客一直使用mac进行创建提交等。因为很多东西经常需要在windows上进行操作，如果发送到mac再进行提交就有些复杂，因此，尝试在两个操作系统上进行提交。 参考链接：https://www.jianshu.com/p/fceaf373d797","text":"之前的hexo博客一直使用mac进行创建提交等。因为很多东西经常需要在windows上进行操作，如果发送到mac再进行提交就有些复杂，因此，尝试在两个操作系统上进行提交。 参考链接：https://www.jianshu.com/p/fceaf373d797 github上的repo创建了两个分支，master保存静态页面，hexo用于保存网站的全部文件。 旧环境 将旧环境中的文件上传到github的hexo分支： github上切换到hexo分支，git clone仓库到本地。 此时本地会多出一个username.github.io文件夹，命令行cd进去，删除除.git文件夹（如果你看不到这个文件夹，说明是隐藏了。windows下需要右击文件夹内空白处，点选’显示/隐藏 异常文件’，Mac下我就不知道了）外的其他文件夹。 命令行git add -A把工作区的变化（包括已删除的文件）提交到暂存区（ps:git add .提交的变化不包括已删除的文件）。 命令行git commint -m &quot;some description&quot;提交。 命令行git push origin hexo推送到远程hexo分支。此时刷下github，如果正常操作，hexo分支应该已经被清空了。 复制本地username.github.io文件夹中的.git文件夹到hexo项目根目录下。此时，hexo项目已经变成了和远程hexo分支关联的本地仓库了。而username.github.io文件夹的使命到此为止，你可以把它删掉，因为我们只是把它作为一个“中转站”的角色。以后每次发布新文章或修改网站样式文件时，git add . &amp; git commit -m &quot;some description&quot; &amp; git push origin hexo即可把环境文件推送到hexo分支。然后再hexo g -d发布网站并推送静态文件到master分支。 新环境这部分应该要简单一点，如果你已经搭建过一个hexo博客的话。 新电脑上安装node.js和git。 安装hexo：npm install -g hexo-cli。 clone远程仓库到本地 git clone git@github.com:username/username.github.io.git。 根据packge.json安装依赖npm install。 本地生成网站并开启博客服务器：hexo g &amp; hexo s。如果一切正常，此时打开浏览器输入http://localhost:4000/已经可以看到博客正常运行了。 在两台电脑上的同步操作至此，迁移工作已完成，在两台电脑之间的同步操作如下： git pull从远程hexo分支拉取最新的环境文件到本地，可以理解为svn的更新操作。比如在公司写了博客，回家在电脑上也要写需要先执行这一步操作。 文章写完，要发布时，需要先提交环境文件，再发布文章。按以下顺序执行命令：git add .、git commit -m &quot;some descrption&quot;、git push origin hexo、hexo g -d。","categories":[{"name":"其他工具","slug":"其他工具","permalink":"https://sjtu-xx.github.io/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sjtu-xx.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://sjtu-xx.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"JAVA-SE笔记5（Web）","slug":"JAVA-SE笔记5（Web）","date":"2021-02-03T11:14:56.000Z","updated":"2021-02-19T02:26:06.135Z","comments":true,"path":"2021/02/03/JAVA-SE笔记5（Web）/","link":"","permalink":"https://sjtu-xx.github.io/2021/02/03/JAVA-SE%E7%AC%94%E8%AE%B05%EF%BC%88Web%EF%BC%89/","excerpt":"JAVA WEB部分","text":"JAVA WEB部分 Web开发端口 不同的进程有不同的端口号，用来区分不同的软件 范围：0~65535 TCP，UDP分别由65536个端口号，两个协议的端口不冲突 端口分类： 公有端口0~1023： http：80 https：443 ftp：21 telent：23 程序注册端口：1024~49151 Tomcat：8080 MySQL：3306 Oracle：1521 动态、私有：49152~65535 123netstat -ano # 查看所有端口netstat -ano|findstr \"5900\" #查看指定端口tasklist|findstr \"8696\" #查看指定端口的进程 Web基础对于Browser来说，请求页面的流程如下： 与服务器建立TCP连接； 发送HTTP请求； 收取HTTP响应，然后把网页在浏览器中显示出来。 浏览器发送的HTTP请求如下： 12345GET &#x2F; HTTP&#x2F;1.1Host: www.sina.com.cnUser-Agent: Mozilla&#x2F;5.0 xxxAccept: *&#x2F;*Accept-Language: zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8 其中，第一行表示使用GET请求获取路径为/的资源，并使用HTTP/1.1协议，从第二行开始，每行都是以Header: Value形式表示的HTTP头，比较常用的HTTP Header包括： Host: 表示请求的主机名，因为一个服务器上可能运行着多个网站，因此，Host表示浏览器正在请求的域名； User-Agent: 标识客户端本身，例如Chrome浏览器的标识类似Mozilla/5.0 ... Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...) like Gecko； Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有； Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate, br。 HTTP目前有多个版本，1.0是早期版本，浏览器每次建立TCP连接后，只发送一个HTTP请求并接收一个HTTP响应，然后就关闭TCP连接。由于创建TCP连接本身就需要消耗一定的时间，因此，HTTP 1.1允许浏览器和服务器在同一个TCP连接上反复发送、接收多个HTTP请求和响应，这样就大大提高了传输效率。 我们注意到HTTP协议是一个请求-响应协议，它总是发送一个请求，然后接收一个响应。能不能一次性发送多个请求，然后再接收多个响应呢？HTTP 2.0可以支持浏览器同时发出多个请求，但每个请求需要唯一标识，服务器可以不按请求的顺序返回多个响应，由浏览器自己把收到的响应和请求对应起来。可见，HTTP 2.0进一步提高了传输效率，因为浏览器发出一个请求后，不必等待响应，就可以继续发下一个请求。 HTTP 3.0为了进一步提高速度，将抛弃TCP协议，改为使用无需创建连接的UDP协议，目前HTTP 3.0仍然处于实验阶段。 TCP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.io.IOException;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class Server &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(8080); // 监听指定端口 System.out.println(\"server is running...\"); for (; ; ) &#123; Socket sock = ss.accept(); System.out.println(\"connected from \" + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); &#125; &#125;&#125;class Handler extends Thread &#123; Socket sock; public Handler(Socket sock) &#123; this.sock = sock; &#125; public void run() &#123; try (InputStream input = this.sock.getInputStream()) &#123; try (OutputStream output = this.sock.getOutputStream()) &#123; handle(input, output); &#125; &#125; catch (Exception e) &#123; try &#123; this.sock.close(); &#125; catch (IOException ioe) &#123; &#125; System.out.println(\"client disconnected.\"); &#125; &#125; private void handle(InputStream input, OutputStream output) throws IOException &#123; System.out.println(\"Process new http request...\"); var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); // 读取HTTP请求: boolean requestOk = false; String first = reader.readLine(); if (first.startsWith(\"GET / HTTP/1.\")) &#123; requestOk = true; &#125; for (; ; ) &#123; String header = reader.readLine(); if (header.isEmpty()) &#123; // 读取到空行时, HTTP Header读取完毕 break; &#125; System.out.println(header); &#125; System.out.println(requestOk ? \"Response OK\" : \"Response Error\"); if (!requestOk) &#123; // 发送错误响应: writer.write(\"HTTP/1.0 404 Not Found\\r\\n\"); writer.write(\"Content-Length: 0\\r\\n\"); writer.write(\"\\r\\n\"); writer.flush(); &#125; else &#123; // 发送成功响应: String data = \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"; int length = data.getBytes(StandardCharsets.UTF_8).length; writer.write(\"HTTP/1.0 200 OK\\r\\n\"); writer.write(\"Connection: close\\r\\n\"); writer.write(\"Content-Type: text/html\\r\\n\"); writer.write(\"Content-Length: \" + length + \"\\r\\n\"); writer.write(\"\\r\\n\"); // 空行标识Header和Body的分隔 writer.write(data); writer.flush(); &#125; &#125;&#125; 聊天应用Server 123456789101112131415161718192021222324252627282930import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class TcpServerDemo1 &#123; public static void main(String[] args) &#123; try (ServerSocket serverSocket = new ServerSocket(9999)) &#123; try (Socket socket = serverSocket.accept()) &#123; try (InputStream inputStream = socket.getInputStream()) &#123; try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();) &#123; byte[] buffer = new byte[1024]; int len; while ((len = inputStream.read(buffer)) != -1) &#123; byteArrayOutputStream.write(buffer, 0, len); &#125; String s = byteArrayOutputStream.toString(); System.out.println(s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Client 12345678910111213141516171819import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;import java.nio.charset.StandardCharsets;public class TcpClientDemo1 &#123; public static void main(String[] args) &#123; try &#123; InetAddress iadress = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; Socket socket = new Socket(iadress, port); OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"欢迎你\".getBytes(StandardCharsets.UTF_8)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 传文件server 1234567891011121314151617181920212223package mmm.tcp;import java.io.FileOutputStream;import java.io.FilterOutputStream;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class TcpServerDemo2 &#123; public static void main(String[] args) &#123; try (ServerSocket serverSocket = new ServerSocket(9999)) &#123; try(Socket socket = serverSocket.accept())&#123; try(InputStream inputStream = socket.getInputStream())&#123; try(FileOutputStream fileOutputStream = new FileOutputStream(\"test.iml\"))&#123; inputStream.transferTo(fileOutputStream); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Client 1234567891011121314151617181920package mmm.tcp;import java.io.FileInputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class TcpClientDemo2 &#123; public static void main(String[] args) &#123; try (Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9999)) &#123; try (OutputStream outputStream = socket.getOutputStream()) &#123; try (FileInputStream fileInputStream = new FileInputStream(\"kuangDemo.iml\")) &#123; fileInputStream.transferTo(outputStream); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; UDP消息发送Client 12345678910111213public class UdpClient &#123; public static void main(String[] args) &#123; try (DatagramSocket datagramSocket = new DatagramSocket()) &#123; String msg = \"你好啊\"; InetAddress inetAddress = InetAddress.getByName(\"localhost\"); int port = 9090; DatagramPacket packet = new DatagramPacket(msg.getBytes(StandardCharsets.UTF_8), 0, msg.getBytes(StandardCharsets.UTF_8).length, inetAddress, port); datagramSocket.send(packet); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Server 123456789101112public class UdpServer &#123; public static void main(String[] args) &#123; try(DatagramSocket datagramSocket = new DatagramSocket(9090))&#123; byte[] bytes = new byte[1024]; DatagramPacket datagramPacket = new DatagramPacket(bytes, 0, bytes.length); datagramSocket.receive(datagramPacket); System.out.println(new String(datagramPacket.getData(),0,datagramPacket.getLength())); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 聊天TalkReiver 1234567891011121314151617181920212223242526272829public class TalkReceiver implements Runnable&#123; DatagramSocket datagramSocket = null; private int port; private String msgFrom; public TalkReceiver(int port,String msgFrom) &#123; this.port = port; this.msgFrom = msgFrom; try &#123; datagramSocket = new DatagramSocket(this.port); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; try&#123; while (true) &#123; byte[] buffer = new byte[1024]; DatagramPacket datagramPacket = new DatagramPacket(buffer, 0, buffer.length); datagramSocket.receive(datagramPacket); System.out.println(msgFrom+\":\"+new String(datagramPacket.getData())); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; TalkSender 1234567891011121314151617181920212223242526272829303132333435public class TalkSender implements Runnable &#123; DatagramSocket datagramSocket = null; BufferedReader bufferedReader = null; int fromPort; int toPort; String toIp; public TalkSender(int fromPort, String toIp, int toPort) &#123; this.fromPort = fromPort; this.toPort = toPort; this.toIp = toIp; try &#123; datagramSocket = new DatagramSocket(this.fromPort); bufferedReader = new BufferedReader(new InputStreamReader(System.in)); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; try &#123; while (true) &#123; String data = bufferedReader.readLine(); byte[] datas = data.getBytes(StandardCharsets.UTF_8); DatagramPacket datagramPacket = new DatagramPacket(datas, 0, datas.length, InetAddress.getByName(this.toIp), this.toPort); datagramSocket.send(datagramPacket); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; Student 123456public class Student &#123; public static void main(String[] args) &#123; new Thread(new TalkSender(4444,\"localhost\",6666)).start(); new Thread(new TalkReceiver(8888,\"老师\")).start(); &#125;&#125; Teacher 123456public class Teacher &#123; public static void main(String[] args) &#123; new Thread(new TalkSender(9999,\"localhost\",8888)).start(); new Thread(new TalkReceiver(6666,\"老师\")).start(); &#125;&#125; URL123456789101112public class UrlDown &#123; public static void main(String[] args) throws Exception &#123; URL url = new URL(\"http://xuexuan.site/images/avatar.png\"); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); try (InputStream inputStream = urlConnection.getInputStream()) &#123; try(FileOutputStream os = new FileOutputStream(\"avatar.png\"))&#123; inputStream.transferTo(os); &#125; &#125; urlConnection.disconnect(); &#125;&#125; Servlet基础1.Maven:注意打包方式为war，dependencies中的scope为provided，确保只在编译时使用，不会打包到war文件 123456789101112131415161718192021222324252627282930&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;web-servlet-hello&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;hello&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 2.最简单的Servlet：类必须继承自HttpServlet，然后通过覆写doGet或doPost来实现请求处理。 123456789101112131415// WebServlet注解表示这是一个Servlet，并映射到地址/:@WebServlet(urlPatterns = \"/\")public class HelloServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 设置响应类型: resp.setContentType(\"text/html\"); // 获取输出流: PrintWriter pw = resp.getWriter(); // 写入响应: pw.write(\"&lt;h1&gt;Hello, world!&lt;/h1&gt;\"); // 最后不要忘记flush强制输出: pw.flush(); &#125;&#125; 3.之后，需要在工程目录下src/main/webapp/WEB-INF目录下，创建一个web.xml描述文件。文件内容可以固定如下： 123456&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;/web-app&gt; 4.需要先启动web服务器，然后运行war，让服务器加载Servlet来处理请求。 常用的支持Servlet API的Web服务器有：Tomcat，Jetty，GlassFish 下载Tomcat后，解压，将打包好的hello.war复制到webapps目录下，然后进入bin目录，执行startup文件。 通过localhost:8080/hello便可以进行网站的访问。 环境快速搭建 Idea 可以直接在Configuration中进行配置 Tomcat实际也是Java程序，启动流程如下： 启动JVM并执行Tomcat的main()方法； 加载war并初始化Servlet； 正常服务。 可以将Tomcat的jar包全部引进来，然后自己编写一个main方法，先启动Tomcat，然后加载webapp pom.xml 12345678910111213141516171819202122232425262728293031323334&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;web-servlet-embedded&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;tomcat.version&gt;9.0.26&lt;/tomcat.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Tomcat中包含了Servlet API引用 main方法： 12345678910111213141516public class Main &#123; public static void main(String[] args) throws Exception &#123; // 启动Tomcat: Tomcat tomcat = new Tomcat(); tomcat.setPort(Integer.getInteger(\"port\", 8080)); tomcat.getConnector(); // 创建webapp: Context ctx = tomcat.addWebapp(\"\", new File(\"src/main/webapp\").getAbsolutePath()); WebResourceRoot resources = new StandardRoot(ctx); resources.addPreResources( new DirResourceSet(resources, \"/WEB-INF/classes\", new File(\"target/classes\").getAbsolutePath(), \"/\")); ctx.setResources(resources); tomcat.start(); tomcat.getServer().await(); &#125;&#125; 进阶HttpServletRequestHttpServletRequest封装了一个HTTP请求，它实际上是从ServletRequest继承而来。最早设计Servlet时，设计者希望Servlet不仅能处理HTTP，也能处理类似SMTP等其他协议，因此，单独抽出了ServletRequest接口，但实际上除了HTTP外，并没有其他协议会用Servlet处理，所以这是一个过度设计。 我们通过HttpServletRequest提供的接口方法可以拿到HTTP请求的几乎全部信息，常用的方法有： getMethod()：返回请求方法，例如，&quot;GET&quot;，&quot;POST&quot;； getRequestURI()：返回请求路径，但不包括请求参数，例如，&quot;/hello&quot;； getQueryString()：返回请求参数，例如，&quot;name=Bob&amp;a=1&amp;b=2&quot;； getParameter(name)：返回请求参数，GET请求从URL读取参数，POST请求从Body中读取参数； getContentType()：获取请求Body的类型，例如，&quot;application/x-www-form-urlencoded&quot;； getContextPath()：获取当前Webapp挂载的路径，对于ROOT来说，总是返回空字符串&quot;&quot;； getCookies()：返回请求携带的所有Cookie； getHeader(name)：获取指定的Header，对Header名称不区分大小写； getHeaderNames()：返回所有Header名称； getInputStream()：如果该请求带有HTTP Body，该方法将打开一个输入流用于读取Body； getReader()：和getInputStream()类似，但打开的是Reader； getRemoteAddr()：返回客户端的IP地址； getScheme()：返回协议类型，例如，&quot;http&quot;，&quot;https&quot;； HttpServletResponseHttpServletResponse封装了一个HTTP响应。由于HTTP响应必须先发送Header，再发送Body，所以，操作HttpServletResponse对象时，必须先调用设置Header的方法，最后调用发送Body的方法。 常用的设置Header的方法有： setStatus(sc)：设置响应代码，默认是200； setContentType(type)：设置Body的类型，例如，&quot;text/html&quot;； setCharacterEncoding(charset)：设置字符编码，例如，&quot;UTF-8&quot;； setHeader(name, value)：设置一个Header的值； addCookie(cookie)：给响应添加一个Cookie； addHeader(name, value)：给响应添加一个Header，因为HTTP协议允许有多个相同的Header； 写入完毕后调用flush是必须的，因为大部分Web服务器都基于HTTP/1.1协议，会复用TCP连接。 写入完毕后不要调用close 重定向与转发重定向12345678910@WebServlet(urlPatterns = \"/hi\")public class RedirectServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 构造重定向的路径: String name = req.getParameter(\"name\"); String redirectToUrl = \"/hello\" + (name == null ? \"\" : \"?name=\" + name); // 发送重定向响应: resp.sendRedirect(redirectToUrl); &#125;&#125; 重定向有两种：一种是302响应，称为临时重定向，一种是301响应，称为永久重定向。两者的区别是，如果服务器发送301永久重定向响应，浏览器会缓存/hi到/hello这个重定向的关联，下次请求/hi的时候，浏览器就直接发送/hello请求了。 redirect()方法用于实现302重定向。 301重定向的实现方式： 12resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);resp.setHeader(\"Location\",\"/hello\"); ForwardForward指内部转发。一个Servlet将请求转发给另一个Servlet。 123456@WebServlet(urlPatterns=\"/morning\")public class ForwardServlet extends HttpServlet&#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; req.getRequestDispatcher(\"/hello\").forward(req, resp); &#125;&#125; 使用Session和CookieSession1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@WebServlet(urlPatterns=\"/signin\")public class SignInServlet extends HttpServlet&#123; // 模拟一个数据库: private Map&lt;String, String&gt; users = Map.of(\"bob\", \"bob123\", \"alice\", \"alice123\", \"tom\", \"tomcat\"); // GET请求时显示登录页: protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"text/html\"); PrintWriter pw = resp.getWriter(); pw.write(\"&lt;h1&gt;Sign In&lt;/h1&gt;\"); pw.write(\"&lt;form action=\\\"/signin\\\" method=\\\"post\\\"&gt;\"); pw.write(\"&lt;p&gt;Username: &lt;input name=\\\"username\\\"&gt;&lt;/p&gt;\"); pw.write(\"&lt;p&gt;Password: &lt;input name=\\\"password\\\" type=\\\"password\\\"&gt;&lt;/p&gt;\"); pw.write(\"&lt;p&gt;&lt;button type=\\\"submit\\\"&gt;Sign In&lt;/button&gt; &lt;a href=\\\"/\\\"&gt;Cancel&lt;/a&gt;&lt;/p&gt;\"); pw.write(\"&lt;/form&gt;\"); pw.flush(); &#125; // POST请求时处理用户登录: protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String name = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); String expectedPassword = users.get(name.toLowerCase()); if (expectedPassword != null &amp;&amp; expectedPassword.equals(password)) &#123; // 登录成功: req.getSession().setAttribute(\"user\", name); resp.sendRedirect(\"/\"); &#125; else &#123; resp.sendError(HttpServletResponse.SC_FORBIDDEN); &#125; &#125;&#125;@WebServlet(urlPatterns = \"/\")public class IndexServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 从HttpSession获取当前用户名: String user = (String) req.getSession().getAttribute(\"user\"); resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"UTF-8\"); resp.setHeader(\"X-Powered-By\", \"JavaEE Servlet\"); PrintWriter pw = resp.getWriter(); pw.write(\"&lt;h1&gt;Welcome, \" + (user != null ? user : \"Guest\") + \"&lt;/h1&gt;\"); if (user == null) &#123; // 未登录，显示登录链接: pw.write(\"&lt;p&gt;&lt;a href=\\\"/signin\\\"&gt;Sign In&lt;/a&gt;&lt;/p&gt;\"); &#125; else &#123; // 已登录，显示登出链接: pw.write(\"&lt;p&gt;&lt;a href=\\\"/signout\\\"&gt;Sign Out&lt;/a&gt;&lt;/p&gt;\"); &#125; pw.flush(); &#125;&#125;@WebServlet(urlPatterns = \"/signout\")public class SignOutServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 从HttpSession移除用户名: req.getSession().removeAttribute(\"user\"); resp.sendRedirect(\"/\"); &#125;&#125; JSP开发JSP（Java Server Pages），文件必须放到/src/main/webapp下，文件名必须以.jsp结尾，文件与HTML的差别不大，但是需要插入变量，或者动态输出的地方，使用特殊指令&lt;%...%&gt; 示例： 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World - JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- JSP Comment --%&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt; &lt;% out.println(\"Your IP address is \"); %&gt; &lt;span style=\"color:red\"&gt; &lt;%= request.getRemoteAddr() %&gt; &lt;/span&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 整个JSP的内容实际上是一个HTML，但是稍有不同： 包含在&lt;%--和--%&gt;之间的是JSP的注释，它们会被完全忽略； 包含在&lt;%和%&gt;之间的是Java代码，可以编写任意Java代码； 如果使用&lt;%= xxx %&gt;则可以快捷输出一个变量的值。 JSP页面内置的几个变量： out：表示HttpServletResponse的PrintWriter session：表示当前的HttpSession对象。 request：表示HttpSevletRequest对象。 JSP可以通过page指令 12&lt;%@ page import=\"java.io.*\" %&gt;&lt;%@ page import=\"java.util.*\" %&gt; 这样后续的Java代码才能引用简单类名而不是完整类名。 使用include指令可以引入另一个JSP文件： 123456&lt;html&gt;&lt;body&gt; &lt;%@ include file=\"header.jsp\"%&gt; &lt;h1&gt;Index Page&lt;/h1&gt; &lt;%@ include file=\"footer.jsp\"%&gt;&lt;/body&gt; MVC开发 Servlet适合编写Java代码，实现各种复杂的业务逻辑，但不适合输出复杂的HTML； JSP适合编写HTML，并在其中插入动态内容，但不适合编写复杂的Java代码。 将两者结合起来。 1234567891011121314151617181920212223public class User&#123; public long id; public String name; public School school;&#125;public class School&#123; public String name; public String address;&#125;@WebServlet(urlPatterns = \"/user\")public class UserServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 假装从数据库读取: School school = new School(\"No.1 Middle School\", \"101 South Street\"); User user = new User(123, \"Bob\", school); // 放入Request中: req.setAttribute(\"user\", user); // forward给user.jsp: req.getRequestDispatcher(\"/WEB-INF/user.jsp\").forward(req, resp); &#125;&#125; 12345678910111213141516171819202122&lt;%@ page import=\"com.itranswarp.learnjava.bean.*\"%&gt;&lt;% User user = (User) request.getAttribute(\"user\");%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World - JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello &lt;%= user.name %&gt;!&lt;/h1&gt; &lt;p&gt;School Name: &lt;span style=\"color:red\"&gt; &lt;%= user.school.name %&gt; &lt;/span&gt; &lt;/p&gt; &lt;p&gt;School Address: &lt;span style=\"color:red\"&gt; &lt;%= user.school.address %&gt; &lt;/span&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 把user.jsp放到/WEB-INF/目录下，是因为WEB-INF是一个特殊目录，Web Server会阻止浏览器对WEB-INF目录下任何资源的访问，这样就防止用户通过/user.jsp路径直接访问到JSP页面； 我们把UserServlet看作业务逻辑处理，把User看作模型，把user.jsp看作渲染，这种设计模式通常被称为MVC：Model-View-Controller，即UserServlet作为控制器（Controller），User作为模型（Model），user.jsp作为视图（View），整个MVC架构如下： 123456789101112 ┌───────────────────────┐ ┌────&gt;│Controller: UserServlet│ │ └───────────────────────┘ │ │┌───────┐ │ ┌─────┴─────┐│Browser│────┘ │Model: User││ │&lt;───┐ └─────┬─────┘└───────┘ │ │ │ ▼ │ ┌───────────────────────┐ └─────│ View: user.jsp │ └───────────────────────┘ 使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。 MVC模式广泛地应用在Web页面和传统的桌面程序中，我们在这里通过Servlet和JSP实现了一个简单的MVC模型，但它还不够简洁和灵活，后续我们会介绍更简单的Spring MVC开发。 MVC高级开发 https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009 直接把MVC搭在Servlet和JSP之上还是不太好，原因如下： Servlet提供的接口仍然偏底层，需要实现Servlet调用相关接口； JSP对页面开发不友好，更好的替代品是模板引擎； 业务逻辑最好由纯粹的Java类实现，而不是强迫继承自Servlet。 通过普通的Java类实现MVC的Controller： 12345678910111213141516public class UserController &#123; @GetMapping(\"/signin\") public ModelAndView signin() &#123; ... &#125; @PostMapping(\"/signin\") public ModelAndView doSignin(SignInBean bean) &#123; ... &#125; @GetMapping(\"/signout\") public ModelAndView signout(HttpSession session) &#123; ... &#125;&#125; 需要进一步的深入研究 使用Filter","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/categories/JAVA/"},{"name":"基础","slug":"JAVA/基础","permalink":"https://sjtu-xx.github.io/categories/JAVA/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"IDEA使用","slug":"IDEA使用","date":"2021-02-03T11:14:33.000Z","updated":"2021-02-19T02:26:06.129Z","comments":true,"path":"2021/02/03/IDEA使用/","link":"","permalink":"https://sjtu-xx.github.io/2021/02/03/IDEA%E4%BD%BF%E7%94%A8/","excerpt":"IDEA快捷键等的使用","text":"IDEA快捷键等的使用 IDEA使用帮助文档： https://www.jetbrains.com/help/idea/discover-intellij-idea.html 安装目录： 可执行文件目录+用户目录/.IntelliJIdea/ 参数设置 安装目录下的bin文件夹中的idea64.exe.vmoptions文件用于设置虚拟机的相关参数。 1234567891011121314-Xms128m &#x2F;&#x2F;初始内存数，可以改为500，-Xmx750m &#x2F;&#x2F;最大内存数，可以改为1500，可以降低垃圾回收频率-XX:ReservedCodeCacheSize&#x3D;512m &#x2F;&#x2F;提高可以降低代码回收率-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB&#x3D;50-XX:CICompilerCount&#x3D;2-XX:+HeapDumpOnOutOfMemoryError-XX:-OmitStackTraceInFastThrow-ea-Dsun.io.useCanonCaches&#x3D;false-Djdk.http.auth.tunneling.disabledSchemes&#x3D;&quot;&quot;-Djdk.attach.allowAttachSelf&#x3D;true-Djdk.module.illegalAccess.silent&#x3D;true-Dkotlinx.coroutines.debug&#x3D;off 快捷键1.Ctrl 快捷键 介绍 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + E 显示最近打开的文件记录列表 （必备） Ctrl + N 根据输入的 类名 查找类文件 （必备） Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 （必备） Ctrl + P 方法参数提示显示 （必备） Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 （必备） Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备） Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码处显示错误信息 （必备） Ctrl + F3 调转到所选中的词的下一个引用位置 （必备） Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备） Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） Ctrl + Delete 删除光标后面的单词或是中文句 （必备） Ctrl + BackSpace 删除光标前面的单词或是中文句 （必备） Ctrl + 1,2,3…9 定位到对应数值的书签位置 （必备） Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 （必备） Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 （必备） Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 （必备） Ctrl + 前方向键 等效于鼠标滚轮向前效果 （必备） Ctrl + 后方向键 等效于鼠标滚轮向后效果 （必备） 2.Alt 快捷键 介绍 Alt + `\\ 显示版本控制常用操作菜单弹出层 （必备） Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备） Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + Home 定位 / 显示到当前文件的 Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备） Alt + 左方向键 切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备） Alt + 右方向键 按切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备） Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 （必备） Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 （必备） Alt + 1,2,3…9 显示对应数值的选项卡，其中 1 是 Project 用得最多 （必备） 3.Shift 快捷键 介绍 Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误 或 警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F6 对文件 / 文件夹 重命名 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + F9 等效于点击工具栏的 Debug 按钮 Shift + F10 等效于点击工具栏的 Run 按钮 Shift + F11 弹出书签显示层 （必备） Shift + Tab 取消缩进 （必备） Shift + ESC 隐藏当前 或 最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备） Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备） Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 （必备） 4.Ctrl + Alt 快捷键 介绍 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 （必备） Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中 Ctrl + Alt + H 调用层次 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + C 重构-快速提取常量 Ctrl + Alt + F 重构-快速提取成员变量 Ctrl + Alt + V 重构-快速提取变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 （必备） Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 （必备） Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备） Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 Ctrl + Alt + 右括号（]） 在打开多个项目的情况下，切换下一个项目窗口 Ctrl + Alt + 左括号（[） 在打开多个项目的情况下，切换上一个项目窗口 5.Ctrl + Shift 快捷键 介绍 Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备） Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 （必备） Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + E 显示最近修改的文件列表的弹出层 Ctrl + Shift + H 显示方法层次结构 Ctrl + Shift + B 跳转到类型声明处 （必备） Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义 Ctrl + Shift + A 查找动作 / 设置 Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 （必备） Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 （必备） Ctrl + Shift + + 展开所有代码 （必备） Ctrl + Shift + - 折叠所有代码 （必备） Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失 （必备） Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Ctrl + Shift + F9 编译选中的文件 / 包 / Module Ctrl + Shift + F12 编辑器最大化 （必备） Ctrl + Shift + Space 智能代码提示 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift + Backspace 退回到上次修改的地方 （必备） Ctrl + Shift + 1,2,3…9 快速添加指定数值的书签 （必备） Ctrl + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备） Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备） Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备） Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备） Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备） 6.Alt + Shift 快捷键 介绍 Alt + Shift + N 选择 / 添加 task （必备） Alt + Shift + F 显示添加到收藏夹弹出层 / 添加到收藏夹 Alt + Shift + C 查看最近操作项目的变化情况列表 Alt + Shift + I 查看项目当前文件 Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9 弹出 Debug 的可选择菜单 Alt + Shift + F10 弹出 Run 的可选择菜单 Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备） Alt + Shift + 前方向键 移动光标所在行向上移动 （必备） Alt + Shift + 后方向键 移动光标所在行向下移动 （必备） 7.Ctrl + Shift + Alt 快捷键 介绍 Ctrl + Shift + Alt + V 无格式黏贴 （必备） Ctrl + Shift + Alt + N 前往指定的变量 / 方法 Ctrl + Shift + Alt + S 打开当前项目设置 （必备） Ctrl + Shift + Alt + C 复制参考信息 8.其他 快捷键 介绍 F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 （必备） F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 F11 添加书签 （必备） F12 回到前一个工具窗口 （必备） Tab 缩进 （必备） ESC 从工具窗口进入代码文件窗口 （必备） 连按两次Shift 弹出 Search Everywhere 弹出层 常用模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class HelloWorld &#123; public static void main(String[] args) &#123; //sout System.out.println(); //soutp/soutp/soutv/xxx.sout System.out.println(\"args = \" + Arrays.deepToString(args)); int num1 = 1; int num2 = 2; // soutv,就近 System.out.println(\"num2 = \" + num2); // xxx.sout System.out.println(num1); //fori for (int i = 0; i &lt; 12; i++) &#123; &#125; //iter for (String arg : args) &#123; &#125; //itar for (int i = 0; i &lt; args.length; i++) &#123; String arg = args[i]; &#125; //list.for ArrayList list = new ArrayList(); list.add(12); list.add(12); list.add(12); for (Object o : list) &#123; &#125; // list.fori for (int i = 0; i &lt; list.size(); i++) &#123; &#125; // list.forr for (int i = list.size() - 1; i &gt;= 0; i--) &#123; &#125; // ifn \\ xxx.null if (list == null) &#123; &#125; // inn \\ xxx.nn if (list != null) &#123; &#125; &#125; // prsf private static final xxx =; // psf public static final; // psfi public static final int; // psfs public static final String ;&#125; 自定义模板 12private String $VAR1$;$END$ 生成文档Tools-&gt;Generate JavaDoc 设置： Locale: zh_CN command arguments: -encoding UTF-8-charset UTF-8 缓存和索引文件的清理File-&gt;Invalidate Caches/Restart 取消更新设置-》Apperance/behaviors-&gt;system settings-&gt;updates","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/categories/JAVA/"},{"name":"基础","slug":"JAVA/基础","permalink":"https://sjtu-xx.github.io/categories/JAVA/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/tags/JAVA/"}]},{"title":"JAVA-SE笔记4","slug":"JAVA-SE笔记4","date":"2021-01-14T08:14:10.000Z","updated":"2021-02-19T02:26:06.134Z","comments":true,"path":"2021/01/14/JAVA-SE笔记4/","link":"","permalink":"https://sjtu-xx.github.io/2021/01/14/JAVA-SE%E7%AC%94%E8%AE%B04/","excerpt":"JAVA学习笔记第四部分:Maven，网络编程，XML与JSON，JDBC，函数式编程，设计模式","text":"JAVA学习笔记第四部分:Maven，网络编程，XML与JSON，JDBC，函数式编程，设计模式 Maven基础Maven是一个Java项目管理和构建工具。它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建。 Maven项目结构一个使用Maven管理的普通的Java项目，它的目录结构默认如下： 12345678910a-maven-project├── pom.xml├── src│ ├── main│ │ ├── java│ │ └── resources│ └── test│ ├── java│ └── resources└── target 项目的根目录a-maven-project是项目名，它有一个项目描述文件pom.xml，存放Java源码的目录是src/main/java，存放资源文件的目录是src/main/resources，存放测试源码的目录是src/test/java，存放测试资源的目录是src/test/resources，最后，所有编译、打包生成的文件都放在target目录里。这些就是一个Maven项目的标准目录结构。 项目描述文件pom.xml，它的内容长得像下面： 1234567891011121314151617&lt;project ...&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;hello&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; ... &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 其中，groupId类似于Java的包名，通常是公司或组织名称，artifactId类似于Java的类名，通常是项目名称，再加上version，一个Maven工程就是由groupId，artifactId和version作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖commons-logging： 123456Maven使用groupId，artifactId和version唯一定位一个依赖。&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 使用&lt;dependency&gt;声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。 安装Maven 下载地址：https://maven.apache.org 依赖关系Maven定义了几种依赖关系，分别是compile、test、runtime和provided： scope 说明 示例 compile 编译时需要用到该jar包（默认） commons-logging test 编译Test时需要用到该jar包 junit runtime 编译时不需要，但运行时需要用到 mysql provided 编译时需要用到，但运行时由JDK或某个服务器提供 servlet-api 123456&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 唯一ID对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包： groupId：属于组织的名称，类似Java的包名； artifactId：该jar包自身的名称，类似Java的类名； version：该jar包的版本。 Maven镜像中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入.m2目录，创建一个settings.xml配置文件，内容如下： 1234567891011&lt;settings&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- 国内推荐阿里云的Maven镜像 --&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 搜索第三方组件最后一个问题：如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？方法是通过search.maven.org搜索关键字，找到对应的组件后，直接复制。 命令行编译在命令中，进入到pom.xml所在目录，输入以下命令： 1$ mvn clean package 生命周期Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，初学者容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是： Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。 Site Lifecycle 生成项目报告，站点，发布站点。 Clean运行mvn clean ，这个的clean是Clean生命周期的一个阶段。有点绕？要知道有Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段： pre-clean 执行一些需要在clean之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean 执行一些需要在clean之后立刻完成的工作 mvn clean 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。 SiteSite生命周期的各个阶段： pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成项目的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上 DefaultMaven的最重要的Default生命周期，绝大部分工作都发生在这个生命周期中，这里，我只解释一些比较重要和常用的阶段： validate generate-sources process-sources generate-resources process-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目的源代码。 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。 test-compile 编译测试源代码。 process-test-classes test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package 接受编译好的代码，打包成可发布的格式，如 JAR 。 pre-integration-test integration-test post-integration-test verify install 将包安装至本地仓库，以让其它项目依赖。 deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享。 构建流程如果我们运行mvn package，Maven就会执行default生命周期，它会从开始一直运行到package这个phase为止。 Maven另一个常用的生命周期是clean，它会执行3个phase： pre-clean clean （注意这个clean不是lifecycle而是phase） post-clean 经常使用的命令有： mvn clean：清理所有生成的class和jar； mvn clean compile：先清理，再执行到compile； mvn clean test：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile； mvn clean package：先清理，再执行到package。 经常用到的phase： clean：清理 compile：编译 test：运行测试 package：打包 Goal执行一个phase又会触发一个或多个goal： 执行的Phase 对应执行的Goal compile compiler:compile test compiler:testCompile surefire:test goal的命名总是abc:xyz这种形式。 其实我们类比一下就明白了： lifecycle相当于Java的package，它包含一个或多个phase； phase相当于Java的class，它包含一个或多个goal； goal相当于class的method，它其实才是真正干活的。 大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器： 1mvn tomcat:run 使用插件使用Maven实际上就是配置好需要使用的插件，然后通过phase调用它们。 Maven内置的插件： 插件名称 对应执行的phase clean clean compiler compile surefire test jar package 自定义插件，使用maven-shade-plugin可以创建一个可执行的jar，要使用这个插件，需要在pom.xml中声明它： 1234567891011121314151617181920212223&lt;project&gt; ... &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; ... &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 自定义插件往往需要一些配置，例如，maven-shade-plugin需要指定Java程序的入口，它的配置是： 1234567&lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"&gt; &lt;mainClass&gt;com.itranswarp.learnjava.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt;&lt;/configuration&gt; 注意，Maven自带的标准插件例如compiler是无需声明的，只有引入其它的插件才需要声明。 下面列举了一些常用的插件： maven-shade-plugin：打包所有依赖包并生成可执行jar； cobertura-maven-plugin：生成单元测试覆盖率报告； findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。 模块管理通常一个大的项目分为多个模块进行单独开发。 12345678910mutiple-project├── module-a│ ├── pom.xml│ └── src├── module-b│ ├── pom.xml│ └── src└── module-c ├── pom.xml └── src Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的pom.xml。例如，模块A的pom.xml： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-a&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-a&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 模块B的pom.xml： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-b&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-b&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以看出来，模块A和模块B的pom.xml高度相似，因此，我们可以提取出共同部分作为parent： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;parent&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 注意到parent的&lt;packaging&gt;是pom而不是jar，因为parent本身不含任何Java代码。编写parent的pom.xml只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下： 12345678910111213multiple-project├── pom.xml├── parent│ └── pom.xml├── module-a│ ├── pom.xml│ └── src├── module-b│ ├── pom.xml│ └── src└── module-c ├── pom.xml └── src 这样模块A就可以简化为： 12345678910111213141516&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;&#x2F;groupId&gt; &lt;artifactId&gt;parent&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;relativePath&gt;..&#x2F;parent&#x2F;pom.xml&lt;&#x2F;relativePath&gt; &lt;&#x2F;parent&gt; &lt;artifactId&gt;module-a&lt;&#x2F;artifactId&gt; &lt;packaging&gt;jar&lt;&#x2F;packaging&gt; &lt;name&gt;module-a&lt;&#x2F;name&gt;&lt;&#x2F;project&gt; 模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。 如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B： 12345678...&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;&#x2F;groupId&gt; &lt;artifactId&gt;module-b&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 最后，在编译的时候，需要在根目录创建一个pom.xml统一编译： 123456789101112131415161718&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;&#x2F;groupId&gt; &lt;artifactId&gt;build&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;packaging&gt;pom&lt;&#x2F;packaging&gt; &lt;name&gt;build&lt;&#x2F;name&gt; &lt;modules&gt; &lt;module&gt;parent&lt;&#x2F;module&gt; &lt;module&gt;module-a&lt;&#x2F;module&gt; &lt;module&gt;module-b&lt;&#x2F;module&gt; &lt;module&gt;module-c&lt;&#x2F;module&gt; &lt;&#x2F;modules&gt;&lt;&#x2F;project&gt; 这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个&lt;module&gt;，一次性全部编译。 中央仓库其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。 私有仓库私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~/.m2/settings.xml中配置好，使用方式和中央仓位没有任何区别。 本地仓库本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。 使用mvnw使用特定版本的mvn：”Maven Wrapper” 安装 在项目的根目录运行安装命令：mvn -N io.takari:maven:0.7.6:wrapper 使用 使用时，只需要把mvn替换为mvnw即可（linux或macos使用./mvnw） 发布Artifacthttps://www.liaoxuefeng.com/wiki/1252599548343744/1347981037010977 将自己的库发布到Maven的repo中： 以静态文件发布 现在生成到本地，然后上传到github，再制定repo 使用Nexus发布到中央仓库 发布到私有仓库 网络编程网络编程基础IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。 TCP编程123456789┌───────────┐ ┌───────────┐│Application│ │Application│├───────────┤ ├───────────┤│ Socket │ │ Socket │├───────────┤ ├───────────┤│ TCP │ │ TCP │├───────────┤ ┌──────┐ ┌──────┐ ├───────────┤│ IP │&lt;────&gt;│Router│&lt;─────&gt;│Router│&lt;────&gt;│ IP │└───────────┘ └──────┘ └──────┘ └───────────┘ 使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。 服务器端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Server &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(6666); // 监听指定端口 System.out.println(\"server is running...\"); for (;;) &#123; Socket sock = ss.accept(); System.out.println(\"connected from \" + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); &#125; &#125;&#125;class Handler extends Thread &#123; Socket sock; public Handler(Socket sock) &#123; this.sock = sock; &#125; @Override public void run() &#123; try (InputStream input = this.sock.getInputStream()) &#123; try (OutputStream output = this.sock.getOutputStream()) &#123; handle(input, output); &#125; &#125; catch (Exception e) &#123; try &#123; this.sock.close(); &#125; catch (IOException ioe) &#123; &#125; System.out.println(\"client disconnected.\"); &#125; &#125; private void handle(InputStream input, OutputStream output) throws IOException &#123; var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); writer.write(\"hello\\n\"); writer.flush(); for (;;) &#123; String s = reader.readLine(); if (s.equals(\"bye\")) &#123; writer.write(\"bye\\n\"); writer.flush(); break; &#125; writer.write(\"ok: \" + s + \"\\n\"); writer.flush(); &#125; &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031public class Client &#123; public static void main(String[] args) throws IOException &#123; Socket sock = new Socket(\"localhost\", 6666); // 连接指定服务器和端口 try (InputStream input = sock.getInputStream()) &#123; try (OutputStream output = sock.getOutputStream()) &#123; handle(input, output); &#125; &#125; sock.close(); System.out.println(\"disconnected.\"); &#125; private static void handle(InputStream input, OutputStream output) throws IOException &#123; var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); Scanner scanner = new Scanner(System.in); System.out.println(\"[server] \" + reader.readLine()); for (;;) &#123; System.out.print(\"&gt;&gt;&gt; \"); // 打印提示 String s = scanner.nextLine(); // 读取一行输入 writer.write(s); writer.newLine(); writer.flush(); // 刷新缓冲区的数据 String resp = reader.readLine(); System.out.println(\"&lt;&lt;&lt; \" + resp); if (resp.equals(\"bye\")) &#123; break; &#125; &#125; &#125;&#125; UDP编程服务器端 1234567891011121314DatagramSocket ds = new DatagramSocket(6666); // 监听指定端口for (;;) &#123; // 无限循环 // 数据缓冲区: byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); ds.receive(packet); // 收取一个UDP数据包 // 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度 // 将其按UTF-8编码转换为String: String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8); // 发送数据: byte[] data = \"ACK\".getBytes(StandardCharsets.UTF_8); packet.setData(data); ds.send(packet);&#125; 客户端 12345678910111213DatagramSocket ds = new DatagramSocket();ds.setSoTimeout(1000);ds.connect(InetAddress.getByName(\"localhost\"), 6666); // 连接指定服务器和端口// 发送:byte[] data = \"Hello\".getBytes();DatagramPacket packet = new DatagramPacket(data, data.length);ds.send(packet);// 接收:byte[] buffer = new byte[1024];packet = new DatagramPacket(buffer, buffer.length);ds.receive(packet);String resp = new String(packet.getData(), packet.getOffset(), packet.getLength());ds.disconnect(); 发送Email12345678 ┌─────────┐ ┌─────────┐ ┌─────────┐ │░░░░░░░░░│ │░░░░░░░░░│ │░░░░░░░░░│┌───────┐ ├─────────┤ ├─────────┤ ├─────────┤ ┌───────┐│░░░░░░░│ │░░░░░░░░░│ │░░░░░░░░░│ │░░░░░░░░░│ │░░░░░░░│├───────┤ ├─────────┤ ├─────────┤ ├─────────┤ ├───────┤│ │───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│&lt;───│ │└───────┘ └─────────┘ └─────────┘ └─────────┘ └───────┘ MUA MTA MTA MDA MUA 类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。电子邮件一旦到达MDA，就不再动了。 MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。 SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，我们无需关心SMTP协议的底层原理，只需要使用JavaMail这个标准API就可以直接发送邮件。 首先，我们需要创建一个Maven工程，并把JavaMail相关的两个依赖加入进来： 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.mail-api&lt;&#x2F;artifactId&gt; &lt;version&gt;1.6.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.mail&lt;&#x2F;artifactId&gt; &lt;version&gt;1.6.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; ... 然后，我们通过JavaMail API连接到SMTP服务器上： 1234567891011121314151617181920&#x2F;&#x2F; 服务器地址:String smtp &#x3D; &quot;smtp.office365.com&quot;;&#x2F;&#x2F; 登录用户名:String username &#x3D; &quot;jxsmtp101@outlook.com&quot;;&#x2F;&#x2F; 登录口令:String password &#x3D; &quot;********&quot;;&#x2F;&#x2F; 连接到SMTP服务器587端口:Properties props &#x3D; new Properties();props.put(&quot;mail.smtp.host&quot;, smtp); &#x2F;&#x2F; SMTP主机名props.put(&quot;mail.smtp.port&quot;, &quot;587&quot;); &#x2F;&#x2F; 主机端口号props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;); &#x2F;&#x2F; 是否需要用户认证props.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;); &#x2F;&#x2F; 启用TLS加密&#x2F;&#x2F; 获取Session实例:Session session &#x3D; Session.getInstance(props, new Authenticator() &#123; protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(username, password); &#125;&#125;);&#x2F;&#x2F; 设置debug模式便于调试:session.setDebug(true); 以587端口为例，连接SMTP服务器时，需要准备一个Properties对象，填入相关信息。最后获取Session实例时，如果服务器需要认证，还需要传入一个Authenticator对象，并返回指定的用户名和口令。 当我们获取到Session实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。 发送邮件发送邮件时，我们需要构造一个Message对象，然后调用Transport.send(Message)即可完成发送： 1234567891011MimeMessage message &#x3D; new MimeMessage(session);&#x2F;&#x2F; 设置发送方地址:message.setFrom(new InternetAddress(&quot;me@example.com&quot;));&#x2F;&#x2F; 设置接收方地址:message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;xiaoming@somewhere.com&quot;));&#x2F;&#x2F; 设置邮件主题:message.setSubject(&quot;Hello&quot;, &quot;UTF-8&quot;);&#x2F;&#x2F; 设置邮件正文:message.setText(&quot;Hi Xiaoming...&quot;, &quot;UTF-8&quot;);&#x2F;&#x2F; 发送:Transport.send(message); 绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。 接收EmailHTTP编程RMI远程调用(远程接口)这部分内容使用时参见廖雪峰博客。 XML与JSONXML由于使用了&lt;、&gt;以及引号等标识符，如果内容出现了特殊符号，需要使用&amp;???;表示转义。例如，Java&lt;tm&gt;必须写成： 1&lt;name&gt;Java&lt;tm&gt;&lt;&#x2F;name&gt; 常见的特殊字符如下： 字符 表示 &lt; &lt; &gt; &gt; &amp; &amp; “ &quot; ‘ &apos; XML解析 XML是一种树形结构的文档，它有两种标准的解析API： DOM：一次性读取XML，并在内存中表示为树形结构； SAX：以流的形式读取XML，使用事件回调。 DOM Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容： Document：代表整个XML文档； Element：代表一个XML元素； Attribute：代表一个元素的某个属性。 1234567891011121314151617181920212223242526272829InputStream input = Main.class.getResourceAsStream(\"/book.xml\");DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder db = dbf.newDocumentBuilder();Document doc = db.parse(input);void printNode(Node n, int indent) &#123; for (int i = 0; i &lt; indent; i++) &#123; System.out.print(' '); &#125; switch (n.getNodeType()) &#123; case Node.DOCUMENT_NODE: // Document节点 System.out.println(\"Document: \" + n.getNodeName()); break; case Node.ELEMENT_NODE: // 元素节点 System.out.println(\"Element: \" + n.getNodeName()); break; case Node.TEXT_NODE: // 文本 System.out.println(\"Text: \" + n.getNodeName() + \" = \" + n.getNodeValue()); break; case Node.ATTRIBUTE_NODE: // 属性 System.out.println(\"Attr: \" + n.getNodeName() + \" = \" + n.getNodeValue()); break; default: // 其他 System.out.println(\"NodeType: \" + n.getNodeType() + \", NodeName: \" + n.getNodeName()); &#125; for (Node child = n.getFirstChild(); child != null; child = child.getNextSibling()) &#123; printNode(child, indent + 1); &#125;&#125; SAX SAX解析会触发一系列事件： startDocument：开始读取XML文档； startElement：读取到了一个元素，例如&lt;book&gt;； characters：读取到了字符； endElement：读取到了一个结束的元素，例如&lt;/book&gt;； endDocument：读取XML文档结束。 如果我们用SAX API解析XML，Java代码如下： 1234InputStream input = Main.class.getResourceAsStream(\"/book.xml\");SAXParserFactory spf = SAXParserFactory.newInstance();SAXParser saxParser = spf.newSAXParser();saxParser.parse(input, new MyHandler()); 关键代码SAXParser.parse()除了需要传入一个InputStream外，还需要传入一个回调对象，这个对象要继承自DefaultHandler： 123456789101112131415161718192021222324252627282930313233class MyHandler extends DefaultHandler &#123; public void startDocument() throws SAXException &#123; print(\"start document\"); &#125; public void endDocument() throws SAXException &#123; print(\"end document\"); &#125; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; print(\"start element:\", localName, qName); &#125; public void endElement(String uri, String localName, String qName) throws SAXException &#123; print(\"end element:\", localName, qName); &#125; public void characters(char[] ch, int start, int length) throws SAXException &#123; print(\"characters:\", new String(ch, start, length)); &#125; public void error(SAXParseException e) throws SAXException &#123; print(\"error:\", e); &#125; void print(Object... objs) &#123; for (Object obj : objs) &#123; System.out.print(obj); System.out.print(\" \"); &#125; System.out.println(); &#125;&#125; Jackson XML文档的结构： 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;book id&#x3D;&quot;1&quot;&gt; &lt;name&gt;Java核心技术&lt;&#x2F;name&gt; &lt;author&gt;Cay S. Horstmann&lt;&#x2F;author&gt; &lt;isbn lang&#x3D;&quot;CN&quot;&gt;1234567&lt;&#x2F;isbn&gt; &lt;tags&gt; &lt;tag&gt;Java&lt;&#x2F;tag&gt; &lt;tag&gt;Network&lt;&#x2F;tag&gt; &lt;&#x2F;tags&gt; &lt;pubDate&#x2F;&gt;&lt;&#x2F;book&gt; 我们发现，它完全可以对应到一个定义好的JavaBean中： 12345678public class Book &#123; public long id; public String name; public String author; public String isbn; public List&lt;String&gt; tags; public String pubDate;&#125; Jackson的开源的第三方库可以轻松做到XML到JavaBean的转换。我们要使用Jackson，先添加两个Maven的依赖： com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.10.1 org.codehaus.woodstox:woodstox-core-asl:4.4.1 然后，定义好JavaBean，就可以用下面几行代码解析： 12345678910InputStream input = Main.class.getResourceAsStream(\"/book.xml\");JacksonXmlModule module = new JacksonXmlModule();XmlMapper mapper = new XmlMapper(module);Book book = mapper.readValue(input, Book.class);System.out.println(book.id);System.out.println(book.name);System.out.println(book.author);System.out.println(book.isbn);System.out.println(book.tags);System.out.println(book.pubDate); JSON一个典型的JSON如下： 12345678910&#123; \"id\": 1, \"name\": \"Java核心技术\", \"author\": &#123; \"firstName\": \"Abc\", \"lastName\": \"Xyz\" &#125;, \"isbn\": \"1234567\", \"tags\": [\"Java\", \"Network\"]&#125; JSON作为数据传输的格式，有几个显著的优点： JSON只允许使用UTF-8编码，不存在编码问题； JSON只允许使用双引号作为key，特殊字符用\\转义，格式简单； 浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。 JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型： 键值对：{&quot;key&quot;: value} 数组：[1, 2, 3] 字符串：&quot;abc&quot; 数值（整数和浮点数）：12.34 布尔值：true或false 空值：null 12345// JSON string to JavaScript object:jsObj = JSON.parse(jsonStr);// JavaScript object to JSON string:jsonStr = JSON.stringify(jsObj); 常用的用于解析JSON的第三方库有： Jackson Gson Fastjson … 只需要引入以下Maven依赖： com.fasterxml.jackson.core:jackson-databind:2.10.0 就可以使用下面的代码解析一个JSON文件： 12345InputStream input = Main.class.getResourceAsStream(\"/book.json\");ObjectMapper mapper = new ObjectMapper();// 反序列化时忽略不存在的JavaBean属性:mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);Book book = mapper.readValue(input, Book.class); 把JSON解析为JavaBean的过程称为反序列化。如果把JavaBean变为JSON，那就是序列化。要实现JavaBean到JSON的序列化，只需要一行代码： 1String json = mapper.writeValueAsString(book); 要把JSON的某些值解析为特定的Java对象，例如LocalDate，也是完全可以的。例如： 1234&#123; &quot;name&quot;: &quot;Java核心技术&quot;, &quot;pubDate&quot;: &quot;2016-09-01&quot;&#125; 要解析为： 1234public class Book &#123; public String name; public LocalDate pubDate;&#125; 只需要引入标准的JSR 310关于JavaTime的数据格式定义至Maven： com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.10.0 然后，在创建ObjectMapper时，注册一个新的JavaTimeModule： 1ObjectMapper mapper &#x3D; new ObjectMapper().registerModule(new JavaTimeModule()); 有些时候，内置的解析规则和扩展的解析规则如果都不满足我们的需求，还可以自定义解析。 举个例子，假设Book类的isbn是一个BigInteger： 1234public class Book &#123; public String name; public BigInteger isbn;&#125; 但JSON数据并不是标准的整形格式： 1234&#123; &quot;name&quot;: &quot;Java核心技术&quot;, &quot;isbn&quot;: &quot;978-7-111-54742-6&quot;&#125; 直接解析，肯定报错。这时，我们需要自定义一个IsbnDeserializer，用于解析含有非数字的字符串： 1234567891011121314public class IsbnDeserializer extends JsonDeserializer&lt;BigInteger&gt; &#123; public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException &#123; // 读取原始的JSON字符串内容: String s = p.getValueAsString(); if (s != null) &#123; try &#123; return new BigInteger(s.replace(\"-\", \"\")); &#125; catch (NumberFormatException e) &#123; throw new JsonParseException(p, s, e); &#125; &#125; return null; &#125;&#125; 然后，在Book类中使用注解标注： 123456public class Book &#123; public String name; // 表示反序列化isbn时使用自定义的IsbnDeserializer: @JsonDeserialize(using = IsbnDeserializer.class) public BigInteger isbn;&#125; 类似的，自定义序列化时我们需要自定义一个IsbnSerializer，然后在Book类中标注@JsonSerialize(using = ...)即可。 JDBC编程函数式编程函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 函数式编程最早是数学家阿隆佐·邱奇研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算。 Lambda表达式123456789public class Main &#123; public static void main(String[] args) &#123; String[] array = new String[] &#123; \"Apple\", \"Orange\", \"Banana\", \"Lemon\" &#125;; Arrays.sort(array, (s1, s2) -&gt; &#123; return s1.compareTo(s2); &#125;); System.out.println(String.join(\", \", array)); &#125;&#125; FunctionalInterface 只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。 对于模板类，如果只有一个抽象方法，也可以用FunctionalInterface注解。 方法引用方法引用：如果某个方法的签名和接口恰好一致，就可以直接传入方法引用。 1234567891011public class Main &#123; public static void main(String[] args) &#123; String[] array = new String[] &#123; \"Apple\", \"Orange\", \"Banana\", \"Lemon\" &#125;; Arrays.sort(array, Main::cmp); System.out.println(String.join(\", \", array)); &#125; static int cmp(String s1, String s2) &#123; return s1.compareTo(s2); &#125;&#125; 构造方法引用 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; names = List.of(\"Bob\", \"Alice\", \"Tim\"); List&lt;Person&gt; persons = names.stream().map(Person::new).collect(Collectors.toList()); System.out.println(persons); &#125;&#125;class Person &#123; String name; public Person(String name) &#123; this.name = name; &#125; public String toString() &#123; return \"Person:\" + this.name; &#125;&#125; 使用Stream java.io java.util.stream 存储 顺序读写的byte或char 顺序输出的任意Java对象实例 用途 序列化至文件或网络 内存计算／业务逻辑 List的用途是操作一组已存在的Java对象，而Stream实现的是惰性计算，两者对比如下： java.util.List java.util.stream 元素 已分配并存储在内存 可能未分配，实时计算 用途 操作一组已存在的Java对象 惰性计算 Stream可以储存有限或无限个元素。 Stream API的基本用法就是：创建一个Stream，然后做若干次转换，最后调用一个求值方法获取真正计算的结果： 12345int result = createNaturalStream() // 创建Stream .filter(n -&gt; n % 2 == 0) // 任意个转换 .map(n -&gt; n * n) // 任意个转换 .limit(100) // 任意个转换 .sum(); // 最终计算结果 创建StreamStream.of() 1234Stream&lt;String&gt; stream = Stream.of(\"A\", \"B\", \"C\", \"D\");// forEach()方法相当于内部循环调用，// 可传入符合Consumer接口的void accept(T t)的方法引用：stream.forEach(System.out::println); 基于数组或Collection 1234Stream&lt;String&gt; stream1 = Arrays.stream(new String[] &#123; \"A\", \"B\", \"C\" &#125;);Stream&lt;String&gt; stream2 = List.of(\"X\", \"Y\", \"Z\").stream();stream1.forEach(System.out::println);stream2.forEach(System.out::println); 基于Supplier 1Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp); 实例： 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; Stream&lt;Integer&gt; natual = Stream.generate(new NatualSupplier()); // 注意：无限序列必须先变成有限序列再打印: natual.limit(20).forEach(System.out::println); &#125;&#125;class NatualSupplier implements Supplier&lt;Integer&gt; &#123; int n = 0; public Integer get() &#123; n++; return n; &#125;&#125; 其他方法 使用API提供的接口，直接获得。 1234567try(Stream&lt;String&gt; lines = Files.lines(Paths.get(\"/path/to/file.tct\")))&#123; ...&#125;Pattern p = Pattern.compile(\"\\\\s+\");Stream&lt;String&gt; s = p.splitAsStream(\"The quick brown fox jumps over the lazy dog\");s.forEach(...); 由于java的范型不支持基本类型，如果使用Stream就会产生频繁的装箱、拆箱操作。为了提高效率，java标准库提供了IntStream\\LongStream\\DoubleStream这三种使用基本类型的Stream。 使用mapMap:将一个Stream转换为另一个Stream 12Stream&lt;Integer&gt; s = Stream.of(1, 2, 3, 4, 5);Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n); 使用filter123IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9) .filter(n -&gt; n % 2 != 0) .forEach(System.out::println); 使用reduce12int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).reduce(0, (acc, n) -&gt; acc + n);System.out.println(sum); // 45 综合使用案例 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; // 按行读取配置文件: List&lt;String&gt; props = List.of(\"profile=native\", \"debug=true\", \"logging=warn\", \"interval=500\"); Map&lt;String, String&gt; map = props.stream() // 把k=v转换为Map[k]=v: .map(kv -&gt; &#123; String[] ss = kv.split(\"\\\\=\", 2); return Map.of(ss[0], ss[1]); &#125;) // 把所有Map聚合到一个Map: .reduce(new HashMap&lt;String, String&gt;(), (m, kv) -&gt; &#123; m.putAll(kv); return m; &#125;); // 打印结果: map.forEach((k, v) -&gt; &#123; System.out.println(k + \" = \" + v); &#125;); &#125;&#125; 输出集合输出为List 12Stream&lt;String&gt; stream = Stream.of(\"Apple\",\"\",null,\"Pear\",\" \",\"Orange\");List&lt;String&gt; list = stream.filter(s -&gt; s!=null &amp;&amp; !s.isBlank()).collect(Collections.toList()); 输出为数组 12List&lt;String&gt; list = List.of(\"Apple\", \"Banana\", \"Orange\");String[] array = list.stream().toArray(String[]::new); 输出为Map 1234567Stream&lt;String&gt; stream = Stream.of(\"APPL:Apple\", \"MSFT:Microsoft\");Map&lt;String, String&gt; map = stream .collect(Collectors.toMap( // 把元素s映射为key: s -&gt; s.substring(0, s.indexOf(':')), // 把元素s映射为value: s -&gt; s.substring(s.indexOf(':') + 1))); 分组输出 1234List&lt;String&gt; list = List.of(\"Apple\", \"Banana\", \"Blackberry\", \"Coconut\", \"Avocado\", \"Cherry\", \"Apricots\");Map&lt;String, List&lt;String&gt;&gt; groups = list.stream() .collect(Collectors.groupingBy(s -&gt; s.substring(0, 1), Collectors.toList()));System.out.println(groups); 其他操作12345678910111213141516171819202122232425262728293031323334353637383940414243//排序List&lt;String&gt; list = List.of(\"Orange\", \"apple\", \"Banana\") .stream() .sorted() .collect(Collectors.toList());List&lt;String&gt; list = List.of(\"Orange\", \"apple\", \"Banana\") .stream() .sorted(String::compareToIgnoreCase) .collect(Collectors.toList());//去重List.of(\"A\", \"B\", \"A\", \"C\", \"B\", \"D\") .stream() .distinct() .collect(Collectors.toList()); // [A, B, C, D]//截取List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\") .stream() .skip(2) // 跳过A, B .limit(3) // 截取C, D, E .collect(Collectors.toList()); // [C, D, E]//合并Stream&lt;String&gt; s1 = List.of(\"A\", \"B\", \"C\").stream();Stream&lt;String&gt; s2 = List.of(\"D\", \"E\").stream();Stream&lt;String&gt; s = Stream.concat(s1, s2);System.out.println(s.collect(Collectors.toList())); // [A, B, C, D, E]//flatMapStream&lt;List&lt;Integer&gt;&gt; s = Stream.of( Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6), Arrays.asList(7, 8, 9));Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());//并行Stream&lt;String&gt; s = ...String[] result = s.parallel() // 变成一个可以并行处理的Stream .sorted() // 可以进行并行排序 .toArray(String[]::new); 其他聚合方法除了reduce()和collect()外，Stream还有一些常用的聚合方法： count()：用于返回元素个数； max(Comparator&lt;? super T&gt; cp)：找出最大元素； min(Comparator&lt;? super T&gt; cp)：找出最小元素。 针对IntStream、LongStream和DoubleStream，还额外提供了以下聚合方法： sum()：对所有元素求和； average()：对所有元素求平均数。 还有一些方法，用来测试Stream的元素是否满足以下条件： boolean allMatch(Predicate&lt;? super T&gt;)：测试是否所有元素均满足测试条件； boolean anyMatch(Predicate&lt;? super T&gt;)：测试是否至少有一个元素满足测试条件。 最后一个常用的方法是forEach()，它可以循环处理Stream的每个元素，我们经常传入System.out::println来打印Stream的元素： 1234Stream&lt;String&gt; s &#x3D; ...s.forEach(str -&gt; &#123; System.out.println(&quot;Hello, &quot; + str);&#125;); 设计模式设计模式基于OOP编程提炼，基于以下几个原则： 开闭原则：软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。 里氏替换原则：如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。 创建型模式创建型模式包括： 工厂方法：Factory Method 抽象工厂：Abstract Factory 建造者：Builder 原型：Prototype 单例：Singleton 工厂方法 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。 工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品： 12345678┌─────────────┐ ┌─────────────┐│ Product │ │ Factory │└─────────────┘ └─────────────┘ ▲ ▲ │ │┌─────────────┐ ┌─────────────┐│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │└─────────────┘ └─────────────┘ 1234567891011121314151617public interface NumberFactory&#123; // 创建方法 Number parse(String s); // 获取工厂实例 static NumberFactory getFactory()&#123; return impl; &#125; static NumberFactory impl = new NumberFactoryImpl();&#125;public class NumberFactoryImpl implements NumberFactory&#123; public Number parse(String s)&#123; return new BigDecimal(s); &#125;&#125; 另一种形式(静态工厂方法)： 12345public class NumberFactory &#123; public static Number parse(String s) &#123; return new BigDecimal(s); &#125;&#125; 工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。 抽象工厂 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 生成器 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。 12345678910111213141516171819202122public class HtmlBuilder &#123; private HeadingBuilder headingBuilder = new HeadingBuilder(); private HrBuilder hrBuilder = new HrBuilder(); private ParagraphBuilder paragraphBuilder = new ParagraphBuilder(); private QuoteBuilder quoteBuilder = new QuoteBuilder(); public String toHtml(String markdown) &#123; StringBuilder buffer = new StringBuilder(); markdown.lines().forEach(line -&gt; &#123; if (line.startsWith(\"#\")) &#123; buffer.append(headingBuilder.buildHeading(line)).append('\\n'); &#125; else if (line.startsWith(\"&gt;\")) &#123; buffer.append(quoteBuilder.buildQuote(line)).append('\\n'); &#125; else if (line.startsWith(\"---\")) &#123; buffer.append(hrBuilder.buildHr(line)).append('\\n'); &#125; else &#123; buffer.append(paragraphBuilder.buildParagraph(line)).append('\\n'); &#125; &#125;); return buffer.toString(); &#125;&#125; 原型 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。 我们举个例子：如果我们已经有了一个String[]数组，想再创建一个一模一样的String[]数组，怎么写？ 实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下： 1234// 原型:String[] original = &#123; \"Apple\", \"Pear\", \"Banana\" &#125;;// 新对象:String[] copy = Arrays.copyOf(original, original.length); 123456789101112131415//使用原型模式更好的方式是定义一个copy()方法，返回明确的类型：public class Student &#123; private int id; private String name; private int score; public Student copy() &#123; Student std = new Student(); std.id = this.id; std.name = this.name; std.score = this.score; return std; &#125;&#125; 单例 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 12345678910111213public class Singleton &#123; // 静态字段引用唯一实例: private static final Singleton INSTANCE = new Singleton(); // 通过静态方法返回实例: public static Singleton getInstance() &#123; return INSTANCE; &#125; // private构造方法保证外部无法实例化: private Singleton() &#123; &#125;&#125; 另一种实现Singleton的方式是利用Java的enum，因为Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可： 12345678910111213141516public enum World &#123; // 唯一枚举: INSTANCE; private String name = \"world\"; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;String name = World.INSTANCE.getName(); 通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是new操作符： 1234@Component // 表示一个单例组件public class MyService &#123; ...&#125; 延迟加载 延迟加载，即在调用方第一次调用getInstance()时才初始化全局唯一实例，类似这样： 12345678910111213public class Singleton &#123; private static Singleton INSTANCE &#x3D; null; public static Singleton getInstance() &#123; if (INSTANCE &#x3D;&#x3D; null) &#123; INSTANCE &#x3D; new Singleton(); &#125; return INSTANCE; &#125; private Singleton() &#123; &#125;&#125; 遗憾的是，这种写法在多线程中是错误的，在竞争条件下会创建出多个实例。必须对整个方法进行加锁： 123456public synchronized static Singleton getInstance() &#123; if (INSTANCE &#x3D;&#x3D; null) &#123; INSTANCE &#x3D; new Singleton(); &#125; return INSTANCE;&#125; 但加锁会严重影响并发性能。还有些童鞋听说过双重检查，类似这样： 12345678910public static Singleton getInstance() &#123; if (INSTANCE &#x3D;&#x3D; null) &#123; synchronized (Singleton.class) &#123; if (INSTANCE &#x3D;&#x3D; null) &#123; INSTANCE &#x3D; new Singleton(); &#125; &#125; &#125; return INSTANCE;&#125; 然而，由于Java的内存模型，双重检查在这里不成立。要真正实现延迟加载，只能通过Java的ClassLoader机制完成。如果没有特殊的需求，使用Singleton模式的时候，最好不要延迟加载，这样会使代码更简单。 结构型模式结构型模式有： 适配器 桥接 组合 装饰器 外观 享元 代理 适配器 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 123456789101112131415161718public class RunnableAdapter implements Runnable &#123; // 引用待转换接口: private Callable&lt;?&gt; callable; public RunnableAdapter(Callable&lt;?&gt; callable) &#123; this.callable = callable; &#125; // 实现指定接口: public void run() &#123; // 将指定接口调用委托给转换接口调用: try &#123; callable.call(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 桥接 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 123456789101112131415161718 ┌───────────┐ │ Car │ └───────────┘ ▲ │ ┌───────────┐ ┌─────────┐ │RefinedCar │ ─ ─ ─&gt;│ Engine │ └───────────┘ └─────────┘ ▲ ▲ ┌────────┼────────┐ │ ┌──────────────┐ │ │ │ ├─│ FuelEngine │┌───────┐┌───────┐┌───────┐ │ └──────────────┘│BigCar ││TinyCar││BossCar│ │ ┌──────────────┐└───────┘└───────┘└───────┘ ├─│ElectricEngine│ │ └──────────────┘ │ ┌──────────────┐ └─│ HybridEngine │ └──────────────┘ 组合 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 使用Composite模式时，需要先统一单个节点以及“容器”节点的接口： 123456789 ┌───────────┐ │ Node │ └───────────┘ ▲ ┌────────────┼────────────┐ │ │ │┌───────────┐┌───────────┐┌───────────┐│ElementNode││ TextNode ││CommentNode│└───────────┘└───────────┘└───────────┘ 组合模式一般用于层级结构 装饰器 动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。 给FileInputStream增加缓冲和解压缩功能，用Decorator模式写出来如下： 123456&#x2F;&#x2F; 创建原始的数据源:InputStream fis &#x3D; new FileInputStream(&quot;test.gz&quot;);&#x2F;&#x2F; 增加缓冲功能:InputStream bis &#x3D; new BufferedInputStream(fis);&#x2F;&#x2F; 增加解压缩功能:InputStream gis &#x3D; new GZIPInputStream(bis); 或者一次性写成这样： 1234InputStream input = new GZIPInputStream( // 第二层装饰 new BufferedInputStream( // 第一层装饰 new FileInputStream(\"test.gz\") // 核心功能 )); 设计自己的装饰器 1234567891011121314151617181920212223242526272829public interface TextNode &#123; // 设置text: void setText(String text); // 获取text: String getText();&#125;public abstract class NodeDecorator implements TextNode &#123; protected final TextNode target; protected NodeDecorator(TextNode target) &#123; this.target = target; &#125; public void setText(String text) &#123; this.target.setText(text); &#125;&#125;public class BoldDecorator extends NodeDecorator &#123; public BoldDecorator(TextNode target) &#123; super(target); &#125; public String getText() &#123; return \"&lt;b&gt;\" + target.getText() + \"&lt;/b&gt;\"; &#125;&#125; 外观 为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 它的基本思想如下： 如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。 享元 运用共享技术有效地支持大量细粒度的对象。 享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。 123456789101112131415161718192021222324252627282930public class Student &#123; // 持有缓存: private static final Map&lt;String, Student&gt; cache = new HashMap&lt;&gt;(); // 静态工厂方法: public static Student create(int id, String name) &#123; String key = id + \"\\n\" + name; // 先查找缓存: Student std = cache.get(key); if (std == null) &#123; // 未找到,创建新对象: System.out.println(String.format(\"create new Student(%s, %s)\", id, name)); std = new Student(id, name); // 放入缓存: cache.put(key, std); &#125; else &#123; // 缓存中存在: System.out.println(String.format(\"return cached Student(%s, %s)\", std.id, std.name)); &#125; return std; &#125; private final int id; private final String name; public Student(int id, String name) &#123; this.id = id; this.name = name; &#125;&#125; 代理 为其他对象提供一种代理以控制对这个对象的访问。 Adapter模式，它用于把A接口转换为B接口： 123456789public BAdapter implements B &#123; private A a; public BAdapter(A a) &#123; this.a = a; &#125; public void b() &#123; a.a(); &#125;&#125; 而Proxy模式不是把A接口转换成B接口，它还是转换成A接口： 123456789public AProxy implements A &#123; private A a; public AProxy(A a) &#123; this.a = a; &#125; public void a() &#123; this.a.a(); &#125;&#125; 用Proxy实现权限检查，我们可以获得更清晰、更简洁的代码： A接口：只定义接口； ABusiness类：只实现A接口的业务逻辑； APermissionProxy类：只实现A接口的权限检查代理。 如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。 远程代理、虚代理、保护代理 行为型模式行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。 行为型模式有： 责任链 命令 解释器 迭代器 中介 备忘录 观察者 状态 策略 模板方法 访问者 责任链 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 命令 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。 解释器 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。举个例子，针对以下的匹配条件： 以+开头的数字表示的区号和电话号码，如+861012345678； 以英文开头，后接英文和数字，并以.分隔的域名，如www.liaoxuefeng.com； 以/开头的文件路径，如/path/to/file.txt； … 因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。 实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单： 12String s &#x3D; &quot;+861012345678&quot;;System.out.println(s.matches(&quot;^\\\\+\\\\d+$&quot;)); 类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。 迭代器 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 中介 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 例如可以用于多个界面控件。 备忘录 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 备忘录模式是为了保存对象的内部状态，并在将来恢复，大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。 观察者 备忘录模式是为了保存对象的内部状态，并在将来恢复，大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。 观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。 12345678910┌─────────┐ ┌───────────────┐│ Store │─ ─ ─&gt;│ProductObserver│└─────────┘ └───────────────┘ │ ▲ │ │ ┌─────┴─────┐ ▼ │ │┌─────────┐ ┌─────────┐ ┌─────────┐│ Product │ │ Admin │ │Customer │ ...└─────────┘ └─────────┘ └─────────┘ 状态 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 状态模式的设计思想是把不同状态的逻辑分离到不同的状态类中，从而使得增加新状态更容易； 状态模式的实现关键在于状态转换。简单的状态转换可以直接由调用方指定，复杂的状态转换可以在内部根据条件触发完成。 策略 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 模板方法 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 访问者 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/categories/JAVA/"},{"name":"基础","slug":"JAVA/基础","permalink":"https://sjtu-xx.github.io/categories/JAVA/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"JAVA-SE笔记3","slug":"JAVA-SE笔记3","date":"2020-12-31T03:31:15.000Z","updated":"2021-02-19T02:26:06.133Z","comments":true,"path":"2020/12/31/JAVA-SE笔记3/","link":"","permalink":"https://sjtu-xx.github.io/2020/12/31/JAVA-SE%E7%AC%94%E8%AE%B03/","excerpt":"JAVA SE第三部分笔记 单元测试、正则表达式、加密与安全、多线程","text":"JAVA SE第三部分笔记 单元测试、正则表达式、加密与安全、多线程 单元测试测试驱动开发（TDD，Test-Driven Development）流程 12345678910111213 编写接口 │ ▼ 编写测试 │ ▼┌─&gt; 编写实现│ ││ N ▼└── 运行测试 │ Y ▼ 任务完成 JUnitJUnit是开源的，是单元测试的标准框架。 JUnit会给出测试报告：包括成功率，代码覆盖率。 测试覆盖率应该在80%以上。 测试类的名称通常为&lt;原名称&gt;Test.java，测试方法加上@Test注解。 测试文件实例： 12345678910111213141516package com.itranswarp.learnjava;import static org.junit.jupiter.api.Assertions.*;import org.junit.jupiter.api.Test;public class FactorialTest &#123; @Test void testFact() &#123; assertEquals(1, Factorial.fact(1)); assertEquals(2, Factorial.fact(2)); assertEquals(6, Factorial.fact(3)); assertEquals(3628800, Factorial.fact(10)); assertEquals(2432902008176640000L, Factorial.fact(20)); &#125;&#125; assertEquals(expected, actual) assertEquals(double expected, double actual, double delta)由于浮点数无法精确比较，需要指定误差值 assertTrue(): 期待结果为true assertFalse(): 期待结果为false assertNotNull(): 期待结果为非null assertArrayEquals(): 期待结果为数组并与期望数组每个元素的值均相等 … 单元测试规范： 单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试； 每个单元测试应当互相独立，不依赖运行的顺序； 测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串&quot;&quot;等情况。 FixtureFixture：编写测试前准备、测试后清理的代码部分。 对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理，它们在各个@Test方法中互不影响，因为是不同的实例； 对于静态变量，在@BeforeAll中初始化，在@AfterAll中清理，它们在各个@Test方法中均是唯一实例，会影响各个@Test方法。 123456789101112131415161718192021222324252627public class CalculatorTest &#123; Calculator calculator; @BeforeEach public void setUp() &#123; this.calculator = new Calculator(); &#125; @AfterEach public void tearDown() &#123; this.calculator = null; &#125; @Test void testAdd() &#123; assertEquals(100, this.calculator.add(100)); assertEquals(150, this.calculator.add(50)); assertEquals(130, this.calculator.add(-20)); &#125; @Test void testSub() &#123; assertEquals(-100, this.calculator.sub(100)); assertEquals(-150, this.calculator.sub(50)); assertEquals(-130, this.calculator.sub(-20)); &#125;&#125; 异常测试123456789101112131415161718// 一般方法，Executable@Testvoid testNegative() &#123; assertThrows(IllegalArgumentException.class, new Executable() &#123; @Override public void execute() throws Throwable &#123; Factorial.fact(-1); &#125; &#125;);&#125;// 函数式编程@Testvoid testNegative() &#123; assertThrows(IllegalArgumentException.class, () -&gt; &#123; Factorial.fact(-1); &#125;);&#125; 条件测试对于需要跳过的方法使用@Disabled注解。 12345678910111213141516@Disabled@Testvoid testBug101() &#123; // 这个测试不会运行&#125;// 操作系统判断@EnabledOnOs(OS.WINDOWS)@EnabledOnOs(&#123; OS.LINUX, OS.MAC &#125;)@DisabledOnOs(OS.WINDOWS)// JRE@DisabledOnJre(JRE.JAVA_8)// 64位@EnabledIfSystemProperty(named = \"os.arch\", matches = \".*64.*\")// 环境变量@EnabledIfEnvironmentVariable(named = \"DEBUG\", matches = \"true\") 参数化测试@ParameterizedTest 12345@ParameterizedTest@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)void testAbs(int x) &#123; assertEquals(x, Math.abs(x));&#125; 参数传入 123456789101112131415161718192021222324252627// 方法1 MethodSource注解@ParameterizedTest@MethodSourcevoid testCapitalize(String input, String result) &#123; assertEquals(result, StringUtils.capitalize(input));&#125;static List&lt;Arguments&gt; testCapitalize() &#123; return List.of( // arguments: Arguments.arguments(\"abc\", \"Abc\"), // Arguments.arguments(\"APPLE\", \"Apple\"), // Arguments.arguments(\"gooD\", \"Good\"));&#125;// 方法2 CsvSource@ParameterizedTest@CsvSource(&#123; \"abc, Abc\", \"APPLE, Apple\", \"gooD, Good\" &#125;)void testCapitalize(String input, String result) &#123; assertEquals(result, StringUtils.capitalize(input));&#125;// 方法3 CsvFileSource： 文件必须在classpath中，通常放在test文件夹中@ParameterizedTest@CsvFileSource(resources = &#123; \"/test-capitalize.csv\" &#125;)void testCapitalizeUsingCsvFile(String input, String result) &#123; assertEquals(result, StringUtils.capitalize(input));&#125; 正则表达式12345678public class Main &#123; public static void main(String[] args) &#123; String re = \"java|php\"; System.out.println(\"java\".matches(re)); System.out.println(\"php\".matches(re)); System.out.println(\"go\".matches(re)); &#125;&#125; 匹配规则特殊字符\\\\、\\&amp; 中文字符匹配非ASCII字符，例如中文，那就用\\u####的十六进制表示，例如：a\\u548cc匹配字符串&quot;a和c&quot;，中文字符和的Unicode编码是548c。 \\\\d{3,5}可以匹配3～5个数字 单个字符的匹配规则如下： 正则表达式 规则 可以匹配 A 指定字符 A \\u548c 指定Unicode字符 和 . 任意字符 a，b，&amp;，0 \\d 数字0~9 0~9 \\w 大小写字母，数字和下划线 a~z，A~Z，0~9，_ \\s 空格、Tab键 空格，Tab \\D 非数字 a，A，&amp;，_，…… \\W 非\\w &amp;，@，中，…… \\S 非\\s a，A，&amp;，_，…… 多个字符的匹配规则如下： 正则表达式 规则 可以匹配 A* 任意个数字符 空，A，AA，AAA，…… A+ 至少1个字符 A，AA，AAA，…… A? 0个或1个字符 空，A A{3} 指定个数字符 AAA A{2,3} 指定范围个数字符 AA，AAA A{2,} 至少n个字符 AA，AAA，AAAA，…… A{0,3} 最多n个字符 空，A，AA，AAA 复杂匹配规则主要有： 正则表达式 规则 可以匹配 ^ 开头 字符串开头 $ 结尾 字符串结束 [ABC] […]内任意字符 A，B，C [A-F0-9xy] 指定范围的字符 A，……，F，0，……，9，x，y A-F 指定范围外的任意字符 非A~F AB\\ CD\\ EF AB或CD或EF AB，CD，EF 分组匹配用(...)把要提取的规则分组 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Pattern p = Pattern.compile(\"(\\\\d&#123;3,4&#125;)\\\\-(\\\\d&#123;7,8&#125;)\"); Matcher m = p.matcher(\"010-12345678\"); if (m.matches()) &#123; String g1 = m.group(1);// 0为整个匹配到的字符串 String g2 = m.group(2); System.out.println(g1); System.out.println(g2); &#125; else &#123; System.out.println(\"匹配失败!\"); &#125; &#125;&#125; 使用Matcher时，必须首先调用matches()判断是否匹配成功，匹配成功后，才能调用group()提取子串。 非贪婪匹配给定一个匹配规则，加上?后就变成了非贪婪匹配。 12345678910public class Main &#123; public static void main(String[] args) &#123; Pattern pattern = Pattern.compile(\"(\\\\d+?)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); if (matcher.matches()) &#123; System.out.println(\"group1=\" + matcher.group(1)); // \"123\" System.out.println(\"group2=\" + matcher.group(2)); // \"0000\" &#125; &#125;&#125; \\d??第一个?表示0个或1个，第二个?表示非贪婪匹配 分割、搜索和替换分割字符串 123\"a b c\".split(\"\\\\s\"); // &#123; \"a\", \"b\", \"c\" &#125;\"a b c\".split(\"\\\\s\"); // &#123; \"a\", \"b\", \"\", \"c\" &#125;\"a, b ;; c\".split(\"[\\\\,\\\\;\\\\s]+\"); // &#123; \"a\", \"b\", \"c\" &#125; 搜索字符串 1234567891011public class Main &#123; public static void main(String[] args) &#123; String s = \"the quick brown fox jumps over the lazy dog.\"; Pattern p = Pattern.compile(\"\\\\wo\\\\w\"); Matcher m = p.matcher(s); while (m.find()) &#123; String sub = s.substring(m.start(), m.end()); System.out.println(sub); &#125; &#125;&#125; 替换字符串 1234567public class Main &#123; public static void main(String[] args) &#123; String s = \"The quick\\t\\t brown fox jumps over the lazy dog.\"; String r = s.replaceAll(\"\\\\s+\", \" \"); System.out.println(r); // \"The quick brown fox jumps over the lazy dog.\" &#125;&#125; 反向引用 12345678// $1、$2等可以用来表示匹配到的字符串public class Main &#123; public static void main(String[] args) &#123; String s = \"the quick brown fox jumps over the lazy dog.\"; String r = s.replaceAll(\"\\\\s([a-z]&#123;4&#125;)\\\\s\", \" &lt;b&gt;$1&lt;/b&gt; \"); System.out.println(r); &#125;&#125; 加密与安全三防： 防窃听 防篡改 防伪造 编码算法URL编码 出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则： 如果字符是A~Z，a~z，0~9以及-、_、.、*，则保持不变； 如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示。 Java标准库提供了一个URLEncoder类来对任意字符串进行URL编码 123456789import java.net.URLEncoder;import java.nio.charset.StandardCharsets;public class Main&#123; public static void main(String[] args)&#123; String encoded = URLEncoder.encode(\"中文\",StandardCharsets.UTF_8); System.out.println(encoded); &#125;&#125; 和标准的URL编码稍有不同，URLEncoder把空格字符编码成+，而现在的URL编码标准要求空格被编码为%20，不过，服务器都可以处理这两种情况。 123456public class Main &#123; public static void main(String[] args) &#123; String decoded = URLDecoder.decode(\"%E4%B8%AD%E6%96%87%21\", StandardCharsets.UTF_8); System.out.println(decoded); &#125;&#125; Base64编码 Base64对二进制数据进行编码。可以把任意长度的二进制数据变为纯文本，且只包含A~Z、a~z、0~9、+、/、=这些字符。 它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。（长度不足时补充0） 因为6位整数的范围总是0~63，所以，能用64个字符表示：字符A~Z对应索引0~25，字符a~z对应索引26~51，字符0~9对应索引52~61，最后两个索引62、63分别用字符+和/表示。 123456789┌───────────────┬───────────────┬───────────────┐│ e4 │ b8 │ ad │└───────────────┴───────────────┴───────────────┘┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘┌───────────┬───────────┬───────────┬───────────┐│ 39 │ 0b │ 22 │ 2d │└───────────┴───────────┴───────────┴───────────┘ 12345678910111213public class Main &#123; public static void main(String[] args) &#123; byte[] input = new byte[] &#123; (byte) 0xe4, (byte) 0xb8, (byte) 0xad &#125;; // 编码 String b64encoded = Base64.getEncoder().encodeToString(input); String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input); // 删除补充的0 System.out.println(b64encoded); // 解码 byte[] output = Base64.getDecoder().decode(\"5Lit\"); System.out.println(Arrays.toString(output)); // [-28, -72, -83] &#125;&#125; 电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。 Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。 哈希算法java自带的哈希算法:https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms 哈希算法（Hash）又称摘要算法（Digest）：对输入计算，得到固定长度的输出。 特点：输入相同则输出相同；输入不同大概率输出不同。 常用的哈希算法有： 算法 输出长度（位） 输出长度（字节） MD5 128 bits 16 bytes SHA-1 160 bits 20 bytes RipeMD-160 160 bits 20 bytes SHA-256 256 bits 32 bytes SHA-512 512 bits 64 bytes 1234567891011public class Main &#123; public static void main(String[] args) throws Exception &#123; // 创建一个MessageDigest实例: MessageDigest md = MessageDigest.getInstance(\"MD5\"); // 反复调用update输入数据: md.update(\"Hello\".getBytes(\"UTF-8\")); md.update(\"World\".getBytes(\"UTF-8\")); byte[] result = md.digest(); // 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6 System.out.println(new BigInteger(1, result).toString(16)); &#125;&#125; 为了抵御彩虹攻击（黑客持有大量常见字符串的MD5加密结果），可以使用加盐加密（Salt）：digest = md5(salt+inputPassword) GetInstance与new区别： new的使用如Object object = new Object()，这时候，就必须要知道有第二个Object的存在，而第二个Object也常常是在当前的应用程序域中的，可以被直接调用的 GetInstance的使用在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。 BouncyCastleBouncyCastle是一个提供了很多哈希算法和加密算法的第三方库. java.security提供了一种机制，通过将BouncyCastle在启动时注册一下，就可以与原有的加密算法无缝接入。 1234567891011public class Main &#123; public static void main(String[] args) throws Exception &#123; // 注册BouncyCastle: Security.addProvider(new BouncyCastleProvider()); // 按名称正常调用: MessageDigest md = MessageDigest.getInstance(\"RipeMD160\"); md.update(\"HelloWorld\".getBytes(\"UTF-8\")); byte[] result = md.digest(); System.out.println(new BigInteger(1, result).toString(16)); &#125;&#125; Hmac算法Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。 Hmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5： 1HmacMD5 ≈ md5(secure_random_key, input) 使用HmacMD5而不是用MD5加salt，有如下好处： HmacMD5使用的key长度是64字节，更安全； Hmac是标准算法，同样适用于SHA-1等其他哈希算法； Hmac输出和原有的哈希算法长度一致。 1234567891011121314public class Main &#123; public static void main(String[] args) throws Exception &#123; KeyGenerator keyGen = KeyGenerator.getInstance(\"HmacMD5\"); SecretKey key = keyGen.generateKey(); // 打印随机生成的key: byte[] skey = key.getEncoded(); System.out.println(new BigInteger(1, skey).toString(16)); Mac mac = Mac.getInstance(\"HmacMD5\"); mac.init(key); mac.update(\"HelloWorld\".getBytes(\"UTF-8\")); byte[] result = mac.doFinal(); System.out.println(new BigInteger(1, result).toString(16)); &#125;&#125; 使用HmacMD5的步骤是： 通过名称HmacMD5获取KeyGenerator实例； 通过KeyGenerator创建一个SecretKey实例； 通过名称HmacMD5获取Mac实例； 用SecretKey初始化Mac实例； 对Mac实例反复调用update(byte[])输入数据； 调用Mac实例的doFinal()获取最终的哈希值。 存储用户名和口令的数据库结构如下： username secret_key (64 bytes) password bob a8c06e05f92e…5e16 7e0387872a57c85ef6dddbaa12f376de alice e6a343693985…f4be c1f929ac2552642b302e739bc0cdbaac tim f27a973dfdc0…6003 af57651c3a8a73303515804d4af43790 12345678910111213141516public class Main &#123; public static void main(String[] args) throws Exception &#123; byte[] hkey = new byte[] &#123; 106, 70, -110, 125, 39, -20, 52, 56, 85, 9, -19, -72, 52, -53, 52, -45, -6, 119, -63, 30, 20, -83, -28, 77, 98, 109, -32, -76, 121, -106, 0, -74, -107, -114, -45, 104, -104, -8, 2, 121, 6, 97, -18, -13, -63, -30, -125, -103, -80, -46, 113, -14, 68, 32, -46, 101, -116, -104, -81, -108, 122, 89, -106, -109 &#125;; // 恢复私钥 SecretKey key = new SecretKeySpec(hkey, \"HmacMD5\"); Mac mac = Mac.getInstance(\"HmacMD5\"); mac.init(key); mac.update(\"HelloWorld\".getBytes(\"UTF-8\")); byte[] result = mac.doFinal(); System.out.println(Arrays.toString(result)); // [126, 59, 37, 63, 73, 90, 111, -96, -77, 15, 82, -74, 122, -55, -67, 54] &#125;&#125; 对称加密算法常用的对称加密算法有： 算法 密钥长度 工作模式 填充模式 DES 56/64 ECB/CBC/PCBC/CTR/… NoPadding/PKCS5Padding/… AES 128/192/256 ECB/CBC/PCBC/CTR/… NoPadding/PKCS5Padding/PKCS7Padding/… IDEA 128 ECB PKCS5Padding/PKCS7Padding/… AES加密ECB模式（简单） 1234567891011121314151617181920212223242526272829303132333435363738import java.security.*;import java.util.Base64;import javax.crypto.*;import javax.crypto.spec.*;public class Main &#123; public static void main(String[] args) throws Exception &#123; // 原文: String message = \"Hello, world!\"; System.out.println(\"Message: \" + message); // 128位密钥 = 16 bytes Key: byte[] key = \"1234567890abcdef\".getBytes(\"UTF-8\"); // 加密: byte[] data = message.getBytes(\"UTF-8\"); byte[] encrypted = encrypt(key, data); System.out.println(\"Encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(key, encrypted); System.out.println(\"Decrypted: \" + new String(decrypted, \"UTF-8\")); &#125; // 加密: public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException &#123; Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); SecretKey keySpec = new SecretKeySpec(key, \"AES\"); cipher.init(Cipher.ENCRYPT_MODE, keySpec); return cipher.doFinal(input); &#125; // 解密: public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException &#123; Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); SecretKey keySpec = new SecretKeySpec(key, \"AES\"); cipher.init(Cipher.DECRYPT_MODE, keySpec); return cipher.doFinal(input); &#125;&#125; CBC模式（安全性高） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Main &#123; public static void main(String[] args) throws Exception &#123; // 原文: String message = \"Hello, world!\"; System.out.println(\"Message: \" + message); // 256位密钥 = 32 bytes Key: byte[] key = \"1234567890abcdef1234567890abcdef\".getBytes(\"UTF-8\"); // 加密: byte[] data = message.getBytes(\"UTF-8\"); byte[] encrypted = encrypt(key, data); System.out.println(\"Encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(key, encrypted); System.out.println(\"Decrypted: \" + new String(decrypted, \"UTF-8\")); &#125; // 加密: public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException &#123; Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\"); // CBC模式需要生成一个16 bytes的initialization vector: SecureRandom sr = SecureRandom.getInstanceStrong(); byte[] iv = sr.generateSeed(16); IvParameterSpec ivps = new IvParameterSpec(iv); cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps); byte[] data = cipher.doFinal(input); // IV不需要保密，把IV和密文一起返回: return join(iv, data); &#125; // 解密: public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException &#123; // 把input分割成IV和密文: byte[] iv = new byte[16]; byte[] data = new byte[input.length - 16]; System.arraycopy(input, 0, iv, 0, 16); System.arraycopy(input, 16, data, 0, data.length); // 解密: Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\"); IvParameterSpec ivps = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps); return cipher.doFinal(data); &#125; public static byte[] join(byte[] bs1, byte[] bs2) &#123; byte[] r = new byte[bs1.length + bs2.length]; System.arraycopy(bs1, 0, r, 0, bs1.length); System.arraycopy(bs2, 0, r, bs1.length, bs2.length); return r; &#125;&#125; 口令加密算法对称加密算法的密钥长度固定。用户输入的口令一般要需要使用PBE算法，利用随机数杂凑计算出真正的密钥再进行加密。 PBE（PBE算法内部使用的仍然是标准对称加密算法（例如AES））就是Password Based Encryption的缩写，它的作用如下： 1key &#x3D; generate(userPassword, secureRandomPassword); 我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static void main(String[] args) throws Exception &#123; // 把BouncyCastle作为Provider添加到java.security: Security.addProvider(new BouncyCastleProvider()); // 原文: String message = \"Hello, world!\"; // 加密口令: String password = \"hello12345\"; // 16 bytes随机Salt: byte[] salt = SecureRandom.getInstanceStrong().generateSeed(16); System.out.printf(\"salt: %032x\\n\", new BigInteger(1, salt)); // 加密: byte[] data = message.getBytes(\"UTF-8\"); byte[] encrypted = encrypt(password, salt, data); System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(password, salt, encrypted); System.out.println(\"decrypted: \" + new String(decrypted, \"UTF-8\")); &#125; // 加密: public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException &#123; PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); SecretKey skey = skeyFactory.generateSecret(keySpec); PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000); Cipher cipher = Cipher.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps); return cipher.doFinal(input); &#125; // 解密: public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException &#123; PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); SecretKey skey = skeyFactory.generateSecret(keySpec); PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000); Cipher cipher = Cipher.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); cipher.init(Cipher.DECRYPT_MODE, skey, pbeps); return cipher.doFinal(input); &#125;&#125; 使用PBE时，我们还需要引入BouncyCastle，并指定算法是PBEwithSHA1and128bitAES-CBC-BC。观察代码，实际上真正的AES密钥是调用Cipher的init()方法时同时传入SecretKey和PBEParameterSpec实现的。在创建PBEParameterSpec的时候，我们还指定了循环次数1000，循环次数越多，暴力破解需要的计算量就越大。 如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。 密钥交换算法密钥交换算法即DH算法：Diffie-Hellman算法 DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换。 DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做： 甲首选选择一个素数p，例如509，底数g，任选，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是215，然后，甲发送p＝509，g=5，A=215给乙； 乙方收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，乙再同时计算s=A^b mod p，结果是121； 乙把计算的B=181发给甲，甲计算s＝B^a mod p的余数，计算结果与乙算出的结果一样，都是121。 DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。 使用Java实现DH算法的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Main &#123; public static void main(String[] args) &#123; // Bob和Alice: Person bob = new Person(\"Bob\"); Person alice = new Person(\"Alice\"); // 各自生成KeyPair: bob.generateKeyPair(); alice.generateKeyPair(); // 双方交换各自的PublicKey: // Bob根据Alice的PublicKey生成自己的本地密钥: bob.generateSecretKey(alice.publicKey.getEncoded()); // Alice根据Bob的PublicKey生成自己的本地密钥: alice.generateSecretKey(bob.publicKey.getEncoded()); // 检查双方的本地密钥是否相同: bob.printKeys(); alice.printKeys(); // 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密... &#125;&#125;class Person &#123; public final String name; public PublicKey publicKey; private PrivateKey privateKey; private byte[] secretKey; public Person(String name) &#123; this.name = name; &#125; // 生成本地KeyPair: public void generateKeyPair() &#123; try &#123; KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DH\"); kpGen.initialize(512); KeyPair kp = kpGen.generateKeyPair(); this.privateKey = kp.getPrivate(); this.publicKey = kp.getPublic(); &#125; catch (GeneralSecurityException e) &#123; throw new RuntimeException(e); &#125; &#125; public void generateSecretKey(byte[] receivedPubKeyBytes) &#123; try &#123; // 从byte[]恢复PublicKey: X509EncodedKeySpec keySpec = new X509EncodedKeySpec(receivedPubKeyBytes); KeyFactory kf = KeyFactory.getInstance(\"DH\"); PublicKey receivedPublicKey = kf.generatePublic(keySpec); // 生成本地密钥: KeyAgreement keyAgreement = KeyAgreement.getInstance(\"DH\"); keyAgreement.init(this.privateKey); // 自己的PrivateKey keyAgreement.doPhase(receivedPublicKey, true); // 对方的PublicKey // 生成SecretKey密钥: this.secretKey = keyAgreement.generateSecret(); &#125; catch (GeneralSecurityException e) &#123; throw new RuntimeException(e); &#125; &#125; public void printKeys() &#123; System.out.printf(\"Name: %s\\n\", this.name); System.out.printf(\"Private key: %x\\n\", new BigInteger(1, this.privateKey.getEncoded())); System.out.printf(\"Public key: %x\\n\", new BigInteger(1, this.publicKey.getEncoded())); System.out.printf(\"Secret key: %x\\n\", new BigInteger(1, this.secretKey)); &#125;&#125; 非对称加密算法非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。 非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要N*(N-1)/2个密钥，因此每个人需要管理N-1个密钥，密钥管理难度大，而且非常容易泄漏。 非对称加密的缺点是运算速度非常慢，比对称加密要慢很多。 在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后： 小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红； 小红用自己的RSA私钥解密得到AES口令； 双方使用这个共享的AES口令用AES加密通信。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Main &#123; public static void main(String[] args) throws Exception &#123; // 明文: byte[] plain = \"Hello, encrypt use RSA\".getBytes(\"UTF-8\"); // 创建公钥／私钥对: Person alice = new Person(\"Alice\"); // 用Alice的公钥加密: byte[] pk = alice.getPublicKey(); System.out.println(String.format(\"public key: %x\", new BigInteger(1, pk))); byte[] encrypted = alice.encrypt(plain); System.out.println(String.format(\"encrypted: %x\", new BigInteger(1, encrypted))); // 用Alice的私钥解密: byte[] sk = alice.getPrivateKey(); System.out.println(String.format(\"private key: %x\", new BigInteger(1, sk))); byte[] decrypted = alice.decrypt(encrypted); System.out.println(new String(decrypted, \"UTF-8\")); &#125;&#125;class Person &#123; String name; // 私钥: PrivateKey sk; // 公钥: PublicKey pk; public Person(String name) throws GeneralSecurityException &#123; this.name = name; // 生成公钥／私钥对: KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"RSA\"); kpGen.initialize(1024); KeyPair kp = kpGen.generateKeyPair(); this.sk = kp.getPrivate(); this.pk = kp.getPublic(); &#125; // 把私钥导出为字节 public byte[] getPrivateKey() &#123; return this.sk.getEncoded(); &#125; // 把公钥导出为字节 public byte[] getPublicKey() &#123; return this.pk.getEncoded(); &#125; // 用公钥加密: public byte[] encrypt(byte[] message) throws GeneralSecurityException &#123; Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.ENCRYPT_MODE, this.pk); return cipher.doFinal(message); &#125; // 用私钥解密: public byte[] decrypt(byte[] input) throws GeneralSecurityException &#123; Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.DECRYPT_MODE, this.sk); return cipher.doFinal(input); &#125;&#125;byte[] pkData = ...byte[] skData = ...KeyFactory kf = KeyFactory.getInstance(\"RSA\");// 恢复公钥:X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(pkData);PublicKey pk = kf.generatePublic(pkSpec);// 恢复私钥:PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(skData);PrivateKey sk = kf.generatePrivate(skSpec); 签名算法在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即： 1signature = encrypt(privateKey, sha256(message)) 对签名进行验证实际上就是用公钥解密： 1hash = decrypt(publicKey, signature) 常用数字签名算法有： MD5withRSA SHA1withRSA SHA256withRSA 它们实际上就是指定某种哈希算法进行RSA签名的方式。 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) throws GeneralSecurityException &#123; // 生成RSA公钥/私钥: KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"RSA\"); kpGen.initialize(1024); KeyPair kp = kpGen.generateKeyPair(); PrivateKey sk = kp.getPrivate(); PublicKey pk = kp.getPublic(); // 待签名的消息: byte[] message = \"Hello, I am Bob!\".getBytes(StandardCharsets.UTF_8); // 用私钥签名: Signature s = Signature.getInstance(\"SHA1withRSA\"); s.initSign(sk); s.update(message); byte[] signed = s.sign(); System.out.println(String.format(\"signature: %x\", new BigInteger(1, signed))); // 用公钥验证: Signature v = Signature.getInstance(\"SHA1withRSA\"); v.initVerify(pk); v.update(message); boolean valid = v.verify(signed); System.out.println(\"valid? \" + valid); &#125;&#125; DSA签名除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。 DSA只能配合SHA使用，常用的算法有： SHA1withDSA SHA256withDSA SHA512withDSA 和RSA数字签名相比，DSA的优点是更快。 ECDSA签名椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。 数字证书摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。 数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。HTTPS协议就是数字证书的应用 在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456： 1keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.keystore -dname \"CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN\" 几个主要的参数是： keyalg：指定RSA加密算法； sigalg：指定SHA1withRSA签名算法； validity：指定证书有效期3650天； alias：指定证书在程序中引用的名称； dname：最重要的CN=www.sample.com指定了Common Name，如果证书用在HTTPS中，这个名称必须与域名完全一致。 执行上述命令，JDK会在当前目录创建一个my.keystore文件，并存储创建成功的一个私钥和一个证书，它的别名是mycert。 有了key store存储的证书，我们就可以通过数字证书进行加解密和签名： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.InputStream;import java.math.BigInteger;import java.security.*;import java.security.cert.*;import javax.crypto.Cipher;public class Main &#123; public static void main(String[] args) throws Exception &#123; byte[] message = \"Hello, use X.509 cert!\".getBytes(\"UTF-8\"); // 读取KeyStore: KeyStore ks = loadKeyStore(\"/my.keystore\", \"123456\"); // 读取私钥: PrivateKey privateKey = (PrivateKey) ks.getKey(\"mycert\", \"123456\".toCharArray()); // 读取证书: X509Certificate certificate = (X509Certificate) ks.getCertificate(\"mycert\"); // 加密: byte[] encrypted = encrypt(certificate, message); System.out.println(String.format(\"encrypted: %x\", new BigInteger(1, encrypted))); // 解密: byte[] decrypted = decrypt(privateKey, encrypted); System.out.println(\"decrypted: \" + new String(decrypted, \"UTF-8\")); // 签名: byte[] sign = sign(privateKey, certificate, message); System.out.println(String.format(\"signature: %x\", new BigInteger(1, sign))); // 验证签名: boolean verified = verify(certificate, message, sign); System.out.println(\"verify: \" + verified); &#125; static KeyStore loadKeyStore(String keyStoreFile, String password) &#123; try (InputStream input = Main.class.getResourceAsStream(keyStoreFile)) &#123; if (input == null) &#123; throw new RuntimeException(\"file not found in classpath: \" + keyStoreFile); &#125; KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); ks.load(input, password.toCharArray()); return ks; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; static byte[] encrypt(X509Certificate certificate, byte[] message) throws GeneralSecurityException &#123; Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey()); return cipher.doFinal(message); &#125; static byte[] decrypt(PrivateKey privateKey, byte[] data) throws GeneralSecurityException &#123; Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateKey); return cipher.doFinal(data); &#125; static byte[] sign(PrivateKey privateKey, X509Certificate certificate, byte[] message) throws GeneralSecurityException &#123; Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initSign(privateKey); signature.update(message); return signature.sign(); &#125; static boolean verify(X509Certificate certificate, byte[] message, byte[] sig) throws GeneralSecurityException &#123; Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initVerify(certificate); signature.update(message); return signature.verify(sig); &#125;&#125; 在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以PrivateKey实例表示，公钥以X509Certificate表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。 以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下： 浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书； 浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器； 服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。 上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。 注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商DigiNotar就发生过私钥泄漏导致公司破产的事故。 多线程创建新线程方法1： 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Thread t = new MyThread(); t.start(); // 启动新线程 &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"start new thread!\"); &#125;&#125; 直接调用run()方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。 方法2： 1234567891011121314151617181920212223//method1public class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread(new MyRunnable()); t.start(); // 启动新线程 &#125;&#125;class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"start new thread!\"); &#125;&#125;// method2public class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; System.out.println(\"start new thread!\"); &#125;); t.start(); // 启动新线程 &#125;&#125; 线程暂停Thread.sleep(10)当前线程暂停10ms。 线程的优先级Thread.setPriority(int n) // 1~10, 默认值5 优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。 线程的状态Java线程的状态有以下几种： New：新创建的线程，尚未执行； Runnable：运行中的线程，正在执行run()方法的Java代码； Blocked：运行中的线程，因为某些操作被阻塞而挂起； Waiting：运行中的线程，因为某些操作在等待中； Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待； Terminated：线程已终止，因为run()方法执行完毕。 线程终止的原因有： 线程正常终止：run()方法执行到return语句返回； 线程意外终止：run()方法因为未捕获的异常导致线程终止； 对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。 一个线程还可以等待另一个线程直到其运行结束。例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行。 中断线程中断一个线程非常简单，只需要在其他线程中对目标线程调用interrupt()方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。 interrupt()方法仅仅向t线程发出了“中断请求”，至于t线程是否能立刻响应，要看具体代码。 目标线程只要捕获到join()方法抛出的InterruptedException，就说明有其他线程对其调用了interrupt()方法，通常情况下该线程应该立刻结束运行。 1234567891011121314151617181920212223242526272829303132333435363738public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t = new MyThread(); t.start(); Thread.sleep(1000); t.interrupt(); // 中断t线程 t.join(); // 等待t线程结束 System.out.println(\"end\"); &#125;&#125;class MyThread extends Thread &#123; public void run() &#123; Thread hello = new HelloThread(); hello.start(); // 启动hello线程 try &#123; hello.join(); // 等待hello线程结束 &#125; catch (InterruptedException e) &#123; System.out.println(\"interrupted!\"); &#125; hello.interrupt(); &#125;&#125;class HelloThread extends Thread &#123; public void run() &#123; int n = 0; while (!isInterrupted()) &#123; n++; System.out.println(n + \" hello!\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; break; &#125; &#125; &#125;&#125; main线程通过调用t.interrupt()从而通知t线程中断，而此时t线程正位于hello.join()的等待中，此方法会立刻结束等待并抛出InterruptedException。由于我们在t线程中捕获了InterruptedException，因此，就可以准备结束该线程。在t线程结束前，对hello线程也进行了interrupt()调用通知其中断。如果去掉这一行代码，可以发现hello线程仍然会继续运行，且JVM不会退出。 InterruptedException: Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted 另一个常用的中断线程的方法是设置标志位。我们通常会用一个running标志位来标识线程是否应该继续运行，在外部线程中，通过把HelloThread.running置为false，就可以让线程结束： 线程间共享变量需要使用volatile关键字标记，确保每个线程都能读取到更新后的变量值。 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; HelloThread t = new HelloThread(); t.start(); Thread.sleep(1); t.running = false; // 标志位置为false &#125;&#125;class HelloThread extends Thread &#123; public volatile boolean running = true; public void run() &#123; int n = 0; while (running) &#123; n ++; System.out.println(n + \" hello!\"); &#125; System.out.println(\"end!\"); &#125;&#125; 守护线程守护线程（Daemon Thread）是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。 创建守护线程： 123Thread t = new MyThread();t.setDaemon(true);t.start(); 守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。 线程同步原子操作：某一个线程执行时，其他线程必须等待 临界区：加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。 Java程序使用synchronized关键字对一个对象进行加锁： 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) throws Exception &#123; var add = new AddThread(); var dec = new DecThread(); add.start(); dec.start(); add.join(); dec.join(); System.out.println(Counter.count); &#125;&#125;class Counter &#123; public static final Object lock = new Object(); public static int count = 0;&#125;class AddThread extends Thread &#123; public void run() &#123; for (int i=0; i&lt;10000; i++) &#123; synchronized(Counter.lock) &#123; Counter.count += 1; &#125;// 无论有无异常，都会在此释放锁 &#125; &#125;&#125;class DecThread extends Thread &#123; public void run() &#123; for (int i=0; i&lt;10000; i++) &#123; synchronized(Counter.lock) &#123; Counter.count -= 1; &#125; &#125; &#125;&#125; 不需要synchronized的操作 JVM规范定义了几种原子操作： 基本类型（long和double除外）赋值，例如：int n = m； 引用类型赋值，例如：List&lt;String&gt; list = anotherList。 long和double是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把long和double的赋值作为原子操作实现的。 单条原子操作的语句不需要同步。例如： 12345public void set(int m) &#123; synchronized(lock) &#123; this.value &#x3D; m; &#125;&#125; 就不需要同步。 volatile只保证： 读主内存到本地副本； 操作本地副本； 回写主内存。 这3步多个线程可以同时进行。 volatile保证了时效性不是原子性 同步方法用synchronized修饰方法可以把整个方法变为同步代码块，synchronized方法加锁对象是this； 通过合理的设计和数据封装可以让一个类变为“线程安全”； 一个类没有特殊说明，默认不是thread-safe； 多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。 下面两种写法是等价的： 12345678public void add(int n) &#123; synchronized(this) &#123; // 锁住this count += n; &#125; // 解锁&#125;public synchronized void add(int n) &#123; // 锁住this count += n;&#125; // 解锁 死锁一个线程可以获取一个锁后，再继续获取另一个锁。例如： a1234567891011121314151617public void add(int m) &#123; synchronized(lockA) &#123; &#x2F;&#x2F; 获得lockA的锁 this.value +&#x3D; m; synchronized(lockB) &#123; &#x2F;&#x2F; 获得lockB的锁 this.another +&#x3D; m; &#125; &#x2F;&#x2F; 释放lockB的锁 &#125; &#x2F;&#x2F; 释放lockA的锁&#125;public void dec(int m) &#123; synchronized(lockB) &#123; &#x2F;&#x2F; 获得lockB的锁 this.another -&#x3D; m; synchronized(lockA) &#123; &#x2F;&#x2F; 获得lockA的锁 this.value -&#x3D; m; &#125; &#x2F;&#x2F; 释放lockA的锁 &#125; &#x2F;&#x2F; 释放lockB的锁&#125; Wait和notify123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; var q = new TaskQueue(); var ts = new ArrayList&lt;Thread&gt;(); for (int i=0; i&lt;5; i++) &#123; var t = new Thread() &#123; public void run() &#123; // 执行task: while (true) &#123; try &#123; String s = q.getTask(); System.out.println(\"execute task: \" + s); &#125; catch (InterruptedException e) &#123; return; &#125; &#125; &#125; &#125;; t.start(); ts.add(t); &#125; var add = new Thread(() -&gt; &#123; for (int i=0; i&lt;10; i++) &#123; // 放入task: String s = \"t-\" + Math.random(); System.out.println(\"add task: \" + s); q.addTask(s); try &#123; Thread.sleep(100); &#125; catch(InterruptedException e) &#123;&#125; &#125; &#125;); add.start(); add.join(); Thread.sleep(100); for (var t : ts) &#123; t.interrupt(); &#125; &#125;&#125;class TaskQueue &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); public synchronized void addTask(String s) &#123; this.queue.add(s); this.notifyAll(); &#125; public synchronized String getTask() throws InterruptedException &#123; while (queue.isEmpty()) &#123; this.wait(); &#125; return queue.remove(); &#125;&#125; 使用notifyAll()将唤醒所有当前正在this锁等待的线程，而notify()只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在getTask()方法内部的wait()中等待，使用notifyAll()将一次性全部唤醒。通常来说，notifyAll()更安全。有些时候，如果我们的代码逻辑考虑不周，用notify()会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。 使用ReentrantLockjava.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁. 12345678910111213public class Counter &#123; private final Lock lock = new ReentrantLock(); private int count; public void add(int n) &#123; lock.lock(); try &#123; count += n; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 因为synchronized是Java语言层面提供的语法，所以我们不需要考虑异常，而ReentrantLock是Java代码实现的锁，我们就必须先获取锁，然后在finally中正确释放锁。 和synchronized不同的是，ReentrantLock可以尝试获取锁： 1234567if (lock.tryLock(1, TimeUnit.SECONDS)) &#123; try &#123; ... &#125; finally &#123; lock.unlock(); &#125;&#125; 使用condition condition类似wait和notify： 123456789101112131415161718192021222324252627class TaskQueue &#123; private final Lock lock = new ReentrantLock(); private final Condition condition = lock.newCondition(); private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); public void addTask(String s) &#123; lock.lock(); try &#123; queue.add(s); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public String getTask() &#123; lock.lock(); try &#123; while (queue.isEmpty()) &#123; condition.await(); &#125; return queue.remove(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; Condition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的: await()会释放当前锁，进入等待状态； signal()会唤醒某个等待线程； signalAll()会唤醒所有等待线程； 唤醒线程从await()返回后需要重新获得锁。 和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来： 12345if (condition.await(1, TimeUnit.SECOND)) &#123; &#x2F;&#x2F; 被其他线程唤醒&#125; else &#123; &#x2F;&#x2F; 指定时间内没有被其他线程唤醒&#125; ReadWriteLock ReadWriteLock保证： 只允许一个线程写入（其他线程既不能写入也不能读取）； 没有写入时，多个线程允许同时读（提高性能）。 123456789101112131415161718192021222324public class Counter &#123; private final ReadWriteLock rwlock = new ReentrantReadWriteLock(); private final Lock rlock = rwlock.readLock(); private final Lock wlock = rwlock.writeLock(); private int[] counts = new int[10]; public void inc(int index) &#123; wlock.lock(); // 加写锁 try &#123; counts[index] += 1; &#125; finally &#123; wlock.unlock(); // 释放写锁 &#125; &#125; public int[] get() &#123; rlock.lock(); // 加读锁 try &#123; return Arrays.copyOf(counts, counts.length); &#125; finally &#123; rlock.unlock(); // 释放读锁 &#125; &#125;&#125; StampedLock StampedLock和ReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。 和ReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。 乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。 12345678910111213141516171819202122232425262728293031323334353637public class Point &#123; private final StampedLock stampedLock = new StampedLock(); private double x; private double y; public void move(double deltaX, double deltaY) &#123; long stamp = stampedLock.writeLock(); // 获取写锁 try &#123; x += deltaX; y += deltaY; &#125; finally &#123; stampedLock.unlockWrite(stamp); // 释放写锁 &#125; &#125; public double distanceFromOrigin() &#123; long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁 // 注意下面两行代码不是原子操作 // 假设x,y = (100,200) double currentX = x; // 此处已读取到x=100，但x,y可能被写线程修改为(300,400) double currentY = y; // 此处已读取到y，如果没有写入，读取是正确的(100,200) // 如果有写入，读取是错误的(100,400) if (!stampedLock.validate(stamp)) &#123; // 检查乐观读锁后是否有其他写锁发生 stamp = stampedLock.readLock(); // 获取一个悲观读锁 try &#123; currentX = x; currentY = y; &#125; finally &#123; stampedLock.unlockRead(stamp); // 释放悲观读锁 &#125; &#125; return Math.sqrt(currentX * currentX + currentY * currentY); &#125;&#125; concurrent集合 interface non-thread-safe thread-safe List ArrayList CopyOnWriteArrayList Map HashMap ConcurrentHashMap Set HashSet / TreeSet CopyOnWriteArraySet Queue ArrayDeque / LinkedList ArrayBlockingQueue / LinkedBlockingQueue Deque ArrayDeque / LinkedList LinkedBlockingDeque 因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把： 1Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); 改为： 1Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); java.util.Collections工具类还提供了一个旧的线程安全集合转换器，可以这么用(不推荐，会降低性能)： 12Map unsafeMap = new HashMap();Map threadSafeMap = Collections.synchronizedMap(unsafeMap); Atomicjava.util.concurrent包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于java.util.concurrent.atomic包。 我们以AtomicInteger为例，它提供的主要操作有： 增加值并返回新值：int addAndGet(int delta) 加1后返回新值：int incrementAndGet() 获取当前值：int get() 用CAS方式设置：int compareAndSet(int expect, int update) Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。 使用线程池把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。 Java标准库提供了ExecutorService接口表示线程池，它的典型用法如下： 12345678// 创建固定大小的线程池:ExecutorService executor = Executors.newFixedThreadPool(3);// 提交任务:executor.submit(task1);executor.submit(task2);executor.submit(task3);executor.submit(task4);executor.submit(task5); 因为ExecutorService只是接口，Java标准库提供的几个常用实现类有： FixedThreadPool：线程数固定的线程池； CachedThreadPool：线程数根据任务动态调整的线程池； SingleThreadExecutor：仅单线程执行的线程池。 12345678910111213import java.util.concurrent.*;public class Main &#123; public static void main(String[] args) &#123; // 创建一个固定大小的线程池: ExecutorService es = Executors.newFixedThreadPool(4); for (int i = 0; i &lt; 6; i++) &#123; es.submit(new Task(\"\" + i)); &#125; // 关闭线程池: es.shutdown(); &#125;&#125; 线程池在程序结束的时候要关闭。使用shutdown()方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。shutdownNow()会立刻停止正在执行的任务，awaitTermination()则会等待指定的时间让线程池关闭。 ScheduledThreadPool 定期反复执行的任务。 1234567ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);// 1秒后执行一次性任务:ses.schedule(new Task(\"one-time\"), 1, TimeUnit.SECONDS);// 2秒后开始执行定时任务，每3秒执行:ses.scheduleAtFixedRate(new Task(\"fixed-rate\"), 2, 3, TimeUnit.SECONDS);// 2秒后开始执行定时任务，以3秒为间隔执行:ses.scheduleWithFixedDelay(new Task(\"fixed-delay\"), 2, 3, TimeUnit.SECONDS); 如果任务的任何执行遇到异常，则将禁止后续任务的执行。 使用FutureRunnable接口没有返回值。Callable接口相比之下多了返回值。 12345class Task implements Callable&lt;String&gt; &#123; public String call() throws Exception &#123; return longTimeCalculation(); &#125;&#125; 获取执行结果： 1234567ExecutorService executor = Executors.newFixedThreadPool(4); // 定义任务:Callable&lt;String&gt; task = new Task();// 提交任务并获得Future:Future&lt;String&gt; future = executor.submit(task);// 从Future获取异步执行返回的结果:String result = future.get(); // 可能阻塞 一个Future&lt;V&gt;接口表示一个未来可能会返回的结果，它定义的方法有： get()：获取结果（可能会等待） get(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间； cancel(boolean mayInterruptIfRunning)：取消当前任务； isDone()：判断任务是否已完成。 CompletableFutureCompletableFuture相比Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。 1234567891011121314151617181920212223242526272829public class Main &#123; public static void main(String[] args) throws Exception &#123; // 创建异步执行任务: // 创建一个CompletableFuture是通过CompletableFuture.supplyAsync()实现的，它需要一个实现了Supplier接口的对象 CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice); // 如果执行成功: cf.thenAccept((result) -&gt; &#123; System.out.println(\"price: \" + result); &#125;); // 如果执行异常: cf.exceptionally((e) -&gt; &#123; e.printStackTrace(); return null; &#125;); // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭: Thread.sleep(200); &#125; static Double fetchPrice() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; if (Math.random() &lt; 0.3) &#123; throw new RuntimeException(\"fetch price failed!\"); &#125; return 5 + Math.random() * 20; &#125;&#125; 紧接着，CompletableFuture已经被提交给默认的线程池执行了，我们需要定义的是CompletableFuture完成时和异常时需要回调的实例。完成时，CompletableFuture会调用Consumer对象： 123public interface Consumer&lt;T&gt; &#123; void accept(T t);&#125; 异常时，CompletableFuture会调用Function对象：java 123public interface Function&lt;T, R&gt; &#123; R apply(T t);&#125; CompletableFuture的优点是： 异步任务结束时，会自动回调某个对象的方法； 异步任务出错时，会自动回调某个对象的方法； 主线程设置好回调后，不再关心异步任务的执行。 多个CompletableFuture可以串行执行. 12345678910111213141516171819202122232425262728293031323334public class Main &#123; public static void main(String[] args) throws Exception &#123; // 第一个任务: CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; &#123; return queryCode(\"中国石油\"); &#125;); // cfQuery成功后继续执行下一个任务: CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; &#123; return fetchPrice(code); &#125;); // cfFetch成功后打印结果: cfFetch.thenAccept((result) -&gt; &#123; System.out.println(\"price: \" + result); &#125;); // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭: Thread.sleep(2000); &#125; static String queryCode(String name) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; return \"601857\"; &#125; static Double fetchPrice(String code) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; return 5 + Math.random() * 20; &#125;&#125; CompletableFuture还可以并行执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Main &#123; public static void main(String[] args) throws Exception &#123; // 两个CompletableFuture执行异步查询: CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123; return queryCode(\"中国石油\", \"https://finance.sina.com.cn/code/\"); &#125;); CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123; return queryCode(\"中国石油\", \"https://money.163.com/code/\"); &#125;); // 用anyOf合并为一个新的CompletableFuture: CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163); // 两个CompletableFuture执行异步查询: CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123; return fetchPrice((String) code, \"https://finance.sina.com.cn/price/\"); &#125;); CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123; return fetchPrice((String) code, \"https://money.163.com/price/\"); &#125;); // 用anyOf合并为一个新的CompletableFuture: CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163); // 最终结果: cfFetch.thenAccept((result) -&gt; &#123; System.out.println(\"price: \" + result); &#125;); // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭: Thread.sleep(200); &#125; static String queryCode(String name, String url) &#123; System.out.println(\"query code from \" + url + \"...\"); try &#123; Thread.sleep((long) (Math.random() * 100)); &#125; catch (InterruptedException e) &#123; &#125; return \"601857\"; &#125; static Double fetchPrice(String code, String url) &#123; System.out.println(\"query price from \" + url + \"...\"); try &#123; Thread.sleep((long) (Math.random() * 100)); &#125; catch (InterruptedException e) &#123; &#125; return 5 + Math.random() * 20; &#125;&#125; 使用Fork/JoinFork/Join:将大任务拆分为小任务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Main &#123; public static void main(String[] args) throws Exception &#123; // 创建2000个随机数组成的数组: long[] array = new long[2000]; long expectedSum = 0; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = random(); expectedSum += array[i]; &#125; System.out.println(\"Expected sum: \" + expectedSum); // fork/join: ForkJoinTask&lt;Long&gt; task = new SumTask(array, 0, array.length); long startTime = System.currentTimeMillis(); Long result = ForkJoinPool.commonPool().invoke(task); long endTime = System.currentTimeMillis(); System.out.println(\"Fork/join sum: \" + result + \" in \" + (endTime - startTime) + \" ms.\"); &#125; static Random random = new Random(0); static long random() &#123; return random.nextInt(10000); &#125;&#125;class SumTask extends RecursiveTask&lt;Long&gt; &#123; static final int THRESHOLD = 500; long[] array; int start; int end; SumTask(long[] array, int start, int end) &#123; this.array = array; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; if (end - start &lt;= THRESHOLD) &#123; // 如果任务足够小,直接计算: long sum = 0; for (int i = start; i &lt; end; i++) &#123; sum += this.array[i]; // 故意放慢计算速度: try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; &#125; &#125; return sum; &#125; // 任务太大,一分为二: int middle = (end + start) / 2; System.out.println(String.format(\"split %d~%d ==&gt; %d~%d, %d~%d\", start, end, start, middle, middle, end)); // “分裂”子任务: SumTask subtask1 = new SumTask(this.array, start, middle); SumTask subtask2 = new SumTask(this.array, middle, end); // invokeAll会并行运行两个子任务: invokeAll(subtask1, subtask2); // 获得子任务的结果: Long subresult1 = subtask1.join(); Long subresult2 = subtask2.join(); Long result = subresult1 + subresult2; System.out.println(\"result = \" + subresult1 + \" + \" + subresult2 + \" ==&gt; \" + result); return result; &#125;&#125; 使用ThreadLocalThread.currentThread()获取当前线程 在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。 Java标准库提供了一个特殊的ThreadLocal，它可以在一个线程中传递同一个对象。 ThreadLocal实例通常总是以静态字段初始化如下： 1static ThreadLocal&lt;User&gt; threadLocalUser = new ThreadLocal&lt;&gt;(); 它的典型使用方式如下： 12345678910void processUser(user) &#123; try &#123; threadLocalUser.set(user); step1(); step2(); &#125; finally &#123; // 如果不删除，可能会影响下一次的状态 threadLocalUser.remove(); &#125;&#125; ThreadLocal相当于给每个线程都开辟了一个独立的存储空间，各个线程的ThreadLocal关联的实例互不干扰。 最后，特别注意ThreadLocal一定要在finally中清除。 为了保证能释放ThreadLocal关联的实例，我们可以通过AutoCloseable接口配合try (resource) {...}结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的ThreadLocal可以封装为一个UserContext对象： 1234567891011121314151617public class UserContext implements AutoCloseable &#123; static final ThreadLocal&lt;String&gt; ctx = new ThreadLocal&lt;&gt;(); public UserContext(String user) &#123; ctx.set(user); &#125; public static String currentUser() &#123; return ctx.get(); &#125; @Override public void close() &#123; ctx.remove(); &#125;&#125; 使用的时候，我们借助try (resource) {...}结构，可以这么写： 1234try (var ctx = new UserContext(\"Bob\")) &#123; // 可任意调用UserContext.currentUser(): String currentUser = UserContext.currentUser();&#125; // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象 这样就在UserContext中完全封装了ThreadLocal，外部代码在try (resource) {...}内部可以随时调用UserContext.currentUser()获取当前线程绑定的用户名。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/categories/JAVA/"},{"name":"基础","slug":"JAVA/基础","permalink":"https://sjtu-xx.github.io/categories/JAVA/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/tags/JAVA/"}]},{"title":"IDEA使用JUnit5编写测试","slug":"IDEA使用JUnit5编写测试","date":"2020-12-30T02:39:42.000Z","updated":"2021-02-19T02:26:06.130Z","comments":true,"path":"2020/12/30/IDEA使用JUnit5编写测试/","link":"","permalink":"https://sjtu-xx.github.io/2020/12/30/IDEA%E4%BD%BF%E7%94%A8JUnit5%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/","excerpt":"廖雪峰的JAVA教程使用Eclipse进行JUnit的使用介绍。个人使用IDEA，因此，学习了IDEA+JUnit5的使用。","text":"廖雪峰的JAVA教程使用Eclipse进行JUnit的使用介绍。个人使用IDEA，因此，学习了IDEA+JUnit5的使用。 使用步骤： File-&gt;Project Structure-&gt;Project Settings-&gt;Sources-&gt;将测试文件目录进行标注 右键代码区，选择Generate-&gt;Test.. 确定 写测试代码 点击测试方法左侧的执行按钮进行测试","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/categories/JAVA/"},{"name":"工具","slug":"JAVA/工具","permalink":"https://sjtu-xx.github.io/categories/JAVA/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/tags/JAVA/"},{"name":"IDEA","slug":"IDEA","permalink":"https://sjtu-xx.github.io/tags/IDEA/"}]},{"title":"JAVA-SE笔记2","slug":"JAVA-SE笔记2","date":"2020-12-29T13:58:49.000Z","updated":"2021-02-19T02:26:06.132Z","comments":true,"path":"2020/12/29/JAVA-SE笔记2/","link":"","permalink":"https://sjtu-xx.github.io/2020/12/29/JAVA-SE%E7%AC%94%E8%AE%B02/","excerpt":"JAVA SE笔记第二部分: 反射、注解、范型、集合、IO、日期和时间","text":"JAVA SE笔记第二部分: 反射、注解、范型、集合、IO、日期和时间 反射反射是指程序运行期间可以拿到一个对象的所有信息。 反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。 除了int等基本类型外，Java的其他类型全部都是class（包括interface）。 Class类每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。 它长这样： 123public final class Class &#123; private Class() &#123;&#125;&#125; 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来： 1Class cls = new Class(String); 12345678910111213141516一个Class实例包含了该class的所有完整信息：┌───────────────────────────┐│ Class Instance │──────&gt; String├───────────────────────────┤│name &#x3D; &quot;java.lang.String&quot; │├───────────────────────────┤│package &#x3D; &quot;java.lang&quot; │├───────────────────────────┤│super &#x3D; &quot;java.lang.Object&quot; │├───────────────────────────┤│interface &#x3D; CharSequence...│├───────────────────────────┤│field &#x3D; value[],hash,... │├───────────────────────────┤│method &#x3D; indexOf()... │└───────────────────────────┘ 获取Class实例方法一：直接通过一个class的静态变量class获取： 1Class cls = String.class; 方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取： 12String s = \"Hello\";Class cls = s.getClass(); 方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取： 1Class cls = Class.forName(\"java.lang.String\"); Class类提供了以下几个方法来获取字段： Field getField(name)：根据字段名获取某个public的field（包括父类） Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类） Field[] getFields()：获取所有public的field（包括父类） Field[] getDeclaredFields()：获取当前类的所有field（不包括父类） 一个Field对象包含了一个字段的所有信息： getName()：返回字段名称，例如，&quot;name&quot;； getType()：返回字段类型，也是一个Class实例，例如，String.class； getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。 123456789101112131415161718192021222324252627282930import java.lang.reflect.Field;Field f = String.class.getDeclaredField(\"value\");f.getName(); // \"value\"f.getType(); // class [B 表示byte[]类型int m = f.getModifiers();Modifier.isFinal(m); // trueModifier.isPublic(m); // falseModifier.isProtected(m); // falseModifier.isPrivate(m); // trueModifier.isStatic(m); // falsepublic class Main &#123; public static void main(String[] args) throws Exception &#123; Object p = new Person(\"Xiao Ming\"); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); Object value = f.get(p); System.out.println(value); // \"Xiao Ming\" &#125;&#125;class Person &#123; public String name; public Person(String name) &#123; this.name = name; &#125;&#125; 1f.setAccessible(true); 调用Field.setAccessible(true)的意思是，别管这个字段是不是public，一律允许访问。 setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值。 Field f = c.getDeclaredField(&quot;name&quot;); f.setAccessible(true); f.set(p, &quot;Xiao Hong&quot;); 调用方法Class类提供了以下几个方法来获取Method： Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 1234567Class stdClass = Student.class;// 获取public方法getScore，参数为String:System.out.println(stdClass.getMethod(\"getScore\", String.class));// 获取继承的public方法getName，无参数:System.out.println(stdClass.getMethod(\"getName\"));// 获取private方法getGrade，参数为int:System.out.println(stdClass.getDeclaredMethod(\"getGrade\", int.class)); 调用方法 一个Method对象包含一个方法的所有信息： getName()：返回方法名称，例如：&quot;getScore&quot;； getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class； getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}； getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。 123456789101112131415// reflectionimport java.lang.reflect.Method;// String对象:String s = \"Hello world\";// 获取String substring(int)方法，参数为int:Method m = String.class.getMethod(\"substring\", int.class);// 在s对象上调用该方法并获取结果:String r = (String) m.invoke(s, 6);//调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。// 获取Integer.parseInt(String)方法，参数为String:Method m = Integer.class.getMethod(\"parseInt\", String.class);// 调用该静态方法并获取结果:Integer n = (Integer) m.invoke(null, \"12345\"); 调用非public方法 为了调用非public方法，我们通过Method.setAccessible(true)允许其调用. setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。 调用构造方法如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法： 1Person p = Person.class.newInstance(); 12345import java.lang.reflect.Constructor; // 获取构造方法Integer(int):Constructor cons1 = Integer.class.getConstructor(int.class);// 调用构造方法:Integer n1 = (Integer) cons1.newInstance(123); 通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 获取继承关系获取父类的Class 12Class i = Integer.class;Class n = i.getSuperclass(); 获取interface 1234567import java.lang.reflect.Method;Class s = Integer.class;Class[] is = s.getInterfaces();for (Class i : is) &#123; System.out.println(i);&#125; getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型 继承关系 如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()： 12345678// Integer i = ?Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer// Number n = ?Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number// Object o = ?Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object// Integer i = ?Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer 动态代理class和interface的区别： 可以实例化class（非abstract）； 不能实例化interface。 所有interface类型的变量总是通过向上转型并指向某个实例的： 1CharSequence cs = new StringBuilder(); 动态代理（Dynamic Proxy）机制：在运行期动态创建某个interface的实例。 在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 123456789101112131415161718192021222324252627import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Main &#123; public static void main(String[] args) &#123; InvocationHandler handler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method); if (method.getName().equals(\"morning\")) &#123; System.out.println(\"Good morning, \" + args[0]); &#125; return null; &#125; &#125;; Hello hello = (Hello) Proxy.newProxyInstance( Hello.class.getClassLoader(), // 传入ClassLoader new Class[] &#123; Hello.class &#125;, // 传入要实现的接口 handler); // 传入处理调用方法的InvocationHandler hello.morning(\"Bob\"); &#125;&#125;interface Hello &#123; void morning(String name);&#125; 注解使用注解注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。 12345678910111213141516// this is a component:@Resource(\"hello\")public class Hello &#123; @Inject int n; @PostConstruct public void hello(@Param String name) &#123; System.out.println(name); &#125; @Override public String toString() &#123; return \"Hello\"; &#125;&#125; Java的注解可以分为三类： 第一类是由编译器使用的注解，例如： @Override：让编译器检查该方法是否正确地实现了覆写； @SuppressWarnings：告诉编译器忽略此处代码产生的警告。 这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。 第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。 第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。 定义一个注解时，还可以定义配置参数。配置参数可以包括： 所有基本类型； String； 枚举类型； 基本类型、String、Class以及枚举的数组。 定义注解 定义一个注解时，还可以定义配置参数。配置参数可以包括： 所有基本类型； String； 枚举类型； 基本类型、String、Class以及枚举的数组。 定义注解Java语言使用@interface语法来定义注解（Annotation），它的格式如下： 12345public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。 元注解有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。 @Target 使用@Target可以定义Annotation能够被应用于源码的哪些位置： 类或接口：ElementType.TYPE； 字段：ElementType.FIELD； 方法：ElementType.METHOD； 构造方法：ElementType.CONSTRUCTOR； 方法参数：ElementType.PARAMETER。 定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)： 123456@Target(ElementType.METHOD)public @interface Report &#123; int type() default 0; String level() default \"info\"; String value() default \"\";&#125; 定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }： 1234567@Target(&#123; ElementType.METHOD, ElementType.FIELD&#125;)public @interface Report &#123; ...&#125; 另一个重要的元注解@Retention定义了Annotation的生命周期： 仅编译期：RetentionPolicy.SOURCE； 仅class文件：RetentionPolicy.CLASS； 运行期：RetentionPolicy.RUNTIME。 如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解： 123456@Retention(RetentionPolicy.RUNTIME)public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; @Repeatable 使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛。 123456789101112@Repeatable(Reports.class)@Target(ElementType.TYPE)public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125;@Target(ElementType.TYPE)public @interface Reports &#123; Report[] value();&#125; 经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解： 1234@Report(type&#x3D;1, level&#x3D;&quot;debug&quot;)@Report(type&#x3D;2, level&#x3D;&quot;warning&quot;)public class Hello &#123;&#125; @Inherited 使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效： 1234567@Inherited@Target(ElementType.TYPE)public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 在使用的时候，如果一个类用到了@Report： 123@Report(type&#x3D;1)public class Person &#123;&#125; 则它的子类默认也定义了该注解： 12public class Student extends Person &#123;&#125; 如何定义Annotation 我们总结一下定义Annotation的步骤： 第一步，用@interface定义注解： 12public @interface Report &#123;&#125; 第二步，添加参数、默认值： 12345public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。 第三步，用元注解配置注解： 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。 处理注解SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。 注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。 反射API 判断某个注解是否存在于Class、Field、Method或Constructor： Class.isAnnotationPresent(Class) Field.isAnnotationPresent(Class) Method.isAnnotationPresent(Class) Constructor.isAnnotationPresent(Class) 读取Annotation： Class.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) 使用注解 在某个JavaBean中，我们可以使用该注解： 1234567public class Person &#123; @Range(min&#x3D;1, max&#x3D;20) public String name; @Range(max&#x3D;10) public String city;&#125; 但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义： 1234567891011121314151617181920void check(Person person) throws IllegalArgumentException, ReflectiveOperationException &#123; // 遍历所有Field: for (Field field : person.getClass().getFields()) &#123; // 获取Field定义的@Range: Range range = field.getAnnotation(Range.class); // 如果@Range存在: if (range != null) &#123; // 获取Field的值: Object value = field.get(person); // 如果值是String: if (value instanceof String) &#123; String s = (String) value; // 判断值是否满足@Range的min/max: if (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123; throw new IllegalArgumentException(\"Invalid field: \" + field.getName()); &#125; &#125; &#125; &#125;&#125; 这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。 范型类型ArrayList&lt;T&gt;可以向上转型为List&lt;T&gt;。 要特别注意：不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;或List&lt;Number&gt;。 编写泛型编写泛型类时，要特别注意，泛型类型&lt;T&gt;不能用于静态方法。例如： 123456789101112131415public class Pair&lt;T&gt; &#123; private T first; private T last; public Pair(T first, T last) &#123; this.first = first; this.last = last; &#125; public T getFirst() &#123; ... &#125; public T getLast() &#123; ... &#125; // 静态泛型方法应该使用其他类型区分: public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) &#123; return new Pair&lt;K&gt;(first, last); &#125;&#125; 多个泛型类型泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型&lt;T, K&gt;： 12345678910public class Pair&lt;T, K&gt; &#123; private T first; private K last; public Pair(T first, K last) &#123; this.first &#x3D; first; this.last &#x3D; last; &#125; public T getFirst() &#123; ... &#125; public K getLast() &#123; ... &#125;&#125; 擦拭法擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。 Java使用擦拭法实现泛型，导致了： 编译器把类型&lt;T&gt;视为Object； 编译器根据&lt;T&gt;实现安全的强制转型。 因为Java泛型的实现方式——擦拭法，Java泛型的局限： 局限一：&lt;T&gt;不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型： 1Pair&lt;int&gt; p &#x3D; new Pair&lt;&gt;(1, 2); &#x2F;&#x2F; compile error! 局限二：无法取得带泛型的Class。如Pair&lt;T&gt;通过getClass()得到的永远是Pair&lt;Object&gt; 局限三：无法判断带泛型的类型 局限四：不能实例化T类型.（不能使用new T()） 泛型继承一个类可以继承自一个泛型类。例如：父类的类型是Pair&lt;Integer&gt;，子类的类型是IntPair，可以这么继承： 1public class IntPair extends Pair&lt;Integer&gt; &#123;&#125; 使用的时候，因为子类IntPair并没有泛型类型，所以，正常使用即可： 1IntPair ip &#x3D; new IntPair(1, 2); 前面讲了，我们无法获取Pair&lt;T&gt;的T类型，即给定一个变量Pair&lt;Integer&gt; p，无法从p中获取到Integer类型。 但是，在父类是泛型类型的情况下，编译器就必须把类型T（对IntPair来说，也就是Integer类型）保存到子类的class文件中，不然编译器就不知道IntPair只能存取Integer这种类型。 在继承了泛型类型的情况下，子类可以获取父类的泛型类型。 extends通配符Pair&lt;? extends Number&gt;使得方法接收所有泛型类型为Number或Number子类的Pair类型。 12345static int add(Pair&lt;? extends Number&gt; p) &#123; Number first = p.getFirst(); Number last = p.getLast(); return first.intValue() + last.intValue();&#125; 这种使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。 List&lt;? extends Integer&gt;的限制： 允许调用get()方法获取Integer的引用； 不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。 使用extends限定T类型 在定义泛型类型Pair&lt;T&gt;的时候，也可以使用extends通配符来限定T的类型： 1public class Pair&lt;T extends Number&gt; &#123; ... &#125; 现在，我们只能定义： 123Pair&lt;Number&gt; p1 = null;Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(1, 2);Pair&lt;Double&gt; p3 = null; super通配符Pair&lt;? super Integer&gt;表示，方法参数接受所有泛型类型为Integer或Integer父类的Pair类型。 使用&lt;? super Integer&gt;通配符表示： 允许调用set(? super Integer)方法传入Integer的引用； 不允许调用get()方法获得Integer的引用。 PECS原则PECS原则：Producer Extends Consumer Super。 即：如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。 无限定通配符Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个?： 1void sample(Pair&lt;?&gt; p) &#123;&#125; 因为&lt;?&gt;通配符既没有extends，也没有super，因此： 不允许调用set(T)方法并传入引用（null除外）； 不允许调用T get()方法并获取T引用（只能获取Object引用）。 既不能读，也不能写，那只能做一些null判断： &lt;?&gt;通配符有一个独特的特点，就是：Pair&lt;?&gt;是所有Pair&lt;T&gt;的超类 范型和反射可以声明带泛型的数组，但不能用new操作符创建带泛型的数组： 12Pair&lt;String&gt;[] ps = null; // okPair&lt;String&gt;[] ps = new Pair&lt;String&gt;[2]; // compile error! 必须通过强制转型实现带泛型的数组： 12@SuppressWarnings(\"unchecked\")Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) new Pair[2]; 如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。 集合Collection标准库自带的java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java.util包主要提供了以下三种类型的集合： List：一种有序列表的集合，例如，按索引排列的Student的List； Set：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set； Map：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student的Map。 Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是List，具体的实现类有ArrayList，LinkedList等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如： 1List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 只能放入String类型 最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。 由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用： Hashtable：一种线程安全的Map实现； Vector：一种线程安全的List实现； Stack：基于Vector实现的LIFO的栈。 还有一小部分接口是遗留接口，也不应该继续使用： Enumeration&lt;E&gt;：已被Iterator&lt;E&gt;取代。 ListList&lt;E&gt;接口，可以看到几个主要的接口方法： 在末尾添加一个元素：boolean add(E e) 在指定索引添加一个元素：boolean add(int index, E e) 删除指定索引的元素：int remove(int index) 删除某个元素：int remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() 1234567891011121314151617181920212223242526272829303132// 创建1List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"apple\"); // size=1list.add(null); // size=2// 创建2List&lt;Integer&gt; list = List.of(1, 2, 5);// 遍历// 始终坚持使用迭代器Iterator来访问List。Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\");for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123; String s = it.next(); System.out.println(s);&#125;// 与上述方法等价List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\");for (String s : list) &#123; System.out.println(s);&#125;// List和Array转换// List to Array// 方法1（会丢失类型信息，所以实际应用很少。）Object[] array = list.toArray();// 方法2Integer[] array = list.toArray(new Integer[list.size()]);// 方法3Integer[] array = list.toArray(Integer[]::new);// Array to ListInteger[] array = &#123; 1, 2, 3 &#125;;List&lt;Integer&gt; list = List.of(array); //返回的是一个只读List 编写equals方法equals()方法要求我们必须满足以下条件： 自反性（Reflexive）：对于非null的x来说，x.equals(x)必须返回true； 对称性（Symmetric）：对于非null的x和y来说，如果x.equals(y)为true，则y.equals(x)也必须为true； 传递性（Transitive）：对于非null的x、y和z来说，如果x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)也必须为true； 一致性（Consistent）：对于非null的x和y来说，只要x和y状态不变，则x.equals(y)总是一致地返回true或者false； 对null的比较：即x.equals(null)永远返回false。 equals()方法的正确编写方法： 先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等； 用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false； 对引用类型用Objects.equals()比较，对基本类型直接用==比较。 1234567public boolean equals(Object o) &#123; if (o instanceof Person) &#123; Person p = (Person) o; return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age; &#125; return false;&#125; 使用Map1234567891011121314151617181920212223import java.util.HashMap;import java.util.Map;public class Main &#123; public static void main(String[] args) &#123; Student s = new Student(\"Xiao Ming\", 99); Map&lt;String, Student&gt; map = new HashMap&lt;&gt;(); map.put(\"Xiao Ming\", s); // 将\"Xiao Ming\"和Student实例映射并关联 Student target = map.get(\"Xiao Ming\"); // 通过key查找并返回映射的Student实例 System.out.println(target == s); // true，同一个实例 System.out.println(target.score); // 99 Student another = map.get(\"Bob\"); // 通过另一个key查找 System.out.println(another); // 未找到返回null &#125;&#125;class Student &#123; public String name; public int score; public Student(String name, int score) &#123; this.name = name; this.score = score; &#125;&#125; 遍历 123456// keySetfor (String key : map.keySet()) &#123; Integer value = map.get(key); System.out.println(key + \" = \" + value);&#125;// entitySet equals和hashCode 对应两个实例a和b： 如果a和b相等，那么a.equals(b)一定为true，则a.hashCode()必须等于b.hashCode()； 如果a和b不相等，那么a.equals(b)一定为false，则a.hashCode()和b.hashCode()尽量不要相等。 12345@Overrideint hashCode() &#123; //如果firstName或lastName为null，上述代码工作起来就会抛NullPointerException。为了解决这个问题，我们在计算hashCode()的时候，经常借助Objects.hash()来计算 return Objects.hash(firstName, lastName, age);;&#125; 编写equals()和hashCode()遵循的原则是： equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算；equals()中没有使用到的字段，绝不可放在hashCode()中计算。 map扩容 map扩容要重新确定hashCode计算索引位置，频繁扩容对HashMap的性能影响很大。如果我们确定要使用一个容量为10000个key-value的HashMap，更好的方式是创建HashMap时就指定容量： 1Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;(10000); 虽然指定容量是10000，但HashMap内部的数组长度总是2n，因此，实际数组长度被初始化为比10000大的16384（214）。 EnumMapEnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。 1234Map&lt;DayOfWeek, String&gt; map = new EnumMap&lt;&gt;(DayOfWeek.class);map.put(DayOfWeek.MONDAY, \"星期一\");map.put(DayOfWeek.TUESDAY, \"星期二\");map.put(DayOfWeek.WEDNESDAY, \"星期三\"); TreeMap使用TreeMap时，放入的Key必须实现Comparable接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。 1234567891011121314 ┌───┐ │Map│ └───┘ ▲ ┌────┴─────┐ │ │┌───────┐ ┌─────────┐│HashMap│ │SortedMap│└───────┘ └─────────┘ ▲ │ ┌─────────┐ │ TreeMap │ └─────────┘ 如果作为Key的class没有实现Comparable接口，那么，必须在创建TreeMap时同时指定一个自定义排序算法： 12345678910111213141516171819202122232425262728import java.util.*public class Main &#123; public static void main(String[] args) &#123; Map&lt;Person, Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123; public int compare(Person p1, Person p2) &#123; return p1.name.compareTo(p2.name); &#125; &#125;); map.put(new Person(\"Tom\"), 1); map.put(new Person(\"Bob\"), 2); map.put(new Person(\"Lily\"), 3); for (Person key : map.keySet()) &#123; System.out.println(key); &#125; // &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125; System.out.println(map.get(new Person(\"Bob\"))); // 2 &#125;&#125;class Person &#123; public String name; Person(String name) &#123; this.name = name; &#125; public String toString() &#123; return \"&#123;Person: \" + name + \"&#125;\"; &#125;&#125; Comparator接口要求实现一个比较方法，它负责比较传入的两个元素a和b，如果a&lt;b，则返回负数，通常是-1，如果a==b，则返回0，如果a&gt;b，则返回正数，通常是1。TreeMap内部根据比较结果对Key进行排序。 使用PropertiesProperties表示一组配置，用于读取配置文件。 由于历史遗留原因，Properties内部本质上是一个Hashtabel 读取配置文件用Properties读取配置文件，一共有三步： 创建Properties实例； 调用load()读取文件； 调用getProperty()获取配置。 典型的配置文件（Java默认配置文件以.properties为扩展名，每行以key=value表示，以#课开头的是注释。）： 1234# setting.propertieslast_open_file=/data/hello.txtauto_save_interval=60 读取： 123456789String f = \"setting.properties\";Properties props = new Properties();// 默认使用ascii编码props.load(new java.io.FileInputStream(f)); //InputStream读入字节流// 修改编码方式props.load(new FileReader(\"settings.properties\", StandardCharsets.UTF_8)); // FileReader读入的是字符流String filepath = props.getProperty(\"last_open_file\");String interval = props.getProperty(\"auto_save_interval\", \"120\"); //默认值 写入配置文件 1234Properties props = new Properties();props.setProperty(\"url\", \"http://www.liaoxuefeng.com\");props.setProperty(\"language\", \"Java\");props.store(new FileOutputStream(\"C:\\\\conf\\\\setting.properties\"), \"这是写入的properties注释\"); Set成员方法 Set用于存储不重复的元素集合，主要提供以下几个方法： 将元素添加进Set&lt;E&gt;：boolean add(E e) 将元素从Set&lt;E&gt;删除：boolean remove(Object e) 判断是否包含元素：boolean contains(Object e) 最常用的Set实现类是HashSet，实际上，HashSet仅仅是对HashMap的一个简单封装。 接口 Set接口并不保证有序，而SortedSet接口则保证元素是有序的： HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口； TreeSet是有序的，因为它实现了SortedSet接口。 1234567891011121314 ┌───┐ │Set│ └───┘ ▲ ┌────┴─────┐ │ │┌───────┐ ┌─────────┐│HashSet│ │SortedSet│└───────┘ └─────────┘ ▲ │ ┌─────────┐ │ TreeSet │ └─────────┘ 使用QueueQueue&lt;String&gt; q = new LinkedList&lt;&gt;(); Queue定义了以下几个方法： int size()：获取队列长度； boolean add(E)/boolean offer(E)：添加元素到队尾； E remove()/E poll()：获取队首元素并从队列中删除； E element()/E peek()：获取队首元素但并不从队列中删除。 throw Exception 返回false或null 添加元素到队尾 add(E e) boolean offer(E e) 取队首元素并删除 E remove() E poll() 取队首元素但不删除 E element() E peek() 使用PriorityQueueQueue&lt;String&gt; q = new PriorityQueue&lt;&gt;(); PriorityQueue允许我们提供一个Comparator对象来判断两个元素的顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;public class Main &#123; public static void main(String[] args) &#123; Queue&lt;User&gt; q = new PriorityQueue&lt;&gt;(new UserComparator()); // 添加3个元素到队列: q.offer(new User(\"Bob\", \"A1\")); q.offer(new User(\"Alice\", \"A2\")); q.offer(new User(\"Boss\", \"V1\")); System.out.println(q.poll()); // Boss/V1 System.out.println(q.poll()); // Bob/A1 System.out.println(q.poll()); // Alice/A2 System.out.println(q.poll()); // null,因为队列为空 &#125;&#125;class UserComparator implements Comparator&lt;User&gt; &#123; public int compare(User u1, User u2) &#123; if (u1.number.charAt(0) == u2.number.charAt(0)) &#123; // 如果两人的号都是A开头或者都是V开头,比较号的大小: return u1.number.compareTo(u2.number); &#125; if (u1.number.charAt(0) == 'V') &#123; // u1的号码是V开头,优先级高: return -1; &#125; else &#123; return 1; &#125; &#125;&#125;class User &#123; public final String name; public final String number; public User(String name, String number) &#123; this.name = name; this.number = number; &#125; public String toString() &#123; return name + \"/\" + number; &#125;&#125; 使用DequeQueue和Deque出队和入队的方法： Queue Deque 添加元素到队尾 add(E e) / offer(E e) addLast(E e) / offerLast(E e) 取队首元素并删除 E remove() / E poll() E removeFirst() / E pollFirst() 取队首元素但不删除 E element() / E peek() E getFirst() / E peekFirst() 添加元素到队首 无 addFirst(E e) / offerFirst(E e) 取队尾元素并删除 无 E removeLast() / E pollLast() 取队尾元素但不删除 无 E getLast() / E peekLast() Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); 使用StackStack只有入栈和出栈的操作： 把元素压栈：push(E)； 把栈顶的元素“弹出”：pop(E)； 取栈顶元素但不弹出：peek(E)。 在Java中，我们用Deque可以实现Stack的功能： 把元素压栈：push(E)/addFirst(E)； 把栈顶的元素“弹出”：pop(E)/removeFirst()； 取栈顶元素但不弹出：peek(E)/peekFirst()。 使用Iterator1234for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123; String s = it.next(); System.out.println(s);&#125; 如果我们自己编写了一个集合类，想要使用for each循环，只需满足以下条件： 集合类实现Iterable接口，该接口要求返回一个Iterator对象； 用Iterator对象迭代集合内部数据。 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class Main &#123; public static void main(String[] args) &#123; ReverseList&lt;String&gt; rlist = new ReverseList&lt;&gt;(); rlist.add(\"Apple\"); rlist.add(\"Orange\"); rlist.add(\"Pear\"); for (String s : rlist) &#123; System.out.println(s); &#125; &#125;&#125;class ReverseList&lt;T&gt; implements Iterable&lt;T&gt; &#123; private List&lt;T&gt; list = new ArrayList&lt;&gt;(); public void add(T t) &#123; list.add(t); &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new ReverseIterator(list.size()); &#125; class ReverseIterator implements Iterator&lt;T&gt; &#123; int index; ReverseIterator(int index) &#123; this.index = index; &#125; @Override public boolean hasNext() &#123; return index &gt; 0; &#125; @Override public T next() &#123; index--; return ReverseList.this.list.get(index); &#125; &#125;&#125; CollectionsCollections是JDK提供的工具类，同样位于java.util包中。它提供了一系列静态方法，能更方便地操作各种集合。 创建空集合 创建空List：List&lt;T&gt; emptyList() 创建空Map：Map&lt;K, V&gt; emptyMap() 创建空Set：Set&lt;T&gt; emptySet() 123// 下面两种方法等价List&lt;String&gt; list1 = List.of();List&lt;String&gt; list2 = Collections.emptyList(); 创建单元素集合 创建一个元素的List：List&lt;T&gt; singletonList(T o) 创建一个元素的Map：Map&lt;K, V&gt; singletonMap(K key, V value) 创建一个元素的Set：Set&lt;T&gt; singleton(T o) 12345List&lt;String&gt; list1 = List.of(); // empty listList&lt;String&gt; list2 = List.of(\"apple\"); // 1 elementList&lt;String&gt; list3 = List.of(\"apple\", \"pear\"); // 2 elementsList&lt;String&gt; list4 = List.of(\"apple\", \"pear\", \"orange\"); // 3 elementsList&lt;String&gt; list2 = Collections.singletonList(\"apple\"); 排序 1Collections.sort(list); 洗牌 1Collections.shuffle(list); 不可变集合 Collections还提供了一组方法把可变集合封装成不可变集合： 封装成不可变List：List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list) 封装成不可变Set：Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set) 封装成不可变Map：Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) 123456List&lt;String&gt; mutable = new ArrayList&lt;&gt;();mutable.add(\"apple\");mutable.add(\"pear\");// 变为不可变集合,返回的对象不影响之前的对象，之前的mutable仍然是可变的List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);immutable.add(\"orange\"); // UnsupportedOperationException! 线程安全集合 Collections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合： 变为线程安全的List：List&lt;T&gt; synchronizedList(List&lt;T&gt; list) 变为线程安全的Set：Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) 变为线程安全的Map：Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) IOInputStream / OutputStream IO流以byte（字节）为最小单位，因此也称为字节流。 Reader/Writer Reader和Writer表示字符流，字符流传输的最小数据单位是char。Reader和Writer本质上是一个能自动编解码的InputStream和OutputStream。 同步和异步 同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。 异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。 Java标准库的包java.io提供了同步IO，而java.nio则是异步IO。上面我们讨论的InputStream、OutputStream、Reader和Writer都是同步IO的抽象类，对应的具体实现类，以文件为例，有FileInputStream、FileOutputStream、FileReader和FileWriter。 File对象12345678910111213141516171819202122import java.io.File;File f = new file(\"/usr/local/bin/1.txt\");System.out.println(f); // \"/usr/local/bin/1.txt\"File.separator; //当前平台的分隔符f.getPath(); //返回构造方法传入的路径f.getAbsolutePath(); //返回绝对路径f.getCanonicalPath(); //返回规范路径（规范路径就是把.和..转换成标准的绝对路径后的路径）//文件和目录File f1 = new File(\"C:\\\\Windows\");f1.isFile(); // 对象是否是一个已存在的文件f1.isDirectory(); // 对象是否是一个已存在的目录//用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：//boolean canRead()：是否可读；//boolean canWrite()：是否可写；//boolean canExecute()：是否可执行；//long length()：文件字节大小。 创建删除文件 当File对象表示一个文件时，可以通过createNewFile()创建一个新文件，用delete()删除该文件 12345678File file = new File(\"/path/to/file\");if (file.createNewFile()) &#123; // 文件创建成功: // TODO: if (file.delete()) &#123; // 删除文件成功: &#125;&#125; 程序需要读写一些临时文件，File对象提供了createTempFile()来创建一个临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。 12345678public class Main &#123; public static void main(String[] args) throws IOException &#123; File f = File.createTempFile(\"tmp-\", \".txt\"); // 提供临时文件的前缀和后缀 f.deleteOnExit(); // JVM退出时自动删除 System.out.println(f.isFile()); System.out.println(f.getAbsolutePath()); &#125;&#125; 遍历文件和目录 当File对象表示一个目录时，可以使用list()和listFiles()列出目录下的文件和子目录名。listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录： 12345678File f = new File(\"/usr/local/bin\");File[] fs1 = f.listFiles(); // 列出所有文件和子目录printFiles(fs1);File[] fs2 = f.listFiles(new FilenameFilter() &#123; // 仅列出.exe文件 public boolean accept(File dir, String name) &#123; return name.endsWith(\".exe\"); // 返回true表示接受该文件 &#125;&#125;); Path对象 Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单： 123456789101112131415public class Main &#123; public static void main(String[] args) throws IOException &#123; Path p1 = Paths.get(\".\", \"project\", \"study\"); // 构造一个Path对象 System.out.println(p1); Path p2 = p1.toAbsolutePath(); // 转换为绝对路径 System.out.println(p2); Path p3 = p2.normalize(); // 转换为规范路径 System.out.println(p3); File f = p3.toFile(); // 转换为File对象 System.out.println(f); for (Path p : Paths.get(\"..\").toAbsolutePath()) &#123; // 可以直接遍历Path System.out.println(\" \" + p); &#125; &#125;&#125; InputStreamInputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下： 1public abstract int read() throws IOException; 这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。 FileInputStream read()读取输入流的下一个字节. 12345678public void readFile() throws IOException &#123; try (InputStream input = new FileInputStream(\"src/readme.txt\")) &#123; int n; while ((n = input.read()) != -1) &#123; System.out.println(n); &#125; &#125; // 编译器在此自动为我们写入finally并调用close()&#125; 实际上，编译器并不会特别地为InputStream加上自动关闭。编译器只看try(resource = ...)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上finally语句并调用close()方法。InputStream和OutputStream都实现了这个接口，因此，都可以用在try(resource)中。 利用缓冲区一次读取多个字节 12345678910public void readFile() throws IOException &#123; try (InputStream input = new FileInputStream(\"src/readme.txt\")) &#123; // 定义1000个字节大小的缓冲区: byte[] buffer = new byte[1000]; int n; while ((n = input.read(buffer)) != -1) &#123; // 读取到缓冲区 System.out.println(\"read \" + n + \" bytes.\"); &#125; &#125;&#125; ByteArrayInputStream模拟InputStream 1234567891011121314151617181920212223import java.io.InputStream;import java.io.ByteArrayInputStream;import java.io.IOException;public class Main &#123; public static void main(String[] args) throws IOException &#123; byte[] ba = new byte[]&#123;'a', 'd', 'e'&#125;; try (InputStream is = new ByteArrayInputStream(ba)) &#123; String s = readAsString(is); System.out.println(s); &#125; &#125; public static String readAsString(InputStream input) throws IOException &#123; int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) &#123; sb.append(n); &#125; return sb.toString(); &#125;&#125; OutputStreamOutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b)，签名如下： 1public abstract void write(int b) throws IOException; 这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b &amp; 0xff）。 OutputStream也提供了close()方法关闭输出流，以便释放系统资源。要特别注意：OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。 12345public void writeFile() throws IOException &#123; try (OutputStream output = new FileOutputStream(\"out/readme.txt\")) &#123; output.write(\"Hello\".getBytes(\"UTF-8\")); // Hello &#125; // 编译器在此自动为我们写入finally并调用close()&#125; ByteArrayOutputStream可以在内存中模拟一个OutputStream 1234567891011public class Main &#123; public static void main(String[] args) throws IOException &#123; byte[] data; try (ByteArrayOutputStream output = new ByteArrayOutputStream()) &#123; output.write(\"Hello \".getBytes(\"UTF-8\")); output.write(\"world!\".getBytes(\"UTF-8\")); data = output.toByteArray(); &#125; System.out.println(new String(data, \"UTF-8\")); &#125;&#125; 可以同时写两个文件 123456// 读取input.txt，写入output.txt:try (InputStream input = new FileInputStream(\"input.txt\"); OutputStream output = new FileOutputStream(\"output.txt\"))&#123; input.transferTo(output); // transferTo的作用是将input文件拷贝到output文件&#125; Filter模式Java的IO标准库提供的InputStream根据来源可以包括： FileInputStream：从文件读取数据，是最终数据源； ServletInputStream：从HTTP请求读取数据，是最终数据源； Socket.getInputStream()：从TCP连接读取数据，是最终数据源； … 为了解决依赖继承会导致子类数量失控的问题，JDK首先将InputStream分为两大类： 一类是直接提供数据的基础InputStream，例如： FileInputStream ByteArrayInputStream ServletInputStream … 一类是提供额外附加功能的InputStream，例如： BufferedInputStream DigestInputStream CipherInputStream … 当我们需要给一个“基础”InputStream附加各种功能时，我们先确定这个能提供数据源的InputStream，因为我们需要的数据总得来自某个地方，例如，FileInputStream，数据来源自文件： 1InputStream file &#x3D; new FileInputStream(&quot;test.gz&quot;); 紧接着，我们希望FileInputStream能提供缓冲的功能来提高读取的效率，因此我们用BufferedInputStream包装这个InputStream，得到的包装类型是BufferedInputStream，但它仍然被视为一个InputStream： 1InputStream buffered &#x3D; new BufferedInputStream(file); 最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个GZIPInputStream： 1InputStream gzip &#x3D; new GZIPInputStream(buffered); 无论我们包装多少次，得到的对象始终是InputStream，我们直接用InputStream来引用它，就可以正常读取： 123456789┌─────────────────────────┐│GZIPInputStream ││┌───────────────────────┐│││BufferedFileInputStream││││┌─────────────────────┐│││││ FileInputStream │││││└─────────────────────┘│││└───────────────────────┘│└─────────────────────────┘ 上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合： 12345678910111213141516 ┌─────────────┐ │ InputStream │ └─────────────┘ ▲ ▲┌────────────────────┐ │ │ ┌─────────────────┐│ FileInputStream │─┤ └─│FilterInputStream│└────────────────────┘ │ └─────────────────┘┌────────────────────┐ │ ▲ ┌───────────────────┐│ByteArrayInputStream│─┤ ├─│BufferedInputStream│└────────────────────┘ │ │ └───────────────────┘┌────────────────────┐ │ │ ┌───────────────────┐│ ServletInputStream │─┘ ├─│ DataInputStream │└────────────────────┘ │ └───────────────────┘ │ ┌───────────────────┐ └─│CheckedInputStream │ └───────────────────┘ 类似的，OutputStream也是以这种模式来提供各种功能： 12345678910111213141516 ┌─────────────┐ │OutputStream │ └─────────────┘ ▲ ▲┌─────────────────────┐ │ │ ┌──────────────────┐│ FileOutputStream │─┤ └─│FilterOutputStream│└─────────────────────┘ │ └──────────────────┘┌─────────────────────┐ │ ▲ ┌────────────────────┐│ByteArrayOutputStream│─┤ ├─│BufferedOutputStream│└─────────────────────┘ │ │ └────────────────────┘┌─────────────────────┐ │ │ ┌────────────────────┐│ ServletOutputStream │─┘ ├─│ DataOutputStream │└─────────────────────┘ │ └────────────────────┘ │ ┌────────────────────┐ └─│CheckedOutputStream │ └────────────────────┘ 操作ZipZipInputStream是一种FilterInputStream，它可以直接读取zip包的内容： JarInputStream是从ZipInputStream派生，它增加的主要功能是直接读取jar文件里面的MANIFEST.MF文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。 读取Zip文件123456789101112try (ZipInputStream zip = new ZipInputStream(new FileInputStream(...))) &#123; ZipEntry entry = null; while ((entry = zip.getNextEntry()) != null) &#123; String name = entry.getName(); if (!entry.isDirectory()) &#123; int n; while ((n = zip.read()) != -1) &#123; ... &#125; &#125; &#125;&#125; 写入Zip文件12345678try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(...))) &#123; File[] files = ... for (File file : files) &#123; zip.putNextEntry(new ZipEntry(file.getName())); zip.write(getFileDataAsBytes(file)); zip.closeEntry(); &#125;&#125; 读取classpath资源从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把default.properties文件放到classpath中，就不用关心它的实际存放路径。 在classpath中的资源文件，路径总是以／开头 12345try (InputStream input = getClass().getResourceAsStream(\"/default.properties\")) &#123; if (input != null) &#123; // TODO: &#125;&#125; 如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置： 123Properties props = new Properties();props.load(inputStreamFromClassPath(\"/default.properties\"));props.load(inputStreamFromFile(\"./conf.properties\")); 序列化把一个Java对象变为byte[]数组，需要使用ObjectOutputStream。 1234567891011121314public class Main &#123; public static void main(String[] args) throws IOException &#123; ByteArrayOutputStream buffer = new ByteArrayOutputStream(); try (ObjectOutputStream output = new ObjectOutputStream(buffer)) &#123; // 写入int: output.writeInt(12345); // 写入String: output.writeUTF(\"Hello\"); // 写入Object: output.writeObject(Double.valueOf(123.456)); &#125; System.out.println(Arrays.toString(buffer.toByteArray())); &#125;&#125; 反序列化ObjectInputStream负责从一个字节流读取Java对象： 12345try (ObjectInputStream input = new ObjectInputStream(...)) &#123; int n = input.readInt(); String s = input.readUTF(); Double d = (Double) input.readObject();&#125; readObject()可能抛出的异常有： ClassNotFoundException：没有找到对应的Class； InvalidClassException：Class不匹配。 为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变serialVersionUID的值，这样就能自动阻止不匹配的class版本： 123public class Person implements Serializable &#123; private static final long serialVersionUID = 2709425275741743919L;&#125; 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 Reader 除了特殊的CharArrayReader和StringReader，普通的Reader实际上是基于InputStream构造的，因为Reader需要从InputStream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。如果我们查看FileReader的源码，它在内部实际上持有一个FileInputStream。 InputStream Reader 字节流，以byte为单位 字符流，以char为单位 读取字节（-1，0~255）：int read() 读取字符（-1，0~65535）：int read() 读到字节数组：int read(byte[] b) 读到字符数组：int read(char[] c) java.io.Reader是所有字符输入流的超类，它最主要的方法是： 1public int read() throws IOException; 这个方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。 FileReader123456789101112public void readFile() throws IOException &#123; // 创建一个FileReader对象: Reader reader = new FileReader(\"src/readme.txt\"); // 字符编码是??? for (;;) &#123; int n = reader.read(); // 反复调用read()方法，直到返回-1 if (n == -1) &#123; break; &#125; System.out.println((char)n); // 打印char &#125; reader.close(); // 关闭流&#125; 指定编码 12try(Reader reader = new FileReader(\"1.txt\",StandardCharsets.UTF_8))&#123;&#125; 读取到缓冲区 123456789public void readFile() throws IOException &#123; try (Reader reader = new FileReader(\"src/readme.txt\", StandardCharsets.UTF_8)) &#123; char[] buffer = new char[1000]; int n; while ((n = reader.read(buffer)) != -1) &#123; System.out.println(\"read \" + n + \" chars.\"); &#125; &#125;&#125; charArrayReader CharArrayReader可以在内存中模拟一个Reader，它的作用实际上是把一个char[]数组变成一个Reader，这和ByteArrayInputStream非常类似： 12try (Reader reader = new CharArrayReader(\"Hello\".toCharArray())) &#123;&#125; StringReader StringReader可以直接把String作为数据源，它和CharArrayReader几乎一样： 12try (Reader reader = new StringReader(\"Hello\")) &#123;&#125; InputStreamReader Reader本质上是一个基于InputStream的byte到char的转换器，那么，如果我们已经有一个InputStream，想把它转换为Reader，是完全可行的。InputStreamReader就是这样一个转换器，它可以把任何InputStream转换为Reader。示例代码如下： 1234// 持有InputStream:InputStream input = new FileInputStream(\"src/readme.txt\");// 变换为Reader:Reader reader = new InputStreamReader(input, \"UTF-8\"); 构造InputStreamReader时，我们需要传入InputStream，还需要指定编码，就可以得到一个Reader对象。上述代码可以通过try (resource)更简洁地改写如下： 123try (Reader reader = new InputStreamReader(new FileInputStream(\"src/readme.txt\"), \"UTF-8\")) &#123; // TODO:&#125; 上述代码实际上就是FileReader的一种实现方式。 使用try (resource)结构时，当我们关闭Reader时，它会在内部自动调用InputStream的close()方法，所以，只需要关闭最外层的Reader对象即可。 Writer OutputStream Writer 字节流，以byte为单位 字符流，以char为单位 写入字节（0~255）：void write(int b) 写入字符（0~65535）：void write(int c) 写入字节数组：void write(byte[] b) 写入字符数组：void write(char[] c) 无对应方法 写入String：void write(String s) Writer是所有字符输出流的超类，它提供的方法主要有： 写入一个字符（0~65535）：void write(int c)； 写入字符数组的所有字符：void write(char[] c)； 写入String表示的所有字符：void write(String s)。 12345try (Writer writer = new FileWriter(\"readme.txt\", StandardCharsets.UTF_8)) &#123; writer.write('H'); // 写入单个字符 writer.write(\"Hello\".toCharArray()); // 写入char[] writer.write(\"Hello\"); // 写入String&#125; CharArrayWriter CharArrayWriter可以在内存中创建一个Writer，它的作用实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组，这和ByteArrayOutputStream非常类似： 123456try (CharArrayWriter writer = new CharArrayWriter()) &#123; writer.write(65); writer.write(66); writer.write(67); char[] data = writer.toCharArray(); // &#123; 'A', 'B', 'C' &#125;&#125; StringWriter StringWriter也是一个基于内存的Writer，它和CharArrayWriter类似。实际上，StringWriter在内部维护了一个StringBuffer，并对外提供了Writer接口。 OutputStreamWriter 除了CharArrayWriter和StringWriter外，普通的Writer实际上是基于OutputStream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream。因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器： 123try (Writer writer &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;readme.txt&quot;), &quot;UTF-8&quot;)) &#123; &#x2F;&#x2F; TODO:&#125; 上述代码实际上就是FileWriter的一种实现方式。这和上一节的InputStreamReader是一样的。 PrintStream和PrintWriterPrintStream在OutputStream接口上提供了一组写入各种数据的方法：print(int),print(boolean)以及一组println()（自动加换行符） System.out是系统默认提供的PrintStream PrintStream最终输出的总是byte数据，而PrintWriter则是扩展了Writer接口，它的print()/println()方法最终输出的是char数据。两者的使用方法几乎是一模一样的： 1234567891011public class Main &#123; public static void main(String[] args) &#123; StringWriter buffer = new StringWriter(); try (PrintWriter pw = new PrintWriter(buffer)) &#123; pw.println(\"Hello\"); pw.println(12345); pw.println(true); &#125; System.out.println(buffer.toString()); &#125;&#125; 使用Files将一个文件的全部内容读取为一个byte[] 1byte[] data = Files.readAllBytes(Paths.get(\"/path/to/file.txt\")); 把一个文件的全部内容读取为String 123456// 默认使用UTF-8编码读取:String content1 = Files.readString(Paths.get(\"/path/to/file.txt\"));// 可指定编码:String content2 = Files.readString(Paths.get(\"/path/to/file.txt\"), StandardCharsets.ISO_8859_1);// 按行读取并返回每行内容:List&lt;String&gt; lines = Files.readAllLines(Paths.get(\"/path/to/file.txt\")); 写入文件 12345678// 写入二进制文件:byte[] data = ...Files.write(Paths.get(\"/path/to/file.txt\"), data);// 写入文本并指定编码:Files.writeString(Paths.get(\"/path/to/file.txt\"), \"文本内容...\", StandardCharsets.ISO_8859_1);// 按行写入文本:List&lt;String&gt; lines = ...Files.write(Paths.get(\"/path/to/file.txt\"), lines); Files工具类还有copy()、delete()、exists()、move()等快捷方法操作文件和目录。 Files提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。 日期与时间 夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。 计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。 在计算机中，通常使用Locale表示一个国家或地区的日期、时间、数字、货币等格式。Locale由语言_国家的字母缩写构成，例如，zh_CN表示中文+中国，en_US表示英文+美国。语言使用小写，国家使用大写。 对于日期来说，不同的Locale，例如，中国和美国的表示方式如下： zh_CN：2016-11-30 en_US：11/30/2016 Date和CalendarEpoch Time又称为时间戳，在不同的编程语言中，会有几种存储方式： 以秒为单位的整数：1574208900，缺点是精度只能到秒； 以毫秒为单位的整数：1574208900123，最后3位表示毫秒数； 以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。 Java程序中，时间戳通常是用long表示的毫秒数，即： 1long t &#x3D; 1574208900123L; 转换成北京时间就是2019-11-20T8:15:00.123。要获取当前时间戳，可以使用System.currentTimeMillis()，这是Java程序获取时间戳最常用的方法。 标准库APIJava标准库有两套处理日期和时间的API： 一套定义在java.util这个包里面，主要包括Date、Calendar和TimeZone这几个类； 一套新的API是在Java 8引入的，定义在java.time这个包里面，主要包括LocalDateTime、ZonedDateTime、ZoneId等。 旧APIDatejava.util.Date是用于表示一个日期和时间的对象，它实际上存储了一个long类型的以毫秒表示的时间戳。 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; // 获取当前时间: Date date = new Date(); System.out.println(date.getYear() + 1900); // 必须加上1900 System.out.println(date.getMonth() + 1); // 0~11，必须加上1 System.out.println(date.getDate()); // 1~31，不能加1 // 转换为String: System.out.println(date.toString()); // 转换为GMT时区: System.out.println(date.toGMTString()); // 转换为本地时区: System.out.println(date.toLocaleString()); var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf.format(date)); &#125;&#125; Date对象有几个严重的问题：它不能转换时区，除了toGMTString()可以按GMT+0:00输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。 CalendarCalendar相比Date多了日期计算功能。年份不需要转换，月份要加一，星期1～7分别表示周日、周一、…、周六 1234567891011121314151617181920212223242526272829303132333435363738394041public class Main &#123; public static void main(String[] args) &#123; // 获取当前时间: Calendar c = Calendar.getInstance(); int y = c.get(Calendar.YEAR); int m = 1 + c.get(Calendar.MONTH); int d = c.get(Calendar.DAY_OF_MONTH); int w = c.get(Calendar.DAY_OF_WEEK); int hh = c.get(Calendar.HOUR_OF_DAY); int mm = c.get(Calendar.MINUTE); int ss = c.get(Calendar.SECOND); int ms = c.get(Calendar.MILLISECOND); System.out.println(y + \"-\" + m + \"-\" + d + \" \" + w + \" \" + hh + \":\" + mm + \":\" + ss + \".\" + ms); &#125;&#125;// 时区选择TimeZone tzDefault = TimeZone.getDefault(); // 当前时区TimeZone tzGMT9 = TimeZone.getTimeZone(\"GMT+09:00\"); // GMT+9:00时区TimeZone tzNY = TimeZone.getTimeZone(\"America/New_York\"); // 纽约时区System.out.println(tzDefault.getID()); // Asia/ShanghaiSystem.out.println(tzGMT9.getID()); // GMT+09:00System.out.println(tzNY.getID()); // America/New_York// 特定时区// 当前时间:Calendar c = Calendar.getInstance();// 清除所有:c.clear();// 设置为北京时区:c.setTimeZone(TimeZone.getTimeZone(\"Asia/Shanghai\"));// 设置年月日时分秒:c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);// 加5天并减去2小时:c.add(Calendar.DAY_OF_MONTH, 5);c.add(Calendar.HOUR_OF_DAY, -2);// 显示时间:var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");sdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"));System.out.println(sdf.format(c.getTime()));// 2019-11-19 19:15:00 利用Calendar进行时区转换的步骤是： 清除所有字段； 设定指定时区； 设定日期和时间； 创建SimpleDateFormat并设定目标时区； 格式化获取的Date对象（注意Date对象无时区信息，时区信息存储在SimpleDateFormat中）。 本质上时区转换只能通过SimpleDateFormat在显示的时候完成。 新API从Java 8开始，java.time包提供了新的日期和时间API，主要涉及的类型有： 本地日期和时间：LocalDateTime，LocalDate，LocalTime； 带时区的日期和时间：ZonedDateTime； 时刻：Instant； 时区：ZoneId，ZoneOffset； 时间间隔：Duration。 以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter。 LocalDateTime12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879LocalDate d = LocalDate.now(); // 当前日期LocalTime t = LocalTime.now(); // 当前时间LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间System.out.println(d); // 严格按照ISO 8601格式打印System.out.println(t); // 严格按照ISO 8601格式打印System.out.println(dt); // 严格按照ISO 8601格式打印// 避免获取延迟LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间LocalDate d = dt.toLocalDate(); // 转换到当前日期LocalTime t = dt.toLocalTime(); // 转换到当前时间// 指定日期和时间:LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);LocalDateTime dt3 = LocalDateTime.of(d2, t2);// 加减时间LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);System.out.println(dt);// 加5天减3小时:LocalDateTime dt2 = dt.plusDays(5).minusHours(3);System.out.println(dt2); // 2019-10-31T17:30:59// 减1月:LocalDateTime dt3 = dt2.minusMonths(1);System.out.println(dt3); // 2019-09-30T17:30:59// 调整日期// 调整年：withYear()// 调整月：withMonth()// 调整日：withDayOfMonth()// 调整时：withHour()// 调整分：withMinute()// 调整秒：withSecond()LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);System.out.println(dt);// 日期变为31日:LocalDateTime dt2 = dt.withDayOfMonth(31);System.out.println(dt2); // 2019-10-31T20:30:59// 月份变为9:LocalDateTime dt3 = dt2.withMonth(9);System.out.println(dt3); // 2019-09-30T20:30:59// With// 本月第一天0:00时刻:LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay();System.out.println(firstDay);// 本月最后1天:LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());System.out.println(lastDay);// 下月第1天:LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());System.out.println(nextMonthFirstDay);// 本月第1个周一:LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));System.out.println(firstWeekday);//判断日期先后// isBefore和isAfterLocalDateTime now = LocalDateTime.now();LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);System.out.println(now.isBefore(target));System.out.println(LocalDate.now().isBefore(LocalDate.of(2019, 11, 19)));System.out.println(LocalTime.now().isAfter(LocalTime.parse(\"08:15:00\")));//时间间隔// Duration表示两个时刻之间的时间间隔。另一个类似的Period表示两个日期之间的天数LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);Duration d = Duration.between(start, end);System.out.println(d); // PT1235H10M30S ：表示1235小时10分钟30秒。Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9));System.out.println(p); // P1M21D ： 表示1个月21天。Duration d1 = Duration.ofHours(10); // 10 hoursDuration d2 = Duration.parse(\"P1DT2H3M\"); // 1 day, 2 hours, 3 minutes ISO 8601规定的日期和时间分隔符是T。标准格式如下： 日期：yyyy-MM-dd 时间：HH:mm:ss 带毫秒的时间：HH:mm:ss.SSS 日期和时间：yyyy-MM-dd’T’HH:mm:ss 带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS DateTimeFormatter12345678910111213// 自定义格式化:DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\");//DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"E, yyyy-MMMM-dd HH:mm\", Locale.US);System.out.println(dtf.format(LocalDateTime.now()));// 用自定义格式解析:LocalDateTime dt2 = LocalDateTime.parse(\"2019/11/30 15:16:17\", dtf);System.out.println(dt2);// 使用ISO8601显示var ldt = LocalDateTime.now();System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt)); ZonedDateTime可以简单地把ZonedDateTime理解成LocalDateTime加ZoneId。 123456789101112131415161718192021// 方法1ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(\"America/New_York\")); // 用指定时区获取当前时间// 方法2// LocalDateTime to ZonedDateTimeLocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17);ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());ZonedDateTime zny = ldt.atZone(ZoneId.of(\"America/New_York\"));// 时区转换// 以中国时区获取当前时间:ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(\"Asia/Shanghai\"));// 转换为纽约时间:ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(\"America/New_York\"));System.out.println(zbj);System.out.println(zny);// 转换本地时间ZonedDateTime zdt = ...LocalDateTime ldt = zdt.toLocalDateTime(); Instant当前时间戳在java.time中以Instant类型表示，我们用Instant.now()获取当前时间戳，效果和System.currentTimeMillis()类似 123456Instant now = Instant.now();// 以指定时间戳创建InstantInstant ins = Instant.ofEpochSecond(1568568760);ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());System.out.println(zdt); // 2019-09-16T01:32:40+08:00[Asia/Shanghai] 最佳实践旧API转新API如果要把旧式的Date或Calendar转换为新API对象，可以通过toInstant()方法转换为Instant对象，再继续转换为ZonedDateTime： 1234567&#x2F;&#x2F; Date -&gt; Instant:Instant ins1 &#x3D; new Date().toInstant();&#x2F;&#x2F; Calendar -&gt; Instant -&gt; ZonedDateTime:Calendar calendar &#x3D; Calendar.getInstance();Instant ins2 &#x3D; calendar.toInstant();ZonedDateTime zdt &#x3D; ins2.atZone(calendar.getTimeZone().toZoneId()); 从上面的代码还可以看到，旧的TimeZone提供了一个toZoneId()，可以把自己变成新的ZoneId。 新API转旧API如果要把新的ZonedDateTime转换为旧的API对象，只能借助long型时间戳做一个“中转”： 123456789101112&#x2F;&#x2F; ZonedDateTime -&gt; long:ZonedDateTime zdt &#x3D; ZonedDateTime.now();long ts &#x3D; zdt.toEpochSecond() * 1000;&#x2F;&#x2F; long -&gt; Date:Date date &#x3D; new Date(ts);&#x2F;&#x2F; long -&gt; Calendar:Calendar calendar &#x3D; Calendar.getInstance();calendar.clear();calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));calendar.setTimeInMillis(zdt.toEpochSecond() * 1000); 从上面的代码还可以看到，新的ZoneId转换为旧的TimeZone，需要借助ZoneId.getId()返回的String完成。 在数据库中存储日期和时间除了旧式的java.util.Date，我们还可以找到另一个java.sql.Date，它继承自java.util.Date，但会自动忽略所有时间相关信息。这个奇葩的设计原因要追溯到数据库的日期与时间类型。 在数据库中，也存在几种日期和时间类型： DATETIME：表示日期和时间； DATE：仅表示日期； TIME：仅表示时间； TIMESTAMP：和DATETIME类似，但是数据库会在创建或者更新记录的时候同时修改TIMESTAMP。 在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。下表是数据库类型与Java新旧API的映射关系： 数据库 对应Java类（旧） 对应Java类（新） DATETIME java.util.Date LocalDateTime DATE java.sql.Date LocalDate TIME java.sql.Time LocalTime TIMESTAMP java.sql.Timestamp LocalDateTime 实际上，在数据库中，我们需要存储的最常用的是时刻（Instant），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数long表示，在数据库中存储为BIGINT类型。 通过存储一个long型时间戳，我们可以编写一个timestampToString()的方法，非常简单地为不同用户以不同的偏好来显示不同的本地时间： import java.time.*; import java.time.format.*; import java.util.Locale; Run 对上述方法进行调用，结果如下： 122019年11月20日 上午8:15Nov 19, 2019, 7:15 PM is=>operation: InputStream fis=>operation: FilterInputStream iis=>operation: InflaterInputStream zis=>operation: ZipInputStream jis=>operation: JarInputStream is->fis->iis->zis->jis{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/categories/JAVA/"},{"name":"基础","slug":"JAVA/基础","permalink":"https://sjtu-xx.github.io/categories/JAVA/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/tags/JAVA/"}]},{"title":"JAVA_SE笔记1","slug":"JAVA-SE笔记1","date":"2020-12-28T11:38:51.000Z","updated":"2021-02-19T02:26:06.131Z","comments":true,"path":"2020/12/28/JAVA-SE笔记1/","link":"","permalink":"https://sjtu-xx.github.io/2020/12/28/JAVA-SE%E7%AC%94%E8%AE%B01/","excerpt":"学习廖雪峰的JAVA入门教程的笔记第一部分。 准备工作、JAVA面向对象编程、JAVA核心类、异常处理","text":"学习廖雪峰的JAVA入门教程的笔记第一部分。 准备工作、JAVA面向对象编程、JAVA核心类、异常处理 准备工作第一个JAVA程序12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(\"Hello world\"); &#125;&#125; 执行代码 1234&#x2F;&#x2F; 编译javac Hello.java&#x2F;&#x2F; 执行java Hello JAVA程序基础变量和数据类型12345678910111213141516171819202122232425262728/* 基本类型及字节数： 整数类型: byte(1),short(2),int(4),long(8) 浮点数类型：float(4)，double(8) 字符类型:char(2) 布尔类型：boolean(没有明确规定，通常JVM会将其处理为4字节的整数)*/int a = 1;float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为falsechar a = 'A';char zh = '中';/* 引用类型*/String s = \"hello\"; 定义变量的时候，如果加上final修饰符，这个变量就变成了常量：final double PI = 3.14; // PI是一个常量 整数运算123456789101112131415161718192021222324252627282930313233343536int x = 12345 / 67; // 184,商int y = 12345 % 67; // 12345÷67的余数是17n += 100; // 3409, 相当于 n = n + 100;n -= 100; // 3309, 相当于 n = n - 100;int n = 3300;n++; // 3301, 相当于 n = n + 1;n--; // 3300, 相当于 n = n - 1;int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1; // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2; // 00000000 00000000 00000000 00011100 = 28int c = n &lt;&lt; 28; // 01110000 00000000 00000000 00000000 = 1879048192int d = n &lt;&lt; 29; // 11100000 00000000 00000000 00000000 = -536870912//如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：int n = -536870912;int a = n &gt;&gt; 1; // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2; // 11111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1//无符号的右移运算int n = -536870912;int a = n &gt;&gt;&gt; 1; // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2; // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1//对byte和short类型进行移位时，会首先转换为int再进行位移。// 位运算n = 0 &amp; 0; // 0n = 0 | 1; // 1n = ~0; // 1n = 0 ^ 1; // 1 如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。 浮点数运算123456789101112131415161718// 比较x和y是否相等，先计算其差的绝对值:double r = Math.abs(x - y);// 再判断绝对值是否足够小:if (r &lt; 0.00001) &#123; // 可以认为相等&#125; else &#123; // 不相等&#125;// 在一个复杂的四则运算中，两个整数的运算不会出现自动提升double d = 1.2 + 24 / 5; // 5.2// 强制转型int n1 = (int) 12.3; // 12int n2 = (int) 12.7; // 12int n2 = (int) -12.7; // -12int n3 = (int) (12.7 + 0.5); // 13int n4 = (int) 1.2e20; // 2147483647 布尔运算布尔运算是一种关系运算，包括以下几类： 比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!= 与运算 &amp;&amp; 或运算 || 非运算 ! 三元运算符 三元运算符b ? x : y 字符和字符串字符类型12345678char c1 = 'A';char c2 = '中';int n1 = 'A'; // 字母“A”的Unicodde编码是65int n2 = '中'; // 汉字“中”的Unicode编码是20013// 注意是十六进制:char c3 = '\\u0041'; // 'A'，因为十六进制0041 = 十进制65char c4 = '\\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013 字符串类型1234567String s = \"\"; // 空字符串，包含0个字符String s1 = \"A\"; // 包含一个字符String s2 = \"ABC\"; // 包含3个字符String s3 = \"中文 ABC\"; // 包含6个字符，其中有一个空格String s = \"abc\\\"xyz\"; // 包含7个字符: a, b, c, \", x, y, z 常见的转义字符包括： \\&quot; 表示字符&quot; \\&#39; 表示字符&#39; \\\\ 表示字符\\ \\n 表示换行符 \\r 表示回车符 \\t 表示Tab \\u#### 表示一个Unicode编码的字符 Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。 从Java 13开始，字符串可以用&quot;&quot;&quot;...&quot;&quot;&quot;表示多行字符串（Text Blocks），多行字符串前面共同的空格会被去掉 123456String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC \"\"\"; 字符串不可变 引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。 数组类型1234567891011121314151617181920212223int[] ns = new int[5];ns[0] = 68;ns[1] = 79;ns[2] = 91;ns[3] = 85;ns[4] = 62;//int[] ns = &#123; 68, 79, 91, 85, 62 &#125;;System.out.println(ns.length); // 5int[] ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;;public class Main &#123; public static void main(String[] args) &#123; String[] names = &#123;\"ABC\", \"XYZ\", \"zoo\"&#125;; String s = names[1]; names[1] = \"cat\"; System.out.println(s); // s是\"XYZ\"还是\"cat\"?: XYZ &#125;&#125; 流程控制格式化输出 123double d = 3.1415926;System.out.printf(\"%.2f\\n\", d); // 显示两位小数3.14System.out.printf(\"%.4f\\n\", d); // 显示4位小数3.1416 java中的占位符 占位符 说明 %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 连续两个%%表示一个%字符本身。 12int n = 12345000;System.out.printf(\"n=%d, hex=%08x\", n, n); // 注意，两个%占位符必须传入两个数 输入 1234567891011121314import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.out.print(\"Input your name: \"); // 打印提示 String name = scanner.nextLine(); // 读取一行输入并获取字符串 System.out.print(\"Input your age: \"); // 打印提示 int age = scanner.nextInt(); // 读取一行输入并获取整数 System.out.printf(\"Hi, %s, you are %d\\n\", name, age); // 格式化输出 &#125;&#125;//scanner.nextLine() / nextInt() / nextDouble() / ... if判断1234567if (n &lt; 60) &#123; // ...&#125; else if (n &lt; 90) &#123; // ...&#125; else &#123; // ...&#125; 判断引用类型是否相等 判断引用类型的变量是否相等时，==表示“引用是否相等”，或者说，是否指向同一个对象。 判断引用类型的值是否相等必须使用equals函数。(s1.equals(s2)) switch多重选择123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int option = 1;switch (option) &#123; case 1: System.out.println(\"Selected 1\"); break; case 2: System.out.println(\"Selected 2\"); break; case 3: System.out.println(\"Selected 3\"); break; default: System.out.println(\"No fruit selected\"); break;&#125;//java12的新语法//不需要breakpublic class Main &#123; public static void main(String[] args) &#123; String fruit = \"apple\"; switch (fruit) &#123; case \"apple\" -&gt; System.out.println(\"Selected apple\"); case \"pear\" -&gt; System.out.println(\"Selected pear\"); case \"mango\" -&gt; &#123; System.out.println(\"Selected mango\"); System.out.println(\"Good choice!\"); &#125; default -&gt; System.out.println(\"No fruit selected\"); &#125; &#125;&#125;//新语法可以直接返回值public class Main &#123; public static void main(String[] args) &#123; String fruit = \"apple\"; int opt = switch (fruit) &#123; case \"apple\" -&gt; 1; case \"pear\", \"mango\" -&gt; 2; default -&gt; 0; &#125;; // 注意赋值语句要以;结束 System.out.println(\"opt = \" + opt); &#125;&#125;// yield// 大多数时候，在switch表达式内部，我们会返回简单的值。// 但是，如果需要复杂的语句，我们也可以写很多语句，放到&#123;...&#125;里，然后，用yield返回一个值作为switch语句的返回值：public class Main &#123; public static void main(String[] args) &#123; String fruit = \"orange\"; int opt = switch (fruit) &#123; case \"apple\" -&gt; 1; case \"pear\", \"mango\" -&gt; 2; default -&gt; &#123; int code = fruit.hashCode(); yield code; // switch语句返回值 &#125; &#125;; System.out.println(\"opt = \" + opt); &#125;&#125; 编译检查 使用IDE时，可以自动检查是否漏写了break语句和default语句，方法是打开IDE的编译检查。 在Eclipse中，选择Preferences - Java - Compiler - Errors/Warnings - Potential programming problems，将以下检查标记为Warning： ‘switch’ is missing ‘default’ case ‘switch’ case fall-through 在Idea中，选择Preferences - Editor - Inspections - Java - Control flow issues，将以下检查标记为Warning： Fallthrough in ‘switch’ statement ‘switch’ statement without ‘default’ branch 当switch语句存在问题时，即可在IDE中获得警告提示。 循环123456789101112131415161718// whilewhile (条件表达式) &#123; 循环语句&#125;do &#123; 执行循环语句&#125; while (条件表达式);// forfor (初始条件; 循环检测条件; 循环后更新计数器) &#123; // 执行语句&#125;// for eachfor (int n : ns) &#123; System.out.println(n);&#125; 在循环过程中，可以使用break语句跳出当前循环。 continue则是提前结束本次循环，直接继续执行下次循环。 数组操作遍历数组12345678910111213import java.util.Arrays;int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;for (int i=0; i&lt;ns.length; i++) &#123; int n = ns[i]; System.out.println(n);&#125;for (int n : ns) &#123; System.out.println(n);&#125;System.out.println(Arrays.toString(ns)); 排序12int[] ns = &#123; 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 &#125;;Arrays.sort(ns); 对数组排序实际上修改了数组本身。 多维数组1234567int[][] ns = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;&#125;;System.out.println(Arrays.deepToString(ns)); //多维数组打印 命令行参数12345678910public class Main &#123; public static void main(String[] args) &#123; for (String arg : args) &#123; if (\"-version\".equals(arg)) &#123; System.out.println(\"v 1.0\"); break; &#125; &#125; &#125;&#125; JAVA面向对象编程面向对象基础1234567public class Person&#123; public String name; public int age;&#125;Person ming = new Person();ming.name = \"小明\";ming.age = 12; //对字段赋值 一个class可以包含多个field（字段） 数据封装123456789101112131415161718192021222324252627282930313233343536373839public class Person&#123; private String name; private int age; // 如果自定义了构造方法，编译器不会生成默认构造方法 public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; // 调用其他构造方法 public Person(String name)&#123; this(name,18); &#125; public void setName(String name)&#123; this.name = name; &#125; public String getName()&#123; return this.name; &#125; // 可变参数// 可变参数用类型...定义，可变参数相当于数组类型：class Group &#123; private String[] names; public void setNames(String... names) &#123; this.names = names; &#125;&#125; Group g = new Group();g.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个Stringg.setNames(\"Xiao Ming\", \"Xiao Hong\"); // 传入2个Stringg.setNames(\"Xiao Ming\"); // 传入1个Stringg.setNames(); // 传入0个String&#125; 构造方法的初始化顺序： 初始化字段 没有赋值的字段初始化为默认值：基本类型=0；默认类型=null； 再执行构造方法的代码 继承和多态JAVA只允许class继承自一个类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Person&#123; private String name; private int age; public void run()&#123;&#125;&#125;public class Student extends Person&#123; //person类定义的private字段无法被子类访问； //protected字段可以被子类访问 private int score; public Student()&#123; // 第一行必须调用父类的构造方法，如果不写，默认生成不带参数的super(); super(); // 调用父类的构造方法 &#125; //覆写父类方法 @Override //非必须，让编译器帮忙检查 public void run()&#123; //调用父类被Override的方法 super.run(); &#125;; public void setScore(int score)&#123;&#125;;&#125;//向上转型Person p = new Person();Student s = new Student();Person ps = new student(); //upcastingObject o1 = p; //upcastingObject o2 = s; //upcasting//向下转型Student s = (Student) p; // ClassCastException//instanceof操作符判断对象的类型Person p = new Person();System.out.println(p instanceof Person); //trueSystem.out.println(p instanceof Student); //falseStudent s = new Student();System.out.println(s instanceof Person); //trueSystem.out.println(s instanceof Student); //trueStudent n = null;System.out.println(n instanceof Student); //false 多态 多态是指针对某个类型的方法调用，其真正执行的方法取决于运行时实际类型的方法 对某个类型调用方法，执行的方法可能是某个子类的方法 利用多态，允许添加更多类型的子类实现功能扩展 Object类定义的几个重要方法 123456789public class Person&#123; ... @Overrride public String toString()&#123;&#125; //把instance输出为String @Override public boolean equals(Object o)&#123;&#125; //判断两个instance是否逻辑相等 @Override public int hashCode()&#123;&#125; //计算一个instance的哈希值&#125; final 用final修饰的方法不能被Override 用final修饰的类不能被继承 用final修饰的字段在初始化后不能被修改 1234567public class Person&#123; public final void setName(String name)&#123;&#125;&#125;public final class Student extends Person&#123; private final int score;&#125; 抽象类和接口抽象类 抽象方法所在的类必须声明为抽象类。 抽象类可以 123public abstract class Person&#123; public abstract void run();&#125; 接口 如果一个类没有字段，所有方法全部是抽象方法，就可以把该抽象类改写为接口 因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 123456789101112131415161718192021222324252627interface Person &#123; void run(); String getName();&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(this.name + \" run\"); &#125; @Override public String getName() &#123; return this.name; &#125;&#125;//在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如：class Student implements Person, Hello &#123; // 实现了两个interface ...&#125; 接口继承 一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： 12345678interface Hello &#123; void hello();&#125;interface Person extends Hello &#123; void run(); String getName();&#125; default方法 在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法： 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person p = new Student(\"Xiao Ming\"); p.run(); &#125;&#125;interface Person &#123; String getName(); default void run() &#123; System.out.println(getName() + \" run\"); &#125;&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125;&#125; default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 静态字段和静态方法static field类的所有实例共享 123456class Person &#123; public String name; public int age; // 定义静态字段number: public static int number;&#125; 静态方法使用类名就可以调用。在静态方法中无法访问this变量，也无法访问实例字段，只能访问静态字段。 接口的静态字段 12345678910public interface Person &#123; public static final int MALE = 1; public static final int FEMALE = 2;&#125;//接口的字段必须是public static final，所以可以省略public interface Person &#123; // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2;&#125; 包和作用域1234567891011//person.java 1package ming; // 申明包名mingpublic class Person &#123;&#125;//person.java 2package mr.jun; // 申明包名mr.junpublic class Arrays &#123;&#125; 包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 包作用域 位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，Person类定义在hello包下面： 1234567891011121314151617package hello;public class Person &#123; // 包作用域: void hello() &#123; System.out.println(\"Hello!\"); &#125;&#125;package hello;public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 &#125;&#125; import 1234567//1：写出完整的类名mr.jun.Arrays arrays = new mr.jun.Arrays();//2：importimport mr.jun.Arrays;Arrays arrays = new Arrays();//3：import static导入类的静态字段和静态方法import static java.lang.System.*; 作用域 定义为public的class、interface可以被其他任何类访问 private访问权限被限定在class的内部，而且与方法声明顺序无关。 protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类 Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限 包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法。 final 用final修饰class可以阻止被继承 用final修饰method可以阻止被子类覆写 用final修饰field可以阻止被重新赋值 用final修饰局部变量可以阻止被重新赋值 123protected void hi(final int t) &#123; t = 1; // error!&#125; 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。 把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。 内部类 定义在另一个类内部的类 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Outer outer = new Outer(\"Nested\"); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner inner.hello(); &#125;&#125;class Outer &#123; private String name; Outer(String name) &#123; this.name = name; &#125; class Inner &#123; void hello() &#123; System.out.println(\"Hello, \" + Outer.this.name); &#125; &#125;&#125; 匿名类（Anonymous class） 1234567891011121314151617181920212223242526272829303132333435363738394041424344//匿名类和Inner Class一样，可以访问Outer Class的private字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。// Outer.this访问外部类public class Main &#123; public static void main(String[] args) &#123; Outer outer = new Outer(\"Nested\"); outer.asyncHello(); &#125;&#125;class Outer &#123; private String name; Outer(String name) &#123; this.name = name; &#125; void asyncHello() &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Hello, \" + Outer.this.name); &#125; &#125;; new Thread(r).start(); &#125;&#125;//匿名类也可以继承自普通类//&lt;classname&gt; &lt;name&gt; = new &lt;classname&gt;()&#123;&#125;import java.util.HashMap;public class Main &#123; public static void main(String[] args) &#123; HashMap&lt;String, String&gt; map1 = new HashMap&lt;&gt;(); HashMap&lt;String, String&gt; map2 = new HashMap&lt;&gt;() &#123;&#125;; // 匿名类! HashMap&lt;String,String&gt;为父类名 HashMap&lt;String, String&gt; map3 = new HashMap&lt;&gt;() &#123; &#123; put(\"A\", \"1\"); put(\"B\", \"2\"); &#125; &#125;; System.out.println(map3.get(\"A\")); &#125;&#125; 静态内部类 用static修饰的内部类和Inner Class有很大的不同，它不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但它可以访问Outer的private静态字段和静态方法。如果把StaticNested移到Outer之外，就失去了访问private的权限。 12345678910class Outer &#123; private static String NAME = \"OUTER\"; private String name; static class StaticNested &#123; void hello() &#123; System.out.println(\"Hello, \" + Outer.NAME); &#125; &#125;&#125; classpath和jarclasspath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。 启动JVM时设定：java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello jar包的使用：java -cp ./hello.jar abc.xyz.Hello 因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从.zip改为.jar，一个jar包就创建成功。 模块 java9开始，JDK中引入了模块（Module）。来解决不同jar包之间的依赖问题。 个人理解，模块主要用于减小JRE发布的体积。 模块之间的依赖项写入单独的文件（module-info.java）。 1234567891011// ./src/module-info.javamodule hello.world&#123; //依赖包 requires java.base; //可不写 requires java.xml; // 对外开放的接口 exports java.xml; exports javax.xml.catalog; exports javax.xml.datatype;&#125; 创建模块的步骤 编译字节码javac -d bin src/module-info.java src/com/itranswarp/sample/*.java 创建jar包：jar --create --file test.jar --main-class com.mmm.Main -C bin . 创建模块：jmod create --class-path test.jar test.jmod(必要时创建环境变量) 运行模块：java --module-path test.jar --module test 打包JRE jlink --module-path test.jmod --add-modules java.base,java.xml,test --output jre/ JAVA核心类String两个字符串比较，必须总是使用equals()方法。 要忽略大小写比较，使用equalsIgnoreCase()方法。 String类还提供了多种方法来搜索子串、提取子串。常用的方法有： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//子串\"Hello\".contains(\"ll\"); // true\"Hello\".indexOf(\"l\"); // 2\"Hello\".lastIndexOf(\"l\"); // 3\"Hello\".startsWith(\"He\"); // true\"Hello\".endsWith(\"lo\"); // true\"Hello\".substring(2); // \"llo\"\"Hello\".substring(2, 4); \"ll\"sb.delete(sb.length() - 2, sb.length());//掐头去尾\" \\tHello\\r\\n \".trim(); // \"Hello\"\"\\u3000Hello\\u3000\".strip(); // \"Hello\" // 和trim()不同的是，类似中文的空格字符\\u3000也会被移除\" Hello \".stripLeading(); // \"Hello \"\" Hello \".stripTrailing(); // \" Hello\"//空\"\".isEmpty(); // true，因为字符串长度为0\" \".isEmpty(); // false，因为字符串长度不为0\" \\n\".isBlank(); // true，因为只包含空白字符\" Hello \".isBlank(); // false，因为包含非空白字符//替换String s = \"hello\";s.replace('l', 'w'); // \"hewwo\"，所有字符'l'被替换为'w's.replace(\"ll\", \"~~\"); // \"he~~o\"，所有子串\"ll\"被替换为\"~~\"//正则表达式替换String s = \"A,,B;C ,D\";s.replaceAll(\"[\\\\,\\\\;\\\\s]+\", \",\"); // \"A,B,C,D\"//分割String s = \"A,B,C,D\";String[] ss = s.split(\"\\\\,\"); // &#123;\"A\", \"B\", \"C\", \"D\"&#125;//拼接String[] arr = &#123;\"A\", \"B\", \"C\"&#125;;String s = String.join(\"***\", arr); // \"A***B***C\"String[] names = &#123;\"Bob\", \"Alice\", \"Grace\"&#125;;var sj = new StringJoiner(\", \");for (String name : names) &#123; sj.add(name);&#125;System.out.println(sj.toString());//格式化字符串//%s：显示字符串；//%d：显示整数；//%x：显示十六进制整数；//%f：显示浮点数。String s = \"Hi %s, your score is %d!\";System.out.println(s.formatted(\"Alice\", 80));//类型转换String.valueOf(123); // \"123\"String.valueOf(45.67); // \"45.67\"String.valueOf(true); // \"true\"String.valueOf(new Object()); // 类似java.lang.Object@636be97cint n1 = Integer.parseInt(\"123\"); // 123int n2 = Integer.parseInt(\"ff\", 16); // 按十六进制转换，255boolean b1 = Boolean.parseBoolean(\"true\"); // trueboolean b2 = Boolean.parseBoolean(\"FALSE\"); // falseInteger.getInteger(\"java.version\"); // 版本号，11 把该字符串对应的系统变量转换为Integer//string和char[]的转换char[] cs = \"Hello\".toCharArray(); // String -&gt; char[]String s = new String(cs); // char[] -&gt; String//编码转换byte[] b1 = \"Hello\".getBytes(); // 按系统默认编码转换，不推荐byte[] b2 = \"Hello\".getBytes(\"UTF-8\"); // 按UTF-8编码转换byte[] b2 = \"Hello\".getBytes(\"GBK\"); // 按GBK编码转换byte[] b3 = \"Hello\".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换byte[] b = ...String s1 = new String(b, \"GBK\"); // 按GBK转换String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换 StringBuilder为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象： 1234567891011StringBuilder sb = new StringBuilder(1024);for (int i = 0; i &lt; 1000; i++) &#123; sb.append(','); sb.append(i); //进行链式操作的关键是，定义的append()方法会返回this sb.append(\"Mr \") .append(\"Bob\") .append(\"!\") .insert(0, \"Hello, \");&#125;String s = sb.toString(); 对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。 包装类型引用类型可以赋值为null，表示空，但基本类型不能赋值为null java核心库中为每种基本类型都提供了对应的包装类型 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 12345678int i = 100;// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):Integer n1 = new Integer(i);// 通过静态方法valueOf(int)创建Integer实例:Integer n2 = Integer.valueOf(i);// 通过静态方法valueOf(String)创建Integer实例:Integer n3 = Integer.valueOf(\"100\");System.out.println(n3.intValue()); Auto Boxing 自动拆包和解包只发生在编译阶段： 12Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue() 不变性 所有的包装类型都是不变类。private final class Integer{private final int value;} 进制转换 123456789int x1 = Integer.parseInt(\"100\"); // 100int x2 = Integer.parseInt(\"100\", 16); // 256,因为按16进制解析Integer.toString(100);System.out.println(Integer.toString(100)); // \"100\",表示为10进制System.out.println(Integer.toString(100, 36)); // \"2s\",表示为36进制System.out.println(Integer.toHexString(100)); // \"64\",表示为16进制System.out.println(Integer.toOctalString(100)); // \"144\",表示为8进制System.out.println(Integer.toBinaryString(100)); // \"1100100\",表示为2进制 包装类型中的静态变量 123456789101112131415161718// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes)// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue(); 在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。 1234byte x = -1;byte y = 127;System.out.println(Byte.toUnsignedInt(x)); // 255System.out.println(Byte.toUnsignedInt(y)); // 127 JavaBean如果读写方法符合以下这种命名规范： 1234&#x2F;&#x2F; 读方法:public Type getXyz()&#x2F;&#x2F; 写方法:public void setXyz(Type value) 那么这种class被称为JavaBean.boolean字段比较特殊，它的读方法一般命名为isXyz(). 12345678910111213141516171819202122232425262728// 枚举JavaBean属性import java.beans.*;public class Main &#123; public static void main(String[] args) throws Exception &#123; BeanInfo info = Introspector.getBeanInfo(Person.class); for (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123; System.out.println(pd.getName()); System.out.println(\" \" + pd.getReadMethod()); System.out.println(\" \" + pd.getWriteMethod()); &#125; &#125;&#125;class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 枚举类12345678910enum Weekday &#123; SUN, MON, TUE, WED, THU, FRI, SAT;&#125;Weekday day = Weekday.SUN;if (day == Weekday.SAT || day == Weekday.SUN) &#123; System.out.println(\"Work at home!\");&#125; else &#123; System.out.println(\"Work at office!\");&#125; enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较 12// 返回indexint n = Weekday.MON.ordinal(); // 1 1234567891011121314151617181920212223242526enum Weekday &#123; MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0); public final int dayValue; private Weekday(int dayValue) &#123; this.dayValue = dayValue; &#125;&#125;enum Weekday &#123; MON(1, \"星期一\"), TUE(2, \"星期二\"), WED(3, \"星期三\"), THU(4, \"星期四\"), FRI(5, \"星期五\"), SAT(6, \"星期六\"), SUN(0, \"星期日\"); public final int dayValue; private final String chinese; private Weekday(int dayValue, String chinese) &#123; this.dayValue = dayValue; this.chinese = chinese; &#125; @Override public String toString() &#123; return this.chinese; &#125;&#125; 记录类使用String、Integer等类型的时候，这些类型都是不变类，一个不变类具有以下特点： 定义class时使用final，无法派生子类； 每个字段使用final，保证创建实例后无法修改任何字段。 从Java 14开始，引入了新的Record类。我们定义Record类时，使用关键字record。 123456789101112131415161718192021222324252627282930313233343536373839public class Main &#123; public static void main(String[] args) &#123; Point p = new Point(123, 456); System.out.println(p.x()); System.out.println(p.y()); System.out.println(p); &#125;&#125;public record Point(int x, int y) &#123;&#125;// 等效的类：public final class Point extends Record &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int x() &#123; return this.x; &#125; public int y() &#123; return this.y; &#125; public String toString() &#123; return String.format(\"Point[x=%s, y=%s]\", x, y); &#125; public boolean equals(Object o) &#123; ... &#125; public int hashCode() &#123; ... &#125;&#125; 如果构造类需要检查参数： 1234567public record Point(int x, int y) &#123; public Point &#123; if (x &lt; 0 || y &lt; 0) &#123; throw new IllegalArgumentException(); &#125; &#125;&#125; 12345678910public record Point(int x, int y) &#123; public static Point of() &#123; return new Point(0, 0); &#125; public static Point of(int x, int y) &#123; return new Point(x, y); &#125;&#125;var z = Point.of();var p = Point.of(123, 456); BigIntegerjava.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数 123BigInteger i = new BigInteger(\"123456789000\");System.out.println(i.longValue()); // 123456789000System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range BigDecimalBigDecimal可以表示一个任意大小且精度完全准确的浮点数。 12345678910111213141516171819202122232425262728BigDecimal d1 = new BigDecimal(\"123.4500\");BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00//scale()表示小数位数BigDecimal d1 = new BigDecimal(\"123.4500\");BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00BigDecimal d3 = new BigDecimal(\"1234500\");BigDecimal d4 = d3.stripTrailingZeros();System.out.println(d3.scale()); // 0System.out.println(d4.scale()); // -2//可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：BigDecimal d1 = new BigDecimal(\"123.456789\");BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567//除法需要截断BigDecimal d1 = new BigDecimal(\"123.456\");BigDecimal d2 = new BigDecimal(\"23.456789\");BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽//使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！ 常用工具类Math12345678910111213141516Math.abs(-100); // 100Math.max(100, 99); // 100Math.min(1.2, 2.3); // 1.2Math.pow(2, 10); // 2的10次方=1024Math.sqrt(2); // 1.414...Math.exp(2); // 7.389...Math.log(4); // 1.386...Math.sin(3.14); // 0.00159...Math.cos(3.14); // -0.9999...Math.tan(3.14); // -0.0015...Math.asin(1.0); // 1.57079...Math.acos(1.0); // 0.0double pi = Math.PI; // 3.14159...double e = Math.E; // 2.7182818...Math.sin(Math.PI / 6); // sin(π/6) = 0.5Math.random(); // 0.53907... 每次都不一样 Random1234567//伪随机Random r = new Random(098);r.nextInt(); // 2071575453,每次都不一样r.nextInt(10); // 5,生成一个[0,10)之间的intr.nextLong(); // 8811649292570369305,每次都不一样r.nextFloat(); // 0.54335...生成一个[0,1)之间的floatr.nextDouble(); // 0.3716...生成一个[0,1)之间的double SecureRandom(真随机)12SecureRandom sr = new SecureRandom();System.out.println(sr.nextInt(100)); 需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！ 异常处理Java的异常Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力，例如： OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 而Exception则是运行时的错误，它可以被捕获并处理。 某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如： NumberFormatException：数值类型的格式错误 FileNotFoundException：未找到文件 SocketException：读取网络失败 还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如： NullPointerException：对某个null的对象调用方法或字段 IndexOutOfBoundsException：数组索引越界 Exception又分为两大类： RuntimeException以及它的子类； 非RuntimeException（包括IOException、ReflectiveOperationException等等） Java规定： 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。 捕获异常1234567891011121314151617181920212223242526272829303132333435363738import java.io.UnsupportedEncodingException;import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; byte[] bs = toGBK(\"中文\"); System.out.println(Arrays.toString(bs)); // 多catch语句 // catch的顺序非常重要：子类必须写在前面 try &#123; process1(); process2(); process3(); &#125; catch (IOException | NumberFormatException e) &#123; // IOException或NumberFormatException System.out.println(\"Bad input\"); &#125; catch (Exception e) &#123; System.out.println(\"Unknown error\"); &#125; finally &#123; System.out.println(\"END\"); &#125; &#125; // throw static byte[] toGBK(String s) throws UnsupportedEncodingException &#123; return s.getBytes(\"GBK\"); // try catch static byte[] toGBK(String s) &#123; try &#123; // 用指定编码转换String为byte[]: return s.getBytes(\"GBK\"); &#125; catch (UnsupportedEncodingException e) &#123; // e.printStackTrace(); // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException: System.out.println(e); // 打印异常信息 return s.getBytes(); // 尝试使用用默认编码 &#125; &#125;&#125; printStackTrace()可以打印出方法的调用栈。 抛出异常 123456789101112131415void process1(String s) &#123; try &#123; process2(); &#125; catch (NullPointerException e) &#123; //转换异常 //为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去，新的Exception就可以持有原始Exception信息。 throw new IllegalArgumentException(e); &#125;&#125;void process2(String s) &#123; if (s==null) &#123; throw new NullPointerException(); &#125;&#125; 在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。 在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出： 1234567891011121314151617public class Main &#123; public static void main(String[] args) throws Exception &#123; Exception origin = null; try &#123; System.out.println(Integer.parseInt(\"abc\")); &#125; catch (Exception e) &#123; origin = e; throw e; &#125; finally &#123; Exception e = new IllegalArgumentException(); if (origin != null) &#123; e.addSuppressed(origin); &#125; throw e; &#125; &#125;&#125; 自定义异常Java标准库定义的常用异常包括： 1234567891011121314151617181920212223242526272829Exception│├─ RuntimeException│ ││ ├─ NullPointerException│ ││ ├─ IndexOutOfBoundsException│ ││ ├─ SecurityException│ ││ └─ IllegalArgumentException│ ││ └─ NumberFormatException│├─ IOException│ ││ ├─ UnsupportedCharsetException│ ││ ├─ FileNotFoundException│ ││ └─ SocketException│├─ ParseException│├─ GeneralSecurityException│├─ SQLException│└─ TimeoutException 自定义异常通常从RuntimeException派生：public class BaseException extends RuntimeException {} 自定义的BaseException应该提供多个构造方法： 1234567891011121314151617public class BaseException extends RuntimeException &#123; public BaseException() &#123; super(); &#125; public BaseException(String message, Throwable cause) &#123; super(message, cause); &#125; public BaseException(String message) &#123; super(message); &#125; public BaseException(Throwable cause) &#123; super(cause); &#125;&#125; NullPointerExceptionNullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误. 123456//成员变量在定义时初始化：//使用空字符串\"\"而不是默认的null可避免很多NullPointerException，编写业务逻辑时，用空字符串\"\"表示未填写比null安全得多。public class Person &#123; private String name = \"\";&#125;//返回空字符串\"\"、空数组而不是null 断言1234567public static void main(String[] args) &#123; double x = Math.abs(-123.45); assert x &gt;= 0; //使用assert语句时，还可以添加一个可选的断言消息： assert x &gt;= 0 : \"x must &gt;= 0\"; System.out.println(x);&#125; 断言失败时会抛出AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。 对于可恢复的程序错误，不应该使用断言。 idea中开启断言的方法 在VM optons中 加入 -ea或-enableassertions 实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解JUnit的使用。 JDK Loggingjava.util.logging需要在JVM启动时传递参数-Djava.util.logging.config.file=&lt;config-file-name&gt;。 Java标准库内置的Logging使用并不是非常广泛。 12345678910111213// loggingimport java.util.logging.Level;import java.util.logging.Logger;public class Hello &#123; public static void main(String[] args) &#123; Logger logger = Logger.getGlobal(); logger.info(\"start process...\"); logger.warning(\"memory is running out...\"); logger.fine(\"ignored.\"); logger.severe(\"process will be terminated...\"); &#125;&#125; JDK的Logging定义了7个日志级别，从严重到普通： SEVERE WARNING INFO CONFIG FINE FINER FINEST Commons LoggingCommons Logging是一个第三方日志库，它是由Apache创建的日志模块。 Commons Logging可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。 12345678910import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;// 在实例方法中引用Log:public class Person &#123; protected final Log log = LogFactory.getLog(getClass());//相比下面的方法，这种方法子类也可以使用该log实例 //protected final Log log = LogFactory.getLog(Person.class); void foo() &#123; log.info(\"foo\"); &#125;&#125; Commons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了一个非常有用的重载方法：info(String, Throwable) 12345try &#123; ...&#125; catch (Exception e) &#123; log.error(\"got exception!\", e);&#125; Log4j配置文件 12345678910111213141516171819202122232425262728293031323334353637// log4j2.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Configuration&gt; &lt;Properties&gt; &lt;!-- 定义日志格式 --&gt; &lt;Property name=\"log.pattern\"&gt;%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n&lt;/Property&gt; &lt;!-- 定义文件名变量 --&gt; &lt;Property name=\"file.err.filename\"&gt;log/err.log&lt;/Property&gt; &lt;Property name=\"file.err.pattern\"&gt;log/err.%i.log.gz&lt;/Property&gt; &lt;/Properties&gt; &lt;!-- 定义Appender，即目的地 --&gt; &lt;Appenders&gt; &lt;!-- 定义输出到屏幕 --&gt; &lt;Console name=\"console\" target=\"SYSTEM_OUT\"&gt; &lt;!-- 日志格式引用上面定义的log.pattern --&gt; &lt;PatternLayout pattern=\"$&#123;log.pattern&#125;\" /&gt; &lt;/Console&gt; &lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt; &lt;RollingFile name=\"err\" bufferedIO=\"true\" fileName=\"$&#123;file.err.filename&#125;\" filePattern=\"$&#123;file.err.pattern&#125;\"&gt; &lt;PatternLayout pattern=\"$&#123;log.pattern&#125;\" /&gt; &lt;Policies&gt; &lt;!-- 根据文件大小自动切割日志 --&gt; &lt;SizeBasedTriggeringPolicy size=\"1 MB\" /&gt; &lt;/Policies&gt; &lt;!-- 保留最近10份 --&gt; &lt;DefaultRolloverStrategy max=\"10\" /&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=\"info\"&gt; &lt;!-- 对info级别的日志，输出到console --&gt; &lt;AppenderRef ref=\"console\" level=\"info\" /&gt; &lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt; &lt;AppenderRef ref=\"err\" level=\"error\" /&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; SLF4J和LogbackSLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。 在Commons Logging中，我们要打印日志，有时候得这么写： 123int score = 99;p.setScore(score);log.info(\"Set score \" + score + \" for Person \" + p.getName() + \" ok.\"); 拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了： 123int score = 99;p.setScore(score);logger.info(\"Set score &#123;&#125; for Person &#123;&#125; ok.\", score, p.getName()); 如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样： 123456import org.slf4j.Logger;import org.slf4j.LoggerFactory;class Main &#123; final Logger logger = LoggerFactory.getLogger(getClass());&#125; 1234567891011121314151617181920212223242526272829// logback.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;utf-8&lt;/charset&gt; &lt;/encoder&gt; &lt;file&gt;log/output.log&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;fileNamePattern&gt;log/output.log.%i&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;1MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt;&lt;/configuration&gt; ob=>operation: Object person=>operation: Person student=>operation: Student student->person->ob{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/categories/JAVA/"},{"name":"基础","slug":"JAVA/基础","permalink":"https://sjtu-xx.github.io/categories/JAVA/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/tags/JAVA/"}]},{"title":"markdown流程图","slug":"markdown流程图","date":"2020-12-27T02:26:49.000Z","updated":"2021-02-19T02:26:06.533Z","comments":true,"path":"2020/12/27/markdown流程图/","link":"","permalink":"https://sjtu-xx.github.io/2020/12/27/markdown%E6%B5%81%E7%A8%8B%E5%9B%BE/","excerpt":"平常使用markdown写博客，最近发现markdown可以画流程图，稍微总结一下。","text":"平常使用markdown写博客，最近发现markdown可以画流程图，稍微总结一下。 hexo支持hexo默认不支持markdown中的流程图渲染，需要安装：npm install --save hexo-filter-flowchart 一个简单的流程图123456789···flowst&#x3D;&gt;start: Startop&#x3D;&gt;operation: Your Operationcond&#x3D;&gt;condition: Yes or No?e&#x3D;&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op··· 稍微复杂的流程图1234567891011121314···flowst&#x3D;&gt;start: Start:&gt;http:&#x2F;&#x2F;www.google.com[blank]e&#x3D;&gt;end:&gt;http:&#x2F;&#x2F;www.google.comop1&#x3D;&gt;operation: My Operationsub1&#x3D;&gt;subroutine: My Subroutinecond&#x3D;&gt;condition: Yesor No?:&gt;http:&#x2F;&#x2F;www.google.comio&#x3D;&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;e# 指定位置cond(no)-&gt;sub1(right)-&gt;op1··· 流程图中的模块类型 操作模块 说明 start 开始 end 结束 operation 普通操作块 condition 判断块 subroutine 子任务块 inputoutput 输入输出块 st=>start: Start op=>operation: Your Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);st=>start: Start:>http://www.google.com[blank] e=>end:>http://www.google.com op1=>operation: My Operation sub1=>subroutine: My Subroutine cond=>condition: Yes or No?:>http://www.google.com io=>inputoutput: catch something... st->op1->cond cond(yes)->io->e cond(no)->sub1(right)->op1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);","categories":[{"name":"其他工具","slug":"其他工具","permalink":"https://sjtu-xx.github.io/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://sjtu-xx.github.io/tags/markdown/"}]},{"title":"shell脚本编程","slug":"shell脚本编程","date":"2020-09-12T09:54:33.000Z","updated":"2021-02-19T02:26:06.716Z","comments":true,"path":"2020/09/12/shell脚本编程/","link":"","permalink":"https://sjtu-xx.github.io/2020/09/12/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/","excerpt":"认识bash","text":"认识bash echo变量设置1NAME&#x3D;shell 变量取用1234567echo $HOMEecho $&#123;HOME&#125;双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示: “var&#x3D;&quot;lang is $LANG&quot;”则“echo $var”可得“lang is zh_TW.UTF-8” 单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示: “var&#x3D;&#39;lang is $LANG&#39;”则“echo $var”可得“lang is $LANG” 扩增变量内容12PATH&#x3D;&quot;$PATH&quot;:&#x2F;home&#x2F;binPATH&#x3D;$&#123;PATH&#125;:&#x2F;home&#x2F;bin 取消变量1unset NAME env和setenv为环境变量 set为自定义变量 export自定义变量转为环境变量 read、array、declare12345678# 输入read -p \"Please keyin your name: \" -t 30 named# 声明变量类型declare [-aixr] variable# arrayvar[1]=\"min\" ulimit文件系统限制1ulimit文件系统限制 删除字串123456# 从头删echo $&#123;path#&#x2F;*:&#125; # 删掉&#x2F;到：的最长部分echo $&#123;path##&#x2F;*:&#125; # 删掉&#x2F;到：的最短部分# 从末尾删echo $&#123;path%:bin&#125; 变量设置方式 说明 ${变量#关键字} 若变量内容从头开始的数据符合“关键字”，则将符合的最短数据删除 ${变量##关键字} 若变量内容从头开始的数据符合“关键字”，则将符合的最长数据删除 ${变量%关键字} 若变量内容从尾向前的数据符合“关键字”，则将符合的最短数据删除 ${变量%%关键字} 若变量内容从尾向前的数据符合“关键字”，则将符合的最 长数据删除 ${变量/旧字串/新字串} 若变量内容符合“旧字串”则“第一个旧字串会被新字串取代” ${变量//旧字串/新字串} 若变量内容符合“旧字串”则“全部的旧字串会被新字串取代” 命令别名与历史命令123alias lm='ls -al|more'history Bash环境bash初始化会读取两个文件/etc/profile和~/.bash_profile或类似名称的文件 /etc/profile.d/*.sh只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使 用者能够具有 r 的权限， 那么该文件就会被 /etc/profile 调用进来。在 CentOS 7.x 中，这个 目录下面的文件规范了 bash 操作接口的颜色、 语系、ll 与 ls 指令的命令别名、vi 的命令别 名、which 的命令别名等等。如果你需要帮所有使用者设置一些共享的命令别名时， 可以在 这个目录下面自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可喔! $$$$1.若 cmd1 执行完毕且正确执行($?=0)，则开始执行 cmd2。 2. 若 cmd1 执行完毕且为错误 ($?≠0)，则 cmd2 不执行。 ||1.若 cmd1 执行完毕且正确执行($?=0)，则 cmd2 不执行。 2. 若 cmd1 执 cmd2 行完毕且为错误 ($?≠0)，则开始执行 cmd2。 管道|cut和grepcut分析每行，截取对应部分 grep截取满足要求的行。 sort,wc,uniqtee双重重定向：同时屏幕和文件 字符转换命令 tr, col, join, paste, expand参数代换: xargs分区命令: splitshell script执行方式通过./test.sh和sh test.sh的方式是在子程序中执行的。 通过source test.sh的方式是在父程序中执行的。 判断符号[ &quot;$HOME&quot; == &quot;$MAIL&quot; ] 参数变量($0,$1,$2)条件判断式12if [ 条件判断式 ]; then 当条件判断式成立时，可以进行的指令工作内容;fi &amp;lt;==将 if 反过来写，就成为 fi 啦!结束 if 之意! 1234567if [ 条件判断式一 ]; then 当条件判断式一成立时，可以进行的指令工作内容;elif [ 条件判断式二 ]; then 当条件判断式二成立时，可以进行的指令工作内容;else 当条件判断式一与二均不成立时，可以进行的指令工作内容;fi 123456789101112case $变量名称 in &amp;lt;==关键字为 case ，还有变量前有钱字号 \"第一个变量内容\"） &amp;lt;==每个变量内容建议用双引号括起来，关键字则为小括号 ） 程序段 ;; &amp;lt;==每个类别结尾使用两个连续的分号来处理！ \"第二个变量内容\"） 程序段 ;; *） &amp;lt;==最后一个变量内容都会用 * 来代表所有其他值 不包含第一个变量内容与第二个变量内容的其他程序执行段 exit 1 ;;esac &amp;lt;==最终的 case 结尾！“反过来写”思考一下！ function1234567891011121314151617181920function printit（）&#123; echo \"Your choice is $&#123;1&#125;\" # 这个 $1 必须要参考下面指令的下达&#125;echo \"This program will print your selection !\"case $&#123;1&#125; in \"one\"） **printit 1** # 请注意， printit 指令后面还有接参数！ ;; \"two\"） **printit 2** ;; \"three\"） **printit 3** ;; *） echo \"Usage $&#123;0&#125; &#123;one&amp;#124;two&amp;#124;three&#125;\" ;;esac 1234while [ condition ] &amp;lt;==中括号内的状态就是判断式do &amp;lt;==do 是循环的开始！ 程序段落done &amp;lt;==done 是循环的结束 1234until [ condition ]do 程序段落done 1234for var in con1 con2 con3 ...do 程序段done 1234for （（ 初始值; 限制值; 执行步阶 ））do 程序段done","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sjtu-xx.github.io/categories/Linux/"}],"tags":[]},{"title":"MPI","slug":"MPI","date":"2020-09-07T12:23:56.000Z","updated":"2021-02-19T02:26:06.266Z","comments":true,"path":"2020/09/07/MPI/","link":"","permalink":"https://sjtu-xx.github.io/2020/09/07/MPI/","excerpt":"MPI（Message-Passing-Interface 消息传递接口）实现并行是进程级别的，通过通信在进程之间进行消息传递。MPI并不是一种新的开发语言，它是一个定义了可以被C、C++和Fortran程序调用的函数库。这些函数库里面主要涉及的是两个进程之间通信的函数。MPI可以在Windows和linux环境中都有相应的库，本篇以Windows10作为演示开发环境。","text":"MPI（Message-Passing-Interface 消息传递接口）实现并行是进程级别的，通过通信在进程之间进行消息传递。MPI并不是一种新的开发语言，它是一个定义了可以被C、C++和Fortran程序调用的函数库。这些函数库里面主要涉及的是两个进程之间通信的函数。MPI可以在Windows和linux环境中都有相应的库，本篇以Windows10作为演示开发环境。https://mpitutorial.com/tutorials/ 一些概念MPI：跨语言的通信协议。是一个信息传递应用程序接口，包括协议和语义说明。 OpenMP(Open Multi-Processing)：共享存储并行编程。用于共享内存并行系统的对处理程序设计的一套指导性编译处理方案。(一般单主机) OpenMPI：一种高性能消息传递库，它是MPI-2标准的一个开源实现，有一些科研机构和企业一起开发和维护。OpenMPI来创建最好的MPI库。易于使用，并运行本身在各种各样的操作系统。 windows与MPIWindows为了兼容MPI，自己做了一套基于一般个人电脑的MPI实现。如果要安装正真意义上的MPI的话，请直接去www.mpich.org下载，里面根据对应的系统下载相应的版本。 一个简单的MPI程序12345678910111213141516171819#include \"mpi.h\" #include &lt;stdio.h&gt; int main(int argc, char* argv[])&#123; int rank, numproces; int namelen; char processor_name[MPI_MAX_PROCESSOR_NAME]; MPI_Init(&amp;argc, &amp;argv); MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);//获得进程号 MPI_Comm_size(MPI_COMM_WORLD, &amp;numproces);//返回通信子的进程数 MPI_Get_processor_name(processor_name, &amp;namelen); fprintf(stderr, \"hello world! process %d of %d on %s\\n\", rank, numproces, processor_name); MPI_Finalize(); return 0;&#125; MPI的使用MPI_Init：告知MPI系统进行所有必要的初始化设置。它是写在启动MPI并行计算的最前面的。具体的语法结构为:1234MPI_Init( int* argc_p, char*** argv_p ); 参数argc_p和argv_p分别指向main函数中的指针参数，为了弄明白这部分，还得从main函数的参数说起：Ｃ语言规定main函数的参数只能有两个，习惯上这两个参数写为argc和argv。因此，main函数的函数头可写为： main (argc,argv)。Ｃ语言还规定argc(第一个形参)必须是整型变量,argv( 第二个形参)必须是指向字符串的指针数组。其中argc参数表示了命令行中参数的个数(注意：文件名本身也 算一个参数)，argc的值是在输入命令行时由系统按实际参数的个数自动赋予的。例如有命令行为： C:”&gt;E6 24 BASIC dbase FORTRAN由于文件名E6 24本身也算一个参数，所以共有4个参数，因此argc取得的值为4。argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处 理)的首地址。 然而在MPI_Init函数中，并不一定都需要设置argc_p和argv_p这两个参数的，不需要的时候，将它们设置为NULL即可。 通讯子（communicator）：MPI_COMM_WORLD表示一组可以互相发送消息的进程集合。 MPI_Comm_rank:用来获取正在调用进程的通信子中的进程号的函数。 MPI_Comm_size:用来得到通信子的进程数的函数。 这两个函数的具体结构如下： 123456789int MPIAPI MPI_Comm_rank( __in MPI_Comm comm, __out int* rank );int MPIAPI MPI_Comm_size( __in MPI_Comm comm, __out int* size ); MPI_Finalize：告知MPI系统MPI已经使用完毕。它总是放到做并行计算的功能块的最后面，在此函数之后就不能再出现任何有关MPI相关的东西了。 以上只是表达了作为一个MPI并行计算的基本结构，并没有真正涉及进程之间的通信，为了更好的进行并行，必然需要进程间的通信，下面介绍两个进程间通信的函数，它们就是MPI_Send和MPI_Recv，分别用于消息的发送和接收。 MPI_Send：阻塞型消息发送。 MPI_Recv：阻塞型消息接收。 MPI_Status：返回消息传递的完成情况。","categories":[{"name":"高性能计算","slug":"高性能计算","permalink":"https://sjtu-xx.github.io/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"}],"tags":[]},{"title":"CUDA基础","slug":"CUDA基础","date":"2020-09-06T09:09:47.000Z","updated":"2021-02-19T02:26:06.038Z","comments":true,"path":"2020/09/06/CUDA基础/","link":"","permalink":"https://sjtu-xx.github.io/2020/09/06/CUDA%E5%9F%BA%E7%A1%80/","excerpt":"并行编程","text":"并行编程 并行编程模型 共享存储模型 线程模型 消息传递模型 数据并行模型 具体实例：OpenMP、MPI、Single Program Multiple Data（SPMD）、MPMD 设计并行处理程序和系统 自动和手动并行 理解问题和程序 分块分割 通讯 同步 数据依赖 指令流水线：取指，译码，执行，访存，写回。 名词FLOPS:floating-point operations per secondGPU: graphic processing unit GPU是异构、众核、处理器，针对吞吐优化。 高效GPU任务具备的条件： 具有成千上万的独立工作 尽量利用大量的ALU单元 大量的片元切换掩藏延迟 可以共享指令流 适用于SIMD处理 最好是计算密集的任务 通信和计算开销比例合适 不要受制于访存带宽 CPU-GPU交互 GPU、CPU拥有各自的内存空间。 通过PCIE总线互连（8～16GHz）。 交互开销大。 CUDA编程概念Thread，block，grid是CUDA编程上的概念，为了方便程序员软件设计，组织线程。 thread：一个CUDA的并行程序会被以许多个threads来执行。 block：数个threads会被群组成一个block，同一个block中的threads可以同步，也可以通过shared memory通信。 grid：多个blocks则会再构成grid。 软硬件对应关系：thread: thread processorblock: SM（streaming multiprocessor） 共享内存shared memory每个设备拥有global memory CUDA编程CUDA术语Host主机端：通常指CPU，采用ANSI标准C语言编程 Device设备端：通常指GPU，采用扩ANSI标准扩展的C语言编程 Host和Device拥有各自的存储器。 CUDA编程包括Host和Device编码， kernel：数据并行处理函数。 grid: 一维或多维线程块 block：多个线程（一二三维）。 一个grid里面每个block中的线程数相同 block内部的每个线程可以：同步，访问共享存储器 每个block对应在一个SM上 device代码段可以： 读写每个线程的寄存器 读写每个线程的local memory 读写每个block的shared memory 读写每个grid的global memory 读每个grid的constant memory host代码段可以： 读写每个grid的global memory和constant memory global memory和constant memory都在GPU芯片中 cudaMalloc() 在设备端分配global memorycudaFree() 在设备端释放内存 cuda内存传输：host和device的内存传输 cudaMemcpy(Md,M,size,cudaMemcpyHostToDevice) cudaMemcpy(P,Pd,size,cudaMemcpyDeviceToHost) cuda 矩阵乘法12345678910111213141516171819202122232425262728293031323334353637383940__global__ void MatrixMulkernel(float* Md,float* Nd,float* Pd,int Width)&#123; int tx= threadIdx.x; int ty= threadIdy.y; float Pvalue = 0; for (int k = 0;k&lt;width;++k)&#123; float Mdelement = Md[ty * Md.width +k]; float Ndelement = Nd[k * Nd.width + tx]; Pvalue += Mdelement * Ndelement; &#125; Pd[ty * width + tx] = Pvalue;&#125;void MatrixMulOnDevice(float* M, float* N, float* P, int width)&#123; int size = width * width *sizeof(float); // load M and N to device memory cudaMalloc(Md,size); cudaMemcpy(Md,M,size,cudaMemcpyHostToDevice); cudaMalloc(Nd,size); cudaMemcpy(Nd,N,size,cudaMemcpyHostToDevice); cudaMalloc(Pd,size); // dim3 dimBlock(width,width); // 1个block含width*width个线程 dim3 dimGrid(1,1); MatrixMulKernel&lt;&lt;&lt;dimGrid,dimBlock&gt;&gt;&gt;(Md,Nd,Pd); // read p from device cudaMemcpy(P,Pd,size,cudaMemcpyDeviceToHost); cudaFree(Md); cudaFree(Nd); cudaFree(Pd);&#125; cuda函数声明 声明 执行 调用 __global__ void KernelFunc() 设备端 主机端 __device__ float DeviceFunc() 设备端 设备端 __host__ float HostFunc() 主机端 主机端 __global__返回类型必须是void global和device函数 少用递归、不要用静态变量、少用malloc、小心通过指针实现函数调用 向量数据类型 通过.x,.y,.z,.w进行访问 部分函数列表 常用的数学函数：intrinsic function:__开头，损失一定精度，但速度大幅提高 线程同步：__syncthreads(); 要求线程的执行时间尽量接近。只在一个块内部进行同步。 在if-else中使用同步可能死锁：不同的目的地。 Warp：一个block内部的一组线程 Warp中的线程切换是0开销的。 内存模型local memory实际上存放在global memory当中。 shared memory可全速读写。 变量声明 存储器 作用域 生命期 单独的自动变量而不是数组 寄存器 thread kernel 自动变量数组 local thread kernel __shared__ int sharedVar&#39; shared block kernel __device__ int globalVar global grid application __constant__ int constantVar; constant grid application global和constant变量 host可以通过以下函数访问： cudaGetSymbolAddress() cudaGetSymbolSize() cudaMemcpyToSymbol() cudaMemcpyFromSymbol() constants变量必须在函数外声明 原子操作：atomicAdd CUDA程序优化有效的数据并行算法+针对GPU架构特性的优化 = 优化的算法 并行规约warp分割 Block被分割为32为单位的线程组，叫做warp。 warp是最基本的调度单元，warp一直执行相同的指令。 warp分割原则：threadIdx是连续增加的一组。 访存合并SM资源动态分割存储优化 减少传输 中间数据直接在GPU分配，操作，释放 有时更适合在GPU上进行重复计算 如果没有减少数据传输的话，将CPU代码移植到GPU可能无法提升性能。 组团传输 大块传输好于小块。 内存传输与计算时间重叠。 双缓存 避免每个线程访问连续的空间。相邻线程访问相邻的空间。 bank冲突：同一个周期对shared memory中同一个bank进行访问。 shared memory和registers一样快，如果没有bank冲突的话。 CUDA中的Texture内存。 优点： 数据被缓存 特别适用于无法合并访存的场合 支持过滤 Wrap模式 一二三维寻址 # of blocks &gt; # of SM尽可能保证每个SM至少有一个work group在执行 块大小必须是32的倍数。最小64，通常采用128or256。依赖于问题本身，需要实验确定。 隐藏延时：需要有足够多的线程来掩藏延时。 循环展开：自动实现#pragma unroll BLOCK_SIZE","categories":[{"name":"高性能计算","slug":"高性能计算","permalink":"https://sjtu-xx.github.io/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"}],"tags":[]},{"title":"显卡","slug":"显卡","date":"2020-09-05T10:59:54.000Z","updated":"2021-02-19T02:26:07.140Z","comments":true,"path":"2020/09/05/显卡/","link":"","permalink":"https://sjtu-xx.github.io/2020/09/05/%E6%98%BE%E5%8D%A1/","excerpt":"显卡中的多个核心可以同时进行多个计算。但是单个核心的功能单一，部分语句如if等在gpu核心中的计算非常缓慢。","text":"显卡中的多个核心可以同时进行多个计算。但是单个核心的功能单一，部分语句如if等在gpu核心中的计算非常缓慢。 对显卡的编程大致分为两类： 通用的并行计算编程cuda，openCL，openACC 图形编程openGL，directX，vulkan 计算机图形渲染：三角形渲染 shader程序：绘制物体的形状、颜色。OpenGL（GLSL），DirectX（Gg/HLSL），SPIR-V（二进制码）","categories":[{"name":"高性能计算","slug":"高性能计算","permalink":"https://sjtu-xx.github.io/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"}],"tags":[]},{"title":"PCB电路板制作流程","slug":"PCB电路板制作流程","date":"2020-09-02T08:16:11.000Z","updated":"2021-02-19T02:26:06.302Z","comments":true,"path":"2020/09/02/PCB电路板制作流程/","link":"","permalink":"https://sjtu-xx.github.io/2020/09/02/PCB%E7%94%B5%E8%B7%AF%E6%9D%BF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/","excerpt":"印制电路板{PCB线路板}，又称印刷电路板，是电子元器件电气连接的提供者。参考链接：http://mouser.eetrend.com/content/2018/100015548.htmlhttp://www.360doc.com/content/16/0529/15/33072037_563261798.shtmlhttps://wenku.baidu.com/view/e809f110cc7931b765ce1577.html","text":"印制电路板{PCB线路板}，又称印刷电路板，是电子元器件电气连接的提供者。参考链接：http://mouser.eetrend.com/content/2018/100015548.htmlhttp://www.360doc.com/content/16/0529/15/33072037_563261798.shtmlhttps://wenku.baidu.com/view/e809f110cc7931b765ce1577.html PCB电路板的组成1、线路与图面（Pattern）：线路是做为原件之间导通的工具，在设计上会另外设计大铜面作为接地及电源层。线路与图面是同时做出的。 2、介电层（Dielectric）：用来保持线路及各层之间的绝缘性，俗称为基材。 3、孔（Through hole / via）：导通孔可使两层次以上的线路彼此导通，较大的导通孔则做为零件插件用，另外有非导通孔（nPTH）通常用来作为表面贴装定位，组装时固定螺丝用。 4、防焊油墨（Solder resistant /Solder Mask） ：并非全部的铜面都要吃锡上零件，因此非吃锡的区域，会印一层隔绝铜面吃锡的物质（通常为环氧树脂），避免非吃锡的线路间短路。根据不同的工艺，分为绿油、红油、蓝油。 5、丝印（Legend /Marking/Silk screen）：此为非必要之构成，主要的功能是在电路板上标注各零件的名称、位置框，方便组装后维修及辨识用。 6、表面处理（Surface Finish）：由于铜面在一般环境中，很容易氧化，导致无法上锡（焊锡性不良），因此会在要吃锡的铜面上进行保护。保护的方式有喷锡（HASL），化金（ENIG），化银（Immersion Silver），化锡（Immersion TIn），有机保焊剂（OSP），方法各有优缺点，统称为表面处理。 PCB制作工艺1.化学清洗—【Chemical Clean】为得到良好质量的蚀刻图形，就要确保抗蚀层与基板表面牢固的结合，要求基板表面无氧化层、油污、灰尘、指印以及其他的污物。因此在涂布抗蚀层前首先要对板进行表面清洗并使铜箔表面达到一定的粗化层度。内层板材：开始做四层板，内层（第二层和第三层）是必须先做的。内层板材是由玻璃纤维和环氧树脂基复合在上下表面的铜薄板。 2.裁板 压膜—【Cut Sheet Dry Film Lamination】涂光刻胶：为了在内层板材作出我们需要的形状，我们首先在内层板材上贴上干膜（光刻胶，光致抗蚀剂）。干膜是由聚酯簿膜，光致抗蚀膜及聚乙烯保护膜三部分组成的。贴膜时，先从干膜上剥下聚乙烯保护膜，然后在加热加压的条件下将干膜粘贴在铜面上。 3.曝光和显影-【Image Expose】 【Image Develop】曝光：在紫外光的照射下，光引发剂吸收了光能分解成游离基，游离基再引发光聚合单体产生聚合交联反应，反应后形成不溶于稀碱溶液的高分子结构。聚合反应还要持续一段时间，为保证工艺的稳定性，曝光后不要立即撕去聚酯膜，应停留15分钟以上，以时聚合反应继续进行，显影前撕去聚酯膜。显影：感光膜中未曝光部分的活性基团与稀碱溶液反应生产可溶性物质而溶解下来，留下已感光交联固化的图形部分。 4.蚀刻-【Copper Etch】在挠性印制板或印制板的生产过程中，以化学反应方法将不要部分的铜箔予以去除，使之形成所需的回路图形，光刻胶下方的铜是被保留下来不受蚀刻的影响的。 5.去膜，蚀后冲孔，AOI检查，氧化Strip Resist】 【Post Etch Punch】 【AOI Inspection】 【Oxide】去膜的目的是清除蚀刻后板面留存的抗蚀层使下面的铜箔暴露出来。“膜渣”过滤以及废液回收则须妥善处理。如果去膜后的水洗能完全清洗干净，则可以考虑不做酸洗。板面清洗后最后要完全干燥，避免水份残留。 6.叠板-保护膜胶片【Layup with prepreg】进压合机之前,需将各多层板使用原料准备好,以便叠板(Lay-up)作业.除已氧化处理之内层外,尚需保护膜胶片(Prepreg)-环氧树脂浸渍玻璃纤维。叠片的作用是按一定的次序将覆有保护膜的板子叠放以来并置于二层钢板之间。 7.叠板-铜箔 和真空层压【Layup with copper foil】【Vacuum Lamination Press】铜箔-给目前的内层板材再在两侧都覆盖一层铜箔，然后进行多层加压（在固定的时间内需要测量温度和压力的挤压）完成后冷却到室温，剩下的就是一个多层合在一起的板材了。 8.CNC钻孔【CNC Drill】在内层精确的条件下，数控钻孔根据模式钻孔。钻孔精度要求很高，以确保孔是在正确位置。 9.电镀-通孔【Electroless Copper】为了使通孔能在各层之间导通（使孔壁上之非导体部份之树脂及玻纤束进行金属化），在孔中必须填充铜。第一步是在孔中镀薄薄一层铜，这个过程完全是化学反应。最终镀的铜厚为50英寸的百万分之一。 10.裁板 压膜【Cut Sheet】 【Dry Film Lamination】涂光刻胶：我们有一次在外层涂光刻胶。 11.曝光和显影-【Image Expose】 【Image Develop】外层曝光和显影 12.线路电镀：【Copper Pattern Electro Plating】此次也成为二次镀铜，主要目的是加厚线路铜和通孔铜厚。 13.电镀锡【Tin Pattern Electro Plating】 其主要目的是蚀刻阻剂, 保护其所覆盖的铜导体不会在碱性蚀铜时受到攻击（保护所有铜线路和通孔内部）。 14.去膜【Strip Resist】我们已经知道了目的，只需要用化学方法，表面的铜被暴露出来。 15.蚀刻【Copper Etch】我们知道了蚀刻的目的，镀锡部分保护了下面的铜箔。 16.预硬化 曝光 显影 上阻焊【LPI coating side 1】 【Tack Dry】 【LPI coating side 2】【Tack Dry】【Image Expose】【Image Develop】 【Thermal Cure Soldermask】阻焊层,是为了把焊盘露出来用的,也就是通常说的绿油层,实际上就是在绿油层上挖孔,把焊盘等不需要绿油盖住的地方露出来。适当清洗可以得到合适的表面特征。 17.表面处理【Surface finish】 > HASL, Silver, OSP, ENIG 热风整平，沉银，有机保焊剂，化学镍金 > Tab Gold if any 金手指热风整平焊料涂覆ＨＡＬ(俗称喷锡)过程是先把印制板上浸上助焊剂，随后在熔融焊料里浸涂，然后从两片风刀之间通过，用风刀中的热压缩空气把印制板上的多余焊料吹掉，同时排除金属孔内的多余焊料，从而得到一个光亮、平整、均匀的焊料涂层。金手指(Gold Finger,或称 Edge Connector)设计的目的,在于藉由connector连接器的插接作为板对外连络的出口,因此须要金手指制程.之所以选择金是因为它优越的导电度及抗氧化性.但因为金的成本极高所以只应用于金手指,局部镀或化学金 最后总结一下所有的过程：1) Inner Layer 内层 > Chemical Clean 化学清洗 > Cut Sheet Dry Film Lamination 裁板 压膜 > Image Expose 曝光 > Image Develop 显影 > Copper Etch 蚀铜 > Strip Resist 去膜 > Post Etch Punch 蚀后冲孔 > AOI Inspection AOI 检查 > Oxide 氧化 > Layup 叠板 > Vacuum Lamination Press 压合 2) CNC Drilling 钻孔 > CNC Drilling 钻孔 3) Outer Layer 外层 > Deburr 去毛刺 > Etch back - Desmear 除胶渣 > Electroless Copper 电镀-通孔 > Cut Sheet Dry Film Lamination 裁板 压膜 > Image Expose 曝光 > Image Develop 显影 4) Plating 电镀 > Image Develop 显影 > Copper Pattern Electro Plating 二次镀铜 > Tin Pattern Electro Plating 镀锡 > Strip Resist 去膜 > Copper Etch 蚀铜 > Strip Tin 剥锡 5) Solder Mask 阻焊 > Surface prep 前处理 > LPI coating side 1 印刷 > Tack Dry 预硬化 > LPI coating side 2 印刷 > Tack Dry 预硬化 > Image Expose 曝光 > Image Develop 显影 > Thermal Cure Soldermask 印阻焊 6) Surface finish 表面处理 > HASL, Silver, OSP, ENIG 热风整平，沉银，有机保焊剂，化学镍金 > Tab Gold if any 金手指 > Legend 图例 7) Profile 成型 > NC Routing or punch 8) ET Testing, continuity and isolation 9) QC Inspection > Ionics 离子残余量测试 > 100% Visual Inspection 目检 > Audit Sample Mechanical Inspection > Pack &amp; Shipping 包装及出货","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"PCB","slug":"PCB","permalink":"https://sjtu-xx.github.io/tags/PCB/"}]},{"title":"弹性力学","slug":"弹性力学","date":"2020-08-26T03:32:36.000Z","updated":"2021-02-19T02:26:06.930Z","comments":true,"path":"2020/08/26/弹性力学/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/26/%E5%BC%B9%E6%80%A7%E5%8A%9B%E5%AD%A6/","excerpt":"三钱之一钱伟长的书，书中的证明详细，没有丝毫的跳跃，值得一读。","text":"三钱之一钱伟长的书，书中的证明详细，没有丝毫的跳跃，值得一读。 固体的近代物理概念许多脆性材料在除去载荷，重复载荷的过程中，并不是沿着一条直线进行，而是沿着一种回路进行，经过回路需要作工，因此发生弹性滞后现象。滞后现象是材料振动时破坏的主要因素。 泊松比 $$\\frac{\\epsilon_y}{\\epsilon_z}=-\\nu$$ 剪切模量 $$\\frac{\\tau}{\\gamma}=\\mu$$ 笔记","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"弹性力学","slug":"弹性力学","permalink":"https://sjtu-xx.github.io/tags/%E5%BC%B9%E6%80%A7%E5%8A%9B%E5%AD%A6/"},{"name":"有限元","slug":"有限元","permalink":"https://sjtu-xx.github.io/tags/%E6%9C%89%E9%99%90%E5%85%83/"}]},{"title":"COMSOL复合材料模拟","slug":"COMSOL复合材料模拟","date":"2020-08-16T13:57:13.000Z","updated":"2021-02-19T02:26:05.981Z","comments":true,"path":"2020/08/16/COMSOL复合材料模拟/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/16/COMSOL%E5%A4%8D%E5%90%88%E6%9D%90%E6%96%99%E6%A8%A1%E6%8B%9F/","excerpt":"参考链接：https://cn.comsol.com/model/micromechanics-and-stress-analysis-of-a-composite-cylinder-67001","text":"参考链接：https://cn.comsol.com/model/micromechanics-and-stress-analysis-of-a-composite-cylinder-67001 COMSOL复合材料模拟纤维复合材料通常为薄层材料，纤维在层中呈单一取向。 薄层使用两种方法模拟：Layerwise (LW) theory，Equivalent Single Layer (ESL)theory 模型定义对符合材料的分析内容包含以下几个部分： 微机械分析 使用LW理论进行应力分析 使用ESL理论进行应力分析 微机械分析假设复合材料由碳纤维单向排列在环氧树脂基体中。碳纤维占据了60%的体积。 材料属性碳纤维T300假设为横观各向同性（正交）；环氧树脂假设为各向同性 材料性能 值 $E_1,E_2,E_3$ {230,15,15}GPa $G_{12},G_{23},G_{13}$ {15,7,15}GPa $\\upsilon_{12}.\\upsilon_{23},\\upsilon_{13}$ {0.2,0.07,0.2} $rho$ 1800$kg/m^3$ 材料性能 值 E 4GPa $\\upsilon$ 0.35 $\\rho$ 1100$kg/m^3$ cell周期性使用cell periodicity节点应用周期性边界条件。 基于LW理论的应力分析LW理论LW理论考虑了表面以及厚度方向的位移自由度。从本构方程角度看，类似于三维固体。适用于厚板。 几何和边界条件几何 长0.5m,半径0.1m的圆柱 边界条件 圆柱体的一端固定 另一端有滚柱支撑 1kN的力施加在1/4外表面 堆叠顺序和材料属性 材料由5层1mm厚的层组成。不同层纤维取向不同，0，45，90，-45，0 ESL理论进行应力分析ESL理论中考虑了薄层中面的位移和旋转自由度（类似与3D壳单元），因此计算量比LW理论要小得多。适用于薄板、中厚板。 建模过程 选择周期性边界条件后，在周期性边界的右上角可以自动创建研究和材料。","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"COMSOL","slug":"COMSOL","permalink":"https://sjtu-xx.github.io/tags/COMSOL/"},{"name":"复合材料","slug":"复合材料","permalink":"https://sjtu-xx.github.io/tags/%E5%A4%8D%E5%90%88%E6%9D%90%E6%96%99/"}]},{"title":"高分子材料强度及破坏行为","slug":"高分子材料强度及破坏行为","date":"2020-08-14T07:08:24.000Z","updated":"2021-02-19T02:26:07.215Z","comments":true,"path":"2020/08/14/高分子材料强度及破坏行为/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/14/%E9%AB%98%E5%88%86%E5%AD%90%E6%9D%90%E6%96%99%E5%BC%BA%E5%BA%A6%E5%8F%8A%E7%A0%B4%E5%9D%8F%E8%A1%8C%E4%B8%BA/","excerpt":"《高分子材料强度及破坏行为》 傅政 —读书笔记","text":"《高分子材料强度及破坏行为》 傅政 —读书笔记 绪论高分子材料的破坏特征破坏过程是宏观与微观相结合的多层次过程微观损伤($10^{-10}m$) 分子链末端的凝聚体、数根没有缠结分子链间的空穴、缠结的分子链、分子链束沿应力方向取向的部分等。 细观损伤($10^{-6}m$) 由微观损伤发展与汇合成的空隙、微裂纹。 多相材料中的异质界面损伤。 加工成型过程中由于工艺、机械、温度、湿度或各种物理化学作用形成的银纹、瑕疵、微孔、杂质和其他缺陷等。 破坏过程具有松弛特征，对时间（速度）、温度由强烈的依赖性。破坏过程是逐渐发展的、不可逆的耗能过程破坏过程伴随物理化学现象 电子激励现象。高分子材料在力、热、声、光的能量作用下，可以产生电场或磁场。如：在外力作用下，成后复合的高分子主链化学键具有亲电子的能力，在破坏过程中发生电子迁移运动而产生受激电子。 力化学反应。 高分子材料在破坏过程中，由于化学键的断裂而产生的自由基和离子等活性中心，在空气、热、光等环境中将导致裂解或结构化反应。特别是在动态破坏过程中，比如橡胶的疲劳过程等。 银纹化。 在较高的应变下，许多高聚物会由于“空化”而发生变形，形变区域呈现白色，称为应力白化（内部银纹化）。 高分子材料的应力-应变行为高分子材料的力学状态高分子材料的力学状态实际上是分子运动的宏观表现。 非晶态高聚物在不同的温度下呈现出不同的力学状态，玻璃态、橡胶态、黏流态。 玻璃态：只有较小的运动单元（侧基、短支链等）可以运动。 橡胶态：链段运动被激发。拉伸时，分子链从卷曲的线团构象变为伸展构象；外力去除时，分子链通过链段运动恢复到原来的卷曲构象，宏观表现为弹性回缩。（高弹性） 黏流态：整个分子链运动，宏观表现为不可逆的黏性流动。 处于玻璃态、橡胶态、结晶态的高分子材料可以视为弹性固体材料，可以利用固体力学的基本理论进行分析。 屈服和银纹化对塑性材料，其使用极限是屈服强度。 高分子材料在载荷作用下会产生微开裂，但这种微开裂并不是真正的裂纹，其内部由高度取向的高聚物纤维束和空穴组成，并且有一定的稳定性，称为银纹化现象。 屈服和银纹化是材料破坏的前奏。 屈服高分子材料一般使用真应力-表观应变描述其屈服行为。（由于其屈服后变形很大。） 应变硬化：分子链取向引起模量和拉伸强度提高；对结晶高聚物可能是因为应变诱发再结晶。 屈服点的确定 显而易见的屈服点 $\\sigma_{0.2}$ Considere作图法（p25） 高分子材料的强度理论影响高分子材料强度的因素 交联：通过化学反应使分子间的共价键相连接，形成网络结构，从而使材料的强度增加。支化：高分子材料的支链 化学结构 主链结构 取代基 支化和交联 分子量及其分布 结晶和取向 温度和形变速率 填料和增塑剂 应力集中物 环境因素 高分子材料的断裂基础断裂力学研究裂纹扩展的两种方法：应力法和能量法。 裂纹类型：张开型、滑开型、撕开型 线弹性断裂适用于应力-应变遵循胡克定律的断裂行为。如果高分子材料的裂纹尖端塑性区很小，且不改变整体材料的线弹性行为，也可以用线弹性断裂理论。 对一个确定的裂纹，裂纹尖端的应力场与应力场强度因子有关（$K_I=\\sigma\\sqrt{\\pi a}y$） 裂纹开始扩展时的应力场强度因子为断裂韧性$K_{IC}$ 非线性断裂及表征适合延性塑料、橡胶和热塑性弹性体等材料的应力-应变曲线是非线性行为。 J积分应变能积分。 冲击破坏和塑性增韧韧性：材料破坏前吸收外加能量的能力。 纤维增强高聚物的强度与破坏纤维增强高聚物的结构与损伤特征纤维起到骨架作用，相当于混凝土中的钢筋的作用；高聚物是基体，把纤维粘接在一起，同时在纤维间传递和均匀载荷，从而充分发挥增强纤维的强度性能。 短纤维增强材料的应力分布和增强机理影响短纤维增强效果的因素短纤维的长径比、用量、取向状态和表面预处理等 长径比临界长径比是指能够发挥短纤维最大强度所需的最小长径比。一般短纤维长径比60～120，长径比过大，纤维易缠结，影响复合效果。 取向程度 预处理 偶联剂：连接基体和纤维 表面涂层：涂敷在纤维表面，改善纤维与基体界面的物理化学反应。 表面氧化：增加纤维比表面积 表面气相沉积：改善纤维形态 低温等离子处理","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/tags/%E6%9D%90%E6%96%99/"},{"name":"强度","slug":"强度","permalink":"https://sjtu-xx.github.io/tags/%E5%BC%BA%E5%BA%A6/"},{"name":"高分子","slug":"高分子","permalink":"https://sjtu-xx.github.io/tags/%E9%AB%98%E5%88%86%E5%AD%90/"},{"name":"破坏行为","slug":"破坏行为","permalink":"https://sjtu-xx.github.io/tags/%E7%A0%B4%E5%9D%8F%E8%A1%8C%E4%B8%BA/"}]},{"title":"疲劳强度理论","slug":"疲劳强度理论","date":"2020-08-14T06:19:44.000Z","updated":"2021-02-19T02:26:07.166Z","comments":true,"path":"2020/08/14/疲劳强度理论/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/14/%E7%96%B2%E5%8A%B3%E5%BC%BA%E5%BA%A6%E7%90%86%E8%AE%BA/","excerpt":"《疲劳强度理论》尚德广———-读书笔记","text":"《疲劳强度理论》尚德广———-读书笔记 随机载荷的处理方法 循环计数法 把连续载荷-时间历程离散呈一系列峰值和谷值后，再把载荷分成一定级数，然后计算峰值或振程等发生的频次、概率密度函数、概率分布函数等。 功率谱法 利用傅里叶变换将随即在和分解为无限多个具有各种频率的间歇变化之和，得到功率谱密度函数的方法。 基于应力的疲劳分析理论广泛应用于低应力作用下的工程零部件的强度和寿命设计中。 对于低周疲劳，由于所施加的载荷存在明显的塑性部分，在这种情况下使用基于应变的疲劳理论更为合适。 应力-寿命（S-N）曲线 概率-应力-寿命（P-S-N）曲线 疲劳极限线图（将不同R（应力比）下的疲劳极限绘制在一张图上） 以应力幅对平均应力，即$\\sigma_a$和$\\sigma_m$为坐标系得到的疲劳极限线图称为Haigh图。 以最大应力、最小应力、平均应力为坐标系得到的疲劳极限线图称为Smith图。 疲劳极限方程 Gerber抛物线方程、Goodman方程、Soderberg方程 S-N曲线的使用 由于机械零件存在应力集中，尺寸，几何形状，表面状态，残余应力，等的影响，S-N曲线修正后才能进行疲劳强度设计或寿命预测。 尺寸：尺寸越大疲劳极限越低；钢的强度越高，尺寸对疲劳强度影响越大；尺寸对疲劳强度的影响随着应力分布的不均匀的增大而增大。 应力集中 表面状态 载荷 载荷类型：对于疲劳极限：弯曲&gt;拉压&gt;扭转 加载频率：多高的加载频率会使得样品升温 载荷变化 温度 基于应力的疲劳强度设计方法疲劳损伤累计理论当材料或零件承受高于疲劳极限的应力时，每一个循环都会使材料产生一定的损伤，而且损伤能够累积，当累积到临界值时，材料将发生破坏，这就是疲劳损伤累积理论。 分为三类： 线性累积损伤理论。如Miner定理 非线性累积损伤理论。如Macro-Starkey理论和Corten-Dolen理论 其他的各类累计损伤理论。多为经验半经验公式。 安全系数。基于应变的疲劳分析理论材料的应变寿命曲线多轴疲劳多轴循环应力应变关系","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"疲劳","slug":"疲劳","permalink":"https://sjtu-xx.github.io/tags/%E7%96%B2%E5%8A%B3/"},{"name":"强度","slug":"强度","permalink":"https://sjtu-xx.github.io/tags/%E5%BC%BA%E5%BA%A6/"}]},{"title":"COMSOL学习笔记（传热）","slug":"COMSOL学习笔记（传热）","date":"2020-08-06T12:48:07.000Z","updated":"2021-02-19T02:26:06.035Z","comments":true,"path":"2020/08/06/COMSOL学习笔记（传热）/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/06/COMSOL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BC%A0%E7%83%AD%EF%BC%89/","excerpt":"COMSOL传热多物理场","text":"COMSOL传热多物理场 理论能量守恒（广义传热方程）\\rho C_p \\frac{\\partial T}{\\partial t}+\\nabla\\cdot(-k\\nabla T)=Q-\\rho C_p u\\cdot\\nabla T+\\tau :S+\\frac{T}{\\rho}(\\frac{\\partial\\rho}{\\partial T})_p (\\frac{\\partial p_a}{\\partial t}+u\\cdot\\nabla p_a) ctrl + / 变量输入提示","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"COMSOL","slug":"COMSOL","permalink":"https://sjtu-xx.github.io/tags/COMSOL/"},{"name":"传热","slug":"传热","permalink":"https://sjtu-xx.github.io/tags/%E4%BC%A0%E7%83%AD/"}]},{"title":"COMSOL学习笔记（结构力学）","slug":"COMSOL学习笔记（结构力学）","date":"2020-08-06T06:21:06.000Z","updated":"2021-02-19T02:26:06.036Z","comments":true,"path":"2020/08/06/COMSOL学习笔记（结构力学）/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/06/COMSOL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BB%93%E6%9E%84%E5%8A%9B%E5%AD%A6%EF%BC%89/","excerpt":"教程地址：https://www.bilibili.com/video/BV1R7411u7cP?p=55 课件地址：https://github.com/sjtu-xx/COMSOL-","text":"教程地址：https://www.bilibili.com/video/BV1R7411u7cP?p=55 课件地址：https://github.com/sjtu-xx/COMSOL- 模态分析在进行模态分析时，如果直接添加研究-&gt;特征频率，则会忽略载荷的影响。 如果需要考虑载荷的影响，需要进行研究-&gt;特征频率、预应力。（实际上是先计算包含应力的稳态，然后将结果进行特征频率分析，分析时勾选几何非线性。） 特征频率的分析对结果进行了归一化，所以结果中的变形并不是真实的变形。 每一个特征值下的变形幅度经过缩放。 不同特征值之间的变形幅度不能进行比较。 只能看振型，而不能当作真实形变。 屈曲分析主要用于研究结构在特定载荷下的稳定性以及确定结构失稳的临界载荷。 线性屈曲是以小位移小应变的线弹性理论为基础的。分析中不考虑结构在受载变形过程中结构构型的变化，也就是在外力施加的各个阶段，总是在结构初始构型上建立平衡方程。 非线性屈曲几何非线性失稳分析 弹塑性失稳分析 非线性后屈曲分析 一致对： ​ 两个表面位移等连续 接触对： ​ 两个表面位移不一定连续 弹簧基础是相对地面的，对于结构之间的连接不能使用弹簧基础。 对称结构使用对称边界条件，不但要求几何对称，还要求载荷，约束以及解也对称。 使用镜像数据集绘制完成的3D几何下的解。 板壳理论薄板：（Kirchhoff-love假设）• 平行于板中面的各层互不挤压。• 直法线假定:忽略剪应力和所引起的剪切变形，且认为板弯曲时沿板厚方向各点的挠度相等。• 中面内各点都无平行于中面的位移。 中厚板（comsol板接口）• Reissner不再采用直法线假定，而是采用直线假定，板内各点的挠度不等于中面挠度。 厚壳Mindlin-Reissner理论将Reissner理论推广到壳 梁接口Euler-Bernouli梁 变形前垂直梁中心线的界面，变形后仍为平面 变形后横截面与变形后的轴线相垂直 Timoshenko梁 变形前垂直梁中心线的界面，变形后仍为平面。 考虑横向剪切变形影响的情况，原来垂直于中心线的截面变形后不再与中心线垂直。 复合材料模拟https://cn.comsol.com/model/micromechanics-and-stress-analysis-of-a-composite-cylinder-67001 等效单层理论（ESL）将整个层和结构按均匀材料属性计算，并只在中面求解。用于薄层 分层理论（LW）具备沿厚度方向求解并可用于包含层分离区域的较厚层和结构。用于稍厚的层。 非线性几何非线性 大变形需要在研究中开启几何非线性。 有限旋转需要在研究中开启几何非线性。 后屈曲分析。 几何非线性的应变项包含了高阶位移项，因此相比于不适用几何非线性的应变小。看上去像是强化了一样，可以看做是应力强化。 对于无穷小旋转，$sin\\theta$被近似为$\\theta$。对于有限旋转，$sin\\theta$不能被近似。 材料非线性 塑形、超弹性、粘弹性、蠕变 蠕变对于时间依赖的本构，要勾选计算耗散能。 接触问题 源面和目标面（与abaqus中的主面和从面类似）源面选择较硬的面，如果硬度相同，选择凹边界为源。目标边界需要更精细的网格 罚函数法速度快，容易收敛。但计算没有增广拉格朗日法精确。 变量缩放需要在研究-&gt;场变量中调整缩放因子，使得结果大致处于相同的量级，提高收敛性。 收敛性： 时间步进：向后差分格式 求解器采用的步长：精确 因变量：接触压力的缩放因子","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"COMSOL","slug":"COMSOL","permalink":"https://sjtu-xx.github.io/tags/COMSOL/"},{"name":"结构力学","slug":"结构力学","permalink":"https://sjtu-xx.github.io/tags/%E7%BB%93%E6%9E%84%E5%8A%9B%E5%AD%A6/"}]},{"title":"COMSOL学习笔记(多物理场基础)","slug":"COMSOL学习笔记","date":"2020-08-04T01:59:44.000Z","updated":"2021-02-19T02:26:05.984Z","comments":true,"path":"2020/08/04/COMSOL学习笔记/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/04/COMSOL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"网格","text":"网格 映射网格要求相对规则的几何。可以通过边组参数设置对应的边组。 虚拟操作不改变几何的情况下，忽略一些结构 求解器直接求解vs迭代求解直接求解 相当于求逆矩阵 LU分解 直接求解 MUMPS：稳定性高，占用内存大 PARDISO：稳定性一般，占用内存小 SPOOLES：稳定性高，占用内存小，计算慢迭代求解 依靠良好的预处理器 不完全LU 稀疏近似逆 多重格点 高效，计算量小 需要控制终止条件，对多物理场需要手动调整。 全耦合vs分离全耦合 单矩阵 内存消耗大 更多CPU装配时间 更复杂的结构 单线性求解器 牛顿法 分离 多个矩阵 多个单个线性求解器 需要迭代 耦合越强，迭代越多 Anderson加速 初始值猜测是阶段性的。 稳态日志 SolEst：基于误差估计的解 ResEst：基于误差估计的残差 #Res：残差装配数 #Jac：Jacobian装配 #Sol：线性代数系统解的数量 Linlt：线性迭代数 LinErr：线性代数系统误差估计 LinRes：线性代数系统残差 时间步的日志步：n，时间$t_n$,步长：$k_n$,阶数：p Tfail：自适应步长的失败次数 NLfail：代数方程组的失败次数 稳态和瞬态问题 从单物理场开始；如果可能先考虑线性 逐渐引入非线性 使用负载逐步增加，非线性逐步增加，稳态逐步化等。 避免不连续数据 使用平滑近似 当增加多物理场时： 从（物理场）自动生成的求解配置开始 从自动生成的网格开始 逐步增强耦合 参数化扫描在稳态/瞬态选项卡中添加的扫描可以调用上一步结果进行迭代计算。 在研究中添加的结果每次从头计算。 线性求解器：技巧如果直接求解器报错或警告 换一个主元预阈值 换一种预排序方法 换一个直接求解器如果迭代求解器不收敛或报错“未定义值” 查看正在使用的物理场预置求解器。 但别局限于迭代/预调节器设置，问题更可能发生在： 太不稳定 -&gt; 非标准矩阵 网格质量较差 -&gt; 非标准矩阵 强材料非线性 -&gt; 非标准矩阵 非物理非线性迭代 -&gt; 非标准矩阵 非线性求解器技巧 使用更小的阻尼因子 会导致更多的迭代 减小“恢复阻尼因子” 每次迭代更新Jacobian 资源消耗更大 允许更多迭代步 改进初始猜测值（稳态） 时间步研究中的时间步是输出的时间步长。 求解器中的时间步长是计算的时间步长。 瞬态研究：时间步进选择 时间步 描述 自由 基于局部误差估计的自适应时间步长。\\n如果非线性回路不收敛就减小，如果误差估计不满秩就减小 严格 和自由相同，但求解输入时间点。 中级 和自由相同，至少在每个输入时间步上计算。 手动 基于全局表达式或基于值列表进行用户控制 Ctrl+F5查看变量位置 后处理标注标注某个点的变量信息，在绘图组中添加标注，在标注—&gt;文本下输入eval(expr,unit)来计算表达式。 最大值在组件—&gt;定义中添加定义值，然后在研究中，更新解。显示时，在标注文本中eval(maxop1(spf.U),unit)，位置设定为maxop1(spf.U,x)等 数据集操作 降维截取数据集 升维生成数据集 合并：对两个结果进行和差商积等操作 派生值 可设置计算组 点计算、全局计算 平均值、最大、最小、积分、其他 派生值中的最大值等只能用于后处理 组件-》定义中的最大值可用于模型参数设定。 快捷键 F1：当前节点的帮助文档。 Ctrl+F1：整体帮助文档。","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"COMSOL","slug":"COMSOL","permalink":"https://sjtu-xx.github.io/tags/COMSOL/"},{"name":"多物理场","slug":"多物理场","permalink":"https://sjtu-xx.github.io/tags/%E5%A4%9A%E7%89%A9%E7%90%86%E5%9C%BA/"}]},{"title":"RAII机制","slug":"RAII机制","date":"2020-08-02T05:28:25.000Z","updated":"2021-02-19T02:26:06.332Z","comments":true,"path":"2020/08/02/RAII机制/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/02/RAII%E6%9C%BA%E5%88%B6/","excerpt":"RAII","text":"RAII RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。 为什么要使用RAII？上面说到RAII是用来管理资源、避免资源泄漏的方法。那么，用了这么久了，也写了这么多程序了，口头上经常会说资源，那么资源是如何定义的？在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤：1 申请资源；2 使用资源；3 释放资源。第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"C++并发与多线程笔记5","slug":"C-并发与多线程笔记5","date":"2020-08-02T04:22:26.000Z","updated":"2021-02-19T02:26:05.974Z","comments":true,"path":"2020/08/02/C-并发与多线程笔记5/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/02/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B05/","excerpt":"第十二节 windows临界区、其他各种mutex互斥量","text":"第十二节 windows临界区、其他各种mutex互斥量 一和二、windows临界区Windows临界区，同一个线程是可以重复进入的，但是进入的次数与离开的次数必须相等。C++互斥量则不允许同一个线程重复加锁。 windows临界区是在windows编程中的内容，了解一下即可，效果几乎可以等同于c++11的mutex包含#include windows中的临界区同mutex一样，可以保护一个代码段。但windows的临界区可以进入多次，离开多次，但是进入的次数与离开的次数必须相等，不会引起程序报异常出错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;Windows.h&gt;#define __WINDOWSJQ_using namespace std;class A&#123;public: // 把收到的消息传入队列 void inMsgRecvQueue() &#123; for (size_t i = 0; i &lt; 1000; ++i) &#123; cout &lt;&lt; \"收到消息，并放入队列 \" &lt;&lt; i &lt;&lt; endl;#ifdef __WINDOWSJQ_ EnterCriticalSection(&amp;my_winsec); // 进入临界区 //EnterCriticalSection(&amp;my_winsec); // 可以再次进入临界区,程序不会出错 msgRecvQueue.push_back(i); LeaveCriticalSection(&amp;my_winsec); // 离开临界区 //LeaveCriticalSection(&amp;my_winsec); // 如果进入两次，必须离开两次不会报错#elif my_mutex.lock(); msgRecvQueue.push_back(i); my_mutex.unlock();#endif // __WINDOWSJQ_ &#125; cout &lt;&lt; \"消息入队结束\" &lt;&lt; endl; &#125; // 从队列中取出消息 void outMsgRecvQueue() &#123; for (size_t i = 0; i &lt; 1000; ++i) &#123;#ifdef __WINDOWSJQ_ EnterCriticalSection(&amp;my_winsec); // 进入临界区 if (!msgRecvQueue.empty()) &#123; // 队列不为空 int num = msgRecvQueue.front(); cout &lt;&lt; \"从消息队列中取出 \" &lt;&lt; num &lt;&lt; endl; msgRecvQueue.pop_front(); &#125; else &#123; // 消息队列为空 cout &lt;&lt; \"消息队列为空 \" &lt;&lt; endl; &#125; LeaveCriticalSection(&amp;my_winsec); // 离开临界区#elif my_mutex.lock(); if (!msgRecvQueue.empty()) &#123; // 队列不为空 int num = msgRecvQueue.front(); cout &lt;&lt; \"从消息队列中取出 \" &lt;&lt; num &lt;&lt; endl; msgRecvQueue.pop_front(); my_mutex.unlock(); &#125; else &#123; // 消息队列为空 cout &lt;&lt; \"消息队列为空 \" &lt;&lt; endl; my_mutex.unlock(); &#125;#endif // __WINDOWSJQ_ &#125; cout &lt;&lt; \"消息出队结束\" &lt;&lt; endl; &#125; A() &#123;#ifdef __WINDOWSJQ_ InitializeCriticalSection(&amp;my_winsec); // 用临界区之前要初始化#endif // __WINDOWSJQ_ &#125;private: list&lt;int&gt; msgRecvQueue; mutex my_mutex;#ifdef __WINDOWSJQ_ CRITICAL_SECTION my_winsec; // windows中的临界区，非常类似C++11中的mutex#endif // __WINDOWSJQ_&#125;;int main()&#123; A myobj; thread myInMsgObj(&amp;A::inMsgRecvQueue, &amp;myobj); thread myOutMsgObj(&amp;A::outMsgRecvQueue, &amp;myobj); myInMsgObj.join(); myOutMsgObj.join(); getchar(); return 0;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 三、自动析构技术C++：lock_guard防止忘了释放信号量，自动释放windows：可以写个类自动释放临界区： 123456789101112131415class CWinLock &#123;public: CWinLock(CRITICAL_SECTION *pCritmp) &#123; my_winsec =pCritmp; EnterCriticalSection(my_winsec); &#125; ~CWinLock() &#123; LeaveCriticalSection(my_winsec) &#125;;private: CRITICAL_SECTION *my_winsec;&#125;;1234567891011121314 上述这种类RAII类（Resource Acquisition is initialization），即资源获取及初始化。容器，智能指针属于这种类。 四、递归独占互斥量 std::recursive_mutexstd::mutex 独占式互斥量 std::recursive_mutex：允许在同一个线程中同一个互斥量多次被 lock() ，（但是递归加锁的次数是有限制的，太多可能会报异常），效率要比mutex低。 如果你真的用了 recursive_mutex 要考虑代码是否有优化空间，如果能调用一次 lock()就不要调用多次。 五、带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex 5.1 std::timed_mutex：是待超时的独占互斥量 try_lock_for()： 等待一段时间，如果拿到了锁，或者超时了未拿到锁，就继续执行（有选择执行）如下： 123456789std::chrono::milliseconds timeout(100);if (my_mymutex.try_lock_for(timeout))&#123; //......拿到锁返回ture&#125;else&#123; std::chrono::milliseconds sleeptime(100); std::this_thread::sleep_for(sleeptime);&#125;12345678 try_lock_until()： 参数是一个未来的时间点，在这个未来的时间没到的时间内，如果拿到了锁头，流程就走下来，如果时间到了没拿到锁，流程也可以走下来。 12345678910std::chrono::milliseconds timeout(100);if (my_mymutex.try_lock_until(chrono::steady_clock::now() + timeout))&#123; //......拿到锁返回ture&#125;else&#123; std::chrono::milliseconds sleeptime(100); std::this_thread::sleep_for(sleeptime);&#125;12345678 两者的区别就是一个参数是时间段，一个参数是时间点 5.2 std::recursive_timed_mutex：是待超时的递归独占互斥量 第十三章 补充知识、线程池浅谈、数量谈、总结 一、补充一些知识点1.1 虚假唤醒：notify_one或者notify_all唤醒wait()后，实际有些线程可能不满足唤醒的条件，就会造成虚假唤醒，可以在wait中再次进行判断解决虚假唤醒。解决：wait中要有第二个参数（lambda），并且这个lambda中要正确判断所处理的公共数据是否存在。 2.2 atomic： 1234std::atomic&lt;int&gt; atm = 0; cout &lt;&lt; atm &lt;&lt; endl;123 这里只有读取atm是原子操作，但是整个这一行代码 cout &lt;&lt; atm &lt;&lt; endl; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。 1234std::atomic&lt;int&gt; atm = 0; auto atm2 = atm; //不可以123 这种拷贝初始化不可以，会报错。 12atomic&lt;int&gt; atm2(atm.load());1 load()：以原子方式读atomic对象的值。 12atm2.store(12);1 原子操作实质上是：不允许在进行原子对象操作时进行CPU的上下文切换。 二、浅谈线程池：场景设想：服务器程序， 每来一个客户端，就创建一个新线程为这个客户提供服务。 问题： 1、2万个玩家，不可能给每个玩家创建一个新线程，此程序写法在这种场景下不通。 2、程序稳定性问题：编写代码中，“时不时地突然”创建一个线程，这种写法，一般情况下不会出错，但是不稳定的； 线程池：把一堆线程弄到一起，统一管理。这种统一管理调度，循环利用的方式，就叫做线程池。 实现方式：程序启动时，一次性创建好一定数量的线程。这种方式让人更放心，觉得程序代码更稳定。 三、线程创建数量谈： 1、线程创建的数量极限的问题 一般来讲，2000个线程基本就是极限；再创建就会崩溃。 2、线程创建数量建议 a、采用某些计数开发程序提供的建议，遵照建议和指示来确保程序高效执行。 b、创建多线程完成业务；考虑可能被阻塞的线程数量，创建多余最大被阻塞线程数量的线程，如100个线程被阻塞再充值业务，开110个线程就是很合适的 c、线程创建数量尽量不要超过500个，尽量控制在200个之内；","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"C++并发与多线程笔记4","slug":"C-并发与多线程笔记4","date":"2020-08-02T04:18:15.000Z","updated":"2021-02-19T02:26:05.961Z","comments":true,"path":"2020/08/02/C-并发与多线程笔记4/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/02/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B04/","excerpt":"第九节、async、future、packaged_task、promise","text":"第九节、async、future、packaged_task、promise 本节内容需要包含头文件#include 一、std::async、std::future创建后台任务并返回值std::async是一个函数模板，用来启动一个异步任务，启动起来一个异步任务之后，它返回一个std::future对象，这个对象是个类模板。 什么叫“启动一个异步任务”？就是自动创建一个线程，并开始 执行对应的线程入口函数，它返回一个std::future对象，这个std::future对象中就含有线程入口函数所返回的结果，我们可以通过调用future对象的成员函数get()来获取结果。 std::future提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，但是在不久的将来，这个线程执行完毕的时候，你就能够拿到结果了，所以，大家这么理解：future中保存着一个值，这个值是在将来的某个时刻能够拿到。 std::future对象的get()成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像join()但是，它是可以获取结果的。 std::future对象的wait()成员函数，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;future&gt;using namespace std;class A &#123;public: int mythread(int mypar) &#123; cout &lt;&lt; mypar &lt;&lt; endl; return mypar; &#125;&#125;; int mythread() &#123; cout &lt;&lt; \"mythread() start\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout &lt;&lt; \"mythread() end\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return 5;&#125; int main() &#123; A a; int tmp = 12; cout &lt;&lt; \"main\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::future&lt;int&gt; result1 = std::async(mythread); cout &lt;&lt; \"continue........\" &lt;&lt; endl; cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果 //类成员函数 std::future&lt;int&gt; result2 = std::async(&amp;A::mythread, &amp;a, tmp); //第二个参数是对象引用才能保证线程里执行的是同一个对象 cout &lt;&lt; result2.get() &lt;&lt; endl; //或者result2.wait(); cout &lt;&lt; \"good luck\" &lt;&lt; endl; return 0;&#125;123456789101112131415161718192021222324252627282930313233343536 我们通过向std::async()传递一个参数，该参数是std::launch类型（枚举类型），来达到一些特殊的目的： 1、std::launch::deferred：（defer推迟，延期）表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行；如果wait()或者get()没有被调用，则不会执行。实际上根本就没有创建新线程。std::lunch::deferred意思时延迟调用，并没有创建新线程，是在主线程中调用的线程入口函数。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;future&gt;using namespace std; int mythread() &#123; cout &lt;&lt; \"mythread() start\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout &lt;&lt; \"mythread() end\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return 5;&#125; int main() &#123; cout &lt;&lt; \"main\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::future&lt;int&gt; result1 = std::async(std::launch::deferred ,mythread); cout &lt;&lt; \"continue........\" &lt;&lt; endl; cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果 cout &lt;&lt; \"good luck\" &lt;&lt; endl; return 0;&#125;123456789101112131415161718192021 永远都会先打印出continue…，然后才会打印出mythread() start和mythread() end等信息。 2、std::launch::async，在调用async函数的时候就开始创建新线程。 123456789int main() &#123; cout &lt;&lt; \"main\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::future&lt;int&gt; result1 = std::async(std::launch::async ,mythread); cout &lt;&lt; \"continue........\" &lt;&lt; endl; cout &lt;&lt; result1.get() &lt;&lt; endl; cout &lt;&lt; \"good luck\" &lt;&lt; endl; return 0;&#125;12345678 二、std::packaged_task：打包任务，把任务包装起来。类模板，它的模板参数是各种可调用对象，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用。 12345678910111213141516171819202122232425262728#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;future&gt;using namespace std; int mythread(int mypar) &#123; cout &lt;&lt; mypar &lt;&lt; endl; cout &lt;&lt; \"mythread() start\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout &lt;&lt; \"mythread() end\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return 5;&#125; int main() &#123; cout &lt;&lt; \"main\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; //我们把函数mythread通过packaged_task包装起来 //参数是一个int，返回值类型是int std::packaged_task&lt;int(int)&gt; mypt(mythread); std::thread t1(std::ref(mypt), 1); t1.join(); std::future&lt;int&gt; result = mypt.get_future(); //std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。 cout &lt;&lt; result.get() &lt;&lt; endl; return 0;&#125;123456789101112131415161718192021222324252627 可调用对象可由函数换成lambda表达式 12345678910111213141516171819202122int main() &#123; cout &lt;&lt; \"main\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::packaged_task&lt;int(int)&gt; mypt([](int mypar) &#123; cout &lt;&lt; mypar &lt;&lt; endl; cout &lt;&lt; \"mythread() start\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout &lt;&lt; \"mythread() end\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return 5; &#125;); std::thread t1(std::ref(mypt), 1); t1.join(); std::future&lt;int&gt; result = mypt.get_future(); //std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。 cout &lt;&lt; result.get() &lt;&lt; endl; cout &lt;&lt; \"good luck\" &lt;&lt; endl; return 0;&#125;123456789101112131415161718192021 packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象lambda的直接调用 12345678910111213141516int main() &#123; cout &lt;&lt; \"main\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::packaged_task&lt;int(int)&gt; mypt([](int mypar) &#123; cout &lt;&lt; mypar &lt;&lt; endl; cout &lt;&lt; \"mythread() start\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout &lt;&lt; \"mythread() end\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return 5; &#125;); mypt(1); std::future&lt;int&gt; result = mypt.get_future(); cout &lt;&lt; result.get() &lt;&lt; endl;&#125;123456789101112131415 std::promise，类模板我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来 1234567891011121314151617181920212223242526#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;future&gt;using namespace std; void mythread(std::promise&lt;int&gt; &amp;tmp, int clac) &#123; cout &lt;&lt; \"mythread() start\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout &lt;&lt; \"mythread() end\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; int result = clac; tmp.set_value(result); //结果保存到了tmp这个对象中 return;&#125; vector&lt;std::packaged_task&lt;int(int)&gt;&gt; task_vec; int main() &#123; std::promise&lt;int&gt; myprom; std::thread t1(mythread, std::ref(myprom), 180); t1.join(); std::future&lt;int&gt; fu1 = myprom.get_future(); //promise和future绑定，用于获取线程返回值 auto result = fu1.get(); cout &lt;&lt; \"result = \" &lt;&lt; result &lt;&lt; endl;&#125;12345678910111213141516171819202122232425 总结：通过promise保存一个值，在将来某个时刻我们通过吧一个future绑定到这个promise上，来得到绑定的值 注意：使用thread时，必须 join() 或者 detach() 否则程序会报异常 小结： 我们学习这些东西的目的并不是，要把他们都用到实际开发中。 相反，如果我们能够用最少的东西写出一个稳定的，高效的多线程程序，更值得赞赏。 我们为了成长必须阅读一些高手写的代码，从而实现自己代码的积累； 第十节 future其他成员函数、shared_future、atomic 一、std::future 的成员函数1、std::future_status status = result.wait_for(std::chrono::seconds(几秒));卡住当前流程，等待std::async()的异步任务运行一段时间，然后返回其状态std::future_status。如果std::async()的参数是std::launch::deferred（延迟执行），则不会卡住主流程。std::future_status是枚举类型，表示异步任务的执行状态。类型的取值有std::future_status::timeoutstd::future_status::readystd::future_status::deferred 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;future&gt;using namespace std; int mythread() &#123; cout &lt;&lt; \"mythread() start\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout &lt;&lt; \"mythread() end\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return 5;&#125;int main() &#123; cout &lt;&lt; \"main\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::future&lt;int&gt; result = std::async(mythread); cout &lt;&lt; \"continue........\" &lt;&lt; endl; //cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果 //等待1秒 std::future_status status = result.wait_for(std::chrono::seconds(1)); if (status == std::future_status::timeout) &#123; //超时：表示线程还没有执行完 cout &lt;&lt; \"超时了，线程还没有执行完\" &lt;&lt; endl; &#125; //类成员函数 return 0;&#125;1234567891011121314151617181920212223242526 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;future&gt;using namespace std; int mythread() &#123; cout &lt;&lt; \"mythread() start\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; //std::chrono::milliseconds dura(5000); //std::this_thread::sleep_for(dura); cout &lt;&lt; \"mythread() end\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return 5;&#125; int main() &#123; cout &lt;&lt; \"main\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::future&lt;int&gt; result = std::async(std::launch::deferred, mythread); //std::future&lt;int&gt; result = std::async(mythread); cout &lt;&lt; \"continue........\" &lt;&lt; endl; //cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果 std::future_status status = result.wait_for(std::chrono::seconds(6)); if (status == std::future_status::timeout) &#123; //超时：表示线程还没有执行完 cout &lt;&lt; \"超时了，线程还没有执行完\" &lt;&lt; endl; &#125; else if (status == std::future_status::ready) &#123; //表示线程成功放回 cout &lt;&lt; \"线程执行成功，返回\" &lt;&lt; endl; cout &lt;&lt; result.get() &lt;&lt; endl; &#125; else if (status == std::future_status::deferred) &#123; //如果设置 std::future&lt;int&gt; result = std::async(std::launch::deferred, mythread);，则本条件成立 cout &lt;&lt; \"线程延迟执行\" &lt;&lt; endl; cout &lt;&lt; result.get() &lt;&lt; endl; &#125; cout &lt;&lt; \"good luck\" &lt;&lt; endl; return 0;&#125;12345678910111213141516171819202122232425262728293031323334353637 get()只能使用一次，比如如果 123auto a = result.get();cout &lt;&lt; result.get() &lt;&lt; endl;12 就会报告异常因为get()函数的设计是一个移动语义，相当于将result中的值移动到了a中，再次get就报告了异常。 二、std::shared_future：也是个类模板std::future的 get() 成员函数是转移数据 std::shared_future 的 get()成员函数是复制数据 123456789101112131415161718192021222324252627282930313233#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;future&gt;using namespace std; int mythread() &#123; cout &lt;&lt; \"mythread() start\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); cout &lt;&lt; \"mythread() end\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return 5;&#125;int main() &#123; cout &lt;&lt; \"main\" &lt;&lt; \"threadid = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::packaged_task&lt;int()&gt; mypt(mythread); std::thread t1(std::ref(mypt)); std::future&lt;int&gt; result = mypt.get_future(); bool ifcanget = result.valid(); //判断future 中的值是不是一个有效值 std::shared_future&lt;int&gt; result_s(result.share()); //执行完毕后result_s里有值，而result里空了 //std::shared_future&lt;int&gt; result_s(std::move(result)); //通过get_future返回值直接构造一个shared_future对象 //std::shared_future&lt;int&gt; result_s(mypt.get_future()); t1.join(); auto myresult1 = result_s.get(); auto myresult2 = result_s.get(); cout &lt;&lt; \"good luck\" &lt;&lt; endl; return 0;&#125;1234567891011121314151617181920212223242526272829303132 三、std::atomic原子操作 3.1 原子操作概念引出范例：互斥量：多线程编程中 用于保护共享数据：先锁住， 操作共享数据， 解锁。 有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。 即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条C语句会被拆成3、4条汇编语句来执行，所以仍然有可能混乱） 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;int g_count = 0; void mythread1() &#123; for (int i = 0; i &lt; 1000000; i++) &#123; g_count++; &#125;&#125; int main() &#123; std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout &lt;&lt; \"正常情况下结果应该是200 0000次，实际是\" &lt;&lt; g_count &lt;&lt; endl;&#125;123456789101112131415161718 使用mutex解决这个问题 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;int g_count = 0;std::mutex mymutex;void mythread1() &#123; for (int i = 0; i &lt; 1000000; i++) &#123; std::unique_lock&lt;std::mutex&gt; u1(mymutex); g_count++; &#125;&#125; int main() &#123; std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout &lt;&lt; \"正常情况下结果应该是200 0000次，实际是\" &lt;&lt; g_count &lt;&lt; endl;&#125;12345678910111213141516171819202122 3.2 基本的std::atomic用法范例大家可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。 原子操作：在多线程中不会被打断的程序执行片段。 从效率上来说，原子操作要比互斥量的方式效率要高。 互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。 原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。 std::atomic来代表原子操作，是个类模板。其实std::atomic是用来封装某个类型的值的 需要添加#include 头文件 范例： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;using namespace std;std::atomic&lt;int&gt; g_count = 0; //封装了一个类型为int的 对象（值）void mythread1() &#123; for (int i = 0; i &lt; 1000000; i++) &#123; g_count++; &#125;&#125; int main() &#123; std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout &lt;&lt; \"正常情况下结果应该是200 0000次，实际是\" &lt;&lt; g_count &lt;&lt; endl;&#125;12345678910111213141516171819 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;using namespace std;std::atomic&lt;bool&gt; g_ifEnd = false; //封装了一个类型为bool的 对象（值） void mythread() &#123; std::chrono::milliseconds dura(1000); while (g_ifEnd == false) &#123; cout &lt;&lt; \"thread id = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; \"运行中\" &lt;&lt; endl; std::this_thread::sleep_for(dura); &#125; cout &lt;&lt; \"thread id = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; \"运行结束\" &lt;&lt; endl;&#125; int main() &#123; std::thread t1(mythread); std::thread t2(mythread); std::chrono::milliseconds dura(5000); std::this_thread::sleep_for(dura); g_ifEnd = true; cout &lt;&lt; \"程序执行完毕\" &lt;&lt; endl; t1.join(); t2.join();&#125;12345678910111213141516171819202122232425 总结：1、原子操作一般用于计数或者统计（如累计发送多少个数据包，累计接收到了多少个数据包），多个线程一起统计，这种情况如果不使用原子操作会导致统计发生混乱。 2、写商业代码时，如果不确定结果的影响，最好自己先写一小段代码调试。或者不要使用。 第十一节 std::atomic续谈、std::async深入谈 一、std::atomic续谈 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;using namespace std;std::atomic&lt;int&gt; g_count = 0; //封装了一个类型为int的 对象（值） void mythread1() &#123; for (int i = 0; i &lt; 1000000; i++) &#123; //虽然g_count使用了原子操作模板，但是这种写法既读又写， //会导致计数错误 g_count = g_count + 1; &#125;&#125;int main() &#123; std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout &lt;&lt; \"正常情况下结果应该是200 0000次，实际是\" &lt;&lt; g_count &lt;&lt; endl;&#125;123456789101112131415161718192021 一般atomic原子操作，针对++，–，+=，-=，&amp;=，|=，^=是支持的，其他操作不一定支持。 二、std::async深入理解2.1 std::async参数详述，async 用来创建一个异步任务 延迟调用参数 std::launch::deferred【延迟调用】，std::launch::async【强制创建一个线程】 std::async()我们一般不叫创建线程（他能够创建线程），我们一般叫它创建一个异步任务。 std::async和std::thread最明显的不同，就是 async 有时候并不创建新线程。 ①如果用std::launch::deferred 来调用async？ 延迟到调用 get() 或者 wait() 时执行，如果不调用就不会执行 ②如果用std::launch::async来调用async？ 强制这个异步任务在新线程上执行，这意味着，系统必须要创建出新线程来运行入口函数。 ③如果同时用 std::launch::async | std::launch::deferred 这里这个或者关系意味着async的行为可能是 std::launch::async 创建新线程立即执行， 也可能是 std::launch::deferred 没有创建新线程并且延迟到调用get()执行，由系统根据实际情况来决定采取哪种方案 ④不带额外参数 std::async(mythread)，只给async 一个入口函数名，此时的系统给的默认值是 std::launch::async | std::launch::deferred 和 ③ 一样，有系统自行决定异步还是同步运行。 2.2 std::async和std::thread()区别： std::thread()如果系统资源紧张可能出现创建线程失败的情况，如果创建线程失败那么程序就可能崩溃，而且不容易拿到函数返回值（不是拿不到）std::async()创建异步任务。可能创建线程也可能不创建线程，并且容易拿到线程入口函数的返回值； 由于系统资源限制：①如果用std::thread创建的线程太多，则可能创建失败，系统报告异常，崩溃。 ②如果用std::async，一般就不会报异常，因为如果系统资源紧张，无法创建新线程的时候，async不加额外参数的调用方式就不会创建新线程。而是在后续调用get()请求结果时执行在这个调用get()的线程上。 如果你强制async一定要创建新线程就要使用 std::launch::async 标记。承受的代价是，系统资源紧张时可能崩溃。 ③根据经验，一个程序中线程数量 不宜超过100~200 。 2.3 async不确定性问题的解决不加额外参数的async调用时让系统自行决定，是否创建新线程。 std::future result = std::async(mythread);问题焦点在于这个写法，任务到底有没有被推迟执行。 通过wait_for返回状态来判断： 123456789101112131415std::future_status status = result.wait_for(std::chrono::seconds(6));//std::future_status status = result.wait_for(6s); if (status == std::future_status::timeout) &#123; //超时：表示线程还没有执行完 cout &lt;&lt; \"超时了，线程还没有执行完\" &lt;&lt; endl; &#125; else if (status == std::future_status::ready) &#123; //表示线程成功放回 cout &lt;&lt; \"线程执行成功，返回\" &lt;&lt; endl; cout &lt;&lt; result.get() &lt;&lt; endl; &#125; else if (status == std::future_status::deferred) &#123; cout &lt;&lt; \"线程延迟执行\" &lt;&lt; endl; cout &lt;&lt; result.get() &lt;&lt; endl; &#125;","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"C++并发与多线程笔记3","slug":"C-并发与多线程笔记3","date":"2020-08-01T10:00:12.000Z","updated":"2021-02-19T02:26:05.950Z","comments":true,"path":"2020/08/01/C-并发与多线程笔记3/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/01/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B03/","excerpt":"第四节 创建多个线程、数据共享问题分析、案例代码","text":"第四节 创建多个线程、数据共享问题分析、案例代码 一、创建和等待多个线程 12345678910111213141516void TextThread()&#123; cout &lt;&lt; \"我是线程\" &lt;&lt; this_thread::get_id() &lt;&lt; endl; /* … */ cout &lt;&lt; \"线程\" &lt;&lt; this_thread::get_id() &lt;&lt; \"执行结束\" &lt;&lt; endl; &#125; //main函数里 vector threadagg; for (int i = 0; i &lt; 10; ++i) &#123; threadagg.push_back(thread(TextThread)); &#125; for (int i = 0; i &lt; 10; ++i) &#123; threadagg[i].join(); &#125;123456789101112131415 把thread对象放入到容器中管理，看起来像个thread对象数组，对一次创建大量的线程并对大量线程进行管理有好处 多个线程执行顺序是乱的，跟操作系统内部对线程的运行调度机制有关 二：数据共享问题分析2.1 只读的数据 是安全稳定的 2.2 有读有写 若不加处理，就会出错 最简单的防止崩溃方法：读的时候不能写，写的时候不能读。 如果写的动作分10小步，由于任务切换，导致各种诡异的事情发生（最可能的还是崩溃） 第五节 互斥量概念、用法、死锁演示及解决详解 一、互斥量（mutex）的基本概念 互斥量就是个类对象，可以理解为一把锁，多个线程尝试用lock()成员函数来加锁，只有一个线程能锁定成功，如果没有锁成功，那么流程将卡在lock()这里不断尝试去锁定。 互斥量使用要小心，保护数据不多也不少，少了达不到效果，多了影响效率。 二、互斥量的用法包含#include&lt;mutex&gt;头文件2.1 lock()，unlock() 步骤：1.lock()，2.操作共享数据，3.unlock()。 lock()和unlock()要成对使用 2.2 lock_guard类模板 std::lock_guard&lt;std::mutex&gt; sbguard(myMutex);取代lock()和unlock() lock_guard构造函数执行了mutex::lock();在作用域结束时，调用析构函数，执行mutex::unlock() 三、死锁3.1 死锁演示死锁至少有两个互斥量mutex1，mutex2。 a.线程A执行时，这个线程先锁mutex1，并且锁成功了，然后去锁mutex2的时候，出现了上下文切换。 b.线程B执行，这个线程先锁mutex2，因为mutex2没有被锁，即mutex2可以被锁成功，然后线程B要去锁mutex1. c.此时，死锁产生了，A锁着mutex1，需要锁mutex2，B锁着mutex2，需要锁mutex1，两个线程没办法继续运行下去。。。 3.2 死锁的一般解决方案：只要保证多个互斥量上锁的顺序一样就不会造成死锁。 3.3 std::lock()函数模板 std::lock(mutex1,mutex2……); 一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量。 如果互斥量中一个没锁住，它就等着，等所有互斥量都锁住，才能继续执行。如果有一个没锁住，就会把已经锁住的释放掉（要么互斥量都锁住，要么都没锁住，防止死锁） 3.4 std::lock_guard的std::adopt_lock参数 std::lock_guardstd::mutex my_guard(my_mutex,std::adopt_lock);加入adopt_lock后，在调用lock_guard的构造函数时，不再进行lock(); adopt_guard为结构体对象，起一个标记作用，表示这个互斥量已经lock()，不需要在lock()。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;public: void inMsgRecvQueue() &#123; for (int i = 0; i &lt; 100000; ++i) &#123; cout &lt;&lt; \"插插插插插插插插插插插插插插插插插插插插入一个元素\" &lt;&lt; i &lt;&lt; endl; &#123; //lock_guard&lt;mutex&gt; sbguard(myMutex1, adopt_lock); lock(myMutex1, myMutex2); //myMutex2.lock(); //myMutex1.lock(); msgRecvQueue.push_back(i); myMutex1.unlock(); myMutex2.unlock(); &#125; &#125; &#125; bool outMsgLULProc() &#123; myMutex1.lock(); myMutex2.lock(); if (!msgRecvQueue.empty()) &#123; cout &lt;&lt; \"删删删删删删删删删删删删删删删删删删删删删删删除元素\" &lt;&lt; msgRecvQueue.front() &lt;&lt; endl; msgRecvQueue.pop_front(); myMutex2.unlock(); myMutex1.unlock(); return true; &#125; myMutex2.unlock(); myMutex1.unlock(); return false; &#125; void outMsgRecvQueue() &#123; for (int i = 0; i &lt; 100000; ++i) &#123; if (outMsgLULProc()) &#123; &#125; else &#123; cout &lt;&lt; \"空空空空空空空空空空空空空空空空空空空空空空空空空空数组为空\" &lt;&lt; endl; &#125; &#125; &#125;private: list&lt;int&gt; msgRecvQueue; mutex myMutex1; mutex myMutex2;&#125;;int main()&#123; A myobja; mutex myMutex; thread myOutMsgObj(&amp;A::outMsgRecvQueue, &amp;myobja); thread myInMsgObj(&amp;A::inMsgRecvQueue, &amp;myobja); myOutMsgObj.join(); myInMsgObj.join(); return 0;&#125; 第六节 unique_lock（类模板）详解 1.unique_lock取代lock_guardunique_lock比lock_guard灵活很多（多出来很多用法），效率差一点。unique_lock&lt;mutex&gt; myUniLock(myMutex); std::chrono::milliseconds sec(20000); std::this_thread::sleep_for(sec); 2.unique_lock的第二个参数2.1 std::adopt_lock： 表示这个互斥量已经被lock()，即不需要在构造函数中lock这个互斥量了。 前提：必须提前lock lock_guard中也可以用这个参数 2.2 std::try_to_lock： 尝试用mutx的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里； 使用try_to_lock的原因是防止其他的线程锁定mutex太长时间，导致本线程一直阻塞在lock这个地方 前提：不能提前lock(); owns_locks()方法判断是否拿到锁，如拿到返回true 2.3 std::defer_lock： 如果没有第二个参数就对mutex进行加锁，加上defer_lock是始化了一个没有加锁的mutex 不给它加锁的目的是以后可以调用unique_lock的一些方法 前提：不能提前lock 3.unique_lock的成员函数（前三个与std::defer_lock联合使用）3.1 lock()：加锁。 123unique_lock&lt;mutex&gt; myUniLock(myMutex， defer_lock);myUniLock.lock();12 不用自己unlock(); 3.2 unlock()：解锁。 12345678unique_lock&lt;mutex&gt; myUniLock(myMutex， defer_lock);myUniLock.lock();//处理一些共享代码myUniLock.unlock();//处理一些非共享代码myUniLock.lock();//处理一些共享代码1234567 因为一些非共享代码要处理，可以暂时先unlock()，用其他线程把它们处理了，处理完后再lock()。 3.3 try_lock()：尝试给互斥量加锁如果拿不到锁，返回false，否则返回true。 3.4 release()： unique_lockmyUniLock(myMutex);相当于把myMutex和myUniLock绑定在了一起，release()就是解除绑定，返回它所管理的mutex对象的指针，并释放所有权 mutex* ptx = myUniLock.release();所有权由ptx接管，如果原来mutex对象处理加锁状态，就需要ptx在以后进行解锁了。 lock的代码段越少，执行越快，整个程序的运行效率越高。a.锁住的代码少，叫做粒度细，执行效率高；b.锁住的代码多，叫做粒度粗，执行效率低； 4.unique_lock所有权的传递unique_lock myUniLock(myMutex);把myMutex和myUniLock绑定在了一起，也就是myUniLock拥有myMutex的所有权。类似unique_ptr1. 使用move转移 myUniLock拥有myMutex的所有权，myUniLock可以把自己对myMutex的所有权转移，但是不能复制。 unique_lock myUniLock2(std::move(myUniLock));现在myUniLock2拥有myMutex的所有权。 2. 在函数中return一个临时变量，即可以实现转移 1234567unique_lock&lt;mutex&gt; aFunction()&#123; unique_lock&lt;mutex&gt; myUniLock(myMutex); //移动构造函数那里讲从函数返回一个局部的unique_lock对象是可以的 //返回这种局部对象会导致系统生成临时的unique_lock对象，并调用unique_lock的移动构造函数 return myUniLock;&#125; 第七节 单例设计模式共享数据分析、解决，call_once 1.设计模式 程序灵活，维护起来可能方便，用设计模式理念写出来的代码很晦涩，但是别人接管、阅读代码都会很痛苦 老外应付特别大的项目时，把项目的开发经验、模块划分经验，总结整理成设计模式 中国零几年设计模式刚开始火时，总喜欢拿一个设计模式往上套，导致一个小小的项目总要加几个设计模式，本末倒置 设计模式有其独特的优点，要活学活用，不要深陷其中，生搬硬套 2.单例设计模式：整个项目中，有某个或者某些特殊的类，只能创建一个属于该类的对象。单例类：只能生成一个对象。 3.单例设计模式共享数据分析、解决面临问题：需要在自己创建的线程中来创建单例类的对象，这种线程可能不止一个。我们可能面临GetInstance()这种成员函数需要互斥。可以在加锁前判断m_instance是否为空，否则每次调用Singelton::getInstance()都要加锁，十分影响效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt; #include &lt;mutex&gt;using namespace std;mutex myMutex;//懒汉模式class Singelton&#123;public: static Singelton * getInstance() &#123; //双重锁定 提高效率 if (instance == NULL) &#123; lock_guard&lt;mutex&gt; myLockGua(myMutex); if (instance == NULL) &#123; instance = new Singelton; &#125; &#125; return instance; &#125;private: Singelton() &#123;&#125; static Singelton *instance;&#125;;Singelton * Singelton::instance = NULL;//饿汉模式class Singelton2 &#123;public: static Singelton2* getInstance() &#123; return instance; &#125;private: Singelton2() &#123;&#125; static Singelton2 * instance;&#125;;Singelton2 * Singelton2::instance = new Singelton2;int main(void)&#123; Singelton * singer = Singelton::getInstance(); Singelton * singer2 = Singelton::getInstance(); if (singer == singer2) cout &lt;&lt; \"二者是同一个实例\" &lt;&lt; endl; else cout &lt;&lt; \"二者不是同一个实例\" &lt;&lt; endl; cout &lt;&lt; \"---------- 以下 是 饿汉式 ------------\" &lt;&lt; endl; Singelton2 * singer3 = Singelton2::getInstance(); Singelton2 * singer4 = Singelton2::getInstance(); if (singer3 == singer4) cout &lt;&lt; \"二者是同一个实例\" &lt;&lt; endl; else cout &lt;&lt; \"二者不是同一个实例\" &lt;&lt; endl; return 0;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 如果觉得在单例模式new了一个对象，而没有自己delete掉，这样不合理。可以增加一个类中类CGarhuishou，new一个单例类时创建一个静态的CGarhuishou对象，这样在程序结束时会调用CGarhuishou的析构函数，释放掉new出来的单例对象。 1234567891011121314151617181920212223242526class Singelton&#123;public: static Singelton * getInstance() &#123; if (instance == NULL) &#123; static CGarhuishou huishou; instance = new Singelton; &#125; return instance; &#125; class CGarhuishou &#123; public: ~CGarhuishou() &#123; if (Singelton::instance) &#123; delete Singelton::instance; Singelton::instance = NULL; &#125; &#125; &#125;;private: Singelton() &#123;&#125; static Singelton *instance;&#125;;Singelton * Singelton::instance = NULL; 4.std::call_once()：函数模板，该函数的第一个参数为标记，第二个参数是一个函数名（如a()）。功能：能够保证函数a()只被调用一次。具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。call_once()需要与一个标记结合使用，这个标记为std::once_flag；其实once_flag是一个结构，call_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态。 多个线程同时执行时，一个线程会等待另一个线程先执行。 123456789101112131415161718once_flag g_flag;class Singelton&#123;public: static void CreateInstance()//call_once保证其只被调用一次 &#123; instance = new Singelton; &#125; //两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕 static Singelton *getInstance() &#123; call_once(g_flag, CreateInstance); return instance; &#125;private: Singelton() &#123;&#125; static Singelton *instance;&#125;;Singelton * Singelton::instance = NULL; 第八节 condition_variable、wait、notify_one、notify_all 一、条件变量condition_variable、wait、notify_one、notify_allstd::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。 12345678910std::mutex mymutex1;std::unique_lock&lt;std::mutex&gt; sbguard1(mymutex1);std::condition_variable condition;condition.wait(sbguard1, [this] &#123;if (!msgRecvQueue.empty()) return true; return false; &#125;); condition.wait(sbguard1);123456789 wait()用来等一个东西 如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。 阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止； 如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样 wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。 当其他线程用notify_one()将本线程wait()唤醒后，这个wait恢复后 1、wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁 2.1、如果wait有第二个参数就判断这个lambda表达式。 a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒 b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。 2.2、如果wait没有第二个参数，则wait返回，流程走下去。 流程只要走到了wait()下面则互斥量一定被锁住了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std; class A &#123;public: void inMsgRecvQueue() &#123; for (int i = 0; i &lt; 100000; ++i) &#123; cout &lt;&lt; \"inMsgRecvQueue插入一个元素\" &lt;&lt; i &lt;&lt; endl; std::unique_lock&lt;std::mutex&gt; sbguard1(mymutex1); msgRecvQueue.push_back(i); //尝试把wait()线程唤醒,执行完这行， //那么outMsgRecvQueue()里的wait就会被唤醒 //只有当另外一个线程正在执行wait()时notify_one()才会起效，否则没有作用 condition.notify_one(); &#125; &#125; void outMsgRecvQueue() &#123; int command = 0; while (true) &#123; std::unique_lock&lt;std::mutex&gt; sbguard2(mymutex1); // wait()用来等一个东西 // 如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行 // 阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止； //当 wait() 被 notify_one() 激活时，会先执行它的 条件判断表达式 是否为 true， //如果为true才会继续往下执行 condition.wait(sbguard2, [this] &#123; if (!msgRecvQueue.empty()) return true; return false;&#125;); command = msgRecvQueue.front(); msgRecvQueue.pop_front(); //因为unique_lock的灵活性，我们可以随时unlock，以免锁住太长时间 sbguard2.unlock(); cout &lt;&lt; \"outMsgRecvQueue()执行，取出第一个元素\" &lt;&lt; endl; &#125; &#125; private: std::list&lt;int&gt; msgRecvQueue; std::mutex mymutex1; std::condition_variable condition;&#125;; int main() &#123; A myobja; std::thread myoutobj(&amp;A::outMsgRecvQueue, &amp;myobja); std::thread myinobj(&amp;A::inMsgRecvQueue, &amp;myobja); myinobj.join(); myoutobj.join();&#125; 二、深入思考 上面的代码可能导致出现一种情况：因为outMsgRecvQueue()与inMsgRecvQueue()并不是一对一执行的，所以当程序循环执行很多次以后，可能在msgRecvQueue 中已经有了很多消息，但是，outMsgRecvQueue还是被唤醒一次只处理一条数据。这时可以考虑把outMsgRecvQueue多执行几次，或者对inMsgRecvQueue进行限流。 三、notify_all() notify_one()：通知一个线程的wait() notify_all()：通知所有线程的wait()","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"C++并发与多线程笔记2","slug":"C-并发与多线程笔记2","date":"2020-08-01T09:06:32.000Z","updated":"2021-02-19T02:26:05.945Z","comments":true,"path":"2020/08/01/C-并发与多线程笔记2/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/01/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B02/","excerpt":"第二节 线程启动、结束，创建线程多法、join，detach","text":"第二节 线程启动、结束，创建线程多法、join，detach 一、范例演示线程运行的开始 程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕 主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行 整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】 创建一个线程： 包含头文件thread 写初始函数 在main中创建thread 必须要明白：有两个线程在跑，相当于整个程序中有两条线在同时走，即使一条被阻塞，另一条也能运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void myPrint()&#123; cout &lt;&lt; \"我的线程开始运行\" &lt;&lt; endl; //------------- //------------- cout &lt;&lt; \"我的线程运行完毕\" &lt;&lt; endl; return;&#125;int main()&#123; //(1)创建了线程，线程执行起点（入口）是myPrint；(2)执行线程 thread myThread(myPrint); //(2)阻塞主线程并等待myPrint执行完，当myPrint执行完毕，join()就执行完毕，主线程继续往下执行 myThread.join(); //设置断点可看到主线程等待子线程的过程 //F11逐语句，就是每次执行一行语句，如果碰到函数调用，它就会进入到函数里面 //F10逐过程，碰到函数时，不进入函数，把函数调用当成一条语句执行 //(3)传统多线程程序中，主线程要等待子线程执行完毕，然后自己才能向下执行 //detach:分离，主线程不再与子线程汇合，不再等待子线程 //detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管 //myThread.detach(); //(4)joinable()判断是否可以成功使用join()或者detach() //如果返回true，证明可以调用join()或者detach() //如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了 if (myThread.joinable()) &#123; cout &lt;&lt; \"可以调用可以调用join()或者detach()\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"不能调用可以调用join()或者detach()\" &lt;&lt; endl; &#125; cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; return 0;&#125; 重要补充：线程类参数是一个可调用对象。一组可执行的语句称为可调用对象，c++中的可调用对象可以是函数、函数指针、lambda表达式、bind创建的对象或者重载了函数调用运算符的类对象。 二、其他创建线程的方法①创建一个类，并编写圆括号重载函数，初始化一个该类的对象，把该对象作为线程入口地址 1234567891011121314151617181920212223class Ta&#123;public: void operator()() &#123; cout &lt;&lt; \"我的线程开始运行\" &lt;&lt; endl; //------------- //------------- cout &lt;&lt; \"我的线程运行完毕\" &lt;&lt; endl; &#125;&#125;;//main函数里的： Ta ta; thread myThread(ta); //对象被复制到线程中去。主线程结束子线程也不会出现问题。 //GCC的实现是拷贝了两次. //看了6.3.0源码,thread里拷贝了两次. //第一次构造bind,这里msvc和gcc都是需要一次拷贝, //区别是msvc直接make_unique tuple去invoke, //gcc是先构造一个bind,再把bind移动到unique_ptr里. //如果创建了移动构造函数，则只调用一次拷贝 myThread.join();12345678910111213141516 ②lambda表达式创建线程 1234567891011//main函数中auto lambdaThread = [] &#123; cout &lt;&lt; \"我的线程开始执行了\" &lt;&lt; endl; //------------- //------------- cout &lt;&lt; \"我的线程开始执行了\" &lt;&lt; endl; &#125;; thread myThread(lambdaThread); myThread.join();12345678910 ③把某个类中的某个函数作为线程的入口地址 123456789101112131415class Data_&#123;public: void GetMsg()&#123;&#125; void SaveMsh()&#123;&#125;&#125;;//main函数里 Data_ s; //第一个&amp;意思是取址，第二个&amp;意思是引用，相当于std::ref(s) //thread oneobj(&amp;Data_::SaveMsh,s)传值也是可以的 //在其他的构造函数中&amp;obj是不会代表引用的，会被当成取地址 thread oneobj(&amp;Data_::SaveMsh,&amp;s); thread twoobj(&amp;Data_::GetMsg,&amp;s); oneobj.join(); twoobj.join(); 第三节 线程传参详解，detach()大坑，成员函数做线程函数 一、传递临时对象作为线程参数1.1要避免的陷阱1： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void myPrint(const int &amp;i, char* pmybuf)&#123; //如果线程从主线程detach了 //i不是mvar真正的引用，实际上值传递，即使主线程运行完毕了，子线程用i仍然是安全的，但仍不推荐传递引用 //推荐改为const int i cout &lt;&lt; i &lt;&lt; endl; //pmybuf还是指向原来的字符串，所以这么写是不安全的 cout &lt;&lt; pmybuf &lt;&lt; endl;&#125;int main()&#123; int mvar = 1; int&amp; mvary = mvar; char mybuf[] = \"this is a test\"; thread myThread(myPrint, mvar, mybuf);//第一个参数是函数名，后两个参数是函数的参数 myThread.join(); //myThread.detach(); cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;&#125;12345678910111213141516171819202122232425 1.2要避免的陷阱2： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;using namespace std;void myPrint(const int i, const string&amp; pmybuf)&#123; cout &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; pmybuf &lt;&lt; endl;&#125;int main()&#123; int mvar = 1; int&amp; mvary = mvar; char mybuf[] = \"this is a test\"; //如果detach了，这样仍然是不安全的 //因为存在主线程运行完了，mybuf被回收了，系统采用mybuf隐式类型转换成string //推荐先创建一个临时对象thread myThread(myPrint, mvar, string(mybuf));就绝对安全了。。。。 thread myThread(myPrint, mvar, mybuf); myThread.join(); //myThread.detach(); cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;&#125;12345678910111213141516171819202122232425 1.3总结 如果传递int这种简单类型，推荐使用值传递，不要用引用和指针 如果传递类对象，避免使用隐式类型转换，全部都是创建线程这一行就创建出临时对象，然后在函数参数里，用引用来接，否则还会创建出一个对象 终极结论：建议不使用detach 二、临时对象作为线程参数继续讲2.1线程id概念 id是个数字，每个线程（不管是主线程还是子线程）实际上都对应着一个数字，而且每个线程对应的这个数字都不一样 线程id可以用C++标准库里的函数来获取。std::this_thread::get_id()来获取 三、传递类对象、智能指针作为线程参数3.1 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;class A &#123;public: mutable int m_i; //m_i即使实在const中也可以被修改 A(int i) :m_i(i) &#123;&#125; //类型转换构造函数&#125;;void myPrint(const A&amp; pmybuf)&#123; pmybuf.m_i = 199; cout &lt;&lt; \"子线程myPrint的参数地址是\" &lt;&lt; &amp;pmybuf &lt;&lt; \"thread = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;&#125;int main()&#123; A myObj(10); //myPrint(const A&amp; pmybuf)中引用不能去掉，如果去掉会多创建一个对象 //const也不能去掉，去掉会出错(因为thread要求传入一个右值) //即使是传递的const引用，但在子线程中还是会调用拷贝构造函数构造一个新的对象， //所以在子线程中修改m_i的值不会影响到主线程 //如果希望子线程中修改m_i的值影响到主线程，可以用thread myThread(myPrint, std::ref(myObj)); //这样const就是真的引用了，myPrint定义中的const就可以去掉了，类A定义中的mutable也可以去掉了 thread myThread(myPrint, myObj); myThread.join(); //myThread.detach(); cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;&#125;12345678910111213141516171819202122232425262728293031 3.2 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;memory&gt;using namespace std;void myPrint(unique_ptr&lt;int&gt; ptn)&#123; cout &lt;&lt; \"thread = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;&#125;int main()&#123; unique_ptr&lt;int&gt; up(new int(10)); //独占式指针只能通过std::move()才可以传递给另一个指针 //传递后up就指向空，新的ptn指向原来的内存 //所以这时就不能用detach了，因为如果主线程先执行完，ptn指向的对象就被释放了 thread myThread(myPrint, std::move(up)); myThread.join(); //myThread.detach(); return 0;&#125;12345678910111213141516171819202122","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"C++并发与多线程笔记1","slug":"C-并发与多线程笔记1","date":"2020-08-01T07:36:22.000Z","updated":"2021-02-19T02:26:05.940Z","comments":true,"path":"2020/08/01/C-并发与多线程笔记1/","link":"","permalink":"https://sjtu-xx.github.io/2020/08/01/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/","excerpt":"一、并发、进程、线程的基本概念和综述并发，线程，进程要求必须掌握","text":"一、并发、进程、线程的基本概念和综述并发，线程，进程要求必须掌握 1.1 并发 两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务； 以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，存在时间开销； 随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发） 使用并发的原因：主要就是同时可以干多个事，提高性能 1.2 可执行程序 磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行） 1.3 进程 运行一个可执行程序，在windows下，可双击；在linux下，./文件名 进行，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。 1.4 线程 ① a)每个进程（执行起来的可执行程序），都有唯一的一个主线程 b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了 ctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码 线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路 ② 除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至区不同的地方 每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径） ③ 多线程（并发） 线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间 必须使用多线程的案例 二、并发的实现方法实现并发的手段：a）通过多个进程实现并发b）在单独的进程中，写代码创建除了主线程之外的其他线程来实现并发 2.1 多进程并发 比如账号服务器一个进程，游戏服务器一个进程。 服务器进程之间存在通信（同一个电脑上：管道，文件，消息队列，共享内存）；（不同电脑上：socket通信技术） 2.2 多线程并发 线程：感觉像是轻量级的进程。每个进程有自己独立的运行路径，但一个进程中的所有线程共享地址空间（共享内存），全局变量、全局内存、全局引用都可以在线程之间传递，所以多线程开销远远小于多进程 多进程并发核多线程并发可以混合使用，但建议优先考虑多线程技术 本课程中只讲多线程并发技术 三、C++11新标准线程库以往 windows：CreateThread(), _beginthread(),_beginthreadexe()创建线程；linux：pthread_create()创建线程；不能跨平台 临界区，互斥量 POSIX thread(pthread):跨平台，但要做一番配置，也不方便 C++11 从C++11新标准，C++语言本身增加对多线程的支持，意味着可移植性（跨平台），这大大减少开发人员的工作量","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"COMSOL疲劳","slug":"COMSOL疲劳","date":"2020-07-31T08:07:19.000Z","updated":"2021-02-19T02:26:06.037Z","comments":true,"path":"2020/07/31/COMSOL疲劳/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/31/COMSOL%E7%96%B2%E5%8A%B3/","excerpt":"COMSOL仿真","text":"COMSOL仿真 COMSOL Multiphysics结构疲劳与损伤仿真视频地址：https://cn.comsol.com/video/simulation-of-structural-fatigue-and-damage-webinar-cn 基础 S-N曲线 环境、表面粗糙度、残余应力等都会影响材料的疲劳寿命 $R=\\frac{\\sigma{min}}{\\sigma{max}}$ R=-1: 对称循环 R=0：脉冲测试 分类 高周疲劳：弹性变形、应力范围控制 低周疲劳（几千次）：塑性变形、应变范围控制 裂纹 疲劳裂纹通常出现在表面 接触分析时通常出现在内部。 仿真方法单个载荷周期的结果—-》疲劳后处理 疲劳模型应力寿命 应变寿命 常用于低周疲劳","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"COMSOL","slug":"COMSOL","permalink":"https://sjtu-xx.github.io/tags/COMSOL/"},{"name":"疲劳","slug":"疲劳","permalink":"https://sjtu-xx.github.io/tags/%E7%96%B2%E5%8A%B3/"}]},{"title":"材料科学基础拾遗","slug":"材料科学基础拾遗","date":"2020-07-31T08:05:37.000Z","updated":"2021-02-19T02:26:07.158Z","comments":true,"path":"2020/07/31/材料科学基础拾遗/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/31/%E6%9D%90%E6%96%99%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%8B%BE%E9%81%97/","excerpt":"材料科学基础拾遗","text":"材料科学基础拾遗 弹性模量是材料刚度的度量。弹性模量越大，刚度越大。 合金的成分越远离共晶点，结晶温度范围越宽，其流动性越差。因此在满足使用性能的前提下，铸造合金应尽量选用共晶合金或接近共品成分的合金。 固溶体合金流动性差，不如共晶和纯金属，且结晶温度范围越大，树枝晶易粗大，偏析严重。 压力加工性能好的合金通常是单相固溶体，因为固溶体强度低、塑性好、变形均匀。 光的干涉分为：双光波干涉, 多光波干涉, 偏振光的干涉 GPC:凝胶色谱法。测量分子量。 SEC：依据分子尺寸大小差异，利用多孔凝胶分离。 微波通常是指频率介于300MHz到300Ghz，波长介于1m到1mm之间的电磁波。 FTIR：官能团测定。无法测定分子量。 衡量微波介质陶瓷主要有三个性能指标：介电常数，谐振频率温度系数，品质因子。 XRD可以用来测定分子量。 XRF指的是X射线荧光光谱仪，可以快速同时对多元素进行测定的仪器。在X射线激发下，被测元素原子的内层电子发生能级跃迁而发出次级X射线（X-荧光）。从不同的角度来观察描述X射线，可将XRF分为能量散射型X射线荧光光谱仪，缩写为EDXRF或EDX和波长散射型X射线荧光光谱仪，可缩写为WDXRF或WDX，但市面上用的较多的为EDX。WDX用晶体分光而后由探测器接收经过衍射的特征X射线信号。 ICP是电感耦合等离子谱仪。能测元素周期表中的绝大部分元素 EDS是能量色散X射线谱仪，简称能谱仪，常用作扫描电镜或透射电镜的微区成分分析。 晶体都是长程有序，非晶体是短程有序。对于晶体说的长程有序指的是元素的有序性。此时，长程有序指的是某个原子周围的原子确定，短程有序指的是原子周围的原子某个比例范围或者指偏聚。 物理拾遗 放大镜的放大倍数 \\frac{1}{p}+\\frac{1}{q}=\\frac1f实像距离为+，虚像距离为－。 对显微镜，物体位于物镜略大于一倍焦距处，在镜筒成倒立放大的实像。该像位于目镜一倍焦距内，呈正立放大的虚像。 对物镜，p固定，pqf为正，则f越大，q越大。 对目镜，p固定，pf为正，q为负，则f越小，q越大。 还有一种说法：显微镜为视角放大率：$M=-\\frac{SD}{F_oF_e}$ 。 S为明视距离，D为物方焦点到像方焦点的距离，即筒长。Fo和Fe分别为物镜和目镜的焦距。 单缝衍射 I=I_0\\frac{sin^2u}{u^2}其中，$u=\\frac{\\pi asin\\theta}{\\lambda}$，a为缝宽，$\\theta$为与光轴的角度。 $\\theta$为0时，中央亮条纹。$k\\pi$暗条纹，即$k\\lambda=a\\theta$ 双缝干涉","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/tags/%E6%9D%90%E6%96%99/"}]},{"title":"python文件混淆","slug":"python文件混淆","date":"2020-07-25T13:32:56.000Z","updated":"2021-02-19T02:26:06.603Z","comments":true,"path":"2020/07/25/python文件混淆/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/25/python%E6%96%87%E4%BB%B6%E6%B7%B7%E6%B7%86/","excerpt":"选择了一种比较合适的加密方式对python文件进行加密。","text":"选择了一种比较合适的加密方式对python文件进行加密。 混淆网址：https://pyob.oxyry.com/ 该方法通过将变量名替换，实现加密效果。 该方法的缺点在于，只能对单个文件进行加密。无法对多个文件进行加密 pyc在混淆后对文件进行编译生成pyc文件，这样反解码出来的文件也是乱码。 单个pyc文件生成python -m foo.py import py_compile py_compile.compile(&#39;/path/to/foo.py&#39;) 批量生成python -m compileall &lt;dir&gt; 12import compileallcompileall.compile_dir(r'/path') 打包还可以考虑将混淆文件打包成exe文件发布。","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"应用","slug":"Python/应用","permalink":"https://sjtu-xx.github.io/categories/Python/%E5%BA%94%E7%94%A8/"}],"tags":[]},{"title":"C++零碎知识点","slug":"C-零碎知识点","date":"2020-07-24T14:34:50.000Z","updated":"2021-02-19T02:26:05.979Z","comments":true,"path":"2020/07/24/C-零碎知识点/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/24/C-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"#define和const的区别","text":"#define和const的区别 define没有数据类型，const可以定义数据类型。 编译器可以对const进行类型检查，不能对define进行类型检查。 malloc/free和new/delete的区别malloc和free是标准库函数，new和delete是c++的运算符。 都可用于动态申请和释放内存。 C++不是类型安全的reinterpret cast可以强制转换 判断操作系统位数sizeof查看指针长度 几种const123const char *p; // 指向const char的指针char const *p; // 同上char *const p; // 指向char的常指针 explicit显式：函数参数不能进行隐式类型转换 数组数组实参传递给函数时，传递的是地址。函数也无法通过sizeof(p)/sizeof(p[0])计算机制。但是可以通过下标访问函数元素。 C++中的全局变量不是由main函数引起的。将“引用”作为函数参数有哪些特点？传递引用给函数和传递指针的效果是一样的 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作(当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好) 与指针作为函数的参数，需要分配存储单元，且容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参，而引用更容易使用、更清晰 “引用”与多态的关系？引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例 例:Class A; Class B : Class A{…}; B b; A&amp; ref = b; 只能用intialization list而不能用assignment对于const和reference类型成员变量，它们只能够被初始化而不能做赋值操作，因此只能用初始化列表。 还有一种情况就是，类的构造函数需要调用其基类的构造函数的时候。 空类大小空类大小等于1，是因为编译器为了区分不同的类，在类中加的一个char型。 如何打印出当前源文件的文件名以及源文件的当前行号？答案：cout &lt;&lt; FILE ;cout&lt;&lt;LINE ;FILE和LINE是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。 main主函数执行完毕后，是否可能会再执行一段代码，给出说明？答案：可以，可以用_onexit注册一个函数，它会在main之后执行int fn1(void), fn2(void), fn3(void), fn4 (void); 1234567891011121314151617181920212223242526272829void main( void )&#123; String str(\"zhanglin\"); _onexit( fn1 ); _onexit( fn2 ); _onexit( fn3 ); _onexit( fn4 ); printf( \"This is executed first.n\" );&#125;int fn1()&#123; printf( \"next.n\" ); return 0;&#125;int fn2()&#123; printf( \"executed \" ); return 0;&#125;int fn3()&#123; printf( \"is \" ); return 0;&#125;int fn4()&#123; printf( \"This \" ); return 0;&#125; 如何判断一段程序是由C 编译程序还是由C++编译程序编译的？12345#ifdef __cpluspluscout&lt;&lt;\"c++\";#elsecout&lt;&lt;\"c\";#endif 文件中有一组整数，要求排序后输出到另一个文件中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;using namespace std;void Order(vector&lt;int&gt; &amp;data) &#123; // 冒泡排序 int count = data.size(); int tag = false; for (int i = 0; i &lt; count; i++) &#123; for (int j = 0; j &lt; count - i - 1; j++) &#123; if (data[j] &gt; data[j + 1]) &#123; tag = true; int temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; &#125; &#125; if (!tag) &#123; break; &#125; &#125;&#125;int main() &#123; vector&lt;int&gt; data; ifstream in(\"data.txt\"); if (!in) &#123; std::cout &lt;&lt; \"file error\"; exit(1); &#125; int temp; while (!in.eof()) &#123; in &gt;&gt; temp; data.push_back(temp); &#125; in.close(); Order(data); ofstream out(\"result.txt\"); if (!out) &#123; cout &lt;&lt; \"file error!\"; exit(1); &#125; for (const auto item:data) out &lt;&lt; item &lt;&lt; \" \"; out.close();&#125; 节点的定义方式123456789101112131415161718//方法1struct node &#123; int data; struct node *next;&#125;;typedef struct node Node;//方法2typedef struct node &#123; int data; struct node *next;&#125; Node;// 使用//建立一个Node对象struct node* a; //1Node* b; //2 链表操作 逆序 123456789101112131415161718192021222324////41typedef struct node &#123; int data; struct node *next;&#125; Node;Node *ReverseList(Node *head) &#123; if (head == nullptr || head-&gt;next == nullptr) &#123; return head; &#125; Node *p1 = head; Node *p2 = head-&gt;next; Node *p3 = p2-&gt;next; p1-&gt;next = nullptr; while (p3 != nullptr) &#123; p2-&gt;next = p1; p1 = p2; p2 = p3; p3 = p3-&gt;next; &#125; p2-&gt;next = p1; head = p2; return head;&#125; 合并链表 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct node &#123; int data; struct node *next;&#125; Node;Node *Merge(Node *head1, Node *head2) &#123; if (head1 == nullptr) &#123; return head2; &#125; if (head2 == nullptr) &#123; return head1; &#125; Node *head = nullptr; Node *p1 = nullptr; Node *p2 = nullptr; if (head1-&gt;data &lt; head2-&gt;data) &#123; head = head1; p1 = head1-&gt;next; p2 = head2; &#125; else &#123; head = head2; p1 = head1; p2 = head2-&gt;next; &#125; Node *pcurhead = head; while (p1-&gt;next != nullptr &amp;&amp; p2-&gt;next != nullptr) &#123; if (p1-&gt;next &lt; p2-&gt;next) &#123; pcurhead-&gt;next = p1-&gt;next; p1 = p1-&gt;next; &#125; else &#123; pcurhead-&gt;next = p2-&gt;next; p2 = p2-&gt;next; &#125; &#125; if (p1-&gt;next == nullptr) &#123; pcurhead-&gt;next = p2; &#125; if (p2-&gt;next == nullptr) &#123; pcurhead-&gt;next = p1; &#125; return head;&#125; 合并链表（递归） 1234567891011121314151617Node *Merge(Node *head1, Node *head2) &#123; if (head1 == nullptr) &#123; return head2; &#125; if (head2 == nullptr) &#123; return head1; &#125; Node *head; if (head1-&gt;data &lt; head2-&gt;data) &#123; head = head1; head-&gt;next = Merge(head1-&gt;next, head2); &#125; else &#123; head = head2; head-&gt;next = Merge(head1, head2-&gt;next); &#125; return head;&#125; 链表中是否有环 1234567891011121314151617181920typedef struct node &#123; int data; struct node *next;&#125; Node;bool check_loop(Node *head) &#123; if (head == nullptr || head-&gt;next == nullptr) &#123; return false; &#125; Node *slow_ptr = head; Node *fast_ptr = head-&gt;next; while (fast_ptr != nullptr &amp;&amp; fast_ptr-&gt;next != nullptr) &#123; slow_ptr = slow_ptr-&gt;next; fast_ptr = fast_ptr-&gt;next-&gt;next; if (fast_ptr==slow_ptr)&#123; return true; &#125; &#125; return false;&#125;; strcpy的实现 12345678#include &lt;cassert&gt;char *strcpy(char *strDest, const char *strSrc) &#123; assert((strDest != nullptr) &amp;&amp; (strSrc != nullptr)); char *address = strDest; while ((*strDest++ = *strSrc++) != '\\0' ); return address;&#125; strlen的实现123456789#include &lt;cassert&gt;int strlen(const char *dst) &#123; assert(dst != nullptr); int count = 0; while (*dst++ != '\\0') &#123; count++; &#125; return count;&#125; malloc和free的使用free只是告诉操作系统，指针P所指向的这块内存我不实用了！由操作系统负责收回。而指针P他的空间中存储的还是原来的空间的地址。当然在free之后再解引用指针就回发生段错误，所以每次free之后，最好p=NULL; 123456char *p = NULL;p = (char *) malloc(sizeof(char));memset(p, 'g', sizeof(char));printf(\"%c\\n\", *p); // gfree(p);p = NULL; include 与 ＃include “file.h”的区别？答：前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。 堆栈溢出一般是由什么原因导致的？ 没有回收垃圾资源 层次太深的递归调用 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。#define MIN(A,B) ((A) &lt;= (B) ？ (A) : (B)) 不能做switch()的参数类型是？C/C++中：支持byte,char,short,int,long,bool,整数bai类型和du枚举类型。不支持float，double，string 什么函数不能声明为虚函数：一个类中将所有的成员函数都尽可能地设置为虚函数总是有益的。设置虚函数须注意：1：只有类的成员函数才能说明为虚函数；2：静态成员函数不能是虚函数；3：内联函数不能为虚函数；4：构造函数不能是虚函数；5：析构函数可以是虚函数，而且通常声明为虚函数。 写inline virtual void f(),不能保证函数f()一定是内联的，只能保证f()是虚函数（从而保证此函数一定不是内联函数） static 全局变量、局部变量、函数与普通全局变量、局部变量、函数有什么区别？static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。 从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。 static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。 volatile的含义一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"overload、override和hide的区别","slug":"overload、override和hide的区别","date":"2020-07-24T12:44:53.000Z","updated":"2021-02-19T02:26:06.550Z","comments":true,"path":"2020/07/24/overload、override和hide的区别/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/24/overload%E3%80%81override%E5%92%8Chide%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"重载(overload)、覆盖(override)、隐藏(hide)的区别","text":"重载(overload)、覆盖(override)、隐藏(hide)的区别 这三个概念都是与OO中的多态有关系的。如果单是区别重载与覆盖这两个概念是比较容易的，但是隐藏这一概念却使问题变得有点复杂了，下面说说它们的区别吧。 重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。 覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样。 隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。什么叫多态？简单地说就是一个接口，多种实现吧。 还是引用一下别人的代码来说明问题吧（引用自林锐的《高质量C/C++编程指南》）。 仔细看下面的代码： 12345678910111213141516171819202122232425262728 1 #include &lt;iostream.h&gt; 2 3 class Base 4 5 &#123; 6 7 public: 8 9 virtual void f(float x)&#123; cout &lt;&lt; \"Base::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; 10 11 void g(float x)&#123; cout &lt;&lt; \"Base::g(float) \" &lt;&lt; x &lt;&lt; endl; &#125; 12 13 void h(float x)&#123; cout &lt;&lt; \"Base::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125; 14 15 &#125;; 1 class Derived : public Base 2 3 &#123; 4 5 public: 6 7 virtual void f(float x)&#123; cout &lt;&lt; \"Derived::f(float) \" &lt;&lt; x &lt;&lt; endl; &#125; 8 9 void g(int x)&#123; cout &lt;&lt; \"Derived::g(int) \" &lt;&lt; x &lt;&lt; endl; &#125; 10 11 void h(float x)&#123; cout &lt;&lt; \"Derived::h(float) \" &lt;&lt; x &lt;&lt; endl; &#125; 12 13 &#125;; 看出什么了吗？下面说明一下： （1）函数Derived::f(float)覆盖了Base::f(float)。 （2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。 （3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。 嗯，概念大概明白了，但是在实际的编程中，我们会因此遇到什么问题呢？再看下面的代码： 12345678910111213141516171819 1 void main(void) 2 3 &#123; 4 Derived d; 5 Base *pb = &amp;d; 6 Derived *pd = &amp;d; 7 8 // Good : behavior depends solely on type of the object 9 pb-&gt;f(3.14f); // Derived::f(float) 3.14 10 pd-&gt;f(3.14f); // Derived::f(float) 3.14 11 12 // Bad : behavior depends on type of the pointer 13 pb-&gt;g(3.14f); // Base::g(float) 3.14 14 pd-&gt;g(3.14f); // Derived::g(int) 3 (surprise!) 15 16 // Bad : behavior depends on type of the pointer 17 pb-&gt;h(3.14f); // Base::h(float) 3.14 (surprise!) 18 pd-&gt;h(3.14f); // Derived::h(float) 3.14 19 &#125; 在第一种调用中，函数的行为取决于指针所指向的对象。在第二第三种调用中，函数的行为取决于指针的类型。所以说，隐藏破坏了面向对象编程中多态这一特性，会使得OOP人员产生混乱。 不过隐藏也并不是一无是处，它可以帮助编程人员在编译时期找出一些错误的调用。但我觉得还是应该尽量使用隐藏这一些特性，该加virtual时就加吧。 成员函数被重载的特征 （1）相同的范围（在同一个类中）； （2）函数名字相同； （3）参数不同； （4）virtual 关键字可有可无。 覆盖是指派生类函数覆盖基类函数，特征是 （1）不同的范围（分别位于派生类与基类）； （2）函数名字相同； （3）参数相同； （4）基类函数必须有virtual 关键字。 “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下 （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 3种情况怎么执行： 1。重载：看参数 2。隐藏：用什么就调用什么 3。覆盖：调用派生类","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"C++数组","slug":"C-数组","date":"2020-07-24T09:09:18.000Z","updated":"2021-02-19T02:26:05.979Z","comments":true,"path":"2020/07/24/C-数组/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/24/C-%E6%95%B0%E7%BB%84/","excerpt":"c++中的数组真的是个神奇的存在,数组仅在定义其的域范围内可确定大小.","text":"c++中的数组真的是个神奇的存在,数组仅在定义其的域范围内可确定大小.本文需要解决C++中关于数组的2个问题：\\1. 数组作为函数参数，传值还是传址？\\2. 函数参数中的数组元素个数能否确定？ 先看下面的代码。 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void testArrayArg(int a[])&#123; cout &lt;&lt; endl; cout &lt;&lt; \"in func...\" &lt;&lt; endl; cout &lt;&lt; \"array address: \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"array size: \" &lt;&lt; sizeof(a) &lt;&lt; endl; cout &lt;&lt; \"array element count: \" &lt;&lt; sizeof(a) / sizeof(a[0]) &lt;&lt; endl; cout &lt;&lt; \"changing the 4th element's value to 10.\" &lt;&lt; endl; a[3] = 10;&#125;int main()&#123; int a[] = &#123;1, 2, 3, 4, 5&#125;; cout &lt;&lt; \"in main...\" &lt;&lt; endl; cout &lt;&lt; \"array address: \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"array size: \" &lt;&lt; sizeof(a) &lt;&lt; endl; cout &lt;&lt; \"array element count: \" &lt;&lt; sizeof(a) / sizeof(a[0]) &lt;&lt; endl; testArrayArg(a); cout &lt;&lt; endl &lt;&lt; \"the 4th element's value: \" &lt;&lt; a[3] &lt;&lt; endl; return 0;&#125; 运行结果如下： in main…array address: 0012FF4Carray size: 20array element count: 5 in func…array address: 0012FF4Carray size: 4array element count: 1changing the 4th element’s value to 10. the 4th element’s value: 10 当我们直接将数组a作为参数调用testArrayArg()时，实参与形参的地址均是0012FF4C。并且，在testArrayArg()中将a[3]的值修改为10后，返回main()函数中，a[3]的值也已经改变。这些都说明C++中数组作为函数参数是传址。 特别需要注意的是，在main()中，数组的大小是可以确定的。 array size: 20array element count: 5 但作为函数参数传递后，其大小信息丢失，只剩下数组中第一个元素的信息。 array size: 4array element count: 1 这是因为C++实际上是将数组作为指针来传递，而该指针指向数组的第一个元素。至于后面数组在哪里结束，C++的函数传递机制并不负责。 上面的特性可总结为，数组仅在定义其的域范围内可确定大小。 因此，如果在接受数组参数的函数中访问数组的各个元素，需在定义数组的域范围将数组大小作为另一辅助参数传递。则有另一函数定义如下： 1234void testArrayArg2(int a[], int arrayLength)&#123; cout &lt;&lt; endl &lt;&lt; \"the last element in array is: \" &lt;&lt; a[arrayLength - 1] &lt;&lt; endl;&#125; 可在main()中这样调用： testArrayArg2(a, sizeof(a) / sizeof(a[0])); 这样，testArrayArg2()中便可安全地访问数组元素了。 数组指针123456789int main() &#123; int t[10]&#123;1, 2, 3, 4, 5, 5&#125;; int *p&#x3D;t; p++; &#x2F;&#x2F; 下面输出的都是t[1]的地址 std::cout &lt;&lt; t+1&lt;&lt;std::endl; std::cout &lt;&lt; p&lt;&lt;std::endl; std::cout &lt;&lt; &amp;t[0]+1&lt;&lt;std::endl;&#125; 不能执行t++","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"数据结构复习","slug":"数据结构复习","date":"2020-07-22T12:10:01.000Z","updated":"2021-02-19T02:26:07.139Z","comments":true,"path":"2020/07/22/数据结构复习/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/","excerpt":"数据结构相关的东西忘的差不多了，临时抱佛脚准备一波。","text":"数据结构相关的东西忘的差不多了，临时抱佛脚准备一波。 左堆空路径长度：如果定义节点的空路径长度npl(x)为节点x到不满两个儿子的节点的最短路径，具有0个或1个儿子的节点的npl为0，空节点为-1，2个节点为1。 左堆：对堆中的每个节点x，左儿子的npl大于等于右儿子的npl。 有序表的查找 顺序查找 二分查找 差值查找 分块查找 查找树二叉查找树左子树的所有元素的键值都比根节点小。右子树所有元素的键值都比根节点大。 最坏的情况退化为单链表。 平均查找的时间复杂度是O（logN） AVL树节点的平衡度：节点的左子树的高度减去右子树的高度。 AVL树：满足每个节点平衡度都为0，-1，+1的二叉查找树 LL或RR情况：单旋转；LR或RL情况：双旋转； 所有操作在最坏情况都是对数级的 红黑树红黑树时间代价也是对数级的。 红黑树是满足如下条件的二叉查找树： 每个节点为黑色或红色。 根节点为黑色。 如果一个节点为红色，子节点必须是黑色。 从任何一个节点出发到空节点的路径上必须包含相同数目的黑节点。 AA树左儿子不能为红色的红黑树 伸展树伸展树：将访问的节点向根节点旋转 B树https://juejin.im/post/5d8194b5e51d4561e6237214 B+树B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。父节点存有右孩子的第一个元素的索引。 B+树相对于B树有一些自己的优势，可以归结为下面几点。 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。所有的叶子节点形成了一个有序链表，更加便于查找。 文件索引使用B树，B+树而不使用二叉树的原因： 索引存放在磁盘中，访问慢","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://sjtu-xx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"C++中零碎知识点拾遗","slug":"C-零碎知识点拾遗","date":"2020-07-22T08:59:52.000Z","updated":"2021-02-19T02:26:05.980Z","comments":true,"path":"2020/07/22/C-零碎知识点拾遗/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/22/C-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97/","excerpt":"STLSTL(标准模板库)，是目前C++内置支持的library。它的底层利用了C++类模板和函数模板的机制，由三大部分组成：容器、算法和迭代器。","text":"STLSTL(标准模板库)，是目前C++内置支持的library。它的底层利用了C++类模板和函数模板的机制，由三大部分组成：容器、算法和迭代器。 目前STL有六大组件: 容器 container 算法 algorthm 迭代器 iterator 仿函数 function object 适配器 adaptor 空间配置器 allocator 多态的实现方式 覆盖 覆盖是指子类重新定义父类的虚函数的做法。 重载 重载是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。 软件设计原则SOLID原则 简称 英文名 中文名 SRP The Single Responsibility Principle 单一职责原则 OCP The Open Closed Principle 开放封闭原则 LSP The Liskov Substitution Principle 里氏替换原则 ISP The Interface Segregation Principle 接口分离原则 DIP The Dependency Inversion Principle 一来导致原则 S:单一责任原则。就一个类而言,应该仅有一个引起它变化的原因,如果你能想到多于一个的动机去改变一个类,那么这个类就具有多于一个的职责.应该把多于的指责分离出去,分别再创建一些类来完成每一个职责。注重的是职责，主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节。 O:开闭原则。一个软件实体应当对扩展开放,对修改关闭.说的是,再设计一个模块的时候,应当使这个模块可以在不被修改的前提下被扩展.换言之,应当可以在不必修改源代码的情况下改变这个模块的行为，在保持系统一定稳定性的基础上，对系统进行扩展。这是面向对象设计（OOD）的基石，也是最重要的原则。对新增开放，对修改关闭。主要是用多态性，面向接口面层。 L:里氏替换原则。 换言之,一个软件实体如果使用的是一个基类的话,那么一定适用于其子类,而且它根本不能察觉出基类对象和子类对象的区别.只有衍生类可以替换基类，软件单位的功能才能不受影响，基类才能真正被复用，而衍生类也能够在基类的基础上增加新功能。反过来的代换不成立。父类可用的情况下，子类也可以使用。也就是说子类条件更严格。 I:接口分离原则。一个类对另外一个类的依赖是建立在最小的接口上。使用多个专门的接口比使用单一的总接口要好.根据客户需要的不同,而为不同的客户端提供不同的服务是一种应当得到鼓励的做法.就像”看人下菜碟”一样,要看客人是谁,再提供不同档次的饭菜。注重对接口依赖的隔离，主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 D:依赖倒置原则。抽象不应当依赖于细节,细节应当依赖于抽象。高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象，主要是面向接口编程而非面向实现编程。 设计模式 创建型模式（Creational Patterns）用于构建对象，以便它们可以从实现系统中分离出来。 结构型模式（Structural Patterns）用于在许多不同的对象之间形成大型对象结构。 行为型模式（Behavioral Patterns）用于管理对象之间的算法、关系和职责。 创建型模式 单例模式（Singleton Pattern）保证一个类仅有一个实例，并提供一个访问它的全局访问点。 抽象工厂模式 （Abstract Factory Pattern）提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 建造者模式（Builder Pattern）将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 工厂方法模式 （Factory Method Pattern）定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。 原型模式（Prototype Pattern）用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 结构型模式 适配器模式（Adapter Pattern）将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 桥接模式（Bridge Pattern）将抽象部分与它的实现部分分离，使它们都可以独立地变化。 装饰者模式（Decorator Pattern）动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。 组合模式（Composite Pattern）将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 外观模式（Facade Pattern）为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元模式（Flyweight Pattern）运用共享技术有效地支持大量细粒度的对象。 代理模式（Proxy Pattern）为其他对象提供一个代理以控制对这个对象的访问。 行为型模式 模版方法模式 （Template Method Pattern）定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 命令模式（Command Pattern）将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 迭代器模式（Iterator Pattern）提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 观察者模式（Observer Pattern）定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。 中介者模式（Mediator Pattern）用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 备忘录模式 （Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 解释器模式（Interpreter Pattern）给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 状态模式（State Pattern）允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 策略模式（Strategy Pattern）定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户端。 职责链模式 （Chain of Responsibility Pattern）为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 访问者模式 （Visitor Pattern）表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 面向对象与面向过程的区别面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了； 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。 如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。 可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。 智能指针的用法 使用std::unique_ptr时，你不打算持有到同一对象的多个引用。例如，将其用作指向内存的指针，该内存在进入某些范围时被分配，而在退出范围时被取消分配。指针在一个确定的范围存在。 使用std::shared_ptr当你想从多个地方是指你的对象-并且不希望你的对象是去分配，直到所有这些提法本身就没了。 std::weak_ptr当您确实想从多个位置引用对象时，请使用-对于可以忽略和取消分配的引用（因此，当您尝试取消引用时，它们只会指出对象已消失）。避免循环引用。 weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。 weak_ptr的使用：1234567891011121314151617181920212223class A&#123;public: A() : a(3) &#123; cout &lt;&lt; \"A Constructor...\" &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"A Destructor...\" &lt;&lt; endl; &#125; int a;&#125;;int main() &#123; shared_ptr&lt;A&gt; sp(new A()); weak_ptr&lt;A&gt; wp(sp); //sp.reset(); if (shared_ptr&lt;A&gt; pa = wp.lock()) &#123; cout &lt;&lt; pa-&gt;a &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"wp指向对象为空\" &lt;&lt; endl; &#125;&#125; 1234567891011121314struct Owner &#123; std::shared_ptr&lt;Owner&gt; other; ~Owner()&#123; cout&lt;&lt;\"destroyed\"; &#125;&#125;;int main() &#123; std::shared_ptr&lt;Owner&gt; p1 (new Owner()); std::shared_ptr&lt;Owner&gt; p2 (new Owner()); cout&lt;&lt;\"p1:\"&lt;&lt;p1&lt;&lt;\" p2:\"&lt;&lt;p2&lt;&lt;endl; p1-&gt;other = p2; // p1 references p2 p2-&gt;other = p1; // p2 references p1&#125; 对于上面的循环引用，在程序结束时，无法正确析构对象。如果采用weak_ptr则可以析构。 深拷贝和浅拷贝深拷贝指的是将对象的值保存。浅拷贝副本的某些成员可能引用与原始对象相同的对象。 浅拷贝：12345678910111213class X&#123;private: int i; int *pi;public: X() : pi(new int) &#123; &#125; X(const X&amp; copy) // &lt;-- copy ctor : i(copy.i), pi(copy.pi) &#123; &#125;&#125;;深拷贝：12345678910111213class X&#123;private: int i; int *pi;public: X() : pi(new int) &#123; &#125; X(const X&amp; copy) // &lt;-- copy ctor : i(copy.i), pi(new int(*copy.pi)) // &lt;-- note this line in particular! &#123; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"enum枚举量声明、定义、使用与强类型枚举详解","slug":"enum枚举量声明、定义、使用与强类型枚举详解","date":"2020-07-22T08:26:35.000Z","updated":"2021-02-19T02:26:06.410Z","comments":true,"path":"2020/07/22/enum枚举量声明、定义、使用与强类型枚举详解/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/22/enum%E6%9E%9A%E4%B8%BE%E9%87%8F%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE%E8%AF%A6%E8%A7%A3/","excerpt":"c++中的enum类型","text":"c++中的enum类型 枚举量的声明枚举类型定义enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}; 这句话声明了一个enumType类型，声明Monday等为符号常量，默认值为0-6. 变量声明enumType Weekday 也可以在定义枚举类型时定义枚举变量 enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday; 赋值在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量。如：Weekday=Sunday 自定义枚举量的值enum enumType {Monday=1, Tuesday=2, Wednesday=3, Thursday=4, Friday=5, Saturday=6, Sunday=7}; 只定义一部分枚举量的值enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};，这样Monday、Wednesday 均被定义为 1，则 Tuesday=2，Thursday、Friday、Saturday、Sunday 的值默认分别为 2、3、4、5。 枚举的取值范围枚举的上限是 大于最大枚举量的 最小的 2 的幂，减去 1。 枚举的下限有两种情况：一、枚举量的最小值不小于 0，则枚举下限取 0；二、枚举量的最小值小于 0，则枚举下限是小于最小枚举量的最大的 2 的幂，加上 1。 如enum enumType1 { First=-5，Second=14，Third=10 };枚举量的上限是16-1=15,枚举的下限是-8+1=-7（-8小于最小枚举量-5，且为2的幂）； 枚举应用123456789enum enumType&#123;Step0, Step1, Step2&#125;Step=Step0; // 注意这里在声明枚举的时候直接定义了枚举变量 Step,并初始化为 Step0switch (Step)x&#123; case Step0:&#123;...;break;&#125; case Step1:&#123;...;break;&#125; case Step2:&#123;...;break;&#125; default:break;&#125; 另外枚举还有一种少见的用法是enum { one ,two ,three};就是不指定一个名字,这样我们自然也没法去定义一些枚举类型了。此时就相当于 static const int one = 0;这样定义三个常量一样。然后用的话就是 int no = one. 强类型枚举传统C++中枚举常量被暴漏在外层作用域中，这样若是同一作用域下有两个不同的枚举类型，但含有相同的枚举常量也是不可的（如enum Side{Right,Left};enum Thing{Wrong,Right};是不可的）。 强类型枚举使用enum class声明。123456enum class Enumeration&#123; VAL1, VAL2, VAL3=100, VAL4&#125;;这样，枚举类型时安全的，枚举值也不会被隐式转换为整数，无法和整数数值比较，比如（Enumeration：：VAL4==10会触发编译错误）。 另外枚举类型所使用的类型默认为int类型，也可指定其他类型，比如：enum class Enum:unsigned int{VAL1,VAL2}; 强类型枚举能解决传统枚举不同枚举类下同枚举值名的问题，使用枚举类型的枚举名时，必须指明所属范围，比如：Enum::VAL1，而单独的VAL1则不再具有意义。","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"hexo主题更新","slug":"hexo主题更新","date":"2020-07-22T07:21:06.000Z","updated":"2021-02-19T02:26:06.415Z","comments":true,"path":"2020/07/22/hexo主题更新/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/22/hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/","excerpt":"hexo更新","text":"hexo更新 直接修改package.json中的版本号，执行npm update进行更新 主题更新 主题下载主题从github下载到theme/icarus目录 安装hexo s，按照提示通过npm安装对应的包。包的版本可以通过package.json中的版本号修改。所有包安装之后，再执行hexo s会在icarus目录生成对应的_config.yml文件 配置 设置主页三栏，文章页两栏将_config.yml复制到_config.post.yml，将_config.post.yml中的widget移动到一侧。","categories":[{"name":"其他工具","slug":"其他工具","permalink":"https://sjtu-xx.github.io/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"VS的使用","slug":"VS的使用","date":"2020-07-22T06:50:44.000Z","updated":"2021-02-19T02:26:06.345Z","comments":true,"path":"2020/07/22/VS的使用/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/22/VS%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"VS的使用","text":"VS的使用 快捷键12345Ctrl + F5 //编译执行F9 //加断点F10 //单步执行F11 //单步执行（进入函数）shift + F9 //查看变量地址 指定目录可以指定下列目录类型。可执行目录搜索可执行文件的目录。对应于 PATH 环境变量。包含目录（*.h）搜索在源代码中引用的包含文件的目录。对应于 INCLUDE 环境变量。引用目录搜索通过 #using 指令在源代码中引用的程序集和模块（元数据）文件的目录。对应于 LIBPATH 环境变量。库目录（*.lib）搜索库（包括运行时库）的目录。对应于 LIB 环境变量。源目录搜索用于 IntelliSense 的源文件的目录。排除目录检查生成依赖项时，不会搜索目录。 调试-&gt;环境(*.dll) PATH=&lt;dll文件目录&gt;","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"C++中的类型转换cast","slug":"C-中的类型转换cast","date":"2020-07-22T06:48:42.000Z","updated":"2021-02-19T02:26:05.939Z","comments":true,"path":"2020/07/22/C-中的类型转换cast/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/22/C-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2cast/","excerpt":"static_cast","text":"static_cast static_cast用于基本上想要逆转隐式转换的情况，但有一些限制和添加。static_cast不执行运行时检查。如果您知道您引用的是特定类型的对象，则应该使用此方法，因此检查将是不必要的。例子:12345678910func(void *data) &#123; MyClass* -&gt; void*的转换是隐式的 MyClass* c = static_cast&lt;MyClass*&gt;(data); …&#125;int main () &#123; MyClass c; start_thread(&amp;func， &amp;c) //将调用func(&amp;c) . join ();&#125;在本例中，您知道您传递了一个MyClass对象，因此不需要运行时检查来确保这一点。 dynamic_cast当你不知道对象的动态类型时，dynamic_cast很有用。如果引用的对象不包含被转换为基类的类型，则返回空指针(在这种情况下，当转换为引用时，会抛出bad_cast异常)。12345if (JumpStm *j = dynamic_cast&lt;JumpStm*&gt;(&amp;stm)) &#123;…&#125; else if (ExprStm *e = dynamic_cast&lt;ExprStm*&gt;(&amp;stm)) &#123;…&#125;如果向下转换(转换到派生类)且参数类型不是多态的，则不能使用dynamic_cast。例如，以下代码是无效的，因为Base不包含任何虚函数:12345678struct Base &#123;&#125;;struct Derived:Base &#123;&#125;;int main () &#123; Derived d; Base *b = &amp;d; dynamic_cast &lt;Derived* &gt; (b);/ /无效&#125;对于static_cast和dynamic_cast，“up-cast”(转换到基类)始终是有效的，而且不需要任何转换，因为“up-cast”是隐式转换。 常规cast这些转换也称为c型转换。C风格的转换基本上等同于尝试一系列c++转换，并进行第一次有效的c++转换，而不考虑dynamic_cast。不用说，它结合了所有的const_cast、static_cast和reinterpret_cast，因此功能更加强大，但是它也不安全，因为它没有使用dynamic_cast。 另外，c样式的强制转换不仅允许您这样做，而且还允许您安全地强制转换到一个私有基类，而“等效的”static_cast序列会为此给出一个编译时错误。 有些人喜欢c风格的类型转换，因为它们很简洁。我只将它们用于数字类型转换，并在涉及用户定义的类型时使用适当的c++类型转换，因为它们提供了更严格的检查。","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"bss段、data段、text段、堆栈","slug":"bss段、data段、text段、堆栈","date":"2020-07-21T07:24:21.000Z","updated":"2021-02-19T02:26:06.345Z","comments":true,"path":"2020/07/21/bss段、data段、text段、堆栈/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/21/bss%E6%AE%B5%E3%80%81data%E6%AE%B5%E3%80%81text%E6%AE%B5%E3%80%81%E5%A0%86%E6%A0%88/","excerpt":"每个线程都有一个栈，但一个应用程序通常只有一个堆","text":"每个线程都有一个栈，但一个应用程序通常只有一个堆 bss段： bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。 bss是英文Block Started by Symbol的简称。 bss段属于静态内存分配。 data段： 数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。 数据段属于静态内存分配。 text段： 代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。 这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。 在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 堆（heap）： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。 当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）； 当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。 栈(stack)： 栈又称堆栈，是用户存放程序临时创建的局部变量， 也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。 除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"}],"tags":[]},{"title":"C++中类所占空间的大小","slug":"C-中类所占空间的大小","date":"2020-07-20T14:21:20.000Z","updated":"2021-02-19T02:26:05.940Z","comments":true,"path":"2020/07/20/C-中类所占空间的大小/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/20/C-%E4%B8%AD%E7%B1%BB%E6%89%80%E5%8D%A0%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F/","excerpt":"struct,class","text":"struct,class123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;struct Empyt&#123; &#125;;struct S&#123; static long c; // static 变量不占用S的存储空间，S为空，那么S占用一个字节&#125;;int main()&#123; char a; cout&lt;&lt;sizeof(a)&lt;&lt;endl; char *b = &amp;a; cout&lt;&lt;\"*:\"&lt;&lt;sizeof(b)&lt;&lt;endl; int c; cout&lt;&lt;\"int:\"&lt;&lt;sizeof(c)&lt;&lt;endl; long d; cout&lt;&lt;\"long:\" &lt;&lt;sizeof(d)&lt;&lt;endl; long long f; cout&lt;&lt;\"long long:\" &lt;&lt; sizeof(f) &lt;&lt;endl; double m; cout&lt;&lt;\"double:\" &lt;&lt; sizeof(m) &lt;&lt;endl; cout&lt;&lt;\"Empyt: \"&lt;&lt;sizeof(Empyt)&lt;&lt;endl; cout&lt;&lt;\"S: \"&lt;&lt;sizeof(S)&lt;&lt;endl;&#125; 在64位系统中的结果如下,static 的变量占用全局的内存. 和全局变量分配的内存在同一个区域里面.所以sizeof（s）的时候没有将其计算在内。123456789101112131415Char: 1*: 8int: 4long: 8long long: 8double: 8Empyt: 1S: 1 字节对齐字节对齐的细节和编译器实现相关，但一般而言，满足三个准则： 1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；2) 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节； 字节对齐实际计算方法看了以后还是不是很理解，也很正常，我们自己试试差不多就能理解了，通俗点讲，就是类（结构体）占用的大小永远都是其内定义的最宽（就是所占字节最大的变量）字节的整数倍，如果不是，那么编译器会自动帮你补上，如K，最宽的类型是int，占四个字节，加上一个char 一个字节 =5，不能被4整除哇，所以编译器将其自动补齐为8。我们再改一改K： struct K{ int a; char b; char c; }; 这时候K 占几个字节？ 没错，答案还是8，看到这里是不是觉得自己应该掌握了， 哈哈，还没有，我们再看下面，我们把K当中的变量顺序换一换： struct K{ char b; int a; char c; }; 是不是感觉没什么变化，我们只把int a 放在了 b 的下面。答案还是8吗？看我都这么说了，结果肯定不是啦，为先说下答案，是12，知道为什么了吗？看到答案为想大家也应该明白了，类当中的空间存储是自上而下的，我还是通俗点讲，先发现char b，字节大小为1，然后往下走碰到了 a 四个字节，这时候对b 进行自动补齐，字节大小变为八，也就是b的偏移量变成了3.继续走又给c分配四个字节，最后结果就是12.那之前为什么是8呢，很简单呀因为 前面的b，c 共同占用四个字节（他们是连在一起的） 所以现在懂了吗，出个小题目： struct K{ int a; long f; char c; int b; char e; char g; char h; char i; char j; }; 现在k占几个字节？ · · 答案是32————————————————原文链接：https://blog.csdn.net/monster_acm/java/article/details/81169289","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/tags/C/"}]},{"title":"dataclasses数据类","slug":"dataclasses数据类","date":"2020-07-07T08:01:04.000Z","updated":"2021-02-19T02:26:06.404Z","comments":true,"path":"2020/07/07/dataclasses数据类/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/07/dataclasses%E6%95%B0%E6%8D%AE%E7%B1%BB/","excerpt":"dataclasses官方文档：https://docs.python.org/zh-cn/3/library/dataclasses.html","text":"dataclasses官方文档：https://docs.python.org/zh-cn/3/library/dataclasses.html 概要这个模块提供了一个装饰器和一些函数，用于自动添加生成的 special methods ，例如 __init__() 和 __repr__() 到用户定义的类。 它最初描述于PEP557。 1234567891011from dataclasses import dataclass@dataclassclass InventoryItem: '''Class for keeping track of an item in inventory.''' name: str unit_price: float quantity_on_hand: int = 0 def total_cost(self) -&gt; float: return self.unit_price * self.quantity_on_hand 除其他事情外，将添加__init__()，其看起来像: 1234def __init__(self, name: str, unit_price: float, quantity_on_hand: int=0): self.name = name self.unit_price = unit_price self.quantity_on_hand = quantity_on_hand 请注意，此方法会自动添加到类中：它不会在上面显示的 InventoryItem 定义中直接指定。 模块级装饰器、类和函数 @dataclasses.dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)dataclass() 的参数有： init: 如果为真值（默认），将生成一个__init__()方法。如果类已定义 __init__() ，则忽略此参数。 repr：如果为真值（默认），将生成一个__repr__()方法。 生成的 repr 字符串将具有类名以及每个字段的名称和 repr ，按照它们在类中定义的顺序。不包括标记为从 repr 中排除的字段。 例如：InventoryItem(name=’widget’, unit_price=3.0, quantity_on_hand=10)。 如果类已定义__repr__()，则忽略此参数。 eq：如果为true（默认值），将生成__eq__()方法。此方法将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。 如果类已定义 __eq__() ，则忽略此参数。 order ：如果为真值（默认为 False ），则 __lt__() 、__le__() 、 __gt__() 和 __ge__() 方法将生成。 这将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。如果 order 为真值并且 eq 为假值 ，则引发 ValueError 。 如果类已经定义了 __lt__() 、__le__() 、 __gt__() 或者 __ge__() 中的任意一个，将引发 TypeError 。 unsafe_hash ：如果为 False （默认值），则根据 eq 和 frozen 的设置方式生成 __hash__() 方法。 __hash__() 由内置的 hash() 使用，当对象被添加到散列集合（如字典和集合）时。有一个__hash__() 意味着类的实例是不可变的。可变性是一个复杂的属性，取决于程序员的意图， __eq__() 的存在性和行为，以及 dataclass() 装饰器中 eq 和 frozen 标志的值。 默认情况下， dataclass() 不会隐式添加 __hash__() 方法，除非这样做是安全的。 它也不会添加或更改现有的明确定义的 __hash__() 方法。 设置类属性 __hash__ = None 对 Python 具有特定含义，如 __hash__() 文档中所述。 如果 __hash__() 没有显式定义，或者它被设置为 None ，那么 dataclass() 可以 添加一个隐式 __hash__() 方法。虽然不推荐，但你可以强制 dataclass() 用 unsafehash=True 创建一个 `_hash()` 方法。 如果你的类在逻辑上是不可变的但实际仍然可变，则可能就是这种情况。这是一个特殊的用例，应该仔细考虑。 以下是隐式创建 __hash__() 方法的规则。请注意，你不能在数据类中都使用显式的 __hash__() 方法并设置 unsafe_hash=True ；这将导致 TypeError 。 如果 eq 和 frozen 都是 true，默认情况下 dataclass() 将为你生成一个 __hash__() 方法。如果 eq 为 true 且 frozen 为 false ，则 __hash__() 将被设置为 None ，标记它不可用（因为它是可变的）。如果 eq 为 false ，则 __hash__() 将保持不变，这意味着将使用超类的 __hash__() 方法（如果超类是 object ，这意味着它将回到基于id的hash）。 frozen: 如为真值 (默认值为 False)，则对字段赋值将会产生异常。 这模拟了只读的冻结实例。 如果在类中定义了 __setattr__() 或__delattr__() 则将会引发 TypeError。 参见下文的讨论。 dataclasses.field(*, default=MISSING, default_factory=MISSING, repr=True, hash=None, init=True, compare=True, metadata=None) field() 参数有： default ：如果提供，这将是该字段的默认值。这是必需的，因为 field() 调用本身会替换一般的默认值。 default_factory ：如果提供，它必须是一个零参数可调用对象，当该字段需要一个默认值时，它将被调用。除了其他目的之外，这可以用于指定具有可变默认值的字段，如下所述。 同时指定 default 和 default_factory 将产生错误。 init ：如果为true（默认值），则该字段作为参数包含在生成的 __init__() 方法中。 repr ：如果为true（默认值），则该字段包含在生成的 __repr__() 方法返回的字符串中。 compare ：如果为true（默认值），则该字段包含在生成的相等性和比较方法中（ __eq__() ， __gt__() 等等）。 hash ：这可以是布尔值或 None 。如果为true，则此字段包含在生成的 __hash__() 方法中。如果为 None （默认值），请使用 compare 的值，这通常是预期的行为。如果字段用于比较，则应在 hash 中考虑该字段。不鼓励将此值设置为 None 以外的任何值。 设置 hash=False 但 compare=True 的一个可能原因是，如果一个计算 hash 的代价很高的字段是检验等价性需要的，但还有其他字段可以计算类型的 hash 。 即使从 hash 中排除某个字段，它仍将用于比较。 metadata ：这可以是映射或 None 。 None 被视为一个空的字典。这个值包含在 MappingProxyType() 中，使其成为只读，并暴露在 Field 对象上。数据类根本不使用它，它是作为第三方扩展机制提供的。多个第三方可以各自拥有自己的键值，以用作元数据中的命名空间。 初始化后处理12345678@dataclassclass C: a: float b: float c: float = field(init=False) def __post_init__(self): self.c = self.a + self.b","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://sjtu-xx.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"pyinstaller打包","slug":"pyinstaller打包","date":"2020-07-01T08:05:08.000Z","updated":"2021-02-19T02:26:06.550Z","comments":true,"path":"2020/07/01/pyinstaller打包/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/01/pyinstaller%E6%89%93%E5%8C%85/","excerpt":"pyinstaller用于windows下python代码的打包。","text":"pyinstaller用于windows下python代码的打包。 参数说明 参数 说明 -F 指定打包后只生成一个 exe 格式的文件 -D –onedir 创建一个目录，包含 exe 文件，但会依赖很多文件（默认选项） -c –console, –nowindowed 使用控制台，无界面 (默认) -w 去除控制台，建议在开发 gui 的时候使用 -i 改变生成程序的 icon 图标 测试文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546from PySide2.QtCore import Slotfrom PySide2.QtGui import QKeySequencefrom PySide2.QtWidgets import QMainWindow, QAction,QApplication,QVBoxLayout,QLabel,QFrameimport sysimport numpy as npimport pandas as pdfrom functools import reduceclass MainWindow(QMainWindow): def __init__(self): QMainWindow.__init__(self) self.setWindowTitle(\"Eartquakes information\") # Menu self.menu = self.menuBar() self.file_menu = self.menu.addMenu(\"File\") # Exit QAction exit_action = QAction(\"Exit\", self) exit_action.setShortcut(QKeySequence.Quit) exit_action.triggered.connect(self.close) self.file_menu.addAction(exit_action) frame = QFrame() g_layout = QVBoxLayout() g_layout.addWidget(QLabel(','.join(map(str,np.arange(1,5).tolist())))) g_layout.addWidget(QLabel(reduce(lambda x,y:str(x)+\",\"+str(y),pd.read_csv(r\"C:\\Users\\10993\\Desktop\\1.csv\", header=None).values.ravel().tolist()))) frame.setLayout(g_layout) self.setCentralWidget(frame) # Status Bar self.status = self.statusBar() self.status.showMessage(\"Data loaded and plotted\") # Window dimensions geometry = QApplication.desktop().availableGeometry(self) self.setFixedSize(int(geometry.width() * 0.8), int(geometry.height() * 0.7))if __name__==\"__main__\": app = QApplication(sys.argv) wind = MainWindow() wind.show() sys.exit(app.exec_())执行pyinstaller -w --hidden-import=pkg_resources.py2_warn -F example.py 出现的一些问题 打包完成执行exe文件时，提示Failed to execute script pyi_rth_pkgres 可以通过增加hidden-import参数（Name an import not visible in the code of the script(s). This option can be used multiple times.）解决：&quot;pyinstaller --hidden-import=pkg_resources.py2_warn example.py&quot;","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"应用","slug":"Python/应用","permalink":"https://sjtu-xx.github.io/categories/Python/%E5%BA%94%E7%94%A8/"}],"tags":[]},{"title":"pyside2与pyqt5的差异","slug":"pyside2与pyqt5的差异","date":"2020-07-01T07:36:25.000Z","updated":"2021-02-19T02:26:06.552Z","comments":true,"path":"2020/07/01/pyside2与pyqt5的差异/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/01/pyside2%E4%B8%8Epyqt5%E7%9A%84%E5%B7%AE%E5%BC%82/","excerpt":"由于pyqt5的GPLv3协议要求，使用其的软件必须开源。而pyside2的LGPL协议允许闭源商用。","text":"由于pyqt5的GPLv3协议要求，使用其的软件必须开源。而pyside2的LGPL协议允许闭源商用。 导入库的差异from PySide.QtCore import * pyside只支持pyqt中的api2api1指的是使用qt中的QString,QVariant等类型api2则是另外一种更加pythonic的接口，使用原生的Python的数据类型。 信号和槽pyside2:QtCore.Signal()和QtCore.Slot()pyqt:QtCore.pyqtSignal()和QtCore.pyqtSignal 属性pyside2:QtCore.Propertypyqt:QtCore.pyqtProperty 功能性差异pyside中不提供qt4.5之前已经废弃函数的python接口 sender() 成员在 partial 或 lambda 函数内返回 None 当继承一个类时，父类的构造函数总是需要被调用 旧式风格的信号需要使用圆括号self.emit(SIGNAL (&#39;text_changed_cb(QString)&#39;), text) 由于兼容性问题，pyside还存在一些问题安装：测试成功的办法python3.7pyside2 5.14.2","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[]},{"title":"excel文件读写（python）","slug":"excel文件读写","date":"2020-07-01T00:40:08.000Z","updated":"2021-02-19T02:26:06.410Z","comments":true,"path":"2020/07/01/excel文件读写/","link":"","permalink":"https://sjtu-xx.github.io/2020/07/01/excel%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/","excerpt":"由于后面的项目需要直接处理excel表格（xls，xlsx等），因此，对excel处理的相关工具进行学习。","text":"由于后面的项目需要直接处理excel表格（xls，xlsx等），因此，对excel处理的相关工具进行学习。 对于csv文件，由于其本质为文本格式，可以直接进行方便的读写操作 通过python对excel表格文件进行处理有多种方式：pandas，openpyxl，xlrd，xlutils和pyexcel之类的软件包都提供了与excel文件交互的接口。 1.pandas与excelpandas读取excel12345import pandas as pdfile = 'example.xlsx'xl = pd.ExcelFile(file)print(xl.sheet_names)df1 = xl.parse('Sheet1') pd.ExcelFile vs pd.read_excelpd.ExcelFile是一个类，而read_excel是一个方法在最新版本的pandas中，read_excel确保它具有一个ExcelFile对象（如果没有则创建一个对象），然后_parse_excel直接调用该方法：123if not isinstance(io, ExcelFile): io = ExcelFile(io, engine=engine)return io._parse_excel(...)通过更新的（统一的）参数处理，ExcelFile.parse实际上仅是一条语句：return self._parse_excel(...) pandas写入excel12345678910111213# Install `XlsxWriter`!pip install XlsxWriterimport pandas as pd# Specify a writerwriter = pd.ExcelWriter('example.xlsx', engine='xlsxwriter')# Write your DataFrame to a file # yourData is a dataframe that you are interested in writing as an excel fileyourData.to_excel(writer, 'Sheet1')# Save the resultwriter.save() 2.openpyxl与excelopenpyxl支持.xlsx，xlsm，xltx，和xltm等格式 读取123456# Import `load_workbook` module from `openpyxl`from openpyxl import load_workbook# Load in the workbookwb = load_workbook('test.xlsx')# Get sheet namesprint(wb.sheetnames) 查看activate sheet12345678# Get a sheet by namesheet = wb['Sheet1']# Print the sheet titleprint('Sheet Title:',sheet.title)# Get currently active sheetanotherSheet = wb.active# Check `anotherSheet`print(anotherSheet) 获取获取某个单元格的信息123456789101112131415161718192021# Retrieve the value of a certain cellprint(sheet['A1'].value)# Select element 'B3' of your sheetc = sheet['B3']# Retrieve the row number of your elementprint('Row No.:', c.row)# Retrieve the column number of your elementprint('Column Letter:', c.column)# Retrieve the coordinates of the cellprint('Coordinates of cell:', c.coordinate)#################### 输出IDRow No.: 3Column Letter: 2Coordinates of cell: B3 获取某个位置的单元格1print(sheet.cell(row&#x3D;1, column&#x3D;2).value) openpyxl有一个utility有两个方法get_column_letter和column_index_from_string。顾名思义，前者返回给定字母的数字/整数，后者返回提供字母的数字作为字符串。12345678910# Import relevant modules from `openpyxl.utils`from openpyxl.utils import get_column_letter, column_index_from_string# Return 'A'print('Column Letter:', get_column_letter(1))# Return '1'print('Column Index:', column_index_from_string('A'))# returnColumn Letter: AColumn Index: 1 切片1234for cellObj in sheet['A1':'C3']: for cell in cellObj: print(cell.coordinate, cell.value) print('--- END ---') sheet属性12345# Retrieve the maximum amount of rowsprint('Max Rows:', sheet.max_row)# Retrieve the maximum amount of columnsprint('Max Columns:', sheet.max_column) 与pandas结合使用可以使用Pandas包中的函数将工作表的值放入DataFrame中，然后使用DataFrame函数来分析和处理数据：12345# Import `pandas`import pandas as pd# Convert Sheet to DataFramedf = pd.DataFrame(sheet.values) 如果要指定标头和索引，则可以传递标头参数，其中标头和索引的列表为True，但是，由于转换为数据框的工作表已经包含标头，因此不需要添加标头：1234567891011121314151617181920from itertools import islice# Put the sheet values in `data`data = sheet.values# Indicate the columns in the sheet valuescols = next(data)[1:]# Convert your data to a listdata = list(data)# Read in the data at index 0 for the indicesidx = [r[0] for r in data]# Slice the data at index 1data = (islice(r, 1, None) for r in data)# Make your DataFramedf = pd.DataFrame(data, index=idx, columns=cols)print(df) 写回excel文件12345678910111213# Import `dataframe_to_rows`from openpyxl.utils.dataframe import dataframe_to_rowsfrom openpyxl import *# Initialize a workbookwb = Workbook()# Get the worksheet in the active workbookws = wb.active# Append the rows of the DataFrame to your worksheetfor r in dataframe_to_rows(df, index=True, header=True): ws.append(r) 3.xlrd与excel读取xls和xlxs格式的文件12345678# Import `xlrd`import xlrd# Open a workbookworkbook = xlrd.open_workbook('test.xlsx')# Loads only current sheets to memoryworkbook = xlrd.open_workbook('test.xlsx', on_demand = True) 获取12345678910111213# Load a specific sheet by nameworksheet = workbook.sheet_by_name('Sheet1')# Load a specific sheet by indexworksheet = workbook.sheet_by_index(0)# Retrieve the value from cell at indices (0,0)sheet.cell(1, 1).valueprint(sheet1.cell(1,0).value)#获取表格里的内容，三种方式print(sheet1.cell_value(1,0))print(sheet1.row(1)[0].value) 4.xlwt与excelxlwt创建电子表格。1234567891011121314# Import `xlwt`import xlwt# Initialize a workbookbook = xlwt.Workbook(encoding=\"utf-8\")# Add a sheet to the workbooksheet1 = book.add_sheet(\"Python Sheet 1\")# Write to the sheet of the workbooksheet1.write(0, 0, \"This is the First Cell of the First Sheet\")# Save the workbookbook.save(\"spreadsheet.xls\") 12345678910111213141516171819# Initialize a workbookbook = xlwt.Workbook()# Add a sheet to the workbooksheet1 = book.add_sheet(\"Sheet1\")# The datacols = [\"A\", \"B\", \"C\", \"D\", \"E\"]txt = [0,1,2,3,4]# Loop over the rows and columns and fill in the valuesfor num in range(5): row = sheet1.row(num) for index, col in enumerate(cols): value = txt[index] + num row.write(index, value)# Save the resultbook.save(\"test.xls\") 1234567891011121314151617181920212223242526272829303132333435import xlwt#设置表格样式def set_style(name,height,bold=False): style = xlwt.XFStyle() font = xlwt.Font() font.name = name font.bold = bold font.color_index = 4 font.height = height style.font = font return style#写Exceldef write_excel(): f = xlwt.Workbook() sheet1 = f.add_sheet('学生',cell_overwrite_ok=True) row0 = [\"姓名\",\"年龄\",\"出生日期\",\"爱好\"] colum0 = [\"张三\",\"李四\",\"恋习Python\",\"小明\",\"小红\",\"无名\"] #写第一行 for i in range(0,len(row0)): sheet1.write(0,i,row0[i],set_style('Times New Roman',220,True)) #写第一列 for i in range(0,len(colum0)): sheet1.write(i+1,0,colum0[i],set_style('Times New Roman',220,True)) sheet1.write(1,3,'2006/12/12') sheet1.write_merge(6,6,1,3,'未知')#合并行单元格 sheet1.write_merge(1,2,3,3,'打游戏')#合并列单元格 sheet1.write_merge(4,5,3,3,'打篮球') f.save('test.xls')if __name__ == '__main__': write_excel() 5.pyexcel与excelpyexcel提供用于读取，操作和在写入数据的单个API接口（.csv，.ods，.xls，.xlsx，和.xlsm文件）。使用pyexcel，可以用最少的代码将excel文件中的数据转换为数组或dict格式。 数组格式12345# Import `pyexcel`import pyexcel# Get an array from the datamy_array = pyexcel.get_array(file_name=\"test.xls\") 字典格式12345# Import `OrderedDict` modulefrom pyexcel._compact import OrderedDict# Get your data in an ordered dictionary of listsmy_dict = pyexcel.get_dict(file_name=\"test.xls\", name_columns_by_row=0) 还可以获得二维数组的字典。简而言之，您可以借助该get_book_dict()功能将所有工作簿表提取到一个字典中。12# Get your data in a dictionary of 2D arraysbook_dict = pyexcel.get_book_dict(file_name=\"test.xls\") 写入excel文件1234567891011121314151617181920212223242526272829# Get the datadata = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]# Save the array to a filepyexcel.save_as(array=data, dest_file_name=\"array_data.xls\")# The datad2_array_dictionary = &#123;'Sheet 1': [ ['ID', 'AGE', 'SCORE'] [1, 22, 5], [2, 15, 6], [3, 28, 9] ], 'Sheet 2': [ ['X', 'Y', 'Z'], [1, 2, 3], [4, 5, 6] [7, 8, 9] ], 'Sheet 3': [ ['M', 'N', 'O', 'P'], [10, 11, 12, 13], [14, 15, 16, 17] [18, 19, 20, 21] ]&#125;# Save the data to a file pyexcel.save_book_as(bookdict=d2_array_dictionary, dest_file_name=\"2d_array_data.xls\") 6. csv库12345678910111213# import `csv`import csv# Read in csv filefor row in csv.reader(open('data.csv'), delimiter=','): print(row)# Write csv filedata = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]outfile = open('data.csv', 'w')writer = csv.writer(outfile, delimiter=';', quotechar='\"')writer.writerows(data)outfile.close() 7. xlsxwriter库官方文档 xlsxwriter库可以在excel文件中使用excel自带的绘图进行绘制简单使用：12345678import xlsxwriterworkbook = xlsxwriter.Workbook('hello.xlsx')worksheet = workbook.add_worksheet()worksheet.write('A1', 'Hello world')workbook.close() 在XlsxWriter中，行和列都是零索引。工作表中的第一个单元格A1是(0, 0)。 设置行高12sheet_handle.set_default_row(30)sheet_handle.set_row(cur_row, 12) 设置单元格格式12title_format = workbook_handle.add_format(&#123;\"font_name\": \"Arial\", \"bold\": True, \"font_size\": 20&#125;)sheet_handle.write(cur_row, 0, description_info[\"title\"], title_format) 添加图表https://xlsxwriter.readthedocs.io/chart.html12chart = workbook.add_chart(&#123;'type': 'column'&#125;)worksheet.insert_chart('A7', chart) type可用类型：bar、column、doughnut、line、pie、radar、scatter、stock 添加序列12345678910111213chart.add_series(&#123; 'categories': '=Sheet1!$A$1:$A$5', 'values': '=Sheet1!$B$1:$B$5', 'line': &#123;'color': 'red'&#125;,&#125;)# Or using a list of values instead of category/value formulas:# [sheetname, first_row, first_col, last_row, last_col]chart.add_series(&#123; 'categories': ['Sheet1', 0, 0, 4, 0], 'values': ['Sheet1', 0, 1, 4, 1], 'line': &#123;'color': 'red'&#125;,&#125;) 序列可设置的参数： values：这是系列中最重要的属性，并且是每个图表对象的唯一必需选项。此选项将图表与其显示的工作表数据链接起来。可以使用上面第一个示例中所示的公式或使用第二个示例中所示的值列表来设置数据范围。 categories：这将设置图表类别标签。类别与X轴大致相同。在大多数图表类型中，该categories 属性是可选的，图表仅假设的序列为 1..n。 name：设置系列的名称。名称显示在编辑栏中。对于非饼图/甜甜圈图，它也会显示在图例中。name属性是可选的，如果未提供，则默认为 。名称也可以是公式，例如或带有工作表名称，行和列的列表，例如。Series 1..n=Sheet1!$A$1[‘Sheet1’, 0, 0] line：设置系列线型的属性，例如颜色和宽度。请参阅图表格式：线。 border：设置系列的边框属性，例如颜色和样式。请参阅图表格式：边框。 fill：设置系列的实心填充属性，例如颜色。请参阅 图表格式：实心填充。 pattern：设置系列的图案填充属性。请参阅 图表格式：模式填充。 gradient：设置系列的渐变填充属性。请参阅 图表格式：“渐变填充”。 marker：设置系列标记的属性，例如样式和颜色。请参阅图表系列选项：标记。 trendline：设置系列趋势线的属性，例如线性，多项式和移动平均线类型。请参阅 图表系列选项：趋势线。 smooth：设置线系列的平滑属性。 y_error_bars：设置图表系列的垂直误差范围。请参阅 图表系列选项：误差线。 x_error_bars：设置图表系列的水平误差范围。请参阅 图表系列选项：误差线。 data_labels：设置系列的数据标签。请参阅 图表系列选项：数据标签。 points：设置系列中各个点的属性。请参阅 图表系列选项：点。 invert_if_negative：将填充颜色反转为负值。通常仅适用于柱状图和条形图。 overlap：在条形图/柱形图中设置系列之间的重叠。范围是+/-100。默认值为0： gap：在条形图/柱形图中设置系列之间的间隔。范围是0到500。默认值是150： 设置轴属性chart.set_x_axis() 辅助x轴chart.set_x2_axis() 合并图表chart.combine（） 设置大小chart.set_size()可设置的属性：width、height、x_scale、y_scale、x_offset、y_offset offset也可通过worksheet.insert_chart(&#39;E2&#39;, chart, {&#39;x_offset&#39;: 25, &#39;y_offset&#39;: 10})设定 设置标题chart.set_title({&#39;name&#39;: &#39;Year End Results&#39;}) 设置图例chart.set_legend({&#39;none&#39;: True}) notation的转换123456789101112131415161718192021from xlsxwriter.utility import xl_rowcol_to_cellcell = xl_rowcol_to_cell(0, 0) # A1cell = xl_rowcol_to_cell(0, 1) # B1cell = xl_rowcol_to_cell(1, 0) # A2str = xl_rowcol_to_cell(0, 0, col_abs=True) # $A1str = xl_rowcol_to_cell(0, 0, row_abs=True) # A$1str = xl_rowcol_to_cell(0, 0, row_abs=True, col_abs=True) # $A$1column = xl_col_to_name(0, False) # Acolumn = xl_col_to_name(0, True) # $Acolumn = xl_col_to_name(1, True) # $Bcell_range = xl_range(0, 0, 9, 0) # A1:A10cell_range = xl_range(1, 2, 8, 2) # C2:C9cell_range = xl_range(0, 0, 3, 4) # A1:E4cell_range = xl_range_abs(0, 0, 9, 0) # $A$1:$A$10cell_range = xl_range_abs(1, 2, 8, 2) # $C$2:$C$9cell_range = xl_range_abs(0, 0, 3, 4) # $A$1:$E$4","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[]},{"title":"爬虫","slug":"爬虫","date":"2020-06-29T14:07:12.000Z","updated":"2021-02-19T02:26:07.164Z","comments":true,"path":"2020/06/29/爬虫/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/%E7%88%AC%E8%99%AB/","excerpt":"爬虫：https://www.cnblogs.com/wupeiqi/articles/5354900.html详细连接:https://www.cnblogs.com/wupeiqi/articles/6283017.html","text":"爬虫：https://www.cnblogs.com/wupeiqi/articles/5354900.html详细连接:https://www.cnblogs.com/wupeiqi/articles/6283017.html 一、爬虫基本操作1.1 爬虫 定向 非定向 1.2 步骤 下载页面 筛选：正则表达式 1.3 开源模块 requests response = request.get() response.txt beautifulsoup bs = Beautifulsoup(request.txt) bs.find(id = “”) 二、requests库Requests 是使用 Apache2 Licensed 许可证的 基于Python开发的HTTP 库，其在Python内置模块的基础上进行了高度的封装，从而使得Pythoner进行网络请求时，变得美好了许多，使用Requests可以轻而易举的完成浏览器可有的任何操作。 1.Get请求1234567891011121314151617181920# 1、无参数实例 import requests ret &#x3D; requests.get(&#39;https:&#x2F;&#x2F;github.com&#x2F;timeline.json&#39;) print ret.urlprint ret.text # 2、有参数实例 import requests payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;ret &#x3D; requests.get(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;, params&#x3D;payload) print ret.urlprint ret.text 2.POST请求1234567891011121314151617181920212223# 1、基本POST实例 import requests payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;ret = requests.post(\"http://httpbin.org/post\", data=payload) print ret.text # 2、发送请求头和数据实例 import requestsimport json url = 'https://api.github.com/some/endpoint'payload = &#123;'some': 'data'&#125;headers = &#123;'content-type': 'application/json'&#125; ret = requests.post(url, data=json.dumps(payload), headers=headers) print ret.textprint ret.cookies 总结 1234567891011import requestsresponse =resquests.get(url = \"\")response = requests.post(url = \"\",data=&#123;\"\":\"\"&#125;,cookies=&#123;\"asdf\":\"asfdasdf\"&#125;)response.content #字节内容response.encoding #编码方式response.apparent_encodingresponse.text #文本内容response.status_code # 200,300........response.cookies # cookies对象response.cookies.get_dict() #cookies字典 详细 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233def param_method_url(): # requests.request(method='get', url='http://127.0.0.1:8000/test/') # requests.request(method='post', url='http://127.0.0.1:8000/test/') passdef param_param(): # - 可以是字典 # - 可以是字符串 # - 可以是字节（ascii编码以内） # requests.request(method='get', # url='http://127.0.0.1:8000/test/', # params=&#123;'k1': 'v1', 'k2': '水电费'&#125;) # requests.request(method='get', # url='http://127.0.0.1:8000/test/', # params=\"k1=v1&amp;k2=水电费&amp;k3=v3&amp;k3=vv3\") # requests.request(method='get', # url='http://127.0.0.1:8000/test/', # params=bytes(\"k1=v1&amp;k2=k2&amp;k3=v3&amp;k3=vv3\", encoding='utf8')) # 错误 # requests.request(method='get', # url='http://127.0.0.1:8000/test/', # params=bytes(\"k1=v1&amp;k2=水电费&amp;k3=v3&amp;k3=vv3\", encoding='utf8')) passdef param_data(): # 可以是字典 # 可以是字符串 # 可以是字节 # 可以是文件对象 # requests.request(method='POST', # url='http://127.0.0.1:8000/test/', # data=&#123;'k1': 'v1', 'k2': '水电费'&#125;) # requests.request(method='POST', # url='http://127.0.0.1:8000/test/', # data=\"k1=v1; k2=v2; k3=v3; k3=v4\" # ) # requests.request(method='POST', # url='http://127.0.0.1:8000/test/', # data=\"k1=v1;k2=v2;k3=v3;k3=v4\", # headers=&#123;'Content-Type': 'application/x-www-form-urlencoded'&#125; # ) # requests.request(method='POST', # url='http://127.0.0.1:8000/test/', # data=open('data_file.py', mode='r', encoding='utf-8'), # 文件内容是：k1=v1;k2=v2;k3=v3;k3=v4 # headers=&#123;'Content-Type': 'application/x-www-form-urlencoded'&#125; # ) passdef param_json(): # 将json中对应的数据进行序列化成一个字符串，json.dumps(...) # 然后发送到服务器端的body中，并且Content-Type是 &#123;'Content-Type': 'application/json'&#125; requests.request(method='POST', url='http://127.0.0.1:8000/test/', json=&#123;'k1': 'v1', 'k2': '水电费'&#125;)def param_headers(): # 发送请求头到服务器端 requests.request(method='POST', url='http://127.0.0.1:8000/test/', json=&#123;'k1': 'v1', 'k2': '水电费'&#125;, headers=&#123;'Content-Type': 'application/x-www-form-urlencoded'&#125; )def param_cookies(): # 发送Cookie到服务器端 requests.request(method='POST', url='http://127.0.0.1:8000/test/', data=&#123;'k1': 'v1', 'k2': 'v2'&#125;, cookies=&#123;'cook1': 'value1'&#125;, ) # 也可以使用CookieJar（字典形式就是在此基础上封装） from http.cookiejar import CookieJar from http.cookiejar import Cookie obj = CookieJar() obj.set_cookie(Cookie(version=0, name='c1', value='v1', port=None, domain='', path='/', secure=False, expires=None, discard=True, comment=None, comment_url=None, rest=&#123;'HttpOnly': None&#125;, rfc2109=False, port_specified=False, domain_specified=False, domain_initial_dot=False, path_specified=False) ) requests.request(method='POST', url='http://127.0.0.1:8000/test/', data=&#123;'k1': 'v1', 'k2': 'v2'&#125;, cookies=obj)def param_files(): # 发送文件（字典） # file_dict = &#123; # 'f1': open('readme', 'rb') # &#125; # requests.request(method='POST', # url='http://127.0.0.1:8000/test/', # files=file_dict) # 发送文件，定制文件名（以元组作为值） # file_dict = &#123; # 'f1': ('test.txt', open('readme', 'rb')) # &#125; # requests.request(method='POST', # url='http://127.0.0.1:8000/test/', # files=file_dict) # 发送文件，定制文件名（文件内容通过自己输入） # file_dict = &#123; # 'f1': ('test.txt', \"hahsfaksfa9kasdjflaksdjf\") # &#125; # requests.request(method='POST', # url='http://127.0.0.1:8000/test/', # files=file_dict) # 发送文件，定制文件名 # file_dict = &#123; # 'f1': ('test.txt', \"hahsfaksfa9kasdjflaksdjf\", 'application/text', &#123;'k1': '0'&#125;) # &#125; # requests.request(method='POST', # url='http://127.0.0.1:8000/test/', # files=file_dict) passdef param_auth(): from requests.auth import HTTPBasicAuth, HTTPDigestAuth ret = requests.get('https://api.github.com/user', auth=HTTPBasicAuth('wupeiqi', 'sdfasdfasdf')) print(ret.text) # ret = requests.get('http://192.168.1.1', # auth=HTTPBasicAuth('admin', 'admin')) ##用户名和密码进行BASIC64认证，一般用不到 # ret.encoding = 'gbk' # print(ret.text) # ret = requests.get('http://httpbin.org/digest-auth/auth/user/pass', auth=HTTPDigestAuth('user', 'pass')) # print(ret) #def param_timeout(): # ret = requests.get('http://google.com/', timeout=1) # print(ret) # ret = requests.get('http://google.com/', timeout=(5, 1)) # print(ret) passdef param_allow_redirects(): ret = requests.get('http://127.0.0.1:8000/test/', allow_redirects=False) print(ret.text) # http是指通过socket.直接发消息没有加密# https有ssl加密。 # verify=False忽略证书的存在# cert = 证书文件 发送证书def param_proxies(): # proxies = &#123; # \"http\": \"61.172.249.96:80\", # \"https\": \"http://61.185.219.126:3128\", # &#125; # proxies = &#123;'http://10.20.1.128': 'http://10.10.1.10:5323'&#125; # ret = requests.get(\"http://www.proxy360.cn/Proxy\", proxies=proxies) # print(ret.headers) # from requests.auth import HTTPProxyAuth # # proxyDict = &#123; # 'http': '77.75.105.165', # 'https': '77.75.105.165' # &#125; # auth = HTTPProxyAuth('username', 'mypassword') # # r = requests.get(\"http://www.google.com\", proxies=proxyDict, auth=auth) # print(r.text) passdef param_stream(): ret = requests.get('http://127.0.0.1:8000/test/', stream=True) print(ret.content) ret.close() # from contextlib import closing # with closing(requests.get('http://httpbin.org/get', stream=True)) as r: # # 在此处理响应。为True时分段传输 # for i in r.iter_content(): # print(i)#session自动对cookie，请求头等进行处理，（保存客户端历史访问信息）def requests_session(): import requests session = requests.Session() ### 1、首先登陆任何页面，获取cookie i1 = session.get(url=\"http://dig.chouti.com/help/service\") ### 2、用户登陆，携带上一次的cookie，后台对cookie中的 gpsd 进行授权 i2 = session.post( url=\"http://dig.chouti.com/login\", data=&#123; 'phone': \"8615131255089\", 'password': \"xxxxxx\", 'oneMonth': \"\" &#125; ) i3 = session.post( url=\"http://dig.chouti.com/link/vote?linksId=8589623\", ) print(i3.text)参数示例 三、beautifulsoup4库1234567891011121314151617181920212223242526272829303132from bs4 import BeautifulSoupsoup = BeautifulSoup(response.text,feature = \"html.parser\")## feature解析引擎，html.parser为python自带引擎## lxml为第三方引擎，需要安装第三方库target = soup.find(id=\"auto-channel-lazyload-article\")li_list = target.find_all(\"li\") #根据标签查找所有的li，，， find查找第一个for li_item in li_list: a_item = li_item.find(\"a\") if a_item: href_item = \"https:\" + a_item.attrs.get(\"href\") # attrs 获得标签属性字典 # get获得标签的某个属性 print(href_item) txt = a_item.find(\"h3\").text # a_item.find(\"img\")得到的对象为tag对象，得到text需要 a_item.find(\"img\").text img_url = \"https:\" + a_item.find(\"img\").attrs.get(\"src\") print(img_url) import re # 将网址中的www3等替换为www mod = re.compile(\"^https://www\\d\") img_url = re.sub(mod, \"https://www\", img_url) # 下载并保存图片 img = requests.get(url=img_url) import uuid file_name = str(uuid.uuid4()) + \".png\" with open(file_name, \"wb\") as f: f.write(img.content) # .content 是以字节储存的内容 总结： 12345678910111213soup = BeautifulSoup(response.text,feature = \"html.parser\")#查询一个v1 = soup.find(\"div\") #标签查询v1 = soup.find(id = \"test\") #属性查询v1 = soup.find(\"div\"，id =\"test\") # 组合查询#查询所有v2 = soup.find_all(\"div\")obj = v1obj = v2[0]obj.text #内容obj.attrs #属性 自动登录点击登录，若页面刷新，以form表单提交，若为刷新，以ajax提交 form提交和ajax提交https://blog.csdn.net/gghh2015/article/details/79116718 模块详细12345678910111213141516import requestspost_dict = &#123;\"phone\": 1231234124, \"password\": \"asdfasdf\", \"loginType\": 2, &#125;response = requests.post( url=\"https://dig.chouti.com/login\", data=post_dict)response.textcookies_dict = response.cookies.get_dict()## 一般情况只需要将url和cookies发过去requests.get(url=\"asfdasf\", cookies=cookies_dict)## 查看操作时的request头 c. 模块详细使用 requests - 方法关系 requests.get(.....) requests.post(.....) requests.put(.....) requests.delete(.....) ... requests.request(&#39;POST&#39;...) - 参数 request.request - method: 提交方式 - url: 提交地址 - params: 在URL中传递的参数,GET requests.request( method=&#39;GET&#39;, url= &#39;http://www.oldboyedu.com&#39;, params = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;} ) # http://www.oldboyedu.com?k1=v1&amp;k2=v2 - data: 在请求体里传递的数据 requests.request( method=&#39;POST&#39;, url= &#39;http://www.oldboyedu.com&#39;, params = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;}, data = {&#39;use&#39;:&#39;alex&#39;,&#39;pwd&#39;: &#39;123&#39;,&#39;x&#39;:[11,2,3]} #data中不能有字典 ) #如果以data形式传递，request将数据封装为请求头和请求体 请求头: content-type: application/url-form-encod..... 请求体: use=alex&amp;pwd=123 - json 在请求体里传递的数据 requests.request( method=&#39;POST&#39;, url= &#39;http://www.oldboyedu.com&#39;, params = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;}, json = {&#39;use&#39;:&#39;alex&#39;,&#39;pwd&#39;: &#39;123&#39;} ) 请求头: content-type: application/json 请求体: &quot;{&#39;use&#39;:&#39;alex&#39;,&#39;pwd&#39;: &#39;123&#39;}&quot; PS: 字典中嵌套字典时使用json，如果没有嵌套，用data即可 - headers 请求头 requests.request( method=&#39;POST&#39;, url= &#39;http://www.oldboyedu.com&#39;, params = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;}, json = {&#39;use&#39;:&#39;alex&#39;,&#39;pwd&#39;: &#39;123&#39;}, headers={ &#39;Referer&#39;: &#39;http://dig.chouti.com/&#39;, ##上一次访问的网站 &#39;User-Agent&#39;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot; ##客户端 } ) - cookies Cookies 放到header中发送 - files 上传文件 - auth 基本认知(headers中加入加密的用户名和密码) - timeout 请求和响应的超市时间 - allow_redirects 是否允许重定向 - proxies 代理 - verify 是否忽略证书 - cert 证书文件 - stream 村长下大片 - session: 用于保存客户端历史访问信息","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[]},{"title":"数据库进阶","slug":"数据库进阶","date":"2020-06-29T13:50:04.000Z","updated":"2021-02-23T14:50:47.894Z","comments":true,"path":"2020/06/29/数据库进阶/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/","excerpt":"[toc] 数据库进阶","text":"[toc] 数据库进阶 知识预览 python关于mysql的API－－pymysql模块 事务 索引 python关于mysql的API－－pymysql模块pymsql是Python中操作MySQL的模块，其使用方法和py2的MySQLdb几乎相同。 模块安装1&#96;pip install pymysql&#96; 执行sql语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import pymysql#添加数据conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='yyy')cursor = conn.cursor()# cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) #显示key value# sql = \"\"\"CREATE TABLE EMPLOYEE (# FIRST_NAME CHAR(20) NOT NULL,# LAST_NAME CHAR(20),# AGE INT,# SEX CHAR(1),# INCOME FLOAT )\"\"\"# # cursor.execute(sql)#row_affected = cursor.execute(\"create table t1(id INT ,name VARCHAR(20))\")#row_affected=cursor.execute(\"INSERT INTO t1(id,name) values (1,'alvin'),(2,'xialv')\")#cursor.execute(\"update t1 set name = 'silv2' where id=2\")#查询数据row_affected=cursor.execute(\"select * from t1\")one=cursor.fetchone() #执行的结果# many=cursor.fetchmany(2)# all=cursor.fetchall()#scroll#cursor.scroll(-1,mode='relative') # 相对当前位置移动#cursor.scroll(2,mode='absolute') # 相对绝对位置移动#更改获取数据结果的数据类型,默认是元组,可以改为字典等:conn.cursor(cursor=pymysql.cursors.DictCursor)conn.commit()cursor.close()conn.close() 事务事务命令事务指逻辑上的一组操作，组成这组操作的各个单元，要不全部成功，要不全部不成功。 数据库开启事务命令 12345-- start transaction 开启事务-- Rollback 回滚事务,即撤销指定的sql语句(只能回退insert delete update语句)，回滚到上一次commit的位置-- Commit 提交事务，提交未存储的事务-- -- savepoint 保留点 ，事务处理中设置的临时占位符 你可以对它发布回退(与整个事务回退不同) 转账实例： 12UPDATE account set balance&#x3D;balance-5000 WHERE name&#x3D;”yuan”;UPDATE account set balance&#x3D;balance+5000 WHERE name&#x3D;”xialv”; 1234567891011121314151617181920212223242526272829303132333435create table test2(id int PRIMARY KEY auto_increment,name VARCHAR(20)) engine&#x3D;innodb;INSERT INTO test2(name) VALUE (&quot;alvin&quot;), (&quot;yuan&quot;), (&quot;xialv&quot;);start transaction;insert into test2 (name)values(&#39;silv&#39;);select * from test2;commit;-- 保留点start transaction;insert into test2 (name)values(&#39;wu&#39;);savepoint insert_wu;select * from test2;delete from test2 where id&#x3D;4;savepoint delete1;select * from test2;delete from test2 where id&#x3D;1;savepoint delete2;select * from test2;rollback to delete1;select * from test2; python中调用数据库启动事务的方式 123456789101112131415161718192021222324252627282930313233import pymysql#添加数据conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='yyy')cursor = conn.cursor()try: insertSQL0=\"INSERT INTO ACCOUNT2 (name,balance) VALUES ('oldboy',4000)\" insertSQL1=\"UPDATE account2 set balance=balance-30 WHERE name='yuan'\" insertSQL2=\"UPDATE account2 set balance=balance+30 WHERE name='xialv'\" cursor = conn.cursor() cursor.execute(insertSQL0) conn.commit() cursor.execute(insertSQL1) raise Exception cursor.execute(insertSQL2) cursor.close() conn.commit()except Exception as e: conn.rollback() conn.commit()cursor.close()conn.close() 事务特性&lt;1&gt; 原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 &lt;2&gt; 一致性（Consistency）：事务前后数据的完整性必须保持一致。在事务执行之前数据库是符合数据完整性约束的，无论事务是否执行成功，事务结束后的数据库中的数据也应该是符合完整性约束的。在某一时间点，如果数据库中的所有记录都能保证满足当前数据库中的所有约束，则可以说当前的数据库是符合数据完整性约束的。比如删部门表前应该删掉关联员工（已经建立外键），如果数据库服务器发生错误，有一个员工没删掉，那么此时员工的部门表已经删除，那么就不符合完整性约束了，所以这样的数据库也就性能太差啦！ &lt;3&gt;隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。 &lt;4&gt;持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 三、隔离性：将数据库设计为串行化程的数据库，让一张表在同一时间内只能有一个线程来操作。如果将数据库设计为这样，那数据库的效率太低了。所以数据库的设计这没有直接将数据库设计为串行化，而是为数据库提供多个隔离级别选项，使数据库的使用者可以根据使用情况自己定义到底需要什么样的隔离级别。 不考虑隔离性可能出现的问题： 脏读 1234567891011121314--一个事务读取到了另一个事务未提交的数据,这是特别危险的，要尽力防止。 a 1000 b 1000 a: start transaction； update set money&#x3D;money+100 where name&#x3D;b; b: start transaction; select * from account where name&#x3D;b;--1100 commit; a: rollback; b: start transaction; select * from account where name&#x3D;b;--1000 不可重复读 123456789101112131415--在一个事务内读取表中的某一行数据，多次读取结果不同。（一个事务读取到了另一个事务已经提交-- 的数据--增加记录、删除记录、修改记录），在某写情况下并不是问题，在另一些情况下就是问题。a:start transaction;select 活期账户 from account where name&#x3D;b;--1000 活期账户：1000select 定期账户 from account where name&#x3D;b；--1000 定期账户:1000select 固定资产 from account where name&#x3D;b；--1000 固定资产：1000------------------------------b:start transaction;update set money&#x3D;0 where name&#x3D;b;commit;------------------------------select 活期+定期+固定 from account where name&#x3D;b; --2000 总资产： 2000 虚读 123456789101112131415是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。（一个事务读取到了另一个事务已经提交的数据---增加记录、删除记录），在某写情况下并不是问题，在另一些情况下就是问题。b 1000c 2000d 3000a:start transactionselect sum(money) from account;---3000 3000-------------------d:start transaction;insert into account values(d,3000);commit;-------------------select count(*)from account;---3 33000&#x2F;3 &#x3D; 1000 1000 四个隔离级别：Serializable：可避免脏读、不可重复读、虚读情况的发生。（串行化）Repeatable read：可避免脏读、不可重复读情况的发生。（可重复读）不可以避免虚读Read committed：可避免脏读情况发生（读已提交）Read uncommitted：最低级别，以上情况均无法保证。(读未提交) 安全性考虑：Serializable&gt;Repeatable read&gt;Read committed&gt;Read uncommitted数据库效率：Read uncommitted&gt;Read committed&gt;Repeatable read&gt;Serializable 一般情况下，我们会使用Repeatable read、Read committed mysql数据库默认的数据库隔离级别Repeatable read mysql中设置数据库的隔离级别语句： 1&#96;set&#96; &#96;[&#96;&#96;global&#96;&#96;&#x2F;session] &#96;&#96;transaction&#96; &#96;isolation&#96; &#96;level&#96; &#96;xxxx;&#96; 如果使用global则修改的是数据库的默认隔离级别，所有新开的窗口的隔离级别继承自这个默认隔离级别如果使用session修改，则修改的是当前客户端的隔离级别，和数据库默认隔离级别无关。当前的客户端是什么隔离级别，就能防止什么隔离级别问题，和其他客户端是什么隔离级别无关。mysql中设置数据库的隔离级别语句： 1&#96;select&#96; &#96;@@tx_isolation;&#96; 索引索引简介索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。 索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。 索引特点：创建与维护索引会消耗很多时间与磁盘空间，但查询速度大大提高！ 索引语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677--创建表时--语法： CREATE TABLE 表名 ( 字段名1 数据类型 [完整性约束条件…], 字段名2 数据类型 [完整性约束条件…], [UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY [索引名] (字段名[(长度)] [ASC |DESC]) );----------------------------------创建普通索引示例： CREATE TABLE emp1 ( id INT, name VARCHAR(30) , resume VARCHAR(50), INDEX index_emp_name (name) --KEY index_dept_name (dept_name) );--创建唯一索引示例： CREATE TABLE emp2 ( id INT, name VARCHAR(30) , bank_num CHAR(18) UNIQUE , resume VARCHAR(50), UNIQUE INDEX index_emp_name (name) );--创建全文索引示例： CREATE TABLE emp3 ( id INT, name VARCHAR(30) , resume VARCHAR(50), FULLTEXT INDEX index_resume (resume) );--创建多列索引示例： CREATE TABLE emp4 ( id INT, name VARCHAR(30) , resume VARCHAR(50), INDEX index_name_resume (name, resume) );------------------------------------添加索引 ---CREATE在已存在的表上创建索引 CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 ON 表名 (字段名[(长度)] [ASC |DESC]) ; ---ALTER TABLE在已存在的表上创建索引 ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 (字段名[(长度)] [ASC |DESC]) ; CREATE INDEX index_emp_name on emp1(name); ALTER TABLE emp2 ADD UNIQUE INDEX index_bank_num(band_num);-- 删除索引 语法：DROP INDEX 索引名 on 表名 DROP INDEX index_emp_name on emp1; DROP INDEX bank_num on emp2; 索引测试实验12345678910111213141516171819202122232425262728--创建表create table Indexdb.t1(id int,name varchar(20));--存储过程delimiter $$create procedure autoinsert() BEGINdeclare i int default 1;while(i&lt;500000)doinsert into Indexdb.t1 values(i,&#39;yuan&#39;);set i&#x3D;i+1;end while;END$$delimiter ;--调用函数call autoinsert();-- 花费时间比较：-- 创建索引前 select * from Indexdb.t1 where id&#x3D;300000;--0.32s-- 添加索引 create index index_id on Indexdb.t1(id);-- 创建索引后 select * from Indexdb.t1 where id&#x3D;300000;--0.00s","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"应用","slug":"Python/应用","permalink":"https://sjtu-xx.github.io/categories/Python/%E5%BA%94%E7%94%A8/"}],"tags":[]},{"title":"数据库","slug":"数据库","date":"2020-06-29T13:48:54.000Z","updated":"2021-02-25T08:01:45.460Z","comments":true,"path":"2020/06/29/数据库/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"数据库","text":"数据库 数据库的简介数据库数据库（database，DB）是指长期存储在计算机内的，有组织，可共享的数据的集合。数据库中的数据按一定的数学模型组织、描述和存储，具有较小的冗余，较高的数据独立性和易扩展性，并可为各种用户共享。 数据库管理系统软件数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过DBMS访问数据库中的数据，数据库管理员也通过dbms进行数据库的维护工作。它可使多个应用程序和用户用不同的方法在同时或不同时刻去建立，修改和询问数据库。大部分DBMS提供数据定义语言DDL（Data Definition Language）和数据操作语言DML（Data Manipulation Language），供用户定义数据库的模式结构与权限约束，实现对数据的追加、删除等操作。 数据库管理系统是数据库系统的核心，是管理数据库的软件。数据库管理系统就是实现把用户意义下抽象的逻辑数据处理，转换成为计算机中具体的物理数据处理的软件。有了数据库管理系统，用户就可以在抽象意义下处理数据，而不必顾及这些数据在计算机中的布局和物理位置。 常见的数据库管理软件：甲骨文的oracle,IBM的db2，sql server, Access,Mysql(开源，免费，跨平台). 数据库系统数据库系统DBS（Data Base System，简称DBS）通常由软件、数据库和数据管理员组成。其软件主要包括操作系统、各种宿主语言、实用程序以及数据库管理系统。数据库由数据库管理系统统一管理，数据的插入、修改和检索均要通过数据库管理系统进行。数据管理员负责创建、监控和维护整个数据库，使数据能被任何有权使用的人有效使用。 MySQLmysql的管理安装mac： https://www.jianshu.com/p/07a9826898c0 linux: 123--yum -y install mariadb mariadb-serverOR--yum -y install mysql mysql-server win: 1--http:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;mysql&#x2F; 解压 放在环境目录下 配置环境变量 在解压目录新建配置文件my.ini 12345[mysqld]basedir=D:\\Environment\\mysql-8.0.23\\datadir=D:\\Environment\\mysql-8.0.23\\data\\port=3306skip-grant-tables 管理员cmd，执行mysqld --install 初始化数据文件mysqld --initialize-insecure --user=mysql 启动mysql：net start mysql 进入管理界面：mysql -u root -p 修改密码alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;123456&#39;; 注释掉ini中的跳过密码 重启mysql。连接测试。 启动12345--service mysqld start #开启--chkconfig mysqld on #设置开机自启OR--systemctl start mariadb--systemctl enable mariadb 查看12-- ps aux |grep mysqld #查看进程-- netstat -an |grep 3306 #查看端口 设置密码12-- mysqladmin -uroot password '123' #设置初始密码，初始密码为空因此-p选项没有用-- mysqladmin -u root -p123 password '1234' #修改root用户密码 登录123-- mysql #本地登录，默认用户root，空密码，用户为root@127.0.0.1-- mysql -uroot -p1234 #本地登录，指定用户名和密码，用户为root@127.0.0.1-- mysql -uroot -p1234 -h 192.168.31.95 #远程登录，用户为root@192.168.31.95 mysql的常用命令123456789101112131415161718192021222324252627-- 启动mysql服务与停止mysql服务命令：net start mysqlnet stop mysql-- 登陆与退出命令：mysql －h 服务器IP -P 端口号 -u 用户名 -p 密码 －－prompt 命令提示符 －－delimiter 指定分隔符mysql －h 127.0.0.1 -P 3306 -uroot -p123exit-- 刷新权限flush privileges;-- my.ini文件：[mysql] default-character-set=gbk [mysqld] character-set-server=gbk-- prompt 命令提示符（\\D:当前日期 \\d:当前数据库 \\u:当前用户 \\T开始日志 \\t结束日志)show warnings;help();select now();select version();select user;delimiter 指定分隔符 忘记密码怎么办？方法1：启动mysql时，跳过授权表1234567891011121314151617181920[root@controller ~]# service mysqld stop[root@controller ~]# mysqld_safe --skip-grant-table &amp;[root@controller ~]# mysqlmysql&gt; select user,host,password from mysql.user;+----------+-----------------------+-------------------------------------------+| user | host | password |+----------+-----------------------+-------------------------------------------+| root | localhost | *A4B6157319038724E3560894F7F932C8886EBFCF || root | localhost.localdomain | || root | 127.0.0.1 | || root | ::1 | || | localhost | || | localhost.localdomain | || root | % | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |+----------+-----------------------+-------------------------------------------+mysql&gt; update mysql.user set password=password(\"123\") where user=\"root\" and host=\"localhost\";mysql&gt; flush privileges;mysql&gt; exit[root@controller ~]# service mysqld restart[root@controller ~]# mysql -uroot -p123 方法2(删库):1234删除与权限相关的库mysql，所有的授权信息都丢失，主要用于测试数据库或者刚刚建库不久没有授权数据的情况（从删库到跑路）[root@controller ~]# rm -rf /var/lib/mysql/mysql[root@controller ~]# service mysqld restart[root@controller ~]# mysql sql及其规范sql是Structured Query Language(结构化查询语言)的缩写。SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。 在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。SQL功能强大、简单易学、使用方便，已经成为了数据库操作的基础，并且现在几乎所有的数据库均支持sql。 &lt;1&gt; 在数据库系统中，SQL语句不区分大小写(建议用大写) 。但字符串常量区分大小写。建议命令大写，表名库名小写； 表名称尽量使用`符号括起来 字符串用单引号括起来 &lt;2&gt; SQL语句可单行或多行书写，以“;”结尾。关键词不能跨多行或简写。 &lt;3&gt; 用空格和缩进来提高语句的可读性。子句通常位于独立行，便于编辑，提高可读性。 12SELECT * FROM tb_table WHERE NAME&#x3D;&quot;YUAN&quot;; &lt;4&gt; 注释：单行注释：– ​ 多行注释：/*……*/ &lt;5&gt;sql语句可以折行操作 &lt;6&gt; DDL,DML和DCL 12345678910--SQL中 DML、DDL、DCL区别 .-- DML（data manipulation language）：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言-- DDL（data definition language）：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE） 的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用-- DCL（Data Control Language）：是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL 数据库操作(DDL)1234567891011121314151617181920-- 1.创建数据库（在磁盘上创建一个对应的文件夹） create database [if not exists] db_name [character set xxx][collate utf8_general_ci]; character set gbk设置编码方式 collate设置字符串比较的方式 -- 2.查看数据库 show databases;查看所有数据库 show create database db_name; 查看数据库的创建方式 show warnings; 查看警告信息-- 3.修改数据库 alter database db_name [character set xxx] -- 4.删除数据库 drop database [if exists] db_name; -- 5.使用数据库 切换数据库 use db_name; -- 注意：进入到某个数据库后没办法再退回之前状态，但可以通过use进行切换 查看当前使用的数据库 select database();-- 6.显示表信息 describe db_name; mysql数据类型MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 123BIT 位类型BOOLEAN ---&gt;自动转换为tinyint(1)BOOL 数值类型下面的表显示了需要的每个整数类型的存储和范围。 1float(4,2) &#x2F;*共4位，小数点后2位，99.99*&#x2F; 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 12char(10) &#x2F;*定长字符串，10字节*&#x2F;varchar(20) &#x2F;*变长字符串，0～20字节*&#x2F; CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。 BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。 有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。 数据表操作每张表固定有几个字段： 12345id 主键version 乐观锁is_delete 伪删除gmt_create 创建时间gmt_update 修改时间 基础操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596-- 1.创建表（类似于一个excel表） create table tab_name( field1 type[完整性约束条件], field2 type, ... fieldn type )[engine&#x3D;][character set&#x3D;xxx]; -- collate用于指明order的顺序 -- 创建一个员工表employee create table employee( id int primary key auto_increment , name varchar(20), gender bit default 1, -- gender char(1) default 1 ----- 或者 TINYINT(1) birthday date, entry_date date, job varchar(20), salary double(4,2) unsigned, resume text -- 注意，这里作为最后一个字段不加逗号 ); &#x2F;* 约束: primary key (非空且唯一) :能够唯一区分出当前记录的字段称为主键！ 为索引 unique not null auto_increment 主键字段必须是数字类型。 外键约束 foreign key *&#x2F;-- 2.查看表信息 desc tab_name 查看表结构 show columns from tab_name 查看表结构 show tables 查看当前数据库中的所有的表 show create table tab_name 查看当前数据库表建表语句 -- 3.修改表结构 -- (1)增加列(字段) alter table tab_name add [column] 列名 类型［完整性约束条件］［first｜after 字段名］; alter table user add addr varchar(20) not null unique first&#x2F;after username; #添加多个字段 alter table users2 add addr varchar(20), add age int first, add birth varchar(20) after name; -- (2)修改一列类型 alter table tab_name modify 列名 类型 [完整性约束条件]［first｜after 字段名］; alter table test_table modify test_col tinyint not null after id; #after调整顺序 alter table users2 modify age tinyint default 20; alter table users2 modify age int after id; -- (3)修改列名 alter table tab_name change [column] 列名 新列名 类型 [完整性约束条件]［first｜after 字段名］; alter table users2 change age Age int default 28 first; -- (4)删除一列 alter table tab_name drop [column] 列名; -- 思考：删除多列呢？删一个填一个呢？ alter table users2 add salary float(6,2) unsigned not null after name, drop addr; -- (5)修改表名 rename table 表名 to 新表名; -- (6)修该表所用的字符集 alter table student character set utf8;-- 4.删除表 drop table tab_name;-- 5 添加主键，删除主键 alter table tab_name add primary key(字段名称,...) alter table users drop primary key; eg: mysql&gt; create table test5(num int auto_increment); ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key create table test(num int primary key auto_increment); -- 思考，如何删除主键？ alter table test modify id int; -- auto_increment没了，但这样写主键依然存在，所以还要加上下面这句 alter table test drop primary key;-- 仅仅用这句也无法直接删除主键-- 唯一索引 alter table tab_name add unique [index|key] [索引名称](字段名称,...) alter table users add unique(name)-- 索引值默认为字段名show create table users; alter table users add unique key user_name(name);-- 索引值为user_name -- 添加联合索引 alter table users add unique index name_age(name,age);#show create table users; -- 删除唯一索引 alter table tab_name drop &#123;index|key&#125; index_name 完整性约束条件之主键约束单字段主键 主键字段特点：非空且唯一 12345create table users( id INT primary key, name varchar(20), city varchar(20) ); 多字段联合主键 123456create table users2( id INT, name varchar(20), city varchar(20), primary key(name,id) ); &lt;1&gt; 一张表只能有一个主键 &lt;2&gt; 主键类型不一定非是整型 表纪录操作表纪录之增，删，改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-- 1.增加一条记录insert &#x2F;*insert ［into］ tab_name (field1,filed2,.......) values (value1,value2,.......);*&#x2F; create table employee_new( id int primary key auto_increment, name varchar(20) not null unique, birthday varchar(20), salary float(7,2) ); insert into employee_new (id,name,birthday,salary) values (1,&#39;yuan&#39;,&#39;1990-09-09&#39;,9000); insert into employee_new values (2,&#39;alex&#39;,&#39;1989-08-08&#39;,3000); insert into employee_new (name,salary) values (&#39;xialv&#39;,1000); -- 插入多条数据 insert into employee_new values (4,&#39;alvin1&#39;,&#39;1993-04-20&#39;,3000), (5,&#39;alvin2&#39;,&#39;1995-05-12&#39;,5000); -- set插入: insert ［into］ tab_name set 字段名&#x3D;值 insert into employee_new set id&#x3D;12,name&#x3D;&quot;alvin3&quot;;-- 2.修改表记录 update tab_name set field1&#x3D;value1,field2&#x3D;value2,......[where 语句] &#x2F;* UPDATE语法可以用新值更新原有表行中的各列。 SET子句指示要修改哪些列和要给予哪些值。 WHERE子句指定应更新哪些行。如没有WHERE子句，则更新所有的行。*&#x2F; update employee_new set birthday&#x3D;&quot;1989-10-24&quot; WHERE id&#x3D;1; --- 将yuan的薪水在原有基础上增加1000元。 update employee_new set salary&#x3D;salary+4000 where name&#x3D;&#39;yuan&#39;;-- 3.删除表纪录 delete from tab_name [where ....] &#x2F;* 如果不跟where语句则删除整张表中的数据 delete只能用来删除一行记录 delete语句只能删除表中的内容，不能删除表本身，想要删除表，用drop TRUNCATE TABLE也可以删除表中的所有数据，词语句首先摧毁表，再新建表。此种方式删除的数据不能在事务中恢复。*&#x2F;105211 -- 删除表中名称为’alex’的记录。 delete from employee_new where name&#x3D;&#39;alex&#39;; -- 删除表中所有记录。（一条一条删除） delete from employee_new;-- 注意auto_increment没有被重置:alter table employee auto_increment&#x3D;1; -- 使用truncate删除表中记录。(直接删除表) truncate table emp_new; 思考： ​ &lt;1&gt; 存储时间用varchar可不可以呢？它与date数据类型又有什么区别呢？（只用来显示时，可以用varchar，如果要计算用date） ​ &lt;2&gt; 表中数据三条，id分别为1，2，3，突然插入一个id＝7，那么下次作为主键的字增长的id会从几开始增长呢？(从7开始) 表纪录之查(单表查询)运算符 运算符 语法 描述 is null a is null is not null a is not null between a between b and c like a like b in a in (a1,a2,a3) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234-- 查询表达式 SELECT *|field1,filed2 ... FROM tab_name WHERE 条件 GROUP BY field HAVING 筛选 ORDER BY field LIMIT 限制条数 ---准备表 CREATE TABLE ExamResult( id INT PRIMARY KEY auto_increment, name VARCHAR (20), JS DOUBLE , Django DOUBLE , OpenStack DOUBLE);INSERT INTO ExamResult VALUES (1,&quot;yuan&quot;,98,98,98), (2,&quot;xialv&quot;,35,98,67), (3,&quot;alex&quot;,59,59,62), (4,&quot;wusir&quot;,88,89,82), (5,&quot;alvin&quot;,88,98,67), (6,&quot;yuan&quot;,86,100,55);-- （1）select [distinct] *|field1，field2，...... from tab_name -- 其中from指定从哪张表筛选，*表示查找所有列，也可以指定一个列 -- 表明确指定要查找的列，distinct用来剔除重复行。 -- 查询表中所有学生的信息。 select * from ExamResult; -- 查询表中所有学生的姓名和对应的英语成绩。 select name,JS from ExamResult; -- 过滤表中重复数据。 select distinct JS ,name from ExamResult;-- （2）select 也可以使用表达式，并且可以使用: 字段 as 别名或者:字段 别名 -- 在所有学生分数上加10分特长分显示。 select name,JS+10,Django+10,OpenStack+10 from ExamResult; -- 统计每个学生的总分。 select name,JS+Django+OpenStack from ExamResult; -- 使用别名表示学生总分。 select name as 姓名,JS+Django+OpenStack as 总成绩 from ExamResult; select name,JS+Django+OpenStack 总成绩 from ExamResult; select name JS from ExamResult; -- what will happen?----&gt;记得加逗号-- （3）使用where子句，进行过滤查询。 -- 查询姓名为XXX的学生成绩 select * from ExamResult where name&#x3D;&#39;yuan&#39;; -- 查询英语成绩大于90分的同学 select id,name,JS from ExamResult where JS&gt;90; -- 查询总分大于200分的所有同学 select name,JS+Django+OpenStack as 总成绩 from ExamResult where JS+Django+OpenStack&gt;200 ; -- where字句中可以使用： -- 比较运算符： &gt; &lt; &gt;&#x3D; &lt;&#x3D; &lt;&gt; !&#x3D; between 80 and 100 值在10到20之间 in(80,90,100) 值是10或20或30 like &#39;yuan%&#39; &#x2F;* pattern可以是%或者_， 如果是%则表示任意多字符，此例如唐僧,唐国强 如果是_则表示一个字符唐_，只有唐僧符合。两个_则表示两个字符：__ *&#x2F; -- 逻辑运算符 在多个条件直接可以使用逻辑运算符 and or not -- 练习 -- 查询JS分数在 70－100之间的同学。 select name ,JS from ExamResult where JS between 80 and 100; -- 查询Django分数为75,76,77的同学。 select name ,Django from ExamResult where Django in (75,98,77); -- 查询所有姓王的学生成绩。 select * from ExamResult where name like &#39;王%&#39;; -- 查询JS分&gt;90，Django分&gt;90的同学。 select id,name from ExamResult where JS&gt;90 and Django &gt;90; -- 查找缺考数学的学生的姓名 select name from ExamResult where Database is null;-- （4）Order by 指定排序的列，排序的列即可是表中的列名，也可以是select 语句后指定的别名。 -- select *|field1,field2... from tab_name order by field [Asc|Desc] -- Asc 升序、Desc 降序，其中asc为默认值 ORDER BY 子句应位于SELECT语句的结尾。 -- 练习： -- 对JS成绩排序后输出。 select * from ExamResult order by JS; -- 对总分排序按从高到低的顺序输出 select name ,(ifnull(JS,0)+ifnull(Django,0)+ifnull(Database,0)) 总成绩 from ExamResult order by 总成绩 desc; -- 对姓李的学生成绩排序输出 select name ,(ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0)) 总成绩 from ExamResult where name like &#39;a%&#39; order by 总成绩 desc;-- （5）group by 分组查询： CREATE TABLE order_menu( id INT PRIMARY KEY auto_increment, product_name VARCHAR (20), price FLOAT(6,2), born_date DATE, class VARCHAR (20) ); INSERT INTO order_menu (product_name,price,born_date,class) VALUES (&quot;苹果&quot;,20,20170612,&quot;水果&quot;), (&quot;香蕉&quot;,80,20170602,&quot;水果&quot;), (&quot;水壶&quot;,120,20170612,&quot;电器&quot;), (&quot;被罩&quot;,70,20170612,&quot;床上用品&quot;), (&quot;音响&quot;,420,20170612,&quot;电器&quot;), (&quot;床单&quot;,55,20170612,&quot;床上用品&quot;), (&quot;草莓&quot;,34,20170612,&quot;水果&quot;); -- 注意,按分组条件分组后每一组只会显示第一条记录 -- group by字句，其后可以接多个列名，也可以跟having子句,对group by 的结果进行筛选。 -- 按位置字段筛选 select * from order_menu group by 5; -- 练习：对购物表按类名分组后显示每一组商品的价格总和 select class,SUM(price)from order_menu group by class; -- 练习：对购物表按类名分组后显示每一组商品价格总和超过150的商品 select class,SUM(price)from order_menu group by class HAVING SUM(price)&gt;150; &#x2F;* having 和 where两者都可以对查询结果进行进一步的过滤，差别有： &lt;1&gt;where语句只能用在分组之前的筛选，having可以用在分组之后的筛选； &lt;2&gt;使用where语句的地方都可以用having进行替换 &lt;3&gt;having中可以用聚合函数，where中就不行。 *&#x2F; -- GROUP_CONCAT() 函数 SELECT id,GROUP_CONCAT(name),GROUP_CONCAT(JS) from ExamResult GROUP BY id;-- （6）聚合函数： 先不要管聚合函数要干嘛，先把要求的内容查出来再包上聚合函数即可。 -- (一般和分组查询配合使用) --&lt;1&gt; 统计表中所有记录 -- COUNT(列名)：统计行的个数 -- 统计一个班级共有多少学生？先查出所有的学生，再用count包上 select count(*) from ExamResult; -- 统计JS成绩大于70的学生有多少个？ select count(JS) from ExamResult where JS&gt;70; -- 统计总分大于280的人数有多少？ select count(name) from ExamResult where (ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0))&gt;280; -- 注意:count(*)统计所有行; count(字段)不统计null值. -- SUM(列名)：统计满足条件的行的内容和 -- 统计一个班级JS总成绩？先查出所有的JS成绩，再用sum包上 select JS as JS总成绩 from ExamResult; select sum(JS) as JS总成绩 from ExamResult; -- 统计一个班级各科分别的总成绩 select sum(JS) as JS总成绩, sum(Django) as Django总成绩, sum(OpenStack) as OpenStack from ExamResult; -- 统计一个班级各科的成绩总和 select sum(ifnull(JS,0)+ifnull(Django,0)+ifnull(Database,0)) as 总成绩 from ExamResult; -- 统计一个班级JS成绩平均分 select sum(JS)&#x2F;count(*) from ExamResult ; -- 注意：sum仅对数值起作用，否则会报错。 -- AVG(列名)： -- 求一个班级JS平均分？先查出所有的JS分，然后用avg包上。 select avg(ifnull(JS,0)) from ExamResult; -- 求一个班级总分平均分 select avg((ifnull(JS,0)+ifnull(Django,0)+ifnull(Database,0))) from ExamResult ; -- Max、Min -- 求班级最高分和最低分（数值范围在统计中特别有用） select Max((ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0))) 最高分 from ExamResult; select Min((ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0))) 最低分 from ExamResult; -- 求购物表中单价最高的商品名称及价格 ---SELECT id, MAX(price) FROM order_menu;--id和最高价商品是一个商品吗? SELECT MAX(price) FROM order_menu; -- 注意：null 和所有的数计算都是null，所以需要用ifnull将null转换为0！ -- -----ifnull(JS,0) -- with rollup的使用 --&lt;2&gt; 统计分组后的组记录-- （7） 重点：Select from where group by having order by -- Mysql在执行sql语句时的执行顺序： -- from where select group by having order by -- 分析: select JS as JS成绩 from ExamResult where JS成绩 &gt;70; ---- 不成功 select JS as JS成绩 from ExamResult having JS成绩 &gt;90; --- 成功-- (8) limit SELECT * from ExamResult limit 1; --显示第一条 SELECT * from ExamResult limit 2,5; --跳过前两条显示接下来的五条纪录 SELECT * from ExamResult limit 2,2;-- (9) 使用正则表达式查询 SELECT * FROM employee WHERE emp_name REGEXP &#39;^yu&#39;; SELECT * FROM employee WHERE emp_name REGEXP &#39;yun$&#39;; SELECT * FROM employee WHERE emp_name REGEXP &#39;m&#123;2&#125;&#39;; 外键约束创建外键外键一定要和关联主键的数据类型保持一致 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859方法1create table test( &#96;id&#96; int, key &#96;fk_id&#96;(&#96;id&#96;), constraint &#96;fk_id&#96; foreign key (&#96;id&#96;) references &#96;student&#96;(&#96;id&#96;))方法2--- 每一个班主任会对应多个学生 , 而每个学生只能对应一个班主任----主表CREATE TABLE ClassCharger( id TINYINT PRIMARY KEY auto_increment, name VARCHAR (20), age INT , is_marriged boolean -- show create table ClassCharger: tinyint(1));INSERT INTO ClassCharger (name,age,is_marriged) VALUES (&quot;冰冰&quot;,12,0), (&quot;丹丹&quot;,14,0), (&quot;歪歪&quot;,22,0), (&quot;姗姗&quot;,20,0), (&quot;小雨&quot;,21,0);----子表CREATE TABLE Student( id INT PRIMARY KEY auto_increment, name VARCHAR (20), charger_id TINYINT, --切记:作为外键一定要和关联主键的数据类型保持一致 -- [ADD CONSTRAINT charger_fk_student FOREIGN KEY (charger_id) REFERENCES ClassCharger(id)) ENGINE&#x3D;INNODB;INSERT INTO Student(name,charger_id) VALUES (&quot;alvin1&quot;,2), (&quot;alvin2&quot;,4), (&quot;alvin3&quot;,1), (&quot;alvin4&quot;,3), (&quot;alvin5&quot;,1), (&quot;alvin6&quot;,3), (&quot;alvin7&quot;,2);DELETE FROM ClassCharger WHERE name&#x3D;&quot;冰冰&quot;;INSERT student (name,charger_id) VALUES (&quot;yuan&quot;,1);-- 删除居然成功,可是 alvin3显示还是有班主任id&#x3D;1的冰冰的;-----------增加外键和删除外键---------ALTER TABLE student ADD CONSTRAINT abc FOREIGN KEY(charger_id) REFERENCES classcharger(id);ALTER TABLE student DROP FOREIGN KEY abc; INNODB支持的ON语句123456789101112131415161718192021222324252627--外键约束对子表的含义: 如果在父表中找不到候选键,则不允许在子表上进行insert&#x2F;update--外键约束对父表的含义: 在父表上进行update&#x2F;delete以更新或删除在子表中有一条或多条对 -- 应匹配行的候选键时,父表的行为取决于：在定义子表的外键时指定的 -- on update&#x2F;on delete子句-----------------innodb支持的四种方式--------------------------------------------cascade方式 在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录-----外键的级联删除：如果父表中的记录被删除，则子表中对应的记录自动被删除-------- FOREIGN KEY (charger_id) REFERENCES ClassCharger(id) ON DELETE CASCADE------set null方式 在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null -- 要注意子表的外键列不能为not null FOREIGN KEY (charger_id) REFERENCES ClassCharger(id) ON DELETE SET NULL------Restrict方式 :拒绝对父表进行删除更新操作(了解)------No action方式 在mysql中同Restrict,如果子表中有匹配的记录,则不允许对父表对应候选键 -- 进行update&#x2F;delete操作（了解） MYISAM INNODB 事务支持 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文索引 支持 支持 表空间大小 较小 较大，约为2倍 MYISAM节约空间，速度较快 INNODB安全性高，事物的处理，多表多用户操作 多表查询准备表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354-- 准备两张表-- company.employee-- company.department create table employee( emp_id int auto_increment primary key not null, emp_name varchar(50), age int, dept_id int ); insert into employee(emp_name,age,dept_id) values (&#39;A&#39;,19,200), (&#39;B&#39;,26,201), (&#39;C&#39;,30,201), (&#39;D&#39;,24,202), (&#39;E&#39;,20,200), (&#39;F&#39;,38,204); create table department( dept_id int, dept_name varchar(100) ); insert into department values (200,&#39;人事部&#39;), (201,&#39;技术部&#39;), (202,&#39;销售部&#39;), (203,&#39;财政部&#39;);mysql&gt; select * from employee;+--------+----------+------+---------+| emp_id | emp_name | age | dept_id |+--------+----------+------+---------+| 1 | A | 19 | 200 || 2 | B | 26 | 201 || 3 | C | 30 | 201 || 4 | D | 24 | 202 || 5 | E | 20 | 200 || 6 | F | 38 | 204 |+--------+----------+------+---------+6 rows in set (0.00 sec)mysql&gt; select * from department;+---------+-----------+| dept_id | dept_name |+---------+-----------+| 200 | 人事部 || 201 | 技术部 || 202 | 销售部 || 203 | 财政部 |+---------+-----------+4 rows in set (0.01 sec) 多表查询之连接查询1.笛卡尔积查询123456789101112131415161718192021222324252627282930313233mysql&gt; SELECT * FROM employee,department;-- select employee.emp_id,employee.emp_name,employee.age,-- department.dept_name from employee,department;+--------+----------+------+---------+---------+-----------+| emp_id | emp_name | age | dept_id | dept_id | dept_name |+--------+----------+------+---------+---------+-----------+| 1 | A | 19 | 200 | 200 | 人事部 || 1 | A | 19 | 200 | 201 | 技术部 || 1 | A | 19 | 200 | 202 | 销售部 || 1 | A | 19 | 200 | 203 | 财政部 || 2 | B | 26 | 201 | 200 | 人事部 || 2 | B | 26 | 201 | 201 | 技术部 || 2 | B | 26 | 201 | 202 | 销售部 || 2 | B | 26 | 201 | 203 | 财政部 || 3 | C | 30 | 201 | 200 | 人事部 || 3 | C | 30 | 201 | 201 | 技术部 || 3 | C | 30 | 201 | 202 | 销售部 || 3 | C | 30 | 201 | 203 | 财政部 || 4 | D | 24 | 202 | 200 | 人事部 || 4 | D | 24 | 202 | 201 | 技术部 || 4 | D | 24 | 202 | 202 | 销售部 || 4 | D | 24 | 202 | 203 | 财政部 || 5 | E | 20 | 200 | 200 | 人事部 || 5 | E | 20 | 200 | 201 | 技术部 || 5 | E | 20 | 200 | 202 | 销售部 || 5 | E | 20 | 200 | 203 | 财政部 || 6 | F | 38 | 204 | 200 | 人事部 || 6 | F | 38 | 204 | 201 | 技术部 || 6 | F | 38 | 204 | 202 | 销售部 || 6 | F | 38 | 204 | 203 | 财政部 |+--------+----------+------+---------+---------+-----------+ 2.内连接1234567891011121314-- 查询两张表中都有的关联数据,相当于利用条件从笛卡尔积结果中筛选出了正确的结果。 select * from employee,department where employee.dept_id &#x3D; department.dept_id;--select * from employee inner join department on employee.dept_id &#x3D; department.dept_id; +--------+----------+------+---------+---------+-----------+ | emp_id | emp_name | age | dept_id | dept_id | dept_name | +--------+----------+------+---------+---------+-----------+ | 1 | A | 19 | 200 | 200 | 人事部 | | 2 | B | 26 | 201 | 201 | 技术部 | | 3 | C | 30 | 201 | 201 | 技术部 | | 4 | D | 24 | 202 | 202 | 销售部 | | 5 | E | 20 | 200 | 200 | 人事部 | +--------+----------+------+---------+---------+-----------+ 3.外连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354--（1）左外连接：在内连接的基础上增加左边有右边没有的结果left join可以连续使用 select * from employee left join department on employee.dept_id &#x3D; department.dept_id; +--------+----------+------+---------+---------+-----------+ | emp_id | emp_name | age | dept_id | dept_id | dept_name | +--------+----------+------+---------+---------+-----------+ | 1 | A | 19 | 200 | 200 | 人事部 | | 5 | E | 20 | 200 | 200 | 人事部 | | 2 | B | 26 | 201 | 201 | 技术部 | | 3 | C | 30 | 201 | 201 | 技术部 | | 4 | D | 24 | 202 | 202 | 销售部 | | 6 | F | 38 | 204 | NULL | NULL | +--------+----------+------+---------+---------+-----------+ --（2）右外连接：在内连接的基础上增加右边有左边没有的结果 select * from employee RIGHT JOIN department on employee.dept_id &#x3D; department.dept_id; +--------+----------+------+---------+---------+-----------+ | emp_id | emp_name | age | dept_id | dept_id | dept_name | +--------+----------+------+---------+---------+-----------+ | 1 | A | 19 | 200 | 200 | 人事部 | | 2 | B | 26 | 201 | 201 | 技术部 | | 3 | C | 30 | 201 | 201 | 技术部 | | 4 | D | 24 | 202 | 202 | 销售部 | | 5 | E | 20 | 200 | 200 | 人事部 | | NULL | NULL | NULL | NULL | 203 | 财政部 | +--------+----------+------+---------+---------+-----------+ --（3）全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果 -- mysql不支持全外连接 full JOIN -- mysql可以使用此种方式间接实现全外连接 select * from employee RIGHT JOIN department on employee.dept_id &#x3D; department.dept_id UNION select * from employee LEFT JOIN department on employee.dept_id &#x3D; department.dept_id; +--------+----------+------+---------+---------+-----------+ | emp_id | emp_name | age | dept_id | dept_id | dept_name | +--------+----------+------+---------+---------+-----------+ | 1 | A | 19 | 200 | 200 | 人事部 | | 2 | B | 26 | 201 | 201 | 技术部 | | 3 | C | 30 | 201 | 201 | 技术部 | | 4 | D | 24 | 202 | 202 | 销售部 | | 5 | E | 20 | 200 | 200 | 人事部 | | NULL | NULL | NULL | NULL | 203 | 财政部 | | 6 | F | 38 | 204 | NULL | NULL | +--------+----------+------+---------+---------+-----------+ -- 注意 union与union all的区别：union会去掉相同的纪录 多表查询之复合条件连接查询123456789101112131415-- 查询员工年龄大于等于25岁的部门 SELECT DISTINCT department.dept_name FROM employee,department WHERE employee.dept_id &#x3D; department.dept_id AND age&gt;25;105211--以内连接的方式查询employee和department表，并且以age字段的升序方式显示 select employee.emp_id,employee.emp_name,employee.age,department.dept_name from employee,department where employee.dept_id &#x3D; department.dept_id order by age asc; 多表查询之子查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657-- 子查询是将一个查询语句嵌套在另一个查询语句中。-- 内层查询语句的查询结果，可以为外层查询语句提供查询条件。-- 子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字-- 还可以包含比较运算符：&#x3D; 、 !&#x3D;、&gt; 、&lt;等-- 1. 带IN关键字的子查询 ---查询employee表，但dept_id必须在department表中出现过 select * from employee where dept_id IN (select dept_id from department);+--------+----------+------+---------+| emp_id | emp_name | age | dept_id |+--------+----------+------+---------+| 1 | A | 19 | 200 || 2 | B | 26 | 201 || 3 | C | 30 | 201 || 4 | D | 24 | 202 || 5 | E | 20 | 200 |+--------+----------+------+---------+5 rows in set (0.01 sec)-- 2. 带比较运算符的子查询 -- &#x3D;、!&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt; -- 查询员工年龄大于等于25岁的部门 select dept_id,dept_name from department where dept_id IN (select DISTINCT dept_id from employee where age&gt;&#x3D;25);-- 3. 带EXISTS关键字的子查询-- EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。-- 而是返回一个真假值。Ture或False-- 当返回Ture时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询 select * from employee WHERE EXISTS (SELECT dept_name from department where dept_id&#x3D;203); --department表中存在dept_id&#x3D;203，Ture select * from employee WHERE EXISTS (SELECT dept_name from department where dept_id&#x3D;205); -- Empty set (0.00 sec) ps: create table t1(select * from t2); 补充：any/some/all 12345678910111213141516171819202122232425262728293031323334353637383940414243444546【4】any&#x2F;some&#x2F;all① any，in，some，all分别是子查询关键词之一any 可以与&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt;结合起来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的任意一个数据。all可以与&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据。② any关键词可以理解为“对于子查询返回的列中的任一数值，如果比较结果为true，则返回true”。例如：select age from t_user where age &gt; any (select age from t_user_copy);假设表t_user 中有一行包含(10)，t_user_copy包含(21,14,6),则表达式为true；如果t_user_copy包含（20,10），或者表t_user_copy为空表，则表达式为false。如果表t_user_copy包含（null，null，null），则表达式为unkonwn。all的意思是“对于子查询返回的列中的所有值，如果比较结果为true，则返回true”例如：select age from t_user where age &gt; all (select age from t_user_copy);假设表t_user 中有一行包含（10）。如果表t_user_copy包含（-5,0，+5），则表达式为true，因为10比t_user_copy中的查出的所有三个值大。如果表t_user_copy包含（12,6，null，-100），则表达式为false，因为t_user_copy中有一个值12大于10。如果表t_user_copy包含（0，null，1），则表达式为unknown。如果t_user_copy为空表，则结果为true。③ not in &#x2F;innot in 是 “&lt;&gt;all”的别名，用法相同。语句in 与“&#x3D;any”是相同的。例如：select s1 from t1 where s1 &#x3D; any (select s1 from t2);select s1 from t1 where s1 in (select s1 from t2);语句some是any的别名，用法相同。例如：select s1 from t1 where s1 &lt;&gt; any (select s1 from t2);select s1 from t1 where s1 &lt;&gt; some (select s1 from t2);在上述查询中some理解上就容易了“表t1中有部分s1与t2表中的s1不相等”，这种语句用any理解就有错了。--------------------- 作者：流烟默 来源：CSDN 原文：https:&#x2F;&#x2F;blog.csdn.net&#x2F;J080624&#x2F;article&#x2F;details&#x2F;72910548 版权声明：本文为博主原创文章，转载请附上博文链接！ MySQL函数官网：https://dev.mysql.com/doc/refman/8.0/en/sql-function-reference.html 常用函数123456789101112131415161718192021222324252627282930313233-- 数学运算select abs(-8);select ceiling(3.2);select floor(5.5);select rand(); -- 0~1之间的随机数select sign(10); -- 负数返回-1，正数返回1-- 字符串函数select char_length(&#39;asdf&#39;); -- 字符串长度select concat(&#39;asd&#39;,&#39;sa&#39;); -- 拼接字符串（有长度限制）select insert(&#39;我爱编程&#39;,1,3,&#39;asdf&#39;); -- 在指定位置插入字串(将第1到第3个字符替换为asdf)select upper(&#39;a&#39;);select lower(&#39;A&#39;);select instr(&#39;asdf&#39;,&#39;a&#39;); -- 返回第一次出现的子串的索引select replace(&#39;abcd&#39;,&#39;ab&#39;,&#39;ww&#39;); -- 替换select substr(&quot;asdf&quot;,1,2);-- 时间select current_date(); -- 当前日期select curdate(); -- 当前日期select now(); -- 当前时间select localtime(); -- 本地时间select sysdate(); -- 系统时间select year(now()); -- 年select month(now()); -- 月-- 系统select system_user();select version();select user();-- 加密MD5(&#39;asdf&#39;) MySQL事务事务：要么都成功，要么都失败 ACID Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。 Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。 Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 隔离 1、脏读：读取了另一个事务未提交的数据。 2、不可重复读：在一个事务中读取表中的某一行数据，多次读取结果不同。 3、虚读（幻读）:在事务内读取了别的事务插入的数据，导致前后读取不一致。 MySQL事务配置123456789101112131415161718192021-- mysql默认开启事务的自动提交。set autocommit &#x3D; 0; &#x2F;*关闭*&#x2F;set autocommit &#x3D; 1; &#x2F;*开启*&#x2F;-- 手动处理事务set autocommit &#x3D; 0-- 事务开始start transaction -- 标记一个事务的开始，从这之后的sql都在同一个事务内。......-- 提交：持久化commit-- 回滚rollback -- 事务一旦提交就被持久化了，无法回滚-- 事务结束set autocommit &#x3D; 1--savepoint 保存点名 -- 设置一个事务的保存点rollback to savepoint 保存点名 -- 回滚到保存点release savepoint 保存点名 -- 撤销保存点 插入多行数据 12345678910111213141516-- 插入百万行数据DELIMITER $$ -- 写函数之前必须要写CREATE FUNCTION mock_data()RETURN INTBEGIN DECLARE num INT DEFAULT 1000000; DECLARE i INT DEFAULT 0; WHILE i&lt;num DO INSERT INTO user(&#96;name&#96;,&#96;email&#96;) VALUES(CONCAT(&#39;用户&#39;,i),&#96;asdflk@qq.com&#96;); SET i&#x3D;i+1; END WHILE; RETURN i;END;SELECT mock_data(); MySQL 索引MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。 打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。 创建索引时，你需要确保该索引是应用在SQL 查询语句的条件(一般作为 WHERE 子句的条件)。 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。 上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 建立索引会占用磁盘空间的索引文件。 索引背后的数据结构http://blog.codinglabs.org/articles/theory-of-mysql-index.html 索引分类 主键索引（PRIMARY KEY） 唯一，非空 唯一索引（UNIQUE KEY） 可以重复 常规索引（KEY/INDEX） 默认的，index或key关键字来设置 全文索引（FullText） 特定的数据库引擎下 快速定位 12345678910111213-- 索引的使用-- 1.创建表的时候给字段增加索引-- 2.创建完毕后，增加索引-- 显示所有的索引信息show index from student-- 增加一个全文索引 索引名（列名）alter table school.student add fulltext index &#96;studentname&#96;(&#96;studentname&#96;);-- 分析mysql执行状态EXPLAIN SELECT * FROM student; -- 非全文索引EXPLAIN SELECT * FROM student WHERE MATCH(studentName) AGAINST(&#39;刘&#39;); 普通索引创建索引这是最基本的索引，它没有任何限制。它有以下几种创建方式： 1CREATE INDEX indexName ON mytable(username(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 修改表结构(添加索引)1ALTER table tableName ADD INDEX indexName(columnName) 创建表的时候直接指定123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法1DROP INDEX [indexName] ON mytable; 唯一索引它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： 创建索引1CREATE UNIQUE INDEX indexName ON mytable(username(length)) 修改表结构1ALTER table mytable ADD UNIQUE [indexName] (username(length)) 创建表的时候直接指定123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 其他索引全文索引1234567create table emp( id int, name varchar(20), salary double(7,2), text varchar(100000), FULLTEXT INDEX text_index (text)) 多列索引1234567create table emp( id int, name varchar(20), salary double(7,2), text varchar(100000), INDEX index_name_salary (name,salary)) 使用ALTER 命令添加和删除索引有四种方式来添加数据表的索引： ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。 以下实例为在表中添加索引。 1mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c); 你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引: 1mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c; 使用 ALTER 命令添加和删除主键主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下： 12mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i); 你也可以使用 ALTER 命令删除主键： 1mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY; 删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。 显示索引信息你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \\G 来格式化输出信息。 尝试以下实例: 12mysql&gt; SHOW INDEX FROM table_name; \\G........ 练习： https://www.cnblogs.com/yuanchenqi/articles/6424245.html 答案：https://www.cnblogs.com/wupeiqi/articles/5748496.html 查询每门课程前3名的几种方法https://blog.csdn.net/iteye_8331/article/details/81655117 CASE用法1 1234567select A,B casewhen case1 then result1when case2 then result2else result3endfrom CASE用法2 12345case Awhen case1 then result1when case2 then result2else result3end 123case when A&gt;2 then result1when A&lt;2 then result2end 注意： group by sid 则结果中sid一定只会出现一次。 权限管理和备份用户管理实际为对mysql.user进行修改 123456789101112131415161718192021222324252627-- 创建用户CREATE USER XX IDENTIFIED BY &#39;123456&#39;-- 修改密码(修改当前用户密码)SET PASSWORD &#x3D; PASSWORD(&#39;11111&#39;) -- mysql8.0删除了password函数-- 修改密码(修改指定用户的密码)SET PASSWORD FOR XX &#x3D; PASSWORD(&#39;123123&#39;)-- 重命名RENAME USER XX TO xxx-- 用户授权（授权除了grant之外的权限）GRANT ALL PRIVILEGES ON *.* TO xxx-- 查询权限SHOW GRANTS FOR xxxSHOW GRANTS FOR root@localhost-- root用户权限GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION-- 撤销权限 REVOKEREVOKE ALL PRIVILEGES ON *.* FROM xxx-- 删除用户drop user xxx MySQL备份 直接拷贝物理文件 在可视化工具中导出 命令行：mysqldump 12345678# mysqldump -h 主机 -u用户 -p密码 库名 [表1 表2 表3]&gt; 磁盘文件mysqldump -hlocalhost -uroot -p12345 school studetn &gt; D:&#x2F;a.sql# 导入# 登录的情况下，切换到指定的数据库source D:&#x2F;a.sqlmysql -uroot -p123456 库名&lt; D:&#x2F;a.sql 规范数据库设计设计方法 分析需求 概要设计：设计关系图E-R图 三大范式第一范式：数据库表的每一列都是不可分割的原子数据 第二范式：在第一范式的基础上，非码属性必须完全依赖于候选码 第三范式：在第二范式的基础上，任何非主属性不依赖于其他非主属性。 规范数据库设计 关联查询的表不得超过三张表 考虑商业化的需求和目标，数据库的性能更加重要 在规范性能的问题的时候，需要适当考虑规范性。 故意给某些表增加一些冗余的字段。（从多表查询变成单表查询） 故意增加一些计算列（从大数据量降为小数据量的查询） JDBC数据库驱动应用程序操作数据库时需要使用数据库驱动进行。 SUN公司为了简化开发人员的操作，提供了一个Java操作数据库的规范，俗称JDBC。 Demo123456789101112131415161718192021222324252627282930313233343536373839public class demo1 &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 1.加载驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); // connector 8.0以上自动加载驱动 // 2.用户信息和url /* mysql: jdbc:mysql://主机地址:端口号/数据库名?参数1&amp;参数2&amp;参数3 oracle: jdbc:oracle:thin:@localhost:1521:sid */ String url = \"jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true\"; String username = \"root\"; String password = \"123456\"; // 3.连接成功，数据库对象 Connection connection = DriverManager.getConnection(url, username, password); // 4.执行SQL的对象 Statement statement = connection.createStatement(); // 5.执行SQL的对象去执行SQL String sql = \"SELECT * FROM users\"; ResultSet resultSet = statement.executeQuery(sql); // 增、删、改使用statement.executeUpdate(sql); while (resultSet.next())&#123; System.out.println(\"id=\"+resultSet.getObject(\"id\")); System.out.println(\"name=\"+resultSet.getObject(\"name\")); &#125; // 6.释放连接 resultSet.close(); statement.close(); connection.close(); &#125;&#125; mysql默认端口3306 oracle默认端口1521 statement对象db.properties 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode&amp;characterEncoding=utf8&amp;useSSL=trueusername=rootpassword=123456 JdbcUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class JdbcUtils &#123; private static String driver = null; private static String url = null; private static String username = null; private static String password = null; static &#123; try &#123; InputStream resourceAsStream = JdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\"); Properties properties = new Properties(); properties.load(resourceAsStream); driver = properties.getProperty(\"driver\"); url = properties.getProperty(\"url\"); username = properties.getProperty(\"username\"); password = properties.getProperty(\"password\"); // 加载驱动 Class.forName(driver); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, username, password); &#125; public static void releaseResource(Connection connection, Statement statement, ResultSet resultSet) &#123; releaseResultSet(resultSet); releaseStatement(statement); releaseConnection(connection); &#125; public static void releaseResultSet(ResultSet resultSet)&#123; if (resultSet != null) &#123; try &#123; resultSet.close(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void releaseStatement(Statement statement)&#123; if (statement != null) &#123; try &#123; statement.close(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void releaseConnection(Connection connection)&#123; if (connection != null) &#123; try &#123; connection.close(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; testInsert.java 1234567891011121314151617181920public class testInsert &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stat = null; ResultSet res = null; try &#123; conn = JdbcUtils.getConnection(); stat = conn.createStatement(); int i = stat.executeUpdate(\"INSERT INTO users(`id`,`NAME`,`PASSWORD`,email,birthday)\\n\" + \"VALUES (4,'小白','123456','1554asdf@qwek.com','2020-01-01')\"); if (i&gt;0) &#123; System.out.println(\"插入成功\"); &#125; &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JdbcUtils.releaseResource(conn, stat, res); &#125; &#125;&#125; PreparedStatementSQL注入问题在sql语句中添加非法的字符。 1234String sql = \"select * from users where `name`='\"+username+\"' AND `password` = '\"+password+\"'\";如果用户输入的username为 ' or '1=1在没有登录的情况下也能查询出结果。 preparedstatementpreparedstatement可以解决 123456789101112131415161718192021222324252627public class testinsert2 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement stat = null; ResultSet res = null; try &#123; conn = JdbcUtils.getConnection(); stat = conn.prepareStatement(\"INSERT INTO users(`id`,`NAME`,`PASSWORD`,email,birthday)\\n\" + \"VALUES (4,'小白','123456','1554asdf@qwek.com','2020-01-01')\"); stat.setInt(1,4); //参数的位置（从1开始），参数值 stat.setString(2,\"xasdf\"); stat.setString(3,\"123\"); stat.setString(4,\"1239123@asdfk.com\"); stat.setDate(5,new java.sql.Date(new java.util.Date().getTime())); int i = stat.executeUpdate(); if (i&gt;0) &#123; System.out.println(\"插入成功\"); &#125; &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JdbcUtils.releaseResource(conn, stat, res); &#125; &#125;&#125; 数据库连接池数据库连接—-执行完毕—释放，浪费资源 连接池：预留多个连接 最小连接数、最大连接数、连接超时 开源数据源实现 DBCP C3P0 Druid：阿里巴巴 DBCPmaven:commons-dbcp commons-pool dbcp.properties 12345678910111213141516171819202122232425262728293031323334#连接设置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=trueusername=rootpassword=123456#&lt;!-- 初始化连接 --&gt;initialSize=10#最大连接数量maxActive=50#&lt;!-- 最大空闲连接 --&gt;maxIdle=20#&lt;!-- 最小空闲连接 --&gt;minIdle=5#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;maxWait=60000#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：【属性名=property;】#注意：\"user\" 与 \"password\" 两个属性会被明确地传递，因此这里不需要包含他们。connectionProperties=useUnicode=true;characterEncoding=UTF8#指定由连接池所创建的连接的自动提交（auto-commit）状态。defaultAutoCommit=true#driver default 指定由连接池所创建的连接的只读（read-only）状态。#如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix）defaultReadOnly=#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLEdefaultTransactionIsolation=READ_UNCOMMITTED JdbcUtils_DBCP.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class JdbcUtils_DBCP &#123; private static DataSource dataSource = null; static &#123; try &#123; InputStream resourceAsStream = JdbcUtils_DBCP.class.getClassLoader().getResourceAsStream(\"db.properties\"); Properties properties = new Properties(); properties.load(resourceAsStream); //创建数据源 工厂模式 dataSource = BasicDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; public static void releaseResource(Connection connection, Statement statement, ResultSet resultSet) &#123; releaseResultSet(resultSet); releaseStatement(statement); releaseConnection(connection); &#125; public static void releaseResultSet(ResultSet resultSet)&#123; if (resultSet != null) &#123; try &#123; resultSet.close(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void releaseStatement(Statement statement)&#123; if (statement != null) &#123; try &#123; statement.close(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void releaseConnection(Connection connection)&#123; if (connection != null) &#123; try &#123; connection.close(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; C3P0maven：c3p0,mchange-commons-java c3p0-config.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;!-- 默认配置，只可以出现一次 --&gt; &lt;default-config&gt; &lt;!-- 连接超时设置30秒 --&gt; &lt;property name=\"checkoutTimeout\"&gt;3000&lt;/property&gt; &lt;!-- 30秒检查一次connection的空闲 --&gt; &lt;property name=\"idleConnectionTestPeriod\"&gt;30&lt;/property&gt; &lt;!--初始化的池大小 --&gt; &lt;property name=\"initialPoolSize\"&gt;2&lt;/property&gt; &lt;!-- 最多的一个connection空闲时间 --&gt; &lt;property name=\"maxIdleTime\"&gt;30&lt;/property&gt; &lt;!-- 最多可以有多少个连接connection --&gt; &lt;property name=\"maxPoolSize\"&gt;5&lt;/property&gt; &lt;!-- 最少的池中有几个连接 --&gt; &lt;property name=\"minPoolSize\"&gt;2&lt;/property&gt; &lt;!-- 批处理的语句 --&gt; &lt;property name=\"maxStatements\"&gt;50&lt;/property&gt; &lt;!-- 每次增长几个连接 --&gt; &lt;property name=\"acquireIncrement\"&gt;3&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt; &lt;![CDATA[jdbc:mysql://127.0.0.1:3306/bookstore?useUnicode=true&amp;characterEncoding=UTF-8]]&gt; &lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;root&lt;/property&gt; &lt;/default-config&gt; &lt;/c3p0-config&gt; JdbcUtils_C3P0.java 1234567891011121314151617public class JdbcUtils_C3P0 &#123; private static ComboPooledDataSource dataSource = null; static &#123; try &#123;// // 代码配置// dataSource = new ComboPooledDataSource();// dataSource.setDriverClass();// dataSource.setUser(); // 文件配置 dataSource = new ComboPooledDataSource(\"MySQL\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; ...&#125; op1=>operation: 应用 op2=>operation: JDBC op3=>operation: 数据库驱动 op4=>operation: 数据库 op1->op2->op3->op4{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://sjtu-xx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"数据库基础","slug":"数据库基础","date":"2020-06-29T13:48:54.000Z","updated":"2021-02-23T14:51:17.855Z","comments":true,"path":"2020/06/29/数据库基础/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","excerpt":"最近组里要求做一个材料数据库，因此对之前数据库的知识进行复习，简单记录。 数据库基础设计原则","text":"最近组里要求做一个材料数据库，因此对之前数据库的知识进行复习，简单记录。 数据库基础设计原则 更小通常更好 一般来说，要试着使用正确地存储和表示数据的最小类型。更小的数据类型通常更快，因为它们使用了更少的磁盘空间、内存和CPU缓存，而且需要的CPU周期也更少。 简单就好 越简单的数据类型，需要的CPU周期就越少。例如：比较整数的代价小于比较字符，因为字符集和排序规则使字符比较更复杂。 尽量避免空 要尽可地把字段定义为NOT NULL 。即使应用程序无须保存NULL，也有许多表包含了可为空的列，这仅仅是因为它为默认选项，除非真的要保存NULL，否则就把列定义为NOT NULL。 需要注意：虽然把NULL列改为NOT NULL 带来的性能提升很小，所以除非确定它引入了问题，否则就不要把它当成优先的优化措施。但如果计划对列进行索引，就要尽量避免把它设置为可为空（NULL） 数据类型整数 TINYINT——这个类型最多可容纳三位数。 SMALLINT——最多可容纳五位数。 MEDIUMINT——最多可容纳八位数。 INT——可以容纳十位数。 BIGINT——最多可容纳二十位数。 整数类型有可选的unsigned（无符号）属性，它表示不允许为负数，并大致把正上限提高了一倍，例如：tinyint unsigned保存的翻围为0到255，而不是-127到128。 实数 由于需要额外的空间和计算开销，\\只有在需要对小数进行精确的时候才使用decimal**，比如保存金融数据。 DECIMAL最适合保存那些将被用于计算的数据。在MySQL中，我们可以指定保存一些正当的数字。还可以指定是否允许存在负值。 指定DECIMAL类型的长度会有些棘手。例如，如果你需要在小数点前面保存五位数，且小数点后只保留三位，那么在数据库中其适当的长度将是：Decimal(5+3,3)或 Decimal(8,3)，可以使用的数据包括：12345.678，56872.690，11.6和12.568等。而这些数字则会引发出错信息：128781.1，8972865.231。 字符串 varchar：保存了可变长度的字符串，是使用得最多的字符串类型，它能比固定类型占用更少的存储空间，因为它只占用了自已需要的空间（也就是说较短的值占用的空间更小）。它使用额外的1-2个字节来存储值的长度。Varchar能节约空间，所以对性能有帮助。然而，由于行的长度是可变的，它们在更新的时候可能会发生变化，这会引起额外的工作。当最大长度远大于平均长度，并且很少发生更新的时候，通常适合用varchar。这时候碎片就不会成为问题，还有你使用复杂的字符集，如utf-8时，它的每个字符都可能会占用不同的存储空间。Varchar存取值时候，MySQL不会去掉字符串末尾的空格。 char：固定长度，char存取值时候，MySQL会去掉末尾的空格。Char在存储很短的字符串或长度近似相同的字符的时候很有用。例如,char适用于存储密码的MD5哈希值，它的长度总是一样的。对于经常改变的值，char也好于varchar，因为固定长度的行不容易产生碎片，对于很短的列，char的效率也高于varchar。Char(1)字符串对于单字节字符集只会占用1个字节，而varchar(1)则会占用2个字节，因为有一个字节用来存储其长度。 Char和varchar的兄弟类型为binary和varbinary，它们用于保存二进制的字符串，二进制字符串的传统的字符串很类似，但是它们保存的是字节而不是字符。填充也有所不同，MySQL使用\\0（0字节）填充binary值，而不是空格，并且不会在获取数据的时候把填充的值截掉。 BLOB和TEXT类型 BLOB和TEXT分别用二进制和字符形式保存大量数据。 日期和时间类型DATETIME 和 TIMESTAMP的区别： MySQL提供两种相似的数据类型：DATETIME 和 TIMESTAMP，对于很多应用程序，它们都能正常工作，但是在某些情况下，一种会好于另外一种。 DATETIME：能够保存大范围的值，从1001年到9999年，精度为秒，它把日期和时间封装到一个格式为yyyy:MM:dd:HH:mm:ss的整数当中，与时区无关。它使用了8个字节存储空间。 TIMESTAMP：保持了自1970年1月1日午夜（格林尼治标准时间）以来的秒数，它和Unix的时间戳相同。它只使用了4个字节存储空间。因此它比DATETIME的范围小得多。它表示自能从1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。 但是，TIMESTAMP显示的值依赖于时区，MySQL服务器、操作系统及客户端连接都有时区设置。因此，保存0值的TIMESTAMP实际显示的时间是美国东部的时间1969-12-31 19:00:00，与格林尼治标准时间（GMT）相差5小时。 MYSQL数据库命名与其设计规范标准化和规范化数据的标准化有助于消除数据库中的数据冗余。标准化有好几种形式，但Third Normal Form（3NF）通常被认为在性能、扩展性和数据完整性方面达到了最好平衡。简单来说，遵守3NF 标准的数据库的表设计原则是： “One Fact in One Place”即某个表只包括其本身基本的属性，当不是它们本身所具有的属性时需进行分解。表之间的关系通过外键相连接。它具有以下特点：有一组表专门存放通过键连接起来的关联数据。 举例：某个存放客户及其有关定单的3NF 数据库就可能有两个表：Customer和Order。Order表不包含定单关联客户的任何信息，但表内会存放一个键值，该键指向Customer表里包含该客户信息的那一行。 事实上，为了效率的缘故，对表不进行标准化有时也是必要的。 数据库涉及字符规范 采用26个英文字母(区分大小写)和0-9这十个自然数,加上下划线’_’组成,共63个字符.不能出现其他字符(注释除外). 注意事项: 1) 以上MYSQL数据库命名都不得超过30个字符的系统限制.变量名的长度限制为29(不包括标识字符@). 2) 数据对象、变量的命名都采用英文字符,禁止使用中文命名.绝对不要在对象名的字符之间留空格. 3) 小心保留词,要保证你的字段名没有和保留词、数据库系统或者常用访问方法冲突 5) 保持字段名和类型的一致性,在命名字段并为其指定数据类型的时候一定要保证一致性.假如数据类型在一个表里是整数,那在另一个表里可就别变成字符型了.命名规范 数据表名使用小写英文以及下划线组成,尽量说明是那个应用或者系统在使用的. 相关应用的数据表使用同一前缀,如论坛的表使用cdb_前缀,博客的数据表使用supe_前缀,前缀名称一般不超过5字 。备份数据表名使用正式表名加上备份时间组成 字段名称使用单词组合完成,首字母小写,后面单词的首字母大写,最好是带表名前缀. 如 web_user 表的字段: 1231. userId 2. userName 3. userPassword 索引使用原则1) 逻辑主键使用唯一的成组索引,对系统键(作为存储过程)采用唯一的非成组索引,对任何外键列采用非成组索引.考虑数据库的空间有多大,表如何进行访问,还有这些访问是否主要用作读写. 2) 大多数数据库都索引自动创建的主键字段,但是可别忘了索引外键,它们也是经常使用的键,比如运行查询显示主表和所有关联表的某条记录就用得上. 3) 不要索引blob/text等字段,不要索引大型字段(有很多字符),这样作会让索引占用太多的存储空间. 4) 不要索引常用的小型表 不要为小型数据表设置任何键,假如它们经常有插入和删除操作就更别这样作了.对这些插入和删除操作的索引维护可能比扫描表空间消耗更多的时间. 多对多的关系若两个实体之间存在多对多的关系，则应消除这种关系。消除的办法是，在两者之间增加第三个实体。这样，原来一个多对多的关系，现在变为两个一对多的关系。要将原来两个实体的属性合理地分配到三个实体中去。这里的第三个实体，实质上是一个较复杂的关系，它对应一张基本表。一般来讲，数据库设计工具不能识别多对多的关系，但能处理多对多的关系。 主键与外键在多表中的重复出现, 不属于数据冗余非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的重复出现，而是字段的派生出现。〖例4〗：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。因此，我们提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。 主键 选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。 常见的可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://sjtu-xx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"linux命令","slug":"linux命令","date":"2020-06-29T13:46:56.000Z","updated":"2021-02-19T02:26:06.511Z","comments":true,"path":"2020/06/29/linux命令/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/linux%E5%91%BD%E4%BB%A4/","excerpt":"参考链接：https://www.cnblogs.com/linhaifeng/articles/6045600.html","text":"参考链接：https://www.cnblogs.com/linhaifeng/articles/6045600.html 笔记1.常用命令df -hl 查看磁盘空间ls 列出当前文件夹中文件（-l 详细信息 -a 显示隐藏文件 -all 同 -a）ll = ls -l —color = autoalias 别名cd 切换到目录（- 返回 ..上一级）pwd 当前目录whoami 查看当前登录用户who 查看所有登录用户date 显示当前时间和日期cal 月历clear 清屏（ctrl+l）useradd (用户名) 添加用户passwd (用户名) 更改用户密码su - (用户名) 切换用户man 命令 使用说明（q退出）echo 回显命令histort查看历史命令grep 搜索过滤(-v 反向过滤)lsof -i :8080 查看8080端口的进程 nestat -an|grep 8080 查看端口状态init 0 关闭linux系统 命令 —help 帮助信息命令跳到行首 ctrl+a 跳到行尾 ctrl+e 2.目录/ 根目录. 当前目录.. 上一层目录bin 可执行文件目录(binary)sbin 系统的可执行文件home 用户的文件dev 设备文件目录etc 配置文件目录/mnt /opt /media 随便用 3.目录及文件操作cp 复制（-i 询问是否覆盖 -r 递归拷贝 -）mv 移动mkdir 建文件夹（-p 递归建立文件夹）touch 建文件 （touch /test/{a..z}.txt）rm 删除（-f 不提示是否删除 -r 删除文件夹）cat 查看文件内容head 查看文件第一行(-n 前n行)tail 查看文件最后一行（-n 最后n行 -f 动态查看文件内容变化）more 按照百分比显示文件内容less 可以用上下键翻 tail -1 /etc/passwd 用户信息tail -1 /etc/shadow 密码tail -1 /etc/grouptail -1 /etc/gshadowtail -1 /var/spool/mail/usernametail -1 /home/username useradd (-u 指定用户uid -g 指定用户所属的群组 -d指定用户的家目录 -c指定用户的备注信息 -s指定用户的shell)userdel 删除用户usermod 修改用户信息（-u -g -d -c -s同上 -G 将用户加入指定的群组 -L将用户加锁 -U将用户解锁） 4.对文件的权限管理文件详细信息10位1:文件类型-:普通文件 d:目录 l:软链接 b:设备 p:管道文件2-4:属主权限 —-》u分三类：读r，写w，执行x,没有权限-5-7:属组权限 —-》g8-10:其他用户 —-》o 修改权限：chmod u=rw- a.txtchmod u-rw a.txt root 用户不受权限限制 执行文件：sh 文件路径bash 文件路径. 文件路径./ 文件路径——————vim原理 读取到内存中，进行修改。 5.对目录的权限管理ll -d 目录 获取目录权限增加文件，删除文件 6.属主属组及基于数字的权限管理chown 属主.属组 参数只改属主： chown 属主 参数只改属组： chown .属组 参数 chown -R (递归修改权限：目录和文件) 数字权限管理-rw-rw-r— 为 664 7.文件合并与文件归档> 左侧命令输出结果覆盖右侧文件 cat /etc/passwd &gt; a.txt>&gt; 左侧命令输出结果追加到右侧文件 wc -l 统计文件行数| 管道符将前面的结果作为后面的指令的参数 归档tarc：创建一个新的tar文件。t：列出tar文件中目录的内容。x：从tar文件中抽取文件。f：指定归档文件或磁带（也可能是软盘）设备（一般都要选）。v：显示所打包的文件的详细信息，v是verbose的第1个字母。z：使用gzip压缩算法来压缩打包后的文件。j：使用bzip2压缩算法来压缩打包后的文件。 打包：tar cvf arch.tar arch解包：tar xvf arch.tar -C 路径 压缩 gzip bzip2解压 gunzip bunzip2打包后压缩 tar czvf test1.tar.gz 1.txt 2.txt 3.txt 8.vim编辑器命令行模式 esc编辑模式 a i o扩展模式 : (:wq退出) dd 删除（剪切）ndd 删除光标所在的向下n行yy 复制光标所在的那一行nyy 复制光标所在的向下n行p 将已复制的数据在光标的下一行粘贴np 复制n次P 将已复制的数据在光标的上一行粘贴u 撤销上一步操作ctrl+r 前进一步0 移动到行首(home)$ 移动到行尾(end)gg 移动到文章开头G 移动到文章最后一行nG 移动到文章第n行H 移动到屏幕最上方M 移动到屏幕中央L 移动到屏幕最下方:w 将文件写入磁盘:q 退出:wq 写入并退出:set nu 显示行号 9.系统启动流程linux系统引导顺序： BIOS—&gt;MBR(主引导记录,512B,从何处装载程序)—&gt;Boot loader(引导)—&gt;Kernel—&gt;init progress 操作系统的启动级别 7个（/etc/inittab）查看内核信息 uname -r查看内核详细信息 uname -a 10.grub加密11.bios加密12.top命令僵尸进程:父进程结束，子进程没有结束（仍然存在）终端:bash程序buffer：缓冲区（内存空间）cache:高速缓存（内存空间，存放cpu经常使用的数据）pid 进程号PRNI（nice） 好心值 值越高优先级越低VIRT 虚拟内存RES 物理内存SHR 共享内存 13.free命令free 查看内存信息free -m 以兆为单位free -h 以G为单位 14.进程管理ps aux 查看所有进程kill 进程号(-9 强制杀死进程)kill %工作号firefox &amp; 打开firefox并在后台运行jobs 查看后台进程fg % 后台掉前台bg % 在后台运行pgrep == ps grep 15.磁盘分区步骤： （1）fdisk /dev/sdb新建分区 （2）partprobe更新分区表（3）mkfs.ext4格式化（4）mount 挂载 ls /dev/sd块存储(磁盘) 文件存储(文件夹) 对象存储(百度网盘) 查看硬盘详细信息 fdisk -l /dev/sdb硬盘分区 fdisk /dev/sdb 写分区列表 w更新分区列表 partprobe 格式化为ext4 : mkfs.ext4 /dev/sdb1扩展分区为逻辑分区不能格式化 16.文件系统与挂载挂载：由设备映射到目录mount /dev/sdb1 /sdb1/ 将sdb1挂载到/sdb1/\\df 查看挂载信息 文件系统xfs 海量数据存贮btrfs 存储效率高 一个设备可以有多个挂载点 卸载：umount 设备（删除最后一个挂载点） umount 挂载点 touch /opt/a.txt 若/opt不存在则寻找/ 查看挂载信息： df mount统计某一目录下文件大小 du -sh /etc/ 文件包括元数据（存放在inode块中）和数据信息操作系统中的block：super blockinode block中存放的信息：inode号。权限，属主，属组，创建时间，文件名，指针directory block中存放的信息：文件+inode号block：存放数据的块 df -i 查看inode的占用情况写文件： dd if=输入文件目录 of=输出文件目录 bs=10G count=1（bs：一个块的大小一般为512） 17.软链接和硬链接 https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html 软链接(快捷方式)： ln -s &lt;源文件路径&gt; &lt;目标文件路径&gt;硬链接： ln &lt;源文件路径&gt; &lt;目标文件路径&gt;软链接的目标和源文件的inode号不同，可以跨分区硬链接的目标和源文件的inode号相同，不可以跨分区 18.linux网络地址管理ip地址格式： 4段.分十进制（4段8位二进制数）网络地址： ip地址和子网掩码按位与查看网卡信息： ifconfig永久修改网卡ip地址： vim /etc/sysconfig/network-scripts/ifcfg-eth0BOOTPROTO=dhcp 从局域网的dhcp服务器获取BOOTPROTO=staticIPADDR=192168.11.200NETMASK=255.255.255.0GATEWAY=192.168.11.1DNS1=2.2.106.0.20DNS2=8.8.8.8 19.软件包管理编译安装：将程序编码为二进制文件存放到计算机中 软件包最后一位为奇数为测试版，偶数为稳定版 rpm 红帽软件包管理rpm包本身就是编译好的二进制文件 yum软件包管理 20.补充ssh服务在服务端开启ssh服务，然后客户端输入ssh 主机密钥错误：vim ~/.ssh/known 一.简介操作系统的内核：操作系统的内核是一个管理和控制程序，负责管理计算机的所有物理资源，其中包括。文件系统、内存管理、设备管理和进程管理。 UNIX操作系统的特点：多用户和多任务a) 多用户表示在同一时刻可以有多个用户同时使用UNIX操作系统而且他们互不干扰；b) 多任务表示任何一个用户在同一时间可以在UNIX操作系统上运行多个程序。 Linux的定义：Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。 登录和退出Linux（操作演示图解见linux系统管理P17-P22）1) 掌握关闭Linux系统的命令：init 02) 掌握什么是Linux终端：Linux终端也称为虚拟控制台。Linux终端采用字符命令行方式工作，用户通过键盘输入命令，通过Linux终端对系统进行控制。3) 掌握切换虚拟终端的方法：Ctrl+Alt+F[1～6]，如想切换到第二号虚拟终端，则同时按Ctrl+Alt+F24) 掌握普通用户登录后系统的提示符：$5) 掌握root用户登录后系统的提示符：#6) 掌握退出命令：exit 二.linux命令 whoami命令（详见linux系统管理P24）1) 了解whoami命令的功能:列出目前登陆Linux系统所使用的用户名（账号）。 who命令（详见linux系统管理P25）1) 掌握who命令的功能：列出目前哪些用户在系统上工作。2) 掌握who命令的输出结果：显示当前登录的所有用户，以及当前的日期和时间。 date、cal、和clear命令及带有参数的命令（详见linux系统管理P28-P29）1) 掌握date命令的功能：显示系统当前的日期和时间。2) 掌握date命令设置时间时间的格式：date 月日时分年。例如：将时间设定成2013年12月24日上午10点18的命令：扩展（date 12241018201hwclock –s 同步硬件 –w 同步系统）3) 掌握cal命令的功能：显示某月的日历。4) 灵活应用cal命令列出某一年某月的日历：例如显示2008年8月份日历的命令为：cal 8 20085) 掌握clear命令的功能：清除屏幕6) 掌握清屏快捷键：ctrl+l su和passwd命令（详见linux系统管理P29-P31）1) 掌握su命令的功能：从当前的用户切换到另一个指定的其他用户。2) 灵活应用su命令切换用户：例如：切到root用户的命令：su – root3) 掌握passwd命令功能：修改用户（既可以是普通用户，也可以是root用户）的密码，查看用户的密码状态等。Useradd4) 掌握使用passwd命令修改用户密码：例如：修改dog用户密码的命令：passwd dog 利用man命令来获取帮助信息（详见linux系统管理P34）1) 掌握man命令的功能：获取某个Linux命令的使用说明。2) 掌握使用man命令查看某命令的使用说明：例如：查看su命令的使用说明的命令为:man su 使用“命令名 —help”获取帮助1) 例如:查看ls命令帮助的命令为：(不使用man方法)ls –-help 三.目录文件的浏览1.Linux系统中的一些重要的目录（详见linux系统管理P41）a) bin目录：用来存放常用的可执行文件b) sbin目录：用来存放系统的可执行文件c) 家目录：用来存放用户自己的文件或目录，其中，超级用户root的家目录是/root，而普通用户的家目录被存放在/home目录下，并使用用户名作为最后一级目录（家目录）的名称，如cat用户的家目录为/home/catd) dev目录：设备文件目录e) etc目录：配置文件目录f) 挂载点(目录)：通常可移除式硬件会被挂载在/media或/mnt目录之下 使用pwd和cd命令来确定和切换目录（详见linux系统管理P43-P46）1) 掌握pwd命令的功能：确定现在所在的工作目录2) 掌握cd命令的功能：切换当前目录3) 掌握“cd –”命令：切换到用户之前的工作目录 使用ls命令列出目录中的内容(详见linux系统管理P47-P50)1) 掌握ls -a命令：列出目录下的所有文件，包括以“.”开头的隐含文件2) 掌握ls –l命令：列出某个目录中每一个文件的详细资料 使用cp命令复制文件和目录（详见linux系统管理P50）1) 掌握cp命令的功能：将文件（可以是多个）复制成一个指定的目的文件或复制到一个指定的目标目录中。2) 掌握cp命令的常用选项： Cp 源文件 目标文件a) –r（recursive，递归的）：递归地复制目录。当复制一个目录时，复制该目录中所有的内容，其中包括子目录的全部内容。b) -f（force，强制）：在目标文件已经存在的时候不询问直接强制复制 使用mv命令移动及修改文件和目录名（详见linux系统管理P54）1) 掌握mv命令的功能：既可以在不同的目录之间移动文件和目录，也可以重新命名文件和目录。2) 掌握mv命令的用法举例：a) 移动文件和目录的例子：将当前目录中的lists文件移动到其子目录babydog中的命令：mv lists babydogb) 重命名文件和目录的例子：将bigdog目录名改为babydog的命令：mv bigdog babydog 使用mkdir命令创建目录（详见linux系统管理P55）1) 掌握mkdir命令的功能：创建一个新目录2) 掌握mkdir命令的用法举例：创建目录daddog的命令：mkdir dadgog 使用touch命令创建文件(详见linux系统管理P56)1) 掌握touch命令的功能：可以创建一个空文件，也可以同时创建多个文件。2) 掌握touch命令的用法举例：在当前目录中创建一个名为babydog1的文件的命令：touch babydog1 使用rm命令删除文件（详见linux系统管理P57）1) 掌握rm命令的功能：永久地在文件系统中删除文件或目录。2) 掌握rm命令的常用选项：a) –r(recursive，递归的）：递归地删除目录。当删除一个目录时，删除该目录中所有的内容，其中包括子目录中的全部内容。b) –f（force，强制）：系统并不询问而是强制删除，即直接删除原有的文件。3) 掌握rm命令的用法举例：删除当前目录中的babydog1文件的命令：rm babydog1 使用rmdir或rm –r命令删除目录（详见linux系统管理P59）1) 掌握rmdir命令的功能：删除空目录。2) 掌握rmdir命令的用法举例：删除空目录 mumdog/girldog/babydog的命令：rmdir mumdog/girldog/babydog3) 掌握rm –r命令的功能：删除包含文件和子目录的目录。4) 掌握rm –r命令的用法举例：删除非空目录mumdog的命令：rm –r mumdog 使用cat命令浏览正文文件的内容（详见linux系统管理P73）5) 掌握cat命令的功能：将一个或多个文件的内容显示在屏幕上，该命令会不停的以只读的方式显示整个文件的内容。6) 掌握cat命令的用法举例：a) 浏览game.txt文件中的全部内容的命令：cat game.txt 使用head命令浏览文件中的内容（详见linux系统管理P75）1) 掌握head命令的功能：默认将显示一个文件的前10行。2) 掌握head命令的常用选项：-n 改变显示的行数3) 掌握head命令的用法举例：a) 查看/etc/passwd文件中前10行的详细信息的命令：head /etc/passwdb) 查看/etc/passwd文件中前5行的详细信息的命令：head –n 5 /etc/passwd 使用tail命令浏览文件中的内容（详见linux系统管理P76）1) 掌握tail命令的功能：默认显示文件最后10行的内容。2) 掌握tail命令的常用选项：-n 显示从文件末尾算起的n行3) 掌握tail命令的用法举例：a) 查看/etc/passwd文件中最后10行的详细信息的命令：tail /etc/passwdb) 查看/etc/passwd文件中最后5行的详细信息的命令：tail –n 5 /etc/passwd 使用more命令浏览文件（详见linux系统管理P78）1) 掌握more命令的功能：使用more命令之后，每次在屏幕上显示一屏（一页）的文件内容，并且在屏幕的尾部将会出现“—More—（n%）”的信息，其中，n%是已经显示文件内容的百分比。2) 灵活应用more命令a) 分页浏览learning.txt文件内容的命令：(翻页：空格，查找：/字符串)more learning.txt 四.用户群组和权限 用户及passwd文件1) 掌握/etc/passwd文件的功能：存储所有用户的相关信息，该文件也被称为用户信息数据库（Database）。2) /etc/passwd文件每个字段的具体含义：a) 第1个字段（列）记录的是这个用户的名字（在创建用户时root用户起的）。b) 第2个字段（列）如果是x，表示该用户登录Linux系统时必须使用密码；如果为空，则该用户在登录时无须提供密码。c) 第3个字段（列）记录的是这个用户的uid。d) 第4个字段（列）记录的是这个用户所属群组的gid。e) 第5个字段（列）记录的是有关这个用户的注释信息（如全名或通信地址）。f) 第6个字段（列）记录的是这个用户的家目录的路径。g) 第7个字段（列）记录的是这个用户登录后，第一个要执行的进程。 shadow文件（详见linux系统管理P133）1) /etc/shadow文件的功能：存储所有用户的密码，每一个用户占用一行记录，该文件实际上就是存放用户密码的数据库（Database）。2) /etc/shadow文件每个字段的具体含义：a) 第1个字段（列）是用户名。b) 第2个字段（列）是密码，这个密码是经过MD5加密算法加密过的密码。 群组及group文件（详见linux系统管理P135）1) /etc/group文件的功能：存放了Linux系统中所有群组的信息，它实际上就是一个存放群组信息的数据库（Database）。2) /etc/group文件每个字段的具体含义：a) 第1个字段是这个群组的名字。b) 第2个字段中的x表示这个群组在登录Linux系统时必须使用密码。c) 第3个字段记录的是这个群组的gid。d) 第4个字段记录的是这个群组里还有哪些群组成员。 怎样在Linux系统中添加一个新的用户账户（详见linux系统管理P449）1) 掌握useradd命令的功能：新增一个用户。2) 了解useradd命令的常用选项： -m: 创建家目录 a) –u：指定用户的UIDb) –g：指定用户所属的群组c) –d：指定用户的家目录d) –c：指定用户的备注信息e) –s：指定用户所用的shell3) 灵活应用useradd命令的举例：a) 例如：在系统中新增一个fox（狐狸）用户的命令：useradd foxb) 例如：在系统中新增一个用户user01，属组为police以及uid为600的命令：useradd –u 600 –g police user01 使用usermod命令修改用户账户（详见linux系统管理P458）1) 掌握usermod命令的功能：修改用户的账户信息。2) 了解usermod命令的常用选项：a) –u：修改用户的UIDb) –g：修改用户的GIDc) –G：将一个用户加入到指定的群组中d) –d：修改用户的家目录e) –c：修改用户的备注信息f) –s：修改用户所用的shell3) 灵活应用usermod命令的举例：a) 修改babydog4用户的家目录为/home/babies的命令：usermod –d /home/babies babydog4b) 将babydog4这个用户添加到babydog6这个群组中的命令：usermod –G babydog6 babydog4c) 将babydog4这个用户的的gid变更为dog群组的命令：usermod –g dog babydog4 使用usermod命令锁住用户及将用户解锁（详见linux系统管理P461）1) 了解usermod –L命户令的功能：将用户的账号锁住2) 了解usermod –L命户令的用法举例：例如：将babydog6用户的账号锁住的命令：usermod –L babydog63) 了解usermod –U命户令的功能：将用户的账号解锁4) 了解usermod –U命户令的用法举例：例如：将babydog6用户的账号解锁的命令：usermod –U babydog6 使用userdel命令删除用户账号（详见linux系统管理P462）1) 掌握userdel命令的功能：删除用户。2) 了解userdel命令的常用选项：a) –r：在删除用户的同时删除这个用户的家目录及其邮箱。3) 灵活应用userdel命令删除用户的举例：a) 例如：删除babydog5用户不删除其家目录的命令： 群组的管理1) 掌握groupadd命令的功能：创建一个新的群组账号。2) 了解groupadd命令的常用选项：c) –g：指定群组的GID3) 灵活应用groupadd命令的举例：例如：在系统中新增加一个名为boydogs的群组的命令：groupadd boydogs4) 掌握groupmod命令的功能：修改一个群组账号的信息。5) 了解groupmod命令的常用选项：a) –g：修改群组的GIDb) –n：修改群组的名称6) 灵活应用groupmod命令的举例：a) 例如：修改police群组的gid为521的命令：groupmod –g 521 policeb) 例如：将群组boydogs改名为daddogs的命令：groupmod –n daddogs boydogs7) 掌握groupdel命令的功能：删除一个群组账号。8) 灵活应用groupdel命令的举例：例如：删除daddogs群组的命令：groupdel daddogs 五.用户群组权限 怎样查看文件的权限（详见linux系统管理P138）1) 掌握使用ls –l命令查看文件上所设定的权限。2) 掌握ls –l命令的显示结果中的第一列分成4组，其中;a) 第1个字符为第1组，代表这是一个文件（-）或是一个目录（d），也可以是其他资源。b) 第2、3、4个字符为第2组，定义了文件或目录的所有者（owner）所具有限的权，使用u代表所有者（owner）对文件的所有权限。c) 第5、6、7个字符为第3组，定义了文件或目录的所有者所在的群组中其他（用户）所具有的权限，使用g代表这一组（group）权限。d) 第8、9、10个字符为第4组，定义了既不是owner也不和owner在同一群组的其他用户对文件或目录所具有的权限。使用o代表这一组（other）权限。3) 掌握ls –l命令的显示结果中的第三列、第四列为文件的属主和属组。 root用户及文件的安全控制（详见linux系统管理P136）1) 掌握root用户的定义：root用户也称为超级用户，它可以完全不受限制地访问任何用户的账户和所有文件及目录。2) 了解Linux系统中用户分类：Linux系统是将系统中的所有用户分成了3类：a) 第1类：所有者b) 第2类：同组用户（修正：所属组，因为你创建一个用户的过程会以为这个用户名为名字创建一个同名的组）c) 第3类：非同组的其他用户3) 掌握文件操作权限包括读（read）、写（write）和执行（execute）4) 掌握Linux操作系统在显示权限时，使用如下4个字符来表示文件操作权限：a) r：表示read权限，也就是可以阅读文件或者ls命令列出目录内容的权限。b) w：表示write权限，也就是可以编辑文件或者在一个目录中创建和删除文件的权限。c) x：表示execute权限，也就是可以执行程序或者使用cd命令切换到这个目录以及使用带有-l选项的ls命令列出这个目录中详细内容的权限等。d) -：表示没有相应的权限（与所在位置的r、w或x相对应）。 掌握使用chown修改文件的属主chown 属主:属组 文件chown :属组 文件chown 属主 文件a) 例如，修改文件file1的属主为root的命令为：chown root file1 掌握使用chgrp修改文件的属组chgrp 属组 文件a) 例如，修改文件file1的属组为wg的命令为：chgrp wg file1 使用符号法设定文件或目录上的权限（详见linux系统管理P132）1) 掌握chmod命令的功能：设定或更改文件或目录上的权限。2) 掌握-R选项：不但设置（或更改）该目录权限，而且还要递归地设置（或）更改该目录中所有文件或子目录的权限。3) 掌握是符号表示法的定义：符号表示法是使用几个特定的符号来设定权限的状态。4) 掌握权限状态可以分为3个部分：a) 第1个部分，表示要设定或更改谁的权限状态。其中的具体表示如下：u:表示所有者（owner）的权限。g：表示群组（group）的权限。o：表示既不是owner也不与owner在同一个group的其他用户（other）的权限。a：表示以上3组，也就是所有用户（all）的权限。b) 第2部分，是运算符（operator），也有人称为操作符，其中的具体表示如下：+：表示加入权限-：表示去掉权限=：表示设定权限c) 第3部分，表示权限（permission），其中的具体表示如下：r：表示read（读）权限。w：表示write（写）权限。X：表示execut（执行）权限。5) 灵活应用符号表示法设定或更改文件或目录上的权限：a) 例如：在dog_wolf文件上添加所有者和同组用户的可执行权限的命令：chmod ug+x dog_wolfb) 例如：在babydog目录上为其他用户添加写权限的命令：chmod o+w babydog 使用数字表示法设定文件或目录上的权限（详见linux系统管理P143）1) 掌握数字表示法的定义：数字表示法是指使用一组三位数的数字来表示文件或目录上的权限状态。其中：第1个数字代表所有者（owner）的权限（u）。第2个数字代表群组（group）的权限（g）。第3个数字代表其他用户（other）的权限（o）。2) 数字代表的资源权限状态：4：表示具有读（read）权限。2：表示具有写（write）权限。1：表示具有执行（execute）权限。0：表示没有相应的权限。3) 灵活应用数字法表示法设定或更改文件或目录上的权限：a) 例如：使用数字表示法对owner开放/home/dog/babydog目录和其中所有文件的一切权限，但是对同组用户开放读和执行权限，而对其他用户只开放读权限的命令：chmod -R 754 /home/dog/babydog 六.正文处理命令及tar命令 使用cat命令进行文件的纵向合并1) 掌握使用cat命令实现文件的纵向合并：a) 例如：使用cat命令将baby.age、baby.kg和baby.sex这三个文件纵向合并为baby文件的方法：cat baby.age baby.kg baby.sex &gt;babyb) 例如：使用cat命令将baby.age文件的内容添加到baby2文件中的方法：cat baby.age &gt;&gt;baby2 归档文件和归档技术（详见linux系统管理P209）1) 掌握归档的定义：归档（archiving）就是将许多文件（或目录）打包成一个文件。2) 了解归档的目的：归档的目的就是方便备份、还原及文件的传输操作。3) 掌握tar命令的功能：将多个文件（也可能包括目录，因为目录本身也是文件）放在一起存放到一个磁带或磁盘归档文件中。并且将来可以根据需要只还原归档文件中的某些指定的文件。4) 掌握tar命令的常用选项：c：创建一个新的tar文件。t：列出tar文件中目录的内容。x：从tar文件中抽取文件。f：指定归档文件或磁带（也可能是软盘）设备（一般都要选）。v：显示所打包的文件的详细信息，v是verbose的第1个字母。z：使用gzip压缩算法来压缩打包后的文件。j：使用bzip2压缩算法来压缩打包后的文件。 使用tar命令创建、查看及抽取归档文件（详见linux系统管理P210）1) 掌握使用tar命令创建归档文件的用法举例：例如：使用tar命令将arch目录打包成一个名为arch.tar的归档文件的方法(要求显示所有打包的文件和目录)：tar cvf arch.tar arch掌握使用tar命令查看归档文件的用法举例：例如：使用tar命令显示arch.tar这个归档文件（包）中的所有文件的方法：tar tf arch.tar2) 掌握使用tar命令抽取归档文件的用法举例：例如：使用tar命令恢复arch.tar中的全部内容的方法：tar xvf arch.tar -C 路径 文件的压缩和解压缩（详见linux系统管理P212）1) 掌握压缩的定义：压缩就是将一个大的文件通过一些压缩算法变成一个小文件。2) 了解压缩的目的：主要是缩小文件的大小，这样会节省存储文件的磁盘或磁带的空间，另外在网络上传输这些小文件也会减少网络的浏览（也就是节省网络的带宽）。3) 掌握解压缩的定义：解压缩就是将一个通过一些压缩算法的文件恢复到压缩之前的样子。4) 掌握gzip命令和gunzip命令的用法举例：a) 例如：将文件file1压缩成.gz格式的压缩包应该使用的命令为：gzip file1 –c &gt; /路径/name.gzb) 例如：将压缩文件file1.gz解压缩的命令为：gunzip file1.gz &gt;5) 掌握bzip2命令和bunzip2命令的用法举例：a) 例如：将文件file1压缩成.bz2格式的压缩包应该使用的命令为：bzip2 file1 &gt;b) 例如：将压缩文件file1.bz2解压缩的命令为：bunzip2 file1.bz2 &gt; 在使用tar命令的同时进行压缩和解压缩（详见linux系统管理P214）1) 掌握在使用tar命令的同时进行压缩和解压缩的用法举例a) 例如：使用tar命令将arch目录打包而且同时使用gzip的技术压缩打包后文件的方法（打包后的文件名为arch.tar.gz）：tar cvfz arch.tar.gz archb) 例如：使用tar命令将arch目录打包而且同时使用bzip2的技术压缩打包后文件的方法（打包后的文件名为arch.tar.bz2）：tar cvfj arch.tar.bz2 arch 七.vi编辑器 vi编辑器的操作模式（详见linux系统管理P255）1) 掌握vi编辑器的3中基本模式：a) 命令行模式：vi的默认模式。在这一模式中，所有的输入被解释成vi命令，可以执行修改、复制、移动、粘贴和删除正文等命令，也可以进行移动光标、搜索字符串和退出vi的操作等。b) 编辑模式：在编辑模式中，可以往一个文件中输入正文。在这一模式下，输入的每一个字符都被vi编辑器解释为输入的正文。使用ESC键返回命令行模式。c) 扩展模式：在一些UNIX系统上也叫最后一行模式。在这一模式下，可以使用一些高级编辑命令，如搜寻和替代字符串、存盘或退出vi编辑器等。要进入最后一行模式，需要在命令行模式中输入冒号（：），冒号这一操作将把光标移到屏幕的最后一行。 在vi编辑器中光标的移动（详见linux系统管理P256）1) 掌握在vi编辑器中用来移动光标位置的键与光标移动之间的关系，如下表： 进入插入模式（详见linux系统管理P258）1) 掌握从命令行模式进入插入模式的命令：a：进入插入模式并在光标之后进行添加。i：进入插入模式并在光标之前进行插入。o：进入插入模式并在当前（光标所在）行之下开启新的一行。 在命令行模式下删除与复制的操作（详见linux系统管理P259）1) 掌握常用的删除与复制的常用按键 6.粘贴命令 1) 掌握粘贴命令： \\7. 复原和重做命令 1) 掌握常用的复原和重做命令： 8.扩展模式与文件的存储和退出 1)掌握扩展模式下常用的命令： 9.快速移动光标在文件中的位置 1）掌握快速移动光标在文件中的位置的命令 10.快速移动光标在屏幕中的位置 1）掌握快速在屏幕中移动光标的位置的命令 八.linux系统初始化和服务 Linux系统引导的顺序（详见linux系统管理P312） 最初始阶段当我们打开计算机电源，计算机会自动从主板的BIOS(Basic Input/Output System)读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。下一步，计算机将从你所选择的存储设备中读取起始的512 bytes(比如光盘一开是的512 bytes，如果我们从光盘启动的话)。这512 bytes叫做主引导记录MBR (master boot record)。MBR会告诉电脑从该设备的某一个分区(partition)来装载引导加载程序(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。常用的boot loader有GRUB和LILO。随后，boot loader会帮助我们加载kernel。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。（Linus Torvalds与其说是Linux之父，不如说是Linux kernel之父。他依然负责Linux kernel的开发和维护。至于Ubuntu, Red Hat, 它们都是基于相同的kernel之上，囊括了不同的应用和界面构成的一个更加完整的操作系统版本。)实际上，我们可以在多个分区安装boot loader，每个boot loader对应不同的操作系统，在读取MBR的时候选择我们想要启动的boot loader。这就是多操作系统的原理。小结：BIOS -&gt; MBR -&gt; boot loader -&gt; kernelkernel如果我们加载的是Linux kernel，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过驱动程序(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个init进程。它是Linux系统中的1号进程(Linux系统没有0号进程)。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。小结: kernel -&gt; init processinit process(根据boot loader的选项，Linux此时可以进入单用户模式(single user mode)。在此模式下，初始脚本还没有开始执行，我们可以检测并修复计算机可能存在的错误)随后，init会运行一系列的初始脚本(startup scripts)，这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录！！！init会给出登录(login)对话框，或者是图形化的登录界面。 输入用户名(比如说vamei)和密码，DONE！在此后的过程中，你将以用户(user)vamei的身份操作电脑。此外，根据你创建用户时的设定，Linux还会将你归到某个组(group)中，比如可以是stupid组，或者是vamei组。所以你将是用户vamei， 同时是vamei组的组员。(注意，组vamei和用户vamei只是重名而已，就好想你可以叫Dell, 同时还是Dell公司的老板一样。你完全也可以是用户vamei，同时为stupid组的组员)总结BIOS -&gt; MBR -&gt; boot loader -&gt; kernel -&gt; init process -&gt; login用户，组 1) 掌握Linux系统引导的顺序：（详见附1） 其中，BIOS的工作是检查计算机的硬件设备，如CPU、内存和风扇速度等；MBR会在启动盘的第1个块中，大小为512B。其中前446中的程序代码是用来选择boot partition（分区），也就是由哪个分区来装入开机用的代码；在内核部分主要是安装计算机设备的驱动程序以便操作系统可以控制计算机上的设备。并且以只读的方式挂载/(根)文件系统，也就是此时的操作系统只能读到根文件系统（目录）所在的分区；init程序的进程id为1，即Linux操作系统第1个执行的程序。 BOIS的初始化和引导加载程序（详见linux系统管理P313）1) 掌握BIOS的定义：BIOS（Basic Input/Output System）（基本输入/输出系统的缩写），它是硬件与软件之间的接口，而且是非常基本的接口。 GRUB程序和grub.conf文件（详见linux系统管理P317）1) 掌握GRUB的定义：GRUB是Grand Unified Bootloader（多重操作系统启动管理器）的缩写。2) 掌握grub的配置文件为：grub.conf设置grub Md5加密命令 grub-MD5-cryptPassword = 明文或 password —md5 密文（编辑grub配置文件的密码）Title red hat 标题Password = 明文或 password —md5 密文（加载内核系统引导必须的密码） 内核的初始化和init的初始化（详见linux系统管理P322）1) 掌握init的配置文件为：/etc/inittab2) 了解init程序要做的工作：a) 决定预设（默认）要使用哪个run levels（运行级别）。b) 执行一些系统初始化的脚本（程序）来初始化操作系统。c) 根据run level的设置来执行所对应目录中的程序，以决定要启动哪些服务。d) 设定某些组合键。e) 定义UPS不间断电源系统，即当电源出现问题时或电源恢复时要执行哪些程序。f) 产生6个virtual consoles，也就是tty1～tty6。 run levels（运行级别）（详见linux系统管理P326）1) 掌握所有的运行级别及每一个运行级别对应的功能： 关闭系统及重启系统（详见linux系统管理P342）1) 掌握常用的可以关闭系统的命令：shutdown -h nowhaltpoweroffinit 02) 掌握常用的可以重启系统的命令：shutdown -r nowrebootinit 6Ctrl+Alt+Delete键 掌握单用户模式修改用户的密码 掌握救援模式 九.系统监控 系统监视和进程控制工具—top和free1) 掌握top命令的功能：top命令是Linux下常用的性能分析工具,能够实时显示系统中各个进程的资源占用状况,类似于Windows的任务管理器。2) 了解使用top命令列出系统状态时，系统默认每5秒刷新一下屏幕上的显示结果。 \\1. 第一行是任务队列信息 12:38:33 当前时间 up 50days 系统运行时间，格式为时:分 1 user 当前登录用户数 load average: 0.06, 0.60, 0.48 系统负载。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 \\2. 第二、三行为进程和CPU的信息 Tasks: 29 total 进程总数 1 running 正在运行的进程数 28 sleeping 睡眠的进程数 0 stopped 停止的进程数 0 zombie 僵尸进程数 Cpu(s): 0.3% us 用户空间占用CPU百分比 1.0% sy 内核空间占用CPU百分比 0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比 98.7% id 空闲CPU百分比 0.0% wa 等待输入输出的CPU时间百分比 0.0% hi 硬件中断占用CPU时间的百分比 0.0% si 软件中断占用CPU时间的百分比 \\3. 第四五行为内存信息。 \\4. 进程信息 列名 含义 PID 进程id PPID 父进程id RUSER Real user name UID 进程所有者的用户id USER 进程所有者的用户名 GROUP 进程所有者的组名 TTY 启动进程的终端名。不是从终端启动的进程则显示为 ? PR 优先级 NI nice值。负值表示高优先级，正值表示低优先级 P 最后使用的CPU，仅在多CPU环境下有意义 %CPU 上次更新到现在的CPU时间占用百分比 TIME 进程使用的CPU时间总计，单位秒 TIME+ 进程使用的CPU时间总计，单位1/100秒 %MEM 进程使用的物理内存百分比 VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。 RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA CODE 可执行代码占用的物理内存大小，单位kb DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb SHR 共享内存大小，单位kb nFLT 页面错误次数 nDRT 最后一次写入到现在，被修改过的页面数。 S 进程状态。 D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 COMMAND 命令名/命令行 WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名 Flags 任务标志，参考 sched.h cpu利用率与load average cpu利用率：上一天班的时间是8个小时，而码农敲代码的时间为2个小时，2/8=0.25 ,25%就是码农在一天的时间内的利用率（正常情况，cpu利用率&lt;70%） cpu负载：公司在一分钟内为某个码农安排了3个任务，而1分钟内该码农能做6个任务，那么该码农一分钟内的负载为0.5 如果公司在5分钟内为某个码农安排了100个任务，而5分钟内该码农只能做50个任务，那么该码农5分钟内的负载为2.0，即超负荷运转 cpu负载&lt;=1:能正常应付 ​ cpu负载&gt;1:超负荷运转 ​ 如果有4核，相当于将100个任务交给4个码农去干，如果每个码农的负载都是100%，那么整体的cpu负载达到4.0则是很正常的现象 ​ 多核cpu， load average 应该 &lt;= cpu核数 * 0.7 为何要有1分钟，5分钟，15分钟三种cpu负载？ 其实之所以要给出3个值，就是希望我们能结合起来看。或者说希望展示一个动态的图表式的数据，比如最近一分钟显示负载120%。而最近5分钟和15分钟显示负载为50%。可能你不用太过担心。但是如果你发现系统的负载一直维持在120%以上，就必须要提高硬件配置了。 cpu利用率和cpu负载过高，都是不好的现象，但是也有可能出现，低利用率，高负载的情况： 为一个码农分配了100个项目，毫无疑问，该码农的负载是很高的，但是码农在具体去做一个项目时，可能会碰到需要购买机器，或者查询资料等耗费时间的问题，真正动手写代码的时间可能很短，而这段时间才是码农真正为公司干活的时间，如果每个项目都有类似这种问题，那么100个项目加到一起，码农真正工作的时间也不会太多，这就造成了低利用率。 在两种情况下会导致一个进程在逻辑上不能运行， 1. 进程挂起是自身原因，遇到I/O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作 2. 与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。 因而一个进程有三种状态 3) 掌握free命令的功能：显示内存的使用状态。(下图centos6中查看效果，用二维数组代表FO即free output) 12345 1 2 3 4 5 61 total used free shared buffers cached2 Mem: 24677460 23276064 1401396 0 870540 120840083 -&#x2F;+ buffers&#x2F;cache: 10321516 143559444 Swap: 25151484 224188 24927296 从操作系统的角度： 物理内存FO[2][1]=24677460KB 物理内存被使用的内存FO[2][2]=23276064KB 可以用内存F[2][3]=1401396KB 等式：FO[2][1] = FO[2][2] + FO[2][3] 共享内存F[2][4]=0,表示几个进程共享的内存（数据共享） F[2][5]=870540表示已经分配但是还未使用的buffers大小 F[2][6]=12084008表示已经分配但是还未使用的buffers大小 buffer和cache的解释： A buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use. 也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。 Linux和其他成熟的操作系统（例如windows），为了提高IO read的性能，总是要多cache一些数据，这也就是为什么FO[2][6]（cached memory）比较大，而FO[2][3]比较小的原因。我们可以做一个简单的测试 释放掉被系统cache占用的数据； echo 3&gt;/proc/sys/vm/drop_caches 读一个大文件，并记录时间； 关闭该文件； 重读这个大文件，并记录时间； 第二次读应该比第一次快很多。 free输出的第二行是从一个应用程序的角度看系统内存的使用情况。 对于FO[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存； 对于FO[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存； 因为被系统cache和buffer占用的内存可以被快速回收，所以通常FO[3][3]比FO[2][3]会大很多。 这里还用两个等式： FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6] FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6] free命令的所有输出值都是从/proc/meminfo中读出的。 4) 掌握free命令的功能：显示内存的使用状态。(下面均为centos7中查看效果) http://www.linuxatemyram.com/提到使用`free`命令查看`Linux`系统使用内存时，`used`一项会把当前`cache`的大小也会加进去，这样会造成`free`这一栏显示的内存特别少： 1234$ free -m total used free shared buff&#x2F;cache availableMem: 1504 1491 13 0 855 869Swap: 2047 6 2041 可是实际上，cache根据应用程序的需要是可以回收利用的，因此free这一栏并不能真实地表现有多少“可以使用”的内存。实际系统可用内存应该以available数据为准。 linuxatemyram所提到的free命令也许是比较老的版本，我尝试了RHEL 7.2，Ubuntu 16.04和Arch Linux这3个Linux发行版，均没有出现used包含cache的情况： 123$ free -m total used free shared buff&#x2F;cache availableMem: 64325 47437 3150 1860 13737 14373 另外，从man free命令中也可以得到，目前计算used的值是要减掉free和buff/cache的： used Used memory (calculated as total – free – buffers – cache) 可以使用-w命令行选项得到buff和cache各自使用的数量： 123$ free -wm total used free shared buffers cache availableMem: 64325 48287 2476 1859 1430 12131 13524 需要注意的是，free表示的是当前完全没有被程序使用的内存；而cache在有需要时，是可以被释放出来以供其它进程使用的（当然，并不是所有cache都可以释放，比如当前被用作ramfs的内存）。而available才真正表明系统目前可以提供给应用程序使用的内存。/proc/meminfo从3.14内核版本开始提供MemAvailable的值；在2.6.27~3.14版本之间，是free程序自己计算available的值；早于2.6.27版本，available的值则同free一样。 \\2. 系统中进程的监控—ps（详见linux系统管理P363）1) 掌握进程的定义：进程是程序的一次动态执行。2) 掌握守护进程的定义：守护进程是在后台运行并提供系统服务的一些进程。3) 掌握父进程、子进程的定义：当一个进程创建另一个进程时，第1个进程被称为新进程的父进程，而新进程被称为子进程。4) 掌握ps命令的功能：用来显示当前进程的状态。ps –aux 显示所有的与用户相关的完整信息系统中进程的监控pstree、kill centos7默认没有pstree，需要yum -y install psmisc1) 掌握pstree命令的功能：以树状图显示程序。2) 掌握pstree命令的用法举例：例如：列出PID为4729的进程的进程状态树的命令：pstree 47293) 掌握kill命令的功能：把一个信号发送给一个或多个进程。默认发送终止信号。4) 灵活应用kill命令终止进程例如：终止PID为3852的进程的命令：kill 38525) 灵活应用kill -9命令杀死进程例如：杀死PID为3906的进程的命令：kill -9 3906 掌握pgrep命令的功能：通过名称或其他属性查找进程例如：查找名为firefox的进程的命令为：pgrep firefox 掌握pkill命令的功能：通过名称或其他属性发信号给进程例如：杀死名为firefox的进程的命令为：pkill firefox 十.硬盘分区、格式化、文件系统管理 硬件设备与文件名的对应关系（详见linux系统管理P297）1) 掌握在Linux系统中，每个设备都被当初一个文件来对待。2) 掌握各种设备在Linux中的文件名 硬盘的结构及硬盘分区（详见linux系统管理P301） 1) 了解为什么要进行硬盘分区： a) 更容易管理和控制系统，因为相关的文件和目录都放在一个分区中。 b) 系统效率更高。 c) 可以限制用户使用硬盘的份额（磁盘空间的大小）。 d) 更容易备份和恢复。 2) 掌握硬盘的逻辑结构：一个硬盘逻辑上可以被划分成块、磁道、磁柱和分区。 3) 掌握块的定义：块是盘片上寻址（访问）的最小单位，一个块可以存储一定字节的数据。 4) 掌握磁道的定义：磁道是由一系列头尾相连的块组成的圆圈。 5) 掌握磁柱的定义：磁柱是由一叠磁道，由在相同半径上每个盘面的磁道所组成。 6) 掌握分区的定义：分区是由一组相邻的磁柱所组成。 Linux系统中硬盘的分区（详见linux系统管理P303）1) 掌握硬盘分区的分类：硬盘的分区可以分为主分区、扩展分区和逻辑分区。2) 掌握主分区的数量：在一个硬盘上最多可以划分出4个主分区。3) 了解Linux操作系统的内核支持每个硬盘上的分区数量还是有一定限制的，Linux内核在每个硬盘上可以最多支持：a) 在SCSI硬盘上划分15个分区（Partitions）。b) 在IDE硬盘上划分63个分区（Partitions）。 使用fdisk和partprobe命令来管理硬盘分区（详见linux系统管理P394）1) 掌握fdisk命令的功能：创建磁盘分区。2) 掌握fdisk命令列表中常用的命令：a) d：删除一个（已经存在的）分区，其中d是delete的第1个字母。b) l：列出（已经存在的）分区的类型，其中l是list的第1个字母。c) m：列出fdisk中使用的所有命令，其中m是menu的第1个字母。d) n：添加一个新的分区，其中n是new的第1个字母。e) p：列出分区表的内容，其中p是print的第1个字母。f) q：退出fdisk，但是不存储所做的变化，其中q是quit的第1个字母。g) t：改变分区系统的id，其中t是title的第1个字母。h) w：退出fdisk并存储所做的变化，其中w是write的第1个字母。3) 掌握partprobe命令的功能：重新初始化内存中内核的分区表。 创建文件系统（数据的管理）（详见linux系统管理P399）1) 掌握格式化的定义：所谓的格式化就是将分区中的硬盘空间划分成大小相等的一些数据块（Blocks），以及设定这个分区中有多少个i节点可以使用等。2) 掌握文件系统的定义：文件系统是操作系统用于明确磁盘或分区上的文件的方法和数据结构；即在磁盘上组织文件的方法。3) 了解常用的文件系统类型ext2：Linux系统中标准的文件系统ext3：一种日志式文件系统ext4：一种针对ext3系统的扩展日志式文件系统lvm：逻辑盘卷管理iso9660：目前唯一通用的光盘文件系统4) 掌握mkfs命令的功能：格式化磁盘。5) 灵活应用常用的格式化命令：mkfs.文件系统类型例如，将分区/dev/sdb1格式化为ext4文件系统的命令为：mkfs.ext4 /dev/sdb1 为一个分区设定label（分区名）（详见linux系统管理P405）1) 掌握e2label命令的功能：设定或查看一个设备的label名称。2) 灵活应用e2label命令设定label：a) 例如：查看/dev/sdb1分区的label的命令为：e2label /dev/sdb1b) 例如：将/dev/sdb1分区的label设定为wg的命令：e2label /dev/sdb1 wg 文件系统的挂载与卸载（详见linux系统管理P406）1) 掌握挂载的定义：挂载指将一个设备（通常是存储设备）挂接到一个已存在的目录上。2) 掌握mount命令的功能：实现文件系统的挂载。3) 灵活应用mount命令实现文件系统的挂载：例如：将/dev/sdb1分区挂载到/wg目录上的命令：mount /dev/sdb1 /wg4) 掌握umount命令的功能：实现文件系统的卸载。5) 灵活应用umount命令实现文件系统的卸载：例如：卸载/wg上的文件系统的命令：umount /wg 虚拟内存的概念以及设置与管理（详见linux系统管理P414）1) 掌握虚拟内存的定义：所谓虚拟内存就是一块硬盘空间被当做内存使用，也被称为交换分区（swap）。2) 了解Linux交换分区的类型为：0x823) 掌握mkswap命令的功能：设置交换分区。4) 掌握使用mkswap命令设置交换分区的用法举例：例如：将分区/dev/sdb2设置为交换分区的命令：mkswap /dev/sdb25) 掌握swapon命令的功能：启动交换分区。6) 掌握swapon –a命令的功能：启动全部的交换分区。7) 掌握swapon –s命令的功能：列出当前正在使用的所有系统交换分区的状态。8) 掌握使用swapon命令的用法举例：例如：启用交换分区/dev/sdb2的命令：swapon /dev/sdb2 i节点（详见linux系统管理P170）1) 掌握i节点的定义：i节点实际上是一个数据结构，它存放了有关一个普通文件、目录或其他文件系统对象的基本信息。 符号（软）链接（详见linux系统管理P174）1) 掌握符号链接的定义：符号链接是指向另一个文件的一个文件。2) 掌握ln命令创建软连接的用法举例：a) 为wolf/dog.wolf.baby文件建立一个dog wolf.boy符号链接并放在bodydog目录中的命令：ln –s wolf/dog.wolf.baby bodydog/dog wolf.boy 硬链接（详见linux系统管理P179）1) 掌握硬链接的定义：一个硬链接（hard link）是一个文件名与一个i节点之间的对应关系，也可以认为一个硬链接是在所对应的文件上添加了一个额外的路径名。2) 掌握ln命令创建硬连接的用法举例：a) 为wolf/wolf.dog文件在backup目录中建立一个名为wolf.dog2的硬链接命令：ln wolf/wolf.dog backup/wolf.dog2 Linux系统中的文件类型（详见linux系统管理P183）1) 掌握Linux系统中常见的文件类型：-：普通文件（regular file），也有人称为正规文件。d:目录（directory）。l：符号（软）链接。b:块特殊文件（b是block的第1个字符），一般指块设备，如硬盘。c:字符特殊文件（c是character的第1个字符），一般指字符设备，如键盘。 怎样检查磁盘空间（详见linux系统管理P185）1) 掌握df命令的功能：显示文件系统中磁盘使用和空闲区的数量。-a 显示所有磁盘-h 单位转换2) 掌握du命令的功能： 显示目录和文件的大小a h同上 十一.linux网络 使用ifconfig命令来维护网络（详见linux系统管理P422）1) 掌握ifconfig命令的功能：显示所有正在启动的网卡的详细信息或设定系统中网卡的IP地址。2) 灵活应用ifconfig命令设定网卡的IP地址：例如：修改eth0网卡的IP地址为172.18.48.56和子网掩码255.255.255.128的命令：ifconfig eth0 172.18.48.56 netmask 255.255.255.128 使用ifup和ifdown命令启动和停止网卡（详见linux系统管理P424）1) 掌握ifup命令的功能：启动系统上指定的网卡。2) 掌握ifdown命令的功能：停止系统上指定的网卡。3) 掌握使用ifup命令启用指定网卡的举例：例如：启动eth0网卡的命令：ifup eth04) 掌握使用ifdown命令停用指定网卡的举例：只能作用于配置文件例如：停用eth0网卡的命令：ifdown eth0 网络配置文件 （详见linux系统管理P425）1) 了解网卡的配置文件存放在/etc/sysconfig/network-scripts目录中，且每个网卡对应的配置文件的文件名以ifcfg-开始，如eth0这个网卡对应的网络配置文件就是ifcfg-eth0。补：虚拟机新添加网卡没有配置文件需手动添加配置或图形添加网卡λ 掌握网络配置的定义：所谓的网络配置（设定）就是要修改网卡所对应的网络配置文件，可以通过使用文字编辑器（vi）直接编辑网络配置文件来重新配置网络。 十二.软件包管理 使用RPM安装及移除软件（详见linux系统管理P374）1) 掌握RPM的定义：RPM就是Red Hat Package Manger（红帽软件包管理工具）的缩写。2) 了解rpm的文件名分为5部分，其中：第1部分是name，表示这个rpm软件包的名称；第2部分是version，表示这个rpm软件包的版本编号；第3部分是release，表示这个rpm软件包的版本发布次数（修正号码）；第4部分是architectures，表示这个rpm软件包适用于哪些平台；最后一部分是rpm，表示这个rpm软件包的文件扩展名。3) 掌握rpm软件安装与移除工作中经常使用的选项：a) –i：安装（Install）软件。b) –U：升级（Upgrade）旧版本的软件。c) –e：移除/删除（Erase）软件。d) –v：显示详细的处理信息。e) –h：显示安装进度。卸载不能用 查看RPM软件包中的信息（详见linux系统管理P379）1) 掌握常用的查询已安装的软件包信息的命令：a) rpm –qa：显示目前操作系统上安装的全部软件包，其中q是query（查询）的第1个字母，a是all（全部）的第1个字母。Rpm –qa | grep dhcpb) rpm –qf 文件名：显示这个文件是由哪个软件包安装的，f是file（文件）的第1个字母。例如：列出安装/bin/tar文件的软件包的命令为：rpm –qf /bin/tarc) rpm –qi 软件包名：显示这个软件包的信息，i是information（信息）的第1个字母。例如：列出tar-1.14-10.RHEL4这个软件包的详细信息的命令：rpm –qi tar-1.14-10.RHEL4d) rpm –ql 软件包名：列出这个软件包中所包含的全部文件，其中l是list的第1个字母。例如：列出tar-1.14-10.RHEL4这个软件包中所包含的全部文件的命令：rpm –ql tarp数据包 RPM包的属性依赖性问题（详见linux系统管理P388）1) 掌握RPM软件包的属性依赖性问题的定义：所谓的RPM软件包的属性依赖性问题，即这个软件包的安装依赖于其他软件包的安装。 yum的功能：yum是Yellow dog Updater, Modified的缩写，目的就是为了解决RPM的依赖关系的问题，方便使用者进行软件的安装、升级等等工作。 掌握光盘挂载和镜像挂载a) 光盘挂载mount /dev/sr0 挂载点或者mount /dev/cdrom 挂载点b) 镜像文件的挂载mount -o loop -t iso9660 镜像文件 挂载点其中，-o loop：用来把一个文件当成硬盘分区挂接上系统 掌握yum的配置yum的配置一般有两种方式，一种是直接配置/etc目录下的yum.conf文件，另外一种是在/etc/yum.repos.d目录下增加.repo文件。 掌握本地yum配置[root@localhost ~]# mount /dev/cdrom /mnt #挂载光盘到/mnt目录[root@localhost ~]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# lsrhel-source.repo[root@localhost yum.repos.d]# cp rhel-source.repo rhel.repo #拷贝一份配置文件[root@localhost yum.repos.d]# vi rhel.repo #编辑配置文件如下[rhel-local] #模块名称，须修改不能与其他.repo文件中的重名name=Red Hat Enterprise Linux 6 local repo #名称随便起baseurl=file:///mnt #指定rpm仓库的位置enabled=1 #1开启该配置，0为关闭gpgcheck=1 #1为校对软件[root@localhost ~]# yum install vsftpd httpd #安装vsftpd及httpd服务 掌握远程yum配置方法 利用vsftpd搭建yum源服务器：Vsftpd默认的配置文件是允许匿名访问，这里直接启动就可以了：[root@localhost ~]# umount /dev/cdrom #卸载光盘[root@localhost ~]# mount /dev/cdrom /var/ftp/pub/ #挂载光盘到vsftpd的公众目录[root@localhost ~]# service vsftpd restart #重启vsftpd服务必须关闭防火墙和selinuxService iptables stopGetenforce :查看selinux状态临时关闭：不用重启：setenforce 00 permissive允许 1 enforcing 执行 配置客户机：[root@localhost ~]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# ls #rhel.repo是按照本地yum配置生成的rhel.repo rhel-source.repo[root@localhost yum.repos.d]# cat rhel.repo #修改为以下内容[rhel-ftp]name=Red Hat Enterprise Linux 6baseurl=ftp://192.168.8.42/pub #指定yum源地址enabled=1gpgcheck=1测试：[root@localhost ~]# yum install bind #安装DNS服务 掌握使用yum安装软件yum –y install 软件名 掌握使用yum删除软件yum –y remove 软件名 掌握使用yum安装组件yum –y groupinstall 组件名 掌握使用yum删除组件yum –y groupremove 组件名 掌握清除yum缓存yum clean all 使用yum查找软件包yum search 十三.samba服务 掌握samba的功能： samba是一个网络服务器，用于Linux和Windows之间共享文件。 掌握samba服务的启动、停止、重启service smb start|stop|restart 掌握samba的主配置文件为：/etc/samba/smb.conf 掌握配置samba服务 注意： 1 客户端要对目录是否有权限，必须samba软件放权+系统放权 2 每个用户的访问方式是：\\服务端ip\\用户名，默认访问自己的家目录（该用户对该目录有w权限，且samba对用户的家目录开启了writeable=yes的权限） 3 对于共享的目录，是所有人打开目录进行操作的，而不是一个打印机，所以printable一定要设置no 4 writeable=yes代表对所有用户放行了写权限，write list=user1,user2无效，因为放行的所有用户中已然包含user1和user2 5 writeable=no，write list=user1,user2代表所有人都没有写权限，唯独user1和user2有 comment = …… 设置共享注译path = 设置共享目录的物理路径valid users = @组名,用户名 设置允许哪些合法组或用户访问public = yes|no 设置共享资源是否能给游客帐号访问browseable = yes|no 设置该共享为隐藏共享writable = yes|no 设置是否允许客户端写入数据hosts allow = 设置允许访问该共享的合法网段或IPsamba安全认证掌握两种：share （匿名访问）user：用户名密码添加smb用户和设置密码：smbpasswd –a 用户Useradd u 掌握windows客户端的访问方式 6.掌握Linux客户端的访问方式 十四.NFS服务十五.计划任务crond服务什么是计划任务：后台运行，到了预定的时间就会自动执行的任务，前提是：事先手动将计划任务设定好。这就用到了crond服务 crond服务相关的软件包[root@MiWiFi-R3-srv ~]# rpm -qa |grep croncronie-anacron-1.4.11-14.el7.x86_64crontabs-1.11-6.20121102git.el7.noarchcronie-1.4.11-14.el7.x86_64 这些包在最小化安装系统时就已经安装了，并且会开机自启动crond服务，并为我们提供好编写计划任务的crontab命令。 计划任务分为两类：系统级和用户级 首先需要知道的是，无论是系统级还是用户级的cron计划都是文本文件，系统的计划文件存放在/etc/crontab路径下。用户的计划文件放在/var/spool/cron/用户名,不管是哪一种，都可以满足我们定制计划任务的需求。 root用户可以直接对文件进行修改来编写计划任务也可以使用 crontab -e命令，而普通用户只能使用后者。除此之外，系统crontab文件中任务的定义也有所不同，在前五个部分之后插入了一个“用户”部分。 [root@MiWiFi-R3-srv ~]# cat /etc/crontab #查看全局计划任务SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root # For details see man 4 crontabs 1234567891011121314151617181920# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed* * * * * root run-parts &#x2F;test #run-parts命令，可以执行一个目录下所有的可执行文件，目录下文件必须有执行权限You have new mail in &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root[root@MiWiFi-R3-srv ~]# crontab -u tom -l #通过命令查看用户tom的计划任务*&#x2F;1 * * * * echo 123213123213[root@MiWiFi-R3-srv ~]# cat &#x2F;var&#x2F;spool&#x2F;cron&#x2F;tom #从文件中查看用户tom的计划任务*&#x2F;1 * * * * echo 123213123213 crontab命令编写计划任务 1语 法：crontab [-u &lt;用户名称&gt;][配置文件] 或 crontab [-u &lt;用户名称&gt;][-elr] crontab任务配置基本格式：* command分钟(0-59) 小时(0-23) 日期(1-31) 月份(1-12) 星期(0-6,0代表星期天) 命令 第1列表示分钟1～59 每分钟用或者 /1表示第2列表示小时1～23（0表示0点）第3列表示日期1～31第4列表示月份1～12第5列标识号星期0～6（0表示星期天）第6列要运行的命令 参 数：-e 编辑该用户的计时器设置。-l 列出该用户的计时器设置。-r 删除该用户的计时器设置。-u&lt;用户名称&gt; 指定要设定计时器的用户名称。 注意： 1 查看计划任务的执行：tail -f /var/log/cron 2 写计划任务时，命令必须加上绝对路径，否则会出现这种情况：从日志中看，确实触发了计划任务的执行，但是命令却没有执行成功，比如 * reboot就会出现这种情况，需要将reboot写成/usr/sbin/reboot crontab例子： 30 21 * /usr/local/etc/rc.d/apache restart #每晚的21:30 重启apache 45 4 1,10,22 /usr/local/etc/rc.d/apache restart #每月1、10、22日的4 : 45重启apache 10 1 6,0 /usr/local/etc/rc.d/apache restart #每周六、周日的1 : 10重启apache 0,30 18-23 * /usr/local/etc/rc.d/apache restart #每天18 : 00至23 : 00之间每隔30分钟重启apache 0 23 6 /usr/local/etc/rc.d/apache restart #每星期六的11 : 00 pm重启apache * 23-7/1 * /usr/local/etc/rc.d/apache restart #晚上11点到早上7点之间，每隔一个小时的每分钟重启 apache 0 /1 /usr/local/etc/rc.d/apache restart #每一小时重启apache 0 11 4 * mon-wed /usr/local/etc/rc.d/apache restart #每月的4号与每周一到周三的11点重启apache 0 4 1 jan * /usr/local/etc/rc.d/apache restart #一月一号的4点重启apache /30 * /usr/sbin/ntpdate 210.72.145.44 #每半小时同步一下时间 0 /2 www /usr/bin/somecommand &gt;&gt; /dev/null 2&gt;&amp;1 #以用户www的身份每两小时就运行某个程序： 0 1 * /home/testuser/test.sh #每天1点调用/home/testuser/test.sh /10 * /home/testuser/test.sh #每10钟调用一次/home/testuser/test.sh 30 21 * /usr/local/etc/rc.d/lighttpd restart #每天的21:30重启lighttpd 45 4 1,10,22 /usr/local/etc/rc.d/lighttpd restart #每月1、10、22日的4 : 45重启lighttpd 10 1 \\ 6,0 /usr/local/etc/rc.d/lighttpd restart #每周六、周日的1 : 10重启lighttpd 0,30 18-23 * /usr/local/etc/rc.d/lighttpd restart #上面的例子表示在每天18 : 00至23 : 00之间每隔30分钟重启apache。 0 23 6 /usr/local/etc/rc.d/lighttpd restart #上面的例子表示每星期六的11 : 00 pm重启lighttpd * /2 /usr/local/etc/rc.d/lighttpd restart #每两小时的每分钟重启lighttpd 0 23-7/1 * /usr/local/etc/rc.d/lighttpd restart #晚上11点到早上7点之间，每隔一小时重启lighttpd 0 11 4 * mon-wed /usr/local/etc/rc.d/lighttpd restart #每月的4号与每周一到周三的11点重启lighttpd 0 4 1 jan * /usr/local/etc/rc.d/lighttpd restart #一月一号的4点重启lighttpd /30 * /usr/sbin/ntpdate 210.72.145.44 #每半小时同步一下时间 对于一些常见的时间格式可以用如@yearly的方式代替 @reboot 代表的意思Run once, at startup.@yearly 代表的意思Run once a year, “0 0 1 1 “.@annually 与@yearly相同意思@monthly 代表的意思Run once a month, “0 0 1 “.@weekly 代表的意思Run once a week, “0 0 0”.@daily 代表的意思Run once a day, “0 0 “.@midnight 与@daily的意思相同@hourly 代表的意思Run once an hour, “0 “.除此之外，系统还有一些自带的计划任务 cron默认配置了调度任务，分别为：hourly、daily、weekly、mouthly，默认配置文件为/etc/anacrontab 将需要执行的脚本放到相应的目录下即可，目录分别为： /etc/cron.hourly /etc/cron.daily /etc/cron.weekly /ect/cron.mouthly 查看cron服务是否起作用： 如果我们要查看定时任务是否准时调用了可以/var/log/cron中的运行信息 cat /var/log/cron 也可以用tail -f /var/spool/mail/用户名，来查看普通用户的计划任务执行情况 此处需要记住两点： 第一：cron 守护进程每分钟都检查 /etc/crontab 文件、etc/cron.d/ 目录、以及 /var/spool/cron 目录中的改变。如果发现了改变，它们就会被载入内存。这样，当某个 crontab 文件改变后就不必重新启动守护进程了。 第二：crontab的用户手册中推荐每一个命令使用绝对路径，例如调用rm命令时写作：/bin/rm，这是为了防止由于每一个用户的PATH环境变量不同而导致命令无法找到的错误。 网上查询到的资料crontab不执行的问题： 转自：http://blog.csdn.net/jbgtwang/article/details/7995801 第一，脚本的原因：大多数情况下，我们要相信科学，相信计算机，不是有鬼，就是我们的脚本的问题，这种问题导致crontab不能执行的概率占到 70%以上。因为程序执行到某一步导致crontab终止执行，我就碰到一次在迁移代码的时候将数据库连错了。导致无法访问而死在那里了。 第二，执行环境问题，当我们碰到第一情况下，一般都可以通过手动执行程序将问题扼杀在摇篮里，一般情况下高手是不应该犯第一种错误的。问题是当我们 手动执行成功而crontab不能执行的时候，笔者碰到一次就是执行环境的问题，例如相关路径的设置问题。解决方案：在代码最前面执行 source /home/user/.bash_profile 第三，系统时间不正确。这种问题最好理解，也是比较常见和隐蔽的问题，解决方案：date -s ** 第四，就是我们的脚本是否有可执行权限。必须保证执行脚本的用户有执行改文件的权限。 第五，crontab 守护进程死掉了。这种情况是极少发生的，但也不排除，当我们实在是找不到其他原因的时候可以用。解决方案：重启该进程。 第六，crontab不执行的问题困扰了好长时间，脚本写的都正确，但是就是不执行，最终解决方法如下：crontab -u root /var/spool/cron/root这样root用户的crontab就生效了service crond restart重启下服务就好了 第七，crond没有启动 第八，脚本编码问题，脚本在window下编写，传到linux下后报“锘?!/bin/bash”，用vi编辑器新建新shell脚本，输入内容后保存。 第九 \\ * * * tar czf /tmp/date &#39;+%Y&#39; /etc 该计划任务中命令的执行流程是crond-&gt;tar命令，而crond在执行tar命令时，无法识别通配符%的意思（shell能识别），所以该命令无法正常执行 改正结果：* * * * * tar czf /tmp/date &#39;+\\%Y&#39; /etc 通常都会把要执行的操作放到文件中，然后/bin/bash a.sh去执行，* * * ** /bin/bash a.sh ，这样的执行流程就变成了crond-&gt;bash shell-&gt;a.sh,这样a.sh内即便是写%号，也能被识别出来**","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sjtu-xx.github.io/categories/Linux/"}],"tags":[]},{"title":"jQuery","slug":"jQuery","date":"2020-06-29T13:37:22.000Z","updated":"2021-02-19T02:26:06.476Z","comments":true,"path":"2020/06/29/jQuery/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/jQuery/","excerpt":"前端学习之jquery","text":"前端学习之jquery 一 jQuery是什么？ jQuery由美国人John Resig创建，至今已吸引了来自世界各地的众多 javascript高手加入其team。 jQuery是继prototype之后又一个优秀的Javascript框架。其宗旨是——WRITE LESS,DO MORE! 它是轻量级的js库(压缩后只有21k) ，这是其它的js库所不及的，它兼容CSS3，还兼容各种浏览器 jQuery是一个快速的，简洁的javaScript库，使用户能更方便地处理HTMLdocuments、events、实现动画效果，并且方便地为网站提供AJAX交互。 jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。 二 什么是jQuery对象？jQuery 对象就是通过jQuery包装DOM对象后产生的对象。jQuery 对象是 jQuery 独有的. 如果一个对象是 jQuery 对象, 那么它就可以使用 jQuery 里的方法: $(“#test”).html(); 12345678910111213$(&quot;#test&quot;).html() &#x2F;&#x2F;意思是指：获取ID为test的元素内的html代码。其中html()是jQuery里的方法 &#x2F;&#x2F; 这段代码等同于用DOM实现代码： document.getElementById(&quot; test &quot;).innerHTML; &#x2F;&#x2F;虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法.乱使用会报错 &#x2F;&#x2F;约定：如果获取的是 jQuery 对象, 那么要在变量前面加上$. var $variable &#x3D; jQuery 对象var variable &#x3D; DOM 对象$variable[0]：jquery对象转为dom对象 $(&quot;#msg&quot;).html(); $(&quot;#msg&quot;)[0].innerHTML jquery的基础语法：$(selector).action() 三 寻找元素(选择器和筛选器)3.1 选择器3.1.1 基本选择器 1$(\"*\") $(\"#id\") $(\".class\") $(\"element\") $(\".class,p,div\") 3.1.2 层级选择器 1$(\".outer div\") $(\".outer&gt;div\") $(\".outer+div\") $(\".outer~div\") //兄弟标签 3.1.3 基本筛选器（过滤） 1234$(\"li:first\") $(\"li:eq(2)\") //第3个$(\"li:even\") //偶数$(\"li:gt(1)\") //从第二个开始 3.1.4 属性选择器 1$('[id=\"div1\"]') $('[\"alex=\"sb\"][id]') 3.1.5 表单选择器 1$(\"[type='text']\")-----&gt;$(\":text\") 注意只适用于input标签 : $(\"input:checked\") 实例之左侧菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;left_menu&lt;/title&gt; &lt;style&gt; .menu&#123; height: 500px; width: 30%; background-color: gainsboro; float: left; &#125; .content&#123; height: 500px; width: 70%; background-color: rebeccapurple; float: left; &#125; .title&#123; line-height: 50px; background-color: #425a66; color: forestgreen;&#125; .hide&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"outer\"&gt; &lt;div class=\"menu\"&gt; &lt;div class=\"item\"&gt; &lt;div class=\"title\"&gt;菜单一&lt;/div&gt; &lt;div class=\"con\"&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"title\"&gt;菜单二&lt;/div&gt; &lt;div class=\"con hide\"&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"title\"&gt;菜单三&lt;/div&gt; &lt;div class=\"con hide\"&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;111&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"content\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=\"jquery-3.2.1.js\"&gt;&lt;/script&gt;&lt;script&gt; $(\".item .title\").click(function () &#123; $(this).next().removeClass(\"hide\").parent().siblings().children(\".con\").addClass(\"hide\");// $(this).next().removeClass(\"hide\");// $(this).parent().siblings().children(\".con\").addClass(\"hide\"); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实例之tab切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;tab&lt;/title&gt; &lt;script&gt; function tab(self)&#123; var index=$(self).attr(\"xxx\"); $(\"#\"+index).removeClass(\"hide\").siblings().addClass(\"hide\"); $(self).addClass(\"current\").siblings().removeClass(\"current\"); &#125; &lt;/script&gt; &lt;style&gt; *&#123; margin: 0px; padding: 0px; &#125; .tab_outer&#123; margin: 0px auto; width: 60%; &#125; .menu&#123; background-color: #cccccc; /*border: 1px solid red;*/ line-height: 40px; &#125; .menu li&#123; display: inline-block; &#125; .menu a&#123; border-right: 1px solid red; padding: 11px; &#125; .content&#123; background-color: tan; border: 1px solid green; height: 300px; &#125; .hide&#123; display: none; &#125; .current&#123; background-color: darkgray; color: yellow; border-top: solid 2px rebeccapurple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"tab_outer\"&gt; &lt;ul class=\"menu\"&gt; &lt;li xxx=\"c1\" class=\"current\" onclick=\"tab(this);\"&gt;菜单一&lt;/li&gt; &lt;li xxx=\"c2\" onclick=\"tab(this);\"&gt;菜单二&lt;/li&gt; &lt;li xxx=\"c3\" onclick=\"tab(this);\"&gt;菜单三&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"content\"&gt; &lt;div id=\"c1\"&gt;内容一&lt;/div&gt; &lt;div id=\"c2\" class=\"hide\"&gt;内容二&lt;/div&gt; &lt;div id=\"c3\" class=\"hide\"&gt;内容三&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.2 筛选器 3.2.1 过滤筛选器 1$(\"li\").eq(2) $(\"li\").first() $(\"ul li\").hasclass(\"test\") 3.2.2 查找筛选器 12345678910111213141516$(\"div\").children(\".test\") //下一代$(\"div\").find(\".test\") //所有子代 $(\".test\").next()$(\".test\").nextAll()$(\".test\").nextUntil() $(\"div\").prev()$(\"div\").prevAll()$(\"div\").prevUntil() $(\".test\").parent()$(\".test\").parents() $(\".test\").parentUntil() $(\"div\").siblings() 四 操作元素(属性，css，文档处理)4.1 属性操作12345678910111213141516--------------------------属性//自定义属性用attr$(\"\").attr(); //一个参数，取值；两个属性，设值（属性名，属性值）$(\"\").removeAttr();//固有属性用prop$(\"\").prop(); //对一些标签的固有属性，需要使用prop代替attr。$(\"\").removeProp();--------------------------CSS类$(\"\").addClass(class|fn)$(\"\").removeClass([class|fn])--------------------------HTML代码/文本/值$(\"\").html([val|fn])$(\"\").text([val|fn])$(\"\").val([val|fn|arr])---------------------------$(\"\").css(\"color\",\"red\") 注意： 123456789101112131415161718192021222324252627&lt;input id&#x3D;&quot;chk1&quot; type&#x3D;&quot;checkbox&quot; &#x2F;&gt;是否可见&lt;input id&#x3D;&quot;chk2&quot; type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot; &#x2F;&gt;是否可见&lt;script&gt;&#x2F;&#x2F;对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。&#x2F;&#x2F;对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。&#x2F;&#x2F;像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此&#x2F;&#x2F;需要使用prop方法去操作才能获得正确的结果。&#x2F;&#x2F; $(&quot;#chk1&quot;).attr(&quot;checked&quot;)&#x2F;&#x2F; undefined&#x2F;&#x2F; $(&quot;#chk1&quot;).prop(&quot;checked&quot;)&#x2F;&#x2F; false&#x2F;&#x2F; ---------手动选中的时候attr()获得到没有意义的undefined-----------&#x2F;&#x2F; $(&quot;#chk1&quot;).attr(&quot;checked&quot;)&#x2F;&#x2F; undefined&#x2F;&#x2F; $(&quot;#chk1&quot;).prop(&quot;checked&quot;)&#x2F;&#x2F; true console.log($(&quot;#chk1&quot;).prop(&quot;checked&quot;));&#x2F;&#x2F;false console.log($(&quot;#chk2&quot;).prop(&quot;checked&quot;));&#x2F;&#x2F;true console.log($(&quot;#chk1&quot;).attr(&quot;checked&quot;));&#x2F;&#x2F;undefined console.log($(&quot;#chk2&quot;).attr(&quot;checked&quot;));&#x2F;&#x2F;checked&lt;&#x2F;script&gt; 实例之全反选 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;jquery-1.11.3.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; function selectall()&#123; $(&quot;table :checkbox&quot;).prop(&quot;checked&quot;,true) &#125; function cancel()&#123; $(&quot;table :checkbox&quot;).prop(&quot;checked&quot;,false) &#125; function reverse()&#123; &#x2F;&#x2F; var idlist&#x3D;$(&quot;table :checkbox&quot;)&#x2F;&#x2F; for(var i&#x3D;0;i&lt;idlist.length;i++)&#123;&#x2F;&#x2F; var element&#x3D;idlist[i];&#x2F;&#x2F;&#x2F;&#x2F; var ischecked&#x3D;$(element).prop(&quot;checked&quot;)&#x2F;&#x2F; if (ischecked)&#123;&#x2F;&#x2F; $(element).prop(&quot;checked&quot;,false)&#x2F;&#x2F; &#125;&#x2F;&#x2F; else &#123;&#x2F;&#x2F; $(element).prop(&quot;checked&quot;,true)&#x2F;&#x2F; &#125;&#x2F;&#x2F;&#x2F;&#x2F; &#125;&#x2F;&#x2F; jquery循环的两种方式 &#x2F;&#x2F;方式一&#x2F;&#x2F; li&#x3D;[10,20,30,40]&#x2F;&#x2F; dic&#x3D;&#123;name:&quot;yuan&quot;,sex:&quot;male&quot;&#125;&#x2F;&#x2F; $.each(li,function(i,x)&#123;&#x2F;&#x2F; console.log(i,x)&#x2F;&#x2F; &#125;) &#x2F;&#x2F;方式二&#x2F;&#x2F; $(&quot;tr&quot;).each(function()&#123;&#x2F;&#x2F; console.log($(this).html())&#x2F;&#x2F; &#125;) $(&quot;table :checkbox&quot;).each(function()&#123; $(this).prop(&quot;checked&quot;,!$(this).prop(&quot;checked&quot;));&#x2F;&#x2F; if ($(this).prop(&quot;checked&quot;))&#123;&#x2F;&#x2F; $(this).prop(&quot;checked&quot;,false)&#x2F;&#x2F; &#125;&#x2F;&#x2F; else &#123;&#x2F;&#x2F; $(this).prop(&quot;checked&quot;,true)&#x2F;&#x2F; &#125; &#x2F;&#x2F; 思考:如果用attr方法可以实现吗? &#125;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;button onclick&#x3D;&quot;selectall();&quot;&gt;全选&lt;&#x2F;button&gt; &lt;button onclick&#x3D;&quot;cancel();&quot;&gt;取消&lt;&#x2F;button&gt; &lt;button onclick&#x3D;&quot;reverse();&quot;&gt;反选&lt;&#x2F;button&gt; &lt;table border&#x3D;&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;111&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;222&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;333&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;444&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 实例之模态对话框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; .back&#123; background-color: rebeccapurple; height: 2000px; &#125; .shade&#123; position: fixed; top: 0; bottom: 0; left:0; right: 0; background-color: coral; opacity: 0.4; &#125; .hide&#123; display: none; &#125; .models&#123; position: fixed; top: 50%; left: 50%; margin-left: -100px; margin-top: -100px; height: 200px; width: 200px; background-color: gold; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;back&quot;&gt; &lt;input id&#x3D;&quot;ID1&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;click&quot; onclick&#x3D;&quot;action1(this)&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;shade hide&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;models hide&quot;&gt; &lt;input id&#x3D;&quot;ID2&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;cancel&quot; onclick&#x3D;&quot;action2(this)&quot;&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;jquery-1.11.3.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; function action1(self)&#123; $(self).parent().siblings().removeClass(&quot;hide&quot;); &#125; function action2(self)&#123; &#x2F;&#x2F;$(self).parent().parent().children(&quot;.models,.shade&quot;).addClass(&quot;hide&quot;) $(self).parent().addClass(&quot;hide&quot;).prev().addClass(&quot;hide&quot;) &#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 4.2 文档处理1234567891011121314151617181920212223242526272829&#x2F;&#x2F;&#x2F;创建一个标签对象 $(&quot;&lt;p&gt;&quot;)&#x2F;&#x2F;内部插入 $(&quot;&quot;).append(content|fn) -----&gt;$(&quot;p&quot;).append(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;); $(&quot;&quot;).appendTo(content) -----&gt;$(&quot;p&quot;).appendTo(&quot;div&quot;); $(&quot;&quot;).prepend(content|fn) -----&gt;$(&quot;p&quot;).prepend(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;); $(&quot;&quot;).prependTo(content) -----&gt;$(&quot;p&quot;).prependTo(&quot;#foo&quot;);&#x2F;&#x2F;外部插入 $(&quot;&quot;).after(content|fn) -----&gt;$(&quot;p&quot;).after(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;); $(&quot;&quot;).before(content|fn) -----&gt;$(&quot;p&quot;).before(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;); $(&quot;&quot;).insertAfter(content) -----&gt;$(&quot;p&quot;).insertAfter(&quot;#foo&quot;); $(&quot;&quot;).insertBefore(content) -----&gt;$(&quot;p&quot;).insertBefore(&quot;#foo&quot;);&#x2F;&#x2F;替换 $(&quot;&quot;).replaceWith(content|fn) -----&gt;$(&quot;p&quot;).replaceWith(&quot;&lt;b&gt;Paragraph. &lt;&#x2F;b&gt;&quot;);&#x2F;&#x2F;删除 $(&quot;&quot;).empty() &#x2F;&#x2F;删除内容 $(&quot;&quot;).remove([expr]) &#x2F;&#x2F;删除标签&#x2F;&#x2F;复制 $(&quot;&quot;).clone([Even[,deepEven]]) 实例之复制样式条 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;outer&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;+&quot; onclick&#x3D;&quot;add(this);&quot;&gt; &lt;input type&#x3D;&quot;text&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;jquery-1.11.3.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;&#x2F;var $clone_obj&#x3D;$(self).parent().clone(); &#x2F;&#x2F; $clone_obj放在这个位置可以吗? function add(self)&#123; &#x2F;&#x2F; 注意:if var $clone_obj&#x3D;$(&quot;.outer .item&quot;).clone();会一遍二,二变四的增加 var $clone_obj&#x3D;$(self).parent().clone(); $clone_obj.children(&quot;:button&quot;).val(&quot;-&quot;).attr(&quot;onclick&quot;,&quot;removed(this)&quot;); $(self).parent().parent().append($clone_obj); &#125; function removed(self)&#123; $(self).parent().remove() &#125; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 4.3 css操作1234567891011121314CSS $(&quot;&quot;).css(name|pro|[,val|fn]) 位置 $(&quot;&quot;).offset([coordinates]) &#x2F;&#x2F;相对视口的偏移量 $(&quot;&quot;).position() &#x2F;&#x2F;相对已经定位的父标签的偏移量 $(&quot;&quot;).scrollTop([val]) &#x2F;&#x2F;无参数查看值，，参数为0返回顶部 $(&quot;&quot;).scrollLeft([val]) 尺寸 $(&quot;&quot;).height([val|fn]) $(&quot;&quot;).width([val|fn]) $(&quot;&quot;).innerHeight() &#x2F;&#x2F;height+padding $(&quot;&quot;).innerWidth() $(&quot;&quot;).outerHeight([soptions]) &#x2F;&#x2F;height+padding+border. &#x2F;&#x2F;参数为true时，加margin $(&quot;&quot;).outerWidth([options]) 实例返回顶部 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;js&#x2F;jquery-2.2.3.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; window.onscroll&#x3D;function()&#123; &#x2F;&#x2F;监听scroll距离 var current&#x3D;$(window).scrollTop(); console.log(current) if (current&gt;100)&#123; $(&quot;.returnTop&quot;).removeClass(&quot;hide&quot;) &#125; else &#123; $(&quot;.returnTop&quot;).addClass(&quot;hide&quot;) &#125; &#125; function returnTop()&#123;&#x2F;&#x2F; $(&quot;.div1&quot;).scrollTop(0); $(window).scrollTop(0) &#125; &lt;&#x2F;script&gt; &lt;style&gt; body&#123; margin: 0px; &#125; .returnTop&#123; height: 60px; width: 100px; background-color: darkgray; position: fixed; right: 0; bottom: 0; color: greenyellow; line-height: 60px; text-align: center; &#125; .div1&#123; background-color: orchid; font-size: 5px; overflow: auto; width: 500px; &#125; .div2&#123; background-color: darkcyan; &#125; .div3&#123; background-color: aqua; &#125; .div&#123; height: 300px; &#125; .hide&#123; display: none; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;div1 div&quot;&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;div2 div&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;div3 div&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;returnTop hide&quot; onclick&#x3D;&quot;returnTop();&quot;&gt;返回顶部&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 五 事件绑定方法 12345678on方法 可以动态的添加bind方法 对已经存在的标签进行添加简写： $(\"ul\").bind(\"click\",function ()&#123;&#125;) $(\"ul\").click(function ()&#123;&#125;) //前面两种方法作用相同 $(\"ul\").on(\"click\",\"li\",function()&#123;&#125;) 1234567891011121314151617181920212223242526页面载入 ready(fn) &#x2F;&#x2F;当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。 $(document).ready(function()&#123;&#125;) -----------&gt; $(function()&#123;&#125;)事件处理 $(&quot;&quot;).on(event,[selector],[data],fn) &#x2F;&#x2F; 在选择元素上绑定一个或多个事件的事件处理函数。 &#x2F;&#x2F; .on的selector参数是筛选出调用.on方法的dom元素的指定子元素，如： &#x2F;&#x2F; $(&#39;ul&#39;).on(&#39;click&#39;, &#39;li&#39;, function()&#123;console.log(&#39;click&#39;);&#125;)就是筛选出ul下的li给其绑定 &#x2F;&#x2F; click事件； [selector]参数的好处: 好处在于.on方法为动态添加的元素也能绑上指定事件；如： &#x2F;&#x2F;$(&#39;ul li&#39;).on(&#39;click&#39;, function()&#123;console.log(&#39;click&#39;);&#125;)的绑定方式和 &#x2F;&#x2F;$(&#39;ul li&#39;).bind(&#39;click&#39;, function()&#123;console.log(&#39;click&#39;);&#125;)一样；我通过js给ul添加了一个 &#x2F;&#x2F;li：$(&#39;ul&#39;).append(&#39;&lt;li&gt;js new li&lt;li&gt;&#39;)；这个新加的li是不会被绑上click事件的 &#x2F;&#x2F;但是用$(&#39;ul&#39;).on(&#39;click&#39;, &#39;li&#39;, function()&#123;console.log(&#39;click&#39;);&#125;方式绑定，然后动态添加 &#x2F;&#x2F;li:$(&#39;ul&#39;).append(&#39;&lt;li&gt;js new li&lt;li&gt;&#39;);这个新生成的li被绑上了click事件 [data]参数的调用: function myHandler(event) &#123; alert(event.data.foo); &#125; $(&quot;li&quot;).on(&quot;click&quot;, &#123;foo: &quot;bar&quot;&#125;, myHandler) 实例之面板拖动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang&#x3D;&quot;en&quot;&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div style&#x3D;&quot;border: 1px solid #ddd;width: 600px;position: absolute;&quot;&gt; &lt;div id&#x3D;&quot;title&quot; style&#x3D;&quot;background-color: black;height: 40px;color: white;&quot;&gt; 标题 &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;height: 300px;&quot;&gt; 内容 &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery-2.2.3.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; $(function()&#123; &#x2F;&#x2F; 页面加载完成之后自动执行 $(&#39;#title&#39;).mouseover(function()&#123; $(this).css(&#39;cursor&#39;,&#39;move&#39;); &#125;).mousedown(function(e)&#123; &#x2F;&#x2F;console.log($(this).offset()); var _event &#x3D; e || window.event; &#x2F;&#x2F; 原始鼠标横纵坐标位置 var ord_x &#x3D; _event.clientX; var ord_y &#x3D; _event.clientY; var parent_left &#x3D; $(this).parent().offset().left; var parent_top &#x3D; $(this).parent().offset().top; $(this).bind(&#39;mousemove&#39;, function(e)&#123; var _new_event &#x3D; e || window.event; var new_x &#x3D; _new_event.clientX; var new_y &#x3D; _new_event.clientY; var x &#x3D; parent_left + (new_x - ord_x); var y &#x3D; parent_top + (new_y - ord_y); $(this).parent().css(&#39;left&#39;,x+&#39;px&#39;); $(this).parent().css(&#39;top&#39;,y+&#39;px&#39;); &#125;) &#125;).mouseup(function()&#123; $(this).unbind(&#39;mousemove&#39;); &#125;); &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 实例之放大镜 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;bigger&lt;&#x2F;title&gt; &lt;style&gt; *&#123; margin: 0; padding:0; &#125; .outer&#123; height: 350px; width: 350px; border: dashed 5px cornflowerblue; &#125; .outer .small_box&#123; position: relative; &#125; .outer .small_box .float&#123; height: 175px; width: 175px; background-color: darkgray; opacity: 0.4; fill-opacity: 0.4; position: absolute; display: none; &#125; .outer .big_box&#123; height: 400px; width: 400px; overflow: hidden; position:absolute; left: 360px; top: 0px; z-index: 1; border: 5px solid rebeccapurple; display: none; &#125; .outer .big_box img&#123; position: absolute; z-index: 5; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;outer&quot;&gt; &lt;div class&#x3D;&quot;small_box&quot;&gt; &lt;div class&#x3D;&quot;float&quot;&gt;&lt;&#x2F;div&gt; &lt;img src&#x3D;&quot;small.jpg&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;big_box&quot;&gt; &lt;img src&#x3D;&quot;big.jpg&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; $(function()&#123; $(&quot;.small_box&quot;).mouseover(function()&#123; $(&quot;.float&quot;).css(&quot;display&quot;,&quot;block&quot;); $(&quot;.big_box&quot;).css(&quot;display&quot;,&quot;block&quot;) &#125;); $(&quot;.small_box&quot;).mouseout(function()&#123; $(&quot;.float&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;.big_box&quot;).css(&quot;display&quot;,&quot;none&quot;) &#125;); $(&quot;.small_box&quot;).mousemove(function(e)&#123; var _event&#x3D;e || window.event; var float_width&#x3D;$(&quot;.float&quot;).width(); var float_height&#x3D;$(&quot;.float&quot;).height(); console.log(float_height,float_width); var float_height_half&#x3D;float_height&#x2F;2; var float_width_half&#x3D;float_width&#x2F;2; console.log(float_height_half,float_width_half); var small_box_width&#x3D;$(&quot;.small_box&quot;).height(); var small_box_height&#x3D;$(&quot;.small_box&quot;).width();&#x2F;&#x2F; 鼠标点距离左边界的长度与float应该与左边界的距离差半个float的width,height同理 var mouse_left&#x3D;_event.clientX-float_width_half; var mouse_top&#x3D;_event.clientY-float_height_half; if(mouse_left&lt;0)&#123; mouse_left&#x3D;0 &#125;else if (mouse_left&gt;small_box_width-float_width)&#123; mouse_left&#x3D;small_box_width-float_width &#125; if(mouse_top&lt;0)&#123; mouse_top&#x3D;0 &#125;else if (mouse_top&gt;small_box_height-float_height)&#123; mouse_top&#x3D;small_box_height-float_height &#125; $(&quot;.float&quot;).css(&quot;left&quot;,mouse_left+&quot;px&quot;); $(&quot;.float&quot;).css(&quot;top&quot;,mouse_top+&quot;px&quot;) var percentX&#x3D;($(&quot;.big_box img&quot;).width()-$(&quot;.big_box&quot;).width())&#x2F; (small_box_width-float_width); var percentY&#x3D;($(&quot;.big_box img&quot;).height()-$(&quot;.big_box&quot;).height())&#x2F;(small_box_height-float_height); console.log(percentX,percentY) $(&quot;.big_box img&quot;).css(&quot;left&quot;, -percentX*mouse_left+&quot;px&quot;) $(&quot;.big_box img&quot;).css(&quot;top&quot;, -percentY*mouse_top+&quot;px&quot;) &#125;) &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 六 动画效果显示隐藏12.hide().show() 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt;$(document).ready(function() &#123; $(&quot;#hide&quot;).click(function () &#123; $(&quot;p&quot;).hide(1000); &#125;); $(&quot;#show&quot;).click(function () &#123; $(&quot;p&quot;).show(1000); &#125;);&#x2F;&#x2F;用于切换被选元素的 hide() 与 show() 方法。 $(&quot;#toggle&quot;).click(function () &#123; $(&quot;p&quot;).toggle(); &#125;);&#125;) &lt;&#x2F;script&gt; &lt;link type&#x3D;&quot;text&#x2F;css&quot; rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;p&gt;hello&lt;&#x2F;p&gt; &lt;button id&#x3D;&quot;hide&quot;&gt;隐藏&lt;&#x2F;button&gt; &lt;button id&#x3D;&quot;show&quot;&gt;显示&lt;&#x2F;button&gt; &lt;button id&#x3D;&quot;toggle&quot;&gt;切换&lt;&#x2F;button&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 滑动12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; $(document).ready(function()&#123; $(&quot;#slideDown&quot;).click(function()&#123; $(&quot;#content&quot;).slideDown(1000); &#125;); $(&quot;#slideUp&quot;).click(function()&#123; $(&quot;#content&quot;).slideUp(1000); &#125;); $(&quot;#slideToggle&quot;).click(function()&#123; $(&quot;#content&quot;).slideToggle(1000); &#125;) &#125;); &lt;&#x2F;script&gt; &lt;style&gt; #content&#123; text-align: center; background-color: lightblue; border:solid 1px red; display: none; padding: 50px; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;slideDown&quot;&gt;出现&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;slideUp&quot;&gt;隐藏&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;slideToggle&quot;&gt;toggle&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;content&quot;&gt;helloworld&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 淡入淡出12345678910111213141516171819202122232425262728293031323334353637383940添加stop来阻止动画重复响应&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; $(document).ready(function()&#123; $(&quot;#in&quot;).click(function()&#123; $(&quot;#id1&quot;).fadeIn(1000); &#125;); $(&quot;#out&quot;).click(function()&#123; $(&quot;#id1&quot;).fadeOut(1000); &#125;); $(&quot;#toggle&quot;).click(function()&#123; $(&quot;#id1&quot;).fadeToggle(1000); &#125;); $(&quot;#fadeto&quot;).click(function()&#123; $(&quot;#id1&quot;).fadeTo(1000,0.4); &#125;);&#125;); &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;button id&#x3D;&quot;in&quot;&gt;fadein&lt;&#x2F;button&gt; &lt;button id&#x3D;&quot;out&quot;&gt;fadeout&lt;&#x2F;button&gt; &lt;button id&#x3D;&quot;toggle&quot;&gt;fadetoggle&lt;&#x2F;button&gt; &lt;button id&#x3D;&quot;fadeto&quot;&gt;fadeto&lt;&#x2F;button&gt; &lt;div id&#x3D;&quot;id1&quot; style&#x3D;&quot;display:none; width: 80px;height: 80px;background-color: blueviolet&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 回调函数123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;button&gt;hide&lt;&#x2F;button&gt; &lt;p&gt;helloworld helloworld helloworld&lt;&#x2F;p&gt; &lt;script&gt; $(&quot;button&quot;).click(function()&#123; $(&quot;p&quot;).hide(1000,function()&#123; alert($(this).html()) &#125;) &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 七 扩展方法 (插件机制)一 用JQuery写插件时，最核心的方两个方法1234567891011121314151617181920212223242526272829&lt;script&gt; $.extend(object) //为JQuery 添加一个静态方法。$.fn.extend(object) //为JQuery实例添加一个方法。$.extend( Myfunc:function() &#123;console.log($.min(3,4));&#125;) jQuery.extend(&#123; min: function(a, b) &#123; return a &lt; b ? a : b; &#125;, max: function(a, b) &#123; return a &gt; b ? a : b; &#125; &#125;); //-----------------------------------------------------------------------$.fn.extend(&#123; \"print\":function()&#123; for (var i=0;i&lt;this.length;i++)&#123; console.log($(this)[i].innerHTML) &#125; // $.each($(this),function()&#123;&#125;) &#125;&#125;);$(\"p\").print();&lt;/script&gt; 二 定义作用域​ 定义一个JQuery插件，首先要把这个插件的代码放在一个不受外界干扰的地方。如果用专业些的话来说就是要为这个插件定义私有作用域。外部的代码不能直接访问插件内部的代码。插件内部的代码不污染全局变量。在一定的作用上解耦了插件与运行环境的依赖。 123456(function(a,b)&#123;return a+b&#125;)(3,5) (function ($) &#123; &#125;)(jQuery);&#x2F;&#x2F;相当于 var fn &#x3D; function ($) &#123; &#125;; fn(jQuery); 三 默认参数定义了jQuery插件之后，如果希望某些参数具有默认值，那么可以以这种方式来指定。 123456789101112131415161718192021222324252627&#x2F;step01 定义JQuery的作用域(function ($) &#123; &#x2F;&#x2F;step03-a 插件的默认值属性 var defaults &#x3D; &#123; prevId: &#39;prevBtn&#39;, prevText: &#39;Previous&#39;, nextId: &#39;nextBtn&#39;, nextText: &#39;Next&#39; &#x2F;&#x2F;…… &#125;; &#x2F;&#x2F;step06-a 在插件里定义方法 var showLink &#x3D; function (obj) &#123; $(obj).append(function () &#123; return &quot;(&quot; + $(obj).attr(&quot;href&quot;) + &quot;)&quot; &#125;); &#125; &#x2F;&#x2F;step02 插件的扩展方法名称 $.fn.easySlider &#x3D; function (options) &#123; &#x2F;&#x2F;step03-b 合并用户自定义属性，默认属性 var options &#x3D; $.extend(defaults, options); &#x2F;&#x2F;step4 支持JQuery选择器 &#x2F;&#x2F;step5 支持链式调用 return this.each(function () &#123; &#x2F;&#x2F;step06-b 在插件里定义方法 showLink(this); &#125;); &#125;&#125;)(jQuery); 八 经典实例练习实例之注册验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;form class&#x3D;&quot;Form&quot;&gt; &lt;p&gt;&lt;input class&#x3D;&quot;v1&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; mark&#x3D;&quot;用户名&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input class&#x3D;&quot;v1&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; mark&#x3D;&quot;邮箱&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input class&#x3D;&quot;v1&quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot; onclick&#x3D;&quot;return validate()&quot;&gt;&lt;&#x2F;p&gt;&lt;&#x2F;form&gt;&lt;script src&#x3D;&quot;jquery-3.1.1.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; &#x2F;&#x2F; 注意: &#x2F;&#x2F; DOM对象---&gt;jquery对象 $(DOM) &#x2F;&#x2F; jquery对象---&gt;DOM对象 $(&quot;&quot;)[0] &#x2F;&#x2F;--------------------------------------------------------- &#x2F;&#x2F; DOM绑定版本 function validate()&#123; flag&#x3D;true; $(&quot;Form .v1&quot;).each(function()&#123; $(this).next(&quot;span&quot;).remove();&#x2F;&#x2F; 防止对此点击按钮产生多个span标签 var value&#x3D;$(this).val(); if (value.trim().length&#x3D;&#x3D;0)&#123; var mark&#x3D;$(this).attr(&quot;mark&quot;); var ele&#x3D;document.createElement(&quot;span&quot;); ele.innerHTML&#x3D;mark+&quot;不能为空!&quot;; $(this).after(ele); $(ele).prop(&quot;class&quot;,&quot;error&quot;);&#x2F;&#x2F; DOM对象转换为jquery对象 flag&#x3D;false; &#x2F;&#x2F; return false--------&gt;引出$.each的return false注意点 &#125; &#125;); return flag &#125; &#x2F;&#x2F;---------------------------------------------------------&#x2F;&#x2F;--------------------------------------------------------- &#x2F;&#x2F;--------------------------------------------------------- function f()&#123; for(var i&#x3D;0;i&lt;4;i++)&#123; if (i&#x3D;&#x3D;2)&#123; return &#125; console.log(i) &#125; &#125; f(); &#x2F;&#x2F; 这个例子大家应该不会有问题吧!!!&#x2F;&#x2F;------------------------------------------ li&#x3D;[11,22,33,44]; $.each(li,function(i,v)&#123; if (v&#x3D;&#x3D;33)&#123; return ; &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;试一试 return false会怎样? &#125; console.log(v) &#125;);&#x2F;&#x2F;------------------------------------------ &#x2F;&#x2F; $.MyEach(obj,function(i,v)&#123;&#125;): for(var i in obj)&#123; func(i,obj[i]) ; &#x2F;&#x2F; i就是索引,v就是对应值 &#x2F;&#x2F; &#123;&#125;:我们写的大括号的内容就是func的执行语句; &#125; &#x2F;&#x2F; 大家再考虑: function里的return只是结束了当前的函数,并不会影响后面函数的执行 &#x2F;&#x2F;本来这样没问题,但因为我们的需求里有很多这样的情况:我们不管循环到第几个函数时,一旦return了, &#x2F;&#x2F;希望后面的函数也不再执行了!基于此,jquery在$.each里又加了一步: for(var i in obj)&#123; ret&#x3D;func(i,obj[i]) ; if(ret&#x3D;&#x3D;false)&#123; return ; &#125; &#125; &#x2F;&#x2F; 这样就很灵活了: &#x2F;&#x2F; &lt;1&gt;如果你想return后下面循环函数继续执行,那么就直接写return或return true &#x2F;&#x2F; &lt;2&gt;如果你不想return后下面循环函数继续执行,那么就直接写return false&#x2F;&#x2F; --------------------------------------------------------------------- &#x2F;&#x2F; 说了这么多,请问大家如果我们的需求是:判断出一个输入有问题后面就不判断了(当然也就不显示了), &#x2F;&#x2F; 怎么办呢? &#x2F;&#x2F; 对了 if (value.trim().length&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;... &#x2F;&#x2F;... &#x2F;&#x2F;flag&#x3D;false; &#x2F;&#x2F; flag&#x3D;false不要去,它的功能是最后如果有问题,不提交数据! return false &#125;&#x2F;&#x2F;最后,大家尝试着用jquery的绑定来完成这个功能! $(&quot;.Form :submit&quot;).click(function()&#123;&#125;); &lt;&#x2F;script&gt; 轮播图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; clear: both; &#125; #outer &#123; position: relative; height: 340px; width: 790px; margin: 0 auto; top: 100px; &#125; .imgarea &#123; position: absolute; height: 100%; width: 100%; list-style: none; &#125; .imgarea li &#123; display: inline-block; position: absolute; height: 100%; width: 100%; &#125; .count &#123; position: absolute; height: 20px; list-style: none; margin-left: 50%; left: -30px; bottom: 3px; background-color: white; padding: 5px 5px; border-radius: 20px; border: 0px solid red; opacity: 0.7; &#125; .count li &#123; display: inline-block; width: 20px; height: 20px; background-color: #bbeff5; border-radius: 20px; margin-left: 5px; line-height: 20px; text-align: center; opacity: 0.5; &#125; .count li:hover &#123; opacity: 0.9; &#125; #outer .btn &#123; position: absolute; display: block; width: 20px; height: 60px; top: 50%; margin-top: -30px; background-color: lightgrey; color: white; opacity: 0.5; line-height: 60px; text-align: center; font-size: 30px; &#125; #outer #leftbtn &#123; left: 0; &#125; #outer #rightbtn &#123; right: 0; &#125; #leftbtn:hover, #rightbtn:hover &#123; opacity: 0.8; &#125; .count .activate &#123; background-color: red; opacity: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"outer\"&gt; &lt;ul class=\"imgarea\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;img src=\"img/1.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;img src=\"img/2.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;img src=\"img/3.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;img src=\"img/4.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;img src=\"img/5.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;img src=\"img/6.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"count\"&gt; &lt;/ul&gt; &lt;div class=\"btn\" id=\"leftbtn\"&gt; &lt;&lt;/div&gt; &lt;div class=\"btn\" id=\"rightbtn\"&gt; &gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; var cur_index = 0; for (var i = 0; i &lt; $(\".imgarea li\").length; ++i) &#123; $(\".count\").append(\"&lt;li&gt;\"); &#125; $(\".imgarea li\").eq(cur_index).show().siblings().hide(); $(\".count li\").eq(cur_index).addClass('activate').siblings().removeClass('activate'); function goR() &#123; ++cur_index; if (cur_index &gt; $(\".imgarea li\").length) &#123; cur_index = 0; &#125; $(\".imgarea li\").eq(cur_index).stop().fadeIn(800).siblings().stop().fadeOut(800) $(\".count li\").eq(cur_index).addClass('activate').siblings().removeClass('activate'); &#125; function goL() &#123; --cur_index; if (cur_index &lt; 0) &#123; cur_index = $(\".imgarea li\").length; &#125; $(\".imgarea li\").eq(cur_index).stop().fadeIn(800).siblings().stop().fadeOut(800) $(\".count li\").eq(cur_index).addClass('activate').siblings().removeClass('activate'); &#125; $(\".count li\").mouseover(function () &#123; cur_index = $(this).index() $(\".imgarea li\").eq(cur_index).stop().fadeIn(800).siblings().stop().fadeOut(800) $(\".count li\").eq(cur_index).addClass('activate').siblings().removeClass('activate'); &#125;); $(\"#rightbtn\").click(goR) $(\"#leftbtn\").click(goL) var intv = setInterval(goR, 1500); $(\"#outer\").hover(function () &#123; clearInterval(intv) &#125;, function () &#123; intv = setInterval(goR, 1500) &#125;) &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://sjtu-xx.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"JavaScript","slug":"JavaScript","date":"2020-06-29T13:26:36.000Z","updated":"2021-02-20T10:27:50.824Z","comments":true,"path":"2020/06/29/JavaScript/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/JavaScript/","excerpt":"[toc] JavaScript 的基础","text":"[toc] JavaScript 的基础 知识预览 BOM对象 DOM对象(DHTML) 8 实例练习 JavaScript概述JavaScript的历史 1992年Nombas开发出C-minus-minus(C–)的嵌入式脚本语言(最初绑定在CEnvi软件中).后将其改名ScriptEase.(客户端执行的语言) Netscape(网景)接收Nombas的理念,(Brendan Eich)在其Netscape Navigator 2.0产品中开发出一套livescript的脚本语言.Sun和Netscape共同完成.后改名叫Javascript 微软随后模仿在其IE3.0的产品中搭载了一个JavaScript的克隆版叫Jscript. 为了统一三家,ECMA(欧洲计算机制造协会)定义了ECMA-262规范.国际标准化组织及国际电工委员会（ISO/IEC）也采纳 ECMAScript 作为标准（ISO/IEC-16262）。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。EcmaScript是规范. ECMAScript尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的： 核心（ECMAScript） 文档对象模型（DOM） Document object model (整合js，css，html) 浏览器对象模型（BOM） Broswer object model（整合js和浏览器） Javascript 在开发中绝大多数情况是基于对象的.也是面向对象的. ​ 简单地说，ECMAScript 描述了以下内容： 语法 类型 语句 关键字 保留字 运算符 对象 (封装 继承 多态) 基于对象的语言.使用对象. JavaScript的引入方式123456&#123;#1 直接编写#&#125; &lt;script&gt; alert(&#39;hello yuan&#39;) &lt;&#x2F;script&gt;&#123;#2 导入文件#&#125; &lt;script src&#x3D;&quot;hello.js&quot;&gt;&lt;&#x2F;script&gt; JavaScript的基础变量123x&#x3D;5y&#x3D;6z&#x3D;x+y 在代数中，我们使用字母（比如 x）来保存值（比如 5）。 通过上面的表达式 z=x+y，我们能够计算出 z 的值为 11。 在 JavaScript 中，这些字母被称为变量。 0 变量是弱类型的(很随便)； 1 声明变量时不用声明变量类型. 全都使用var关键字; 1var a; 2 一行可以声明多个变量.并且可以是不同类型. 1var name&#x3D;&quot;yuan&quot;, age&#x3D;20, job&#x3D;&quot;lecturer&quot;; 3 (了解) 声明变量时 可以不用var. 如果不用var 那么它是全局变量. 4 变量命名,首字符只能是字母,下划线,$美元符 三选一，且区分大小写，x与X是两个变量 5 变量还应遵守以下某条著名的命名规则： 123456789Camel 标记法首字母是小写的，接下来的字母都以大写字符开头。例如：var myTestValue &#x3D; 0, mySecondValue &#x3D; &quot;hi&quot;;Pascal 标记法首字母是大写的，接下来的字母都以大写字符开头。例如：Var MyTestValue &#x3D; 0, MySecondValue &#x3D; &quot;hi&quot;;匈牙利类型标记法在以 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。例如，i 表示整数，s 表示字符串，如下所示“Var iMyTestValue &#x3D; 0, sMySecondValue &#x3D; &quot;hi&quot;; 注意： 1234567891011 function func1()&#123; var a &#x3D; 123; b&#x3D;456 &#125; func1(); &#x2F;&#x2F; alert(a);&#x2F;&#x2F; alert(b);&#x2F;&#x2F; 不推荐 基础规范1 每行结束可以不加分号. 没有分号会以换行符作为每行的结束 1234567891011121314151617a&#x3D;1;b&#x3D;2;a&#x3D;1 b&#x3D;2;------错误a&#x3D;1b&#x3D;2&#x2F;&#x2F;推荐a&#x3D;1;b&#x3D;2;&#123; a&#x3D;1; b&#x3D;2; &#x2F;&#x2F;推荐加tab a&#x3D;1; b&#x3D;2;&#125; 2 注释 支持多行注释和单行注释. /* */ // 3 使用{}来封装代码块 2.3 常量和标识符常量 ：直接在程序中出现的数据值 标识符： 由不以数字开头的字母、数字、下划线(_)、美元符号($)组成 常用于表示函数、变量等的名称 例如：_abc,$abc,abc,abc123是标识符，而1abc不是 JavaScript语言中代表特定含义的词称为保留字，不允许程序再定义为标识符 ​ ​ 数据类型​ image 数字类型(Number)123456简介最基本的数据类型不区分整型数值和浮点型数值所有数字都采用64位浮点格式存储，相当于Java和C语言中的double格式能表示的最大值是±1.7976931348623157 x 10308 能表示的最小值是±5 x 10 -324 整数： 在JavaScript中10进制的整数由数字的序列组成 精确表达的范围是-9007199254740992 (-253) 到 9007199254740992 (253) 超出范围的整数，精确度将受影响 浮点数： 使用小数点记录数据 例如：3.4，5.6 使用指数记录数据 例如：4.3e23 = 4.3 x 1023 16进制和8进制数的表达 16进制数据前面加上0x，八进制前面加0 16进制数是由0-9,A-F等16个字符组成 8进制数由0-7等8个数字组成 16进制和8进制与2进制的换算 12# 2进制: 1111 0011 1101 0100 &lt;-----&gt; 16进制:0xF3D4 &lt;-----&gt; 10进制:62420# 2进制: 1 111 001 111 010 100 &lt;-----&gt; 8进制:0171724 字符串(String)1234567简介是由Unicode字符、数字、标点符号组成的序列字符串常量首尾由单引号或双引号括起JavaScript中没有字符类型常用特殊字符在字符串中的表达字符串中部分特殊字符必须加上右划线\\常用的转义字符 \\n:换行 \\&#39;:单引号 \\&quot;:双引号 \\\\:右划线 String数据类型的使用 特殊字符的使用方法和效果 Unicode的插入方法 1234&lt;script&gt; var str&#x3D;&quot;\\u4f60\\u597d\\n欢迎来到\\&quot;JavaScript世界\\&quot;&quot;; alert(str);&lt;&#x2F;script&gt; 布尔型(Boolean)123456789简介Boolean类型仅有两个值：true和false，也代表1和0，实际运算中true&#x3D;1,false&#x3D;0布尔值也可以看作on&#x2F;off、yes&#x2F;no、1&#x2F;0对应true&#x2F;falseBoolean值主要用于JavaScript的控制语句，例如 if (x&#x3D;&#x3D;1)&#123; y&#x3D;y+1; &#125;else &#123; y&#x3D;y-1; &#125; Null &amp; UndefinedUndefined 类型 Undefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。 当函数无明确返回值时，返回的也是值 “undefined”; Null 类型 另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。 尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。 var person=new Person() var person=null 数据类型转换1234JavaScript属于松散类型的程序语言变量在声明的时候并不需要指定数据类型变量只有在赋值的时候才会确定数据类型表达式中包含不同类型数据则在计算过程中会强制进行类别转换 数字 + 字符串：数字转换为字符串 数字 + 布尔值：true转换为1，false转换为0 字符串 + 布尔值：布尔值转换为字符串true或false 强制类型转换函数 12345函数parseInt： 强制转换成整数 例如parseInt(&quot;6.12&quot;)&#x3D;6 ; parseInt(“12a&quot;)&#x3D;12 ; parseInt(“a12&quot;)&#x3D;NaN ;parseInt(“1a2&quot;)&#x3D;1函数parseFloat： 强制转换成浮点数 parseFloat(&quot;6.12&quot;)&#x3D;6.12函数eval： 将字符串强制转换为表达式并返回结果 eval(&quot;1+1&quot;)&#x3D;2 ; eval(&quot;1&lt;2&quot;)&#x3D;true 类型查询函数(typeof)ECMAScript 提供了 typeof 运算符来判断一个值是否在某种类型的范围内。可以用这种运算符判断一个值是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。 123456函数typeof ：查询数值当前类型 (string &#x2F; number &#x2F; boolean &#x2F; object )例如typeof(&quot;test&quot;+3) &quot;string&quot;例如typeof(null) &quot;object &quot;例如typeof(true+1) &quot;number&quot;例如typeof(true-false) &quot;number&quot; ECMAScript 运算符ECMAScript 算数运算符12345加(＋)、 减(－)、 乘(*) 、除(&#x2F;) 、余数(% ) 加、减、乘、除、余数和数学中的运算方法一样 例如：9&#x2F;2&#x3D;4.5，4*5&#x3D;20，9%2&#x3D;1-除了可以表示减号还可以表示负号 例如：x&#x3D;-y+除了可以表示加法运算还可以用于字符串的连接 例如：&quot;abc&quot;+&quot;def&quot;&#x3D;&quot;abcdef&quot; 递增(＋＋) 、递减(－－) 123456789假如x&#x3D;2，那么x++表达式执行后的值为3，x--表达式执行后的值为1i++相当于i&#x3D;i+1，i--相当于i&#x3D;i-1递增和递减运算符可以放在变量前也可以放在变量后：--i var i&#x3D;1;console.log(i++); #先执行后加法console.log(++i); #先加法后执行console.log(i--);console.log(--i); 一元加减法： 123456789101112131415161718192021222324 var a&#x3D;1; var b&#x3D;1; a&#x3D;-a; &#x2F;&#x2F;a&#x3D;-1 var c&#x3D;&quot;10&quot;; alert(typeof (c)); c&#x3D;+c; &#x2F;&#x2F;类型转换 alert(typeof (c));&#x2F;&#x2F; ------------------- var d&#x3D;&quot;yuan&quot;; d&#x3D;+d; alert(d);&#x2F;&#x2F;NaN:属于Number类型的一个特殊值,当遇到将字符串转成数字无效时,就会得到一个NaN数据 alert(typeof(d));&#x2F;&#x2F;Number &#x2F;&#x2F;NaN特点: var n&#x3D;NaN; alert(n&gt;3); alert(n&lt;3); alert(n&#x3D;&#x3D;3); alert(n&#x3D;&#x3D;NaN); alert(n!&#x3D;NaN);&#x2F;&#x2F;NaN参与的所有的运算都是false,除了!&#x3D; ECMAScript 逻辑运算符12345678等于 ( &#x3D;&#x3D; ) 、不等于( !&#x3D; ) 、 大于( &gt; ) 、 小于( &lt; ) 大于等于(&gt;&#x3D;) 、小于等于(&lt;&#x3D;)与 (&amp;&amp;) 、或(||) 、非(!)1 &amp;&amp; 1 &#x3D; 1 1 || 1 &#x3D; 11 &amp;&amp; 0 &#x3D; 0 1 || 0 &#x3D; 10 &amp;&amp; 0 &#x3D; 0 0 || 0 &#x3D; 0!0&#x3D;1!1&#x3D;0 逻辑 AND 运算符(&amp;&amp;)逻辑 AND 运算的运算数可以是任何类型的，不止是 Boolean 值。 如果某个运算数不是原始的 Boolean 型值，逻辑 AND 运算并不一定返回 Boolean 值： 如果某个运算数是 null，返回 null。 如果某个运算数是 NaN，返回 NaN。 如果某个运算数是 undefined，返回undefined。 逻辑 OR 运算符(||)与逻辑 AND 运算符相似，如果某个运算数不是 Boolean 值，逻辑 OR 运算并不一定返回 Boolean 值 ECMAScript 赋值运算符1234567赋值 &#x3D; JavaScript中&#x3D;代表赋值，两个等号&#x3D;&#x3D;表示判断是否相等例如，x&#x3D;1表示给x赋值为1if (x&#x3D;&#x3D;1)&#123;...&#125;程序表示当x与1相等时if(x&#x3D;&#x3D;“on”)&#123;…&#125;程序表示当x与“on”相等时 配合其他运算符形成的简化表达式例如i+&#x3D;1相当于i&#x3D;i+1，x&amp;&#x3D;y相当于x&#x3D;x&amp;y 实例： 123456789102 &#x3D;&#x3D; “2” #进行类型转换后比较2 &#x3D;&#x3D;&#x3D; “2” #不进行类型转换直接进行比较 4 !&#x3D; “4” 4 !&#x3D;&#x3D; “4” var a &#x3D; 2; var b &#x3D; 4;var c &#x3D; a&lt;b | --b&gt;--a;var c &#x3D; a&lt;b || --b&gt;--a; var c &#x3D; a&lt;b &amp;&amp;--b&gt;--a;var c &#x3D; a&lt;b &amp; --b&gt;--a; ECMAScript等性运算符执行类型转换的规则如下： 如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。 在比较时，该运算符还遵守下列规则： 值 null 和 undefined 相等。 在检查相等性时，不能把 null 和 undefined 转换成其他值。 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 ​ ECMAScript 关系运算符**(重要)**12var bResult &#x3D; &quot;Blue&quot; &lt; &quot;alpha&quot;;alert(bResult); &#x2F;&#x2F;输出 true 在上面的例子中，字符串 “Blue” 小于 “alpha”，因为字母 B 的字符代码是 66，字母 a 的字符代码是 97。 比较数字和字符串 另一种棘手的状况发生在比较两个字符串形式的数字时，比如： 12var bResult &#x3D; &quot;25&quot; &lt; &quot;3&quot;;alert(bResult); &#x2F;&#x2F;输出 &quot;true&quot; 上面这段代码比较的是字符串 “25” 和 “3”。两个运算数都是字符串，所以比较的是它们的字符代码（”2” 的字符代码是 50，”3” 的字符代码是 51）。 不过，如果把某个运算数该为数字，那么结果就有趣了： 12var bResult &#x3D; &quot;25&quot; &lt; 3;alert(bResult); &#x2F;&#x2F;输出 &quot;false&quot; 这里，字符串 “25” 将被转换成数字 25，然后与数字 3 进行比较，结果不出所料。 总结： 12比较运算符两侧如果一个是数字类型,一个是其他类型,会将其类型转换成数字类型.比较运算符两侧如果都是字符串类型,比较的是最高位的asc码,如果最高位相等,继续取第二位比较. Boolean运算符(重要)1234567var temp&#x3D;new Object();&#x2F;&#x2F; false;[];0; null; undefined;object(new Object();) if(temp)&#123; console.log(&quot;yuan&quot;) &#125;else &#123; console.log(&quot;alex&quot;) &#125; 全等号和非全等号等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。 控制语句if 控制语句1234567891011if-else基本格式if (表达式)&#123;语句１;......&#125;else&#123;语句２;.....&#125;功能说明如果表达式的值为true则执行语句1,否则执行语句2 123456789101112131415161718var x&#x3D; (new Date()).getDay();&#x2F;&#x2F;获取今天的星期值，0为星期天var y;if ( (x&#x3D;&#x3D;6) || (x&#x3D;&#x3D;0) ) &#123;y&#x3D;&quot;周末&quot;;&#125;else&#123;y&#x3D;&quot;工作日&quot;;&#125;alert(y);&#x2F;&#x2F;等价于y&#x3D;&quot;工作日&quot;;if ( (x&#x3D;&#x3D;6) || (x&#x3D;&#x3D;0) ) &#123;y&#x3D;&quot;周末&quot;;&#125; if 可以单独使用 12345678910if语句嵌套格式if (表达式1) &#123; 语句1;&#125;else if (表达式2)&#123; 语句2;&#125;else if (表达式3)&#123; 语句3;&#125; else&#123; 语句4;&#125; 1234567891011if (x&#x3D;&#x3D;1)&#123; y&#x3D;&quot;星期一&quot;;&#125;else if (x&#x3D;&#x3D;2)&#123; y&#x3D;&quot;星期二&quot;;...&#125;else if (x&#x3D;&#x3D;6)&#123; y&#x3D;&quot;星期六&quot;;&#125;else if (x&#x3D;&#x3D;0)&#123; y&#x3D;&quot;星期日&quot;;&#125;else&#123; y&#x3D;&quot;未定义&quot;; switch 选择控制语句1234567switch基本格式switch (表达式) &#123; case 值1:语句1;break; case 值2:语句2;break; case 值3:语句3;break; default:语句4;&#125; 12345678910switch(x)&#123;case 1:y&#x3D;&quot;星期一&quot;; break;case 2:y&#x3D;&quot;星期二&quot;; break;case 3:y&#x3D;&quot;星期三&quot;; break;case 4:y&#x3D;&quot;星期四&quot;; break;case 5:y&#x3D;&quot;星期五&quot;; break;case 6:y&#x3D;&quot;星期六&quot;; break;case 7:y&#x3D;&quot;星期日&quot;; break;default: y&#x3D;&quot;未定义&quot;;&#125; switch比else if结构更加简洁清晰，使程序可读性更强,效率更高。 123456789101112131415161718192021首先要看一个问题，if 语句适用范围比较广，只要是 boolean 表达式都可以用 if 判断；而 switch 只能对基本类型进行数值比较。两者的可比性就仅限在两个基本类型比较的范围内。说到基本类型的数值比较，那当然要有两个数。然后重点来了——if 语句每一句都是独立的，看下面的语句：if (a &#x3D;&#x3D; 1) ...else if (a &#x3D;&#x3D; 2) ...这样 a 要被读入寄存器两次，1 和 2 分别被读入寄存器一次。于是你是否发现其实 a 读两次是有点多余的，在你全部比较完之前只需要一次读入寄存器就行了，其余都是额外开销。但是 if 语句必须每次都把里面的两个数从内存拿出来读到寄存器，它不知道你其实比较的是同一个 a。于是 switch case 就出来了，把上面的改成 switch case 版本：switch (a) &#123; case 0: break; case 1:&#125; 总结:1.switch用来根据一个整型值进行多路分支，并且编译器可以对多路分支进行优化2.switch-case只将表达式计算一次,然后将表达式的值与每个case的值比较,进而选 择执行哪一个case的语句块3.if..else 的判断条件范围较广，每条语句基本上独立的，每次判断时都要条件加载 一次。所以在多路分支时用switch比if..else if .. else结构要效率高。 for 循环控制语句1234567for循环基本格式for (初始化;条件;增量)&#123; 语句1; ...&#125;功能说明实现条件循环，当条件成立时，执行语句1，否则跳出循环体 ​ 12345678910for (var i&#x3D;1;i&lt;&#x3D;7;i++)&#123; document.write(&quot;&lt;H&quot;+i+&quot;&gt;hello&lt;&#x2F;H &quot;+i+&quot;&gt; &quot;); document.write(&quot;&lt;br&gt;&quot;);&#125;---------------------------------------------- var arr&#x3D;[1,&quot;hello&quot;,true]&#x2F;&#x2F;var dic&#x3D;&#123;&quot;1&quot;:&quot;111&quot;&#125; for (var i in arr)&#123; console.log(i) console.log(arr[i]) &#125; 注意： 1234567891011121314 doms&#x3D;document.getElementsByTagName(&quot;p&quot;); for (var i in doms)&#123; console.log(i); &#x2F;&#x2F; 0 1 2 length item namedItem &#x2F;&#x2F;console.log(doms[i]) &#125;&#x2F;&#x2F;循环的是你获取的th一个DOM元素集，for in用来循环对象的所有属性，dom元素集包含了你上面输出的属性。&#x2F;&#x2F;如果你只要循环dom对象的话，可以用for循环: for (var i&#x3D;0;i&lt;doms.length;i++)&#123; console.log(i) ; &#x2F;&#x2F; 0 1 2 &#x2F;&#x2F;console.log(doms[i]) &#125; 结论：for i in 不推荐使用. while 循环控制语句1234567while循环基本格式while (条件)&#123;语句1；...&#125;功能说明运行功能和for类似，当条件成立循环执行语句花括号&#123;&#125;内的语句，否则跳出循环 ​ 1234567var i&#x3D;1;while (i&lt;&#x3D;7) &#123; document.write(&quot;&lt;H&quot;+i+&quot;&gt;hello&lt;&#x2F;H &quot;+i+&quot;&gt; &quot;); document.write(&quot;&lt;br&gt;&quot;); i++;&#125;&#x2F;&#x2F;循环输出H1到H7的字体大小 123456789101112&lt;script language&#x3D;&quot;JavaScript&quot;&gt;&#x2F;* sayhello是定义的函数名，前面必须加上function和空格*&#x2F;function sayHello()&#123; var hellostr; var myname&#x3D;prompt(&quot;请问您贵姓？&quot;,&quot;苑&quot;); hellostr&#x3D;&quot;您好，&quot;+myname+&#39;先生，欢迎进入&quot;探索之旅&quot;！&#39;; alert(hellostr); document.write(hellostr);&#125; &#x2F;&#x2F;这里是对前面定义的函数进行调用sayHello();&lt;&#x2F;script&gt; 练习：分别用for循环和while循环计算出1-100的和？ 异常处理12345678910try &#123; &#x2F;&#x2F;这段代码从上往下运行，其中任何一个语句抛出异常该代码块就结束运行&#125;catch (e) &#123; &#x2F;&#x2F; 如果try代码块中抛出了异常，catch代码块中的代码就会被执行。 &#x2F;&#x2F;e是一个局部变量，用来指向Error对象或者其他抛出的对象&#125;finally &#123; &#x2F;&#x2F;无论try中代码是否有异常抛出（甚至是try代码块中有return语句），finally代码块中始终会被执行。&#125; 注：主动抛出异常 throw Error(‘xxxx’) ECMA对象从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。 var o = new Object(); 对象的概念与分类： 由ECMAScript定义的本地对象.独立于宿主环境的 ECMAScript 实现提供的对象.(native object) ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现.这意味着开发者不必明确实例化内置对象，它已被实例化了。ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。（built-in object） 所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有 BOM 和 DOM 对象都是宿主对象。 object对象：ECMAScript 中的所有对象都由这个对象继承而来；Object 对象中的所有属性和方法都会出现在其他对象中 12ToString() : 返回对象的原始字符串表示。ValueOf() : 返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。 11种内置对象包括： Array ,String , Date, Math, Boolean, Number Function, Global, Error, RegExp , Object 简介： 在JavaScript中除了null和undefined以外其他的数据类型都被定义成了对象，也可以用创建对象的方法定义变量，String、Math、Array、Date、RegExp都是JavaScript中重要的内置对象，在JavaScript程序大多数功能都是通过对象实现的 12345678910&lt;script language&#x3D;&quot;javascript&quot;&gt;var aa&#x3D;Number.MAX_VALUE; &#x2F;&#x2F;利用数字对象获取可表示最大数var bb&#x3D;new String(&quot;hello JavaScript&quot;); &#x2F;&#x2F;创建字符串对象var cc&#x3D;new Date();&#x2F;&#x2F;创建日期对象var dd&#x3D;new Array(&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;); &#x2F;&#x2F;数组对象&lt;&#x2F;script&gt; ​ String对象自动创建字符串对象： 123var str1&#x3D;&quot;hello world&quot;;alert(str1.length);alert(str1.substr(1,5)); 调用字符串的对象属性或方法时自动创建对象，用完就丢弃 手工创建字符串对象 123var str1&#x3D; new String(&quot;hello word&quot;);alert(str1.length);alert(str1.substr(1,3)); 采用new创建字符串对象str1，全局有效 String对象的属性12获取字符串长度length var str1=”String对象”; var str2=””; alert(“str1长度 “+str1.length); alert(“str2长度 “+str2.length); ​ String对象的方法(1) —— 格式编排方法 格式编排方法返回值列表 123456789书写格式:String对象提供了一组针对HTML格式的方法，如x.anchor()返回锚定义字符串&lt;a&gt;x&lt;&#x2F;a&gt;，x.bold()返回粗体表示字符串&lt;b&gt;x&lt;&#x2F;b&gt;，x.sup()返回上标格式字符串&lt;sup&gt;x&lt;&#x2F;sup&gt;。-----------------------------------------var x&#x3D;&quot;yuan&quot;;var y&#x3D;&quot;x.italics():&quot;+x.italics();document.write(y.fontsize(10));&#x2F;&#x2F;&lt;font size&#x3D;&quot;10&quot;&gt;x.italics():&lt;i&gt;yuan&lt;&#x2F;i&gt;&lt;&#x2F;font&gt; String对象的方法(2)—— 大小写转换 12345678var str1&#x3D;&quot;AbcdEfgh&quot;; var str2&#x3D;str1.toLowerCase();var str3&#x3D;str1.toUpperCase();alert(str2);&#x2F;&#x2F;结果为&quot;abcdefgh&quot;alert(str3);&#x2F;&#x2F;结果为&quot;ABCDEFGH&quot; String对象的方法(3) —— 获取指定字符 12345678910111213141516171819202122书写格式x.charAt(index)x.charCodeAt(index)使用注解x代表字符串对象index代表字符位置index从0开始编号charAt返回index位置的字符charCodeAt返回index位置的Unicode编码----------------------var str1&#x3D;&quot;welcome to the world of JS! 苑昊&quot;;var str2&#x3D;str1.charAt(28);var str3&#x3D;str1.charCodeAt(28);alert(str2);&#x2F;&#x2F;结果为&quot;苑&quot;alert(str3);&#x2F;&#x2F;结果为33489 String对象的方法(4)—— 查询字符串 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F;书写格式&#x2F;&#x2F;&#x2F;&#x2F;x.indexOf(findstr,index)&#x2F;&#x2F;x.lastIndexOf(findstr)&#x2F;&#x2F;-------------------------------------var str1&#x3D;&quot;welcome to the world of JS!&quot;;var str2&#x3D;str1.indexOf(&quot;l&quot;);var str3&#x3D;str1.lastIndexOf(&quot;l&quot;);alert(str2);&#x2F;&#x2F;结果为2alert(str3);&#x2F;&#x2F;结果为18&#x2F;&#x2F;-------*********************************************************-------&#x2F;&#x2F;书写格式&#x2F;&#x2F;&#x2F;&#x2F;x.match(regexp)&#x2F;&#x2F;&#x2F;&#x2F;x.search(regexp)&#x2F;&#x2F;&#x2F;&#x2F;使用注解&#x2F;&#x2F;&#x2F;&#x2F;x代表字符串对象&#x2F;&#x2F;&#x2F;&#x2F;regexp代表正则表达式或字符串&#x2F;&#x2F;&#x2F;&#x2F;match返回匹配字符串的数组，如果没有匹配则返回null&#x2F;&#x2F;&#x2F;&#x2F;search返回匹配字符串的首字符位置索引&#x2F;&#x2F;-------------------------------------var str1&#x3D;&quot;welcome to the world of JS!&quot;;var str2&#x3D;str1.match(&quot;world&quot;);var str3&#x3D;str1.search(&quot;world&quot;);alert(str2[0]);&#x2F;&#x2F;结果为&quot;world&quot;alert(str3);&#x2F;&#x2F;结果为15 String对象的方法(5) ——子字符串处理 截取子字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x2F;&#x2F;截取子字符串&#x2F;&#x2F;&#x2F;&#x2F;书写格式&#x2F;&#x2F;&#x2F;&#x2F;x.substr(start, length)&#x2F;&#x2F;&#x2F;&#x2F;x.substring(start, end)&#x2F;&#x2F;&#x2F;&#x2F;使用注解&#x2F;&#x2F;&#x2F;&#x2F;x代表字符串对象&#x2F;&#x2F;&#x2F;&#x2F;start表示开始位置&#x2F;&#x2F;&#x2F;&#x2F;length表示截取长度&#x2F;&#x2F;&#x2F;&#x2F;end是结束位置加1&#x2F;&#x2F;&#x2F;&#x2F;第一个字符位置为0var str1&#x3D;&quot;abcdefgh&quot;;var str2&#x3D;str1.substr(2,4);var str3&#x3D;str1.substring(2,4);alert(str2);&#x2F;&#x2F;结果为&quot;cdef&quot;alert(str3);&#x2F;&#x2F;结果为&quot;cd&quot;&#x2F;&#x2F;-------*********************************************************-------&#x2F;&#x2F;x.slice(start, end)var str1&#x3D;&quot;abcdefgh&quot;;var str2&#x3D;str1.slice(2,4);var str3&#x3D;str1.slice(4);var str4&#x3D;str1.slice(2,-1);var str5&#x3D;str1.slice(-3,-1);alert(str2);&#x2F;&#x2F;结果为&quot;cd&quot;alert(str3);&#x2F;&#x2F;结果为&quot;efgh&quot;alert(str4);&#x2F;&#x2F;结果为&quot;cdefg&quot;alert(str5);&#x2F;&#x2F;结果为&quot;fg&quot; 替换子字符串 123456&#x2F;&#x2F;x.replace(findstr,tostr)var str1&#x3D;&quot;abcdefgh&quot;;var str2&#x3D;str1.replace(&quot;cd&quot;,&quot;aaa&quot;);alert(str2);&#x2F;&#x2F;结果为&quot;abaaaefgh&quot; 分割字符串 123456var str1&#x3D;&quot;一,二,三,四,五,六,日&quot;; var strArray&#x3D;str1.split(&quot;,&quot;);alert(strArray[1]);&#x2F;&#x2F;结果为&quot;二&quot; 连接字符串 12345678910111213&#x2F;&#x2F;y&#x3D;x.concat(addstr)&#x2F;&#x2F;&#x2F;&#x2F;使用注解&#x2F;&#x2F;&#x2F;&#x2F;x代表字符串对象&#x2F;&#x2F;addstr为添加字符串&#x2F;&#x2F;返回x+addstr字符串 var str1&#x3D;&quot;abcd&quot;; var str2&#x3D;str1.concat(&quot;efgh&quot;);alert(str2);&#x2F;&#x2F;结果为&quot;abcdefgh&quot; Array对象创建数组对象12345678910111213141516171819Array 对象用于在单个的变量中存储多个值。语法:创建方式1:var a&#x3D;[1,2,3];创建方式2:new Array(); &#x2F;&#x2F; 创建数组时允许指定元素个数也可以不指定元素个数。new Array(size);&#x2F;&#x2F;if 1个参数且为数字,即代表size,not content 初始化数组对象: var cnweek&#x3D;new Array(7); cnweek[0]&#x3D;&quot;星期日&quot;; cnweek[1]&#x3D;&quot;星期一&quot;; ... cnweek[6]&#x3D;&quot;星期六&quot;;new Array(element0, element1, ..., elementn)&#x2F;&#x2F;也可以直接在建立对象时初始化数组元素，元素类型允许不同var test&#x3D;new Array(100,&quot;a&quot;,true); 创建二维数组1234567891011var cnweek&#x3D;new Array(7);for (var i&#x3D;0;i&lt;&#x3D;6;i++)&#123; cnweek[i]&#x3D;new Array(2);&#125;cnweek[0][0]&#x3D;&quot;星期日&quot;;cnweek[0][1]&#x3D;&quot;Sunday&quot;;cnweek[1][0]&#x3D;&quot;星期一&quot;;cnweek[1][1]&#x3D;&quot;Monday&quot;;...cnweek[6][0]&#x3D;&quot;星期六&quot;;cnweek[6][1]&#x3D;&quot;Saturday&quot;; Array对象的属性获取数组元素的个数：length 1234567891011var cnweek&#x3D;new Array(7);cnweek[0]&#x3D;&quot;星期日&quot;;cnweek[1]&#x3D;&quot;星期一&quot;;cnweek[2]&#x3D;&quot;星期二&quot;;cnweek[3]&#x3D;&quot;星期三&quot;;cnweek[4]&#x3D;&quot;星期四&quot;;cnweek[5]&#x3D;&quot;星期五&quot;;cnweek[6]&#x3D;&quot;星期六&quot;;for (var i&#x3D;0;i&lt;cnweek.length;i++)&#123; document.write(cnweek[i]+&quot; | &quot;);&#125; Array对象的方法 连接数组-join方法 123456789101112131415&#x2F;&#x2F;书写格式&#x2F;&#x2F;x.join(bystr)&#x2F;&#x2F;使用注解&#x2F;&#x2F;&#x2F;&#x2F;x代表数组对象&#x2F;&#x2F;bystr作为连接数组中元素的字符串&#x2F;&#x2F;返回连接后的字符串&#x2F;&#x2F;与字符串的split功能刚好相反 var arr1&#x3D;[1, 2, 3, 4, 5, 6, 7];var str1&#x3D;arr1.join(&quot;-&quot;);alert(str1);&#x2F;&#x2F;结果为&quot;1-2-3-4-5-6-7&quot; 连接数组-concat方法 1234567891011121314&#x2F;&#x2F;连接数组-concat方法&#x2F;&#x2F;&#x2F;&#x2F;x.concat(value,...)var a &#x3D; [1,2,3];var a &#x3D; new Array(1,2,3);var b&#x3D;a.concat(4,5) ;alert(a.toString());&#x2F;&#x2F;返回结果为1,2,3alert(b.toString());&#x2F;&#x2F;返回结果为1,2,3,4,5 数组排序-reverse sort 默认将数字转换为字符串后比较。 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F;x.reverse()&#x2F;&#x2F;x.sort()var arr1&#x3D;[32, 12, 111, 444];&#x2F;&#x2F;var arr1&#x3D;[&quot;a&quot;,&quot;d&quot;,&quot;f&quot;,&quot;c&quot;];arr1.reverse(); &#x2F;&#x2F;颠倒数组元素alert(arr1.toString());&#x2F;&#x2F;结果为444,111,12,32arr1.sort(); &#x2F;&#x2F;排序数组元素alert(arr1.toString());&#x2F;&#x2F;结果为111,12,32,444&#x2F;&#x2F;------------------------------arr&#x3D;[1,5,2,100];&#x2F;&#x2F;arr.sort();&#x2F;&#x2F;alert(arr);&#x2F;&#x2F;如果就想按着数字比较呢?function intSort(a,b)&#123; if (a&gt;b)&#123; return 1;&#x2F;&#x2F;-1 &#125; else if(a&lt;b)&#123; return -1;&#x2F;&#x2F;1 &#125; else &#123; return 0 &#125;&#125;arr.sort(intSort);alert(arr);function IntSort(a,b)&#123; return a-b;&#125; 数组切片-slice 12345678910111213141516171819202122&#x2F;&#x2F;x.slice(start, end)&#x2F;&#x2F;&#x2F;&#x2F;使用注解&#x2F;&#x2F;&#x2F;&#x2F;x代表数组对象&#x2F;&#x2F;start表示开始位置索引&#x2F;&#x2F;end是结束位置下一数组元素索引编号&#x2F;&#x2F;第一个数组元素索引为0&#x2F;&#x2F;start、end可为负数，-1代表最后一个数组元素&#x2F;&#x2F;end省略则相当于从start位置截取以后所有数组元素var arr1&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;];var arr2&#x3D;arr1.slice(2,4);var arr3&#x3D;arr1.slice(4);var arr4&#x3D;arr1.slice(2,-1);alert(arr2.toString());&#x2F;&#x2F;结果为&quot;c,d&quot; alert(arr3.toString());&#x2F;&#x2F;结果为&quot;e,f,g,h&quot;alert(arr4.toString());&#x2F;&#x2F;结果为&quot;c,d,e,f,g&quot; 删除子数组 12345678910111213141516171819202122&#x2F;&#x2F;x. splice(start, deleteCount, value, ...)&#x2F;&#x2F;&#x2F;&#x2F;使用注解&#x2F;&#x2F;&#x2F;&#x2F;x代表数组对象&#x2F;&#x2F;splice的主要用途是对数组指定位置进行删除和插入&#x2F;&#x2F;start表示开始位置索引&#x2F;&#x2F;deleteCount删除数组元素的个数&#x2F;&#x2F;value表示在删除位置插入的数组元素&#x2F;&#x2F;value参数可以省略var a &#x3D; [1,2,3,4,5,6,7,8];a.splice(1,2);&#x2F;&#x2F;a变为 [1,4,5,6,7,8]alert(a.toString());a.splice(1,1); &#x2F;&#x2F;a变为[1,5,6,7,8]alert(a.toString());a.splice(1,0,2,3); &#x2F;&#x2F;a变为[1,2,3,5,6,7,8]alert(a.toString()); 数组的进出栈操作(1) 12345678910111213141516171819202122&#x2F;&#x2F;push pop这两个方法模拟的是一个栈操作&#x2F;&#x2F;x.push(value, ...) 压栈&#x2F;&#x2F;x.pop() 弹栈 &#x2F;&#x2F;使用注解&#x2F;&#x2F;&#x2F;&#x2F;x代表数组对象&#x2F;&#x2F;value可以为字符串、数字、数组等任何值&#x2F;&#x2F;push是将value值添加到数组x的结尾&#x2F;&#x2F;pop是将数组x的最后一个元素删除var arr1&#x3D;[1,2,3];arr1.push(4,5);alert(arr1);&#x2F;&#x2F;结果为&quot;1,2,3,4,5&quot;arr1.push([6,7]);alert(arr1)&#x2F;&#x2F;结果为&quot;1,2,3,4,5,6,7&quot;arr1.pop();alert(arr1);&#x2F;&#x2F;结果为&quot;1,2,3,4,5&quot; 数组的进出栈操作(2) 1234567891011121314151617181920&#x2F;&#x2F; unshift shift &#x2F;&#x2F;x.unshift(value,...)&#x2F;&#x2F;x.shift()&#x2F;&#x2F;使用注解&#x2F;&#x2F;&#x2F;&#x2F;x代表数组对象&#x2F;&#x2F;value可以为字符串、数字、数组等任何值&#x2F;&#x2F;unshift是将value值插入到数组x的开始&#x2F;&#x2F;shift是将数组x的第一个元素删除var arr1&#x3D;[1,2,3];arr1.unshift(4,5);alert(arr1);&#x2F;&#x2F;结果为&quot;4,5,1,2,3&quot;arr1. unshift([6,7]);alert(arr1);&#x2F;&#x2F;结果为&quot;6,7,4,5,1,2,3&quot;arr1.shift();alert(arr1);&#x2F;&#x2F;结果为&quot;4,5,1,2,3&quot; 总结js的数组特性： 123456789&#x2F;&#x2F; js中数组的特性 &#x2F;&#x2F;java中数组的特性, 规定是什么类型的数组,就只能装什么类型.只有一种类型. &#x2F;&#x2F;js中的数组特性1: js中的数组可以装任意类型,没有任何限制. &#x2F;&#x2F;js中的数组特性2: js中的数组,长度是随着下标变化的.用到多长就有多长. var arr5 &#x3D; [&#39;abc&#39;,123,1.14,true,null,undefined,new String(&#39;1213&#39;),new Function(&#39;a&#39;,&#39;b&#39;,&#39;alert(a+b)&#39;)]; &#x2F;* alert(arr5.length);&#x2F;&#x2F;8 arr5[10] &#x3D; &quot;hahaha&quot;; alert(arr5.length); &#x2F;&#x2F;11 alert(arr5[9]);&#x2F;&#x2F; undefined *&#x2F; Date对象创建Date对象1234567891011121314151617&#x2F;&#x2F;方法1：不指定参数var nowd1&#x3D;new Date();alert(nowd1.toLocaleString( ));&#x2F;&#x2F;方法2：参数为日期字符串var nowd2&#x3D;new Date(&quot;2004&#x2F;3&#x2F;20 11:12&quot;);alert(nowd2.toLocaleString( ));var nowd3&#x3D;new Date(&quot;04&#x2F;03&#x2F;20 11:12&quot;);alert(nowd3.toLocaleString( ));&#x2F;&#x2F;方法3：参数为毫秒数var nowd3&#x3D;new Date(5000);alert(nowd3.toLocaleString( ));alert(nowd3.toUTCString());&#x2F;&#x2F;方法4：参数为年月日小时分钟秒毫秒var nowd4&#x3D;new Date(2004,2,20,11,12,0,300);alert(nowd4.toLocaleString( ));&#x2F;&#x2F;毫秒并不直接显示 Date对象的方法—获取日期和时间1234567891011获取日期和时间getDate() 获取日getDay () 获取星期getMonth () 获取月（0-11）getFullYear () 获取完整年份getYear () 获取年getHours () 获取小时getMinutes () 获取分钟getSeconds () 获取秒getMilliseconds () 获取毫秒getTime () 返回累计毫秒数(从1970&#x2F;1&#x2F;1午夜) 练习实例： 1234567891011121314151617181920212223242526272829303132333435363738function getCurrentDate()&#123; &#x2F;&#x2F;1. 创建Date对象 var date &#x3D; new Date(); &#x2F;&#x2F;没有填入任何参数那么就是当前时间 &#x2F;&#x2F;2. 获得当前年份 var year &#x3D; date.getFullYear(); &#x2F;&#x2F;3. 获得当前月份 js中月份是从0到11. var month &#x3D; date.getMonth()+1; &#x2F;&#x2F;4. 获得当前日 var day &#x3D; date.getDate(); &#x2F;&#x2F;5. 获得当前小时 var hour &#x3D; date.getHours(); &#x2F;&#x2F;6. 获得当前分钟 var min &#x3D; date.getMinutes(); &#x2F;&#x2F;7. 获得当前秒 var sec &#x3D; date.getSeconds(); &#x2F;&#x2F;8. 获得当前星期 var week &#x3D; date.getDay(); &#x2F;&#x2F;没有getWeek &#x2F;&#x2F; 2014年06月18日 15:40:30 星期三 return year+&quot;年&quot;+changeNum(month)+&quot;月&quot;+day+&quot;日 &quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec+&quot; &quot;+parseWeek(week); &#125;alert(getCurrentDate());&#x2F;&#x2F;解决 自动补齐成两位数字的方法 function changeNum(num)&#123; if(num &lt; 10)&#123; return &quot;0&quot;+num; &#125;else&#123; return num; &#125;&#125;&#x2F;&#x2F;将数字 0~6 转换成 星期日到星期六 function parseWeek(week)&#123; var arr &#x3D; [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;]; &#x2F;&#x2F; 0 1 2 3 ............. return arr[week];&#125; Date对象的方法—设置日期和时间123456789101112131415161718192021222324&#x2F;&#x2F;设置日期和时间&#x2F;&#x2F;setDate(day_of_month) 设置日&#x2F;&#x2F;setMonth (month) 设置月&#x2F;&#x2F;setFullYear (year) 设置年&#x2F;&#x2F;setHours (hour) 设置小时&#x2F;&#x2F;setMinutes (minute) 设置分钟&#x2F;&#x2F;setSeconds (second) 设置秒&#x2F;&#x2F;setMillliseconds (ms) 设置毫秒(0-999)&#x2F;&#x2F;setTime (allms) 设置累计毫秒(从1970&#x2F;1&#x2F;1午夜) var x&#x3D;new Date();x.setFullYear (1997); &#x2F;&#x2F;设置年1997x.setMonth(7); &#x2F;&#x2F;设置月7x.setDate(1); &#x2F;&#x2F;设置日1x.setHours(5); &#x2F;&#x2F;设置小时5x.setMinutes(12); &#x2F;&#x2F;设置分钟12x.setSeconds(54); &#x2F;&#x2F;设置秒54x.setMilliseconds(230); &#x2F;&#x2F;设置毫秒230document.write(x.toLocaleString( )+&quot;&lt;br&gt;&quot;);&#x2F;&#x2F;返回1997年8月1日5点12分54秒x.setTime(870409430000); &#x2F;&#x2F;设置累计毫秒数document.write(x.toLocaleString( )+&quot;&lt;br&gt;&quot;);&#x2F;&#x2F;返回1997年8月1日12点23分50秒 Date对象的方法—日期和时间的转换123456789101112日期和时间的转换:getTimezoneOffset():8个时区×15度×4分&#x2F;度&#x3D;480;返回本地时间与GMT的时间差，以分钟为单位toUTCString()返回国际标准时间字符串toLocalString()返回本地格式时间字符串Date.parse(x)返回累计毫秒数(从1970&#x2F;1&#x2F;1午夜到本地时间)Date.UTC(x)返回累计毫秒数(从1970&#x2F;1&#x2F;1午夜到国际时间) RegExp对象123456789101112131415161718192021222324252627&#x2F;&#x2F;RegExp对象 &#x2F;&#x2F; 在表单验证时使用该对象验证用户填入的字符串是否符合规则. &#x2F;&#x2F;创建正则对象方式1 参数1 正则表达式 参数2 验证模式 g global &#x2F; i 忽略大小写. &#x2F;&#x2F;参数2一般填写g就可以，也有“gi”. &#x2F;&#x2F; 用户名 首字母必须是英文, 除了第一位其他只能是英文数字和_ . 长度最短不能少于6位 最长不能超过12位 &#x2F;&#x2F;----------------------------创建方式1 &#x2F;* var reg1 &#x3D; new RegExp(&quot;^[a-zA-Z][a-zA-Z0-9_]&#123;5,11&#125;$&quot;,&quot;g&quot;); &#x2F;&#x2F; &#x2F;&#x2F;验证字符串 var str &#x3D; &quot;bc123&quot;; alert(reg1.test(str));&#x2F;&#x2F; true &#x2F;&#x2F;----------------------------创建方式2 &#x2F;填写正则表达式&#x2F;匹配模式; var reg2 &#x3D; &#x2F;^[a-zA-Z][a-zA-Z0-9_]&#123;5,11&#125;$&#x2F;g; alert(reg2.test(str));&#x2F;&#x2F; true *&#x2F; &#x2F;&#x2F;-------------------------------正则对象的方法------------------- &#x2F;&#x2F;test方法 &#x3D;&#x3D;&gt; 测试一个字符串是否复合 正则规则. 返回值是true 和false. &#x2F;&#x2F;-------------------------String 中与正则结合的4个方法------------------. &#x2F;&#x2F; macth search split replace var str &#x3D; &quot;hello world&quot;; &#x2F;&#x2F;alert(str.match(&#x2F;o&#x2F;g)); &#x2F;&#x2F;查找字符串中 复合正则的 内容. &#x2F;&#x2F;alert(str.search(&#x2F;h&#x2F;g));&#x2F;&#x2F; 0 查找字符串中符合正则表达式的内容位置 &#x2F;&#x2F;alert(str.split(&#x2F;o&#x2F;g)); &#x2F;&#x2F; 按照正则表达式对字符串进行切割. 返回数组; alert(str.replace(&#x2F;o&#x2F;g, &quot;s&quot;)); &#x2F;&#x2F; hells wsrld 对字符串按照正则进行替换. Math对象12345678910111213141516171819202122232425262728293031 &#x2F;&#x2F;Math对象 &#x2F;&#x2F;该对象中的属性方法 和数学有关. &#x2F;&#x2F;Math是内置对象 , 与Global的不同之处是, 在调用时 需要打出 &quot;Math.&quot;前缀. &#x2F;&#x2F;属性学习: &#x2F;&#x2F;alert(Math.PI); &#x2F;&#x2F;方法学习: &#x2F;&#x2F;alert(Math.random()); &#x2F;&#x2F; 获得随机数 0~1 不包括1. &#x2F;&#x2F;alert(Math.round(1.5)); &#x2F;&#x2F; 四舍五入 &#x2F;&#x2F;练习：获取1-100的随机整数，包括1和100 &#x2F;&#x2F;var num&#x3D;Math.random(); &#x2F;&#x2F;num&#x3D;num*10; &#x2F;&#x2F;num&#x3D;Math.round(num); &#x2F;&#x2F; alert(num) &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;max min&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;* alert(Math.max(1,2));&#x2F;&#x2F; 2 alert(Math.min(1,2));&#x2F;&#x2F; 1 *&#x2F; &#x2F;&#x2F;-------------pow-------------------------------- alert(Math.pow(2,4));&#x2F;&#x2F; pow 计算参数1 的参数2 次方. abs(x) 返回数的绝对值。exp(x) 返回 e 的指数。floor(x)对数进行下舍入。log(x) 返回数的自然对数（底为e）。max(x,y) 返回 x 和 y 中的最高值。min(x,y) 返回 x 和 y 中的最低值。pow(x,y) 返回 x 的 y 次幂。random() 返回 0 ~ 1 之间的随机数。round(x) 把数四舍五入为最接近的整数。sin(x) 返回数的正弦。sqrt(x) 返回数的平方根。tan(x) 返回角的正切。 Function 对象(重点)函数的定义：123function 函数名 (参数)&#123;函数体; return 返回值;&#125; 功能说明： 可以使用变量、常量或表达式作为函数调用的参数 函数由关键字function定义 函数名的定义规则与标识符一致，大小写是敏感的 返回值必须使用return Function 类可以表示开发者定义的任何函数。 用 Function 类直接创建函数的语法如下： 123456function 函数名 (参数)&#123; 函数体; return 返回值;&#125;&#x2F;&#x2F;another way:var 函数名 &#x3D; new Function(&quot;参数1&quot;,&quot;参数n&quot;,&quot;function_body&quot;); 虽然由于字符串的关系，第二种形式写起来有些困难，但有助于理解函数只不过是一种引用类型，它们的行为与用 Function 类明确创建的函数行为是相同的。 实例： 123456789101112alert(1);function func1()&#123; alert(&#39;hello yuan!&#39;); return 8&#125; ret&#x3D;func1(); alert(ret)－－－－－－－－－－－－－－－－ var func1&#x3D;new Function(&quot;name&quot;,&quot;alert(\\&quot;hello\\&quot;+name);&quot;)func1(&quot;yuan&quot;) 注意：js的函数加载执行与python不同，它是整体加载完才会执行，所以执行函数放在函数声明上面或下面都可以： 12345678910&lt;script&gt; &#x2F;&#x2F;f(); ---&gt;OK function f()&#123; console.log(&quot;hello&quot;) &#125; f() &#x2F;&#x2F;-----&gt;OK&lt;&#x2F;script&gt; Function 对象的 length 属性 如前所述，函数属于引用类型，所以它们也有属性和方法。 比如，ECMAScript 定义的属性 length 声明了函数期望的参数个数。 1&#96;alert(func1.length)&#96; Function 对象的方法 Function 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。 1&#96;alert(void(fun1(1,2)))&#96; 运算符void()作用：拦截方法的返回值 函数的调用1234567891011121314151617181920function func1(a,b)&#123; alert(a+b);&#125; func1(1,2); &#x2F;&#x2F;3 func1(1,2,3);&#x2F;&#x2F;3 func1(1); &#x2F;&#x2F;NaN func1(); &#x2F;&#x2F;NaN &#x2F;&#x2F;只要函数名写对即可,参数怎么填都不报错.-------------------面试题----------- function a(a,b)&#123; alert(a+b);&#125; var a&#x3D;1; var b&#x3D;2; a(a,b) 函数的内置对象arguments123456789101112131415161718192021222324252627282930313233function add(a,b)&#123; console.log(a+b);&#x2F;&#x2F;3 console.log(arguments.length);&#x2F;&#x2F;2 console.log(arguments);&#x2F;&#x2F;[1,2] &#125; add(1,2) ------------------arguments的用处1 ------------------ function nxAdd()&#123; var result&#x3D;0; for (var num in arguments)&#123; result+&#x3D;arguments[num] &#125; alert(result) &#125; nxAdd(1,2,3,4,5)&#x2F;&#x2F; ------------------arguments的用处2 ------------------ function f(a,b,c)&#123; if (arguments.length!&#x3D;3)&#123; throw new Error(&quot;function f called with &quot;+arguments.length+&quot; arguments,but it just need 3 arguments&quot;) &#125; else &#123; alert(&quot;success!&quot;) &#125; &#125; f(1,2,3,4,5) 匿名函数12345678910111213&#x2F;&#x2F; 匿名函数 var func &#x3D; function(arg)&#123; return &quot;tony&quot;; &#125;&#x2F;&#x2F; 匿名函数的应用 (function()&#123; alert(&quot;tony&quot;); &#125; )() (function(arg)&#123; console.log(arg); &#125;)(&#39;123&#39;) 函数的作用域链和闭包作用域js的作用域和py相似，if while等控制语句并没有自己作用域；而函数是有自己的作用域的； 123456789101112if(1&#x3D;&#x3D;1)&#123; var s&#x3D;12; &#125; console.log(s);&#x2F;&#x2F;12 &#x2F;&#x2F; ---------------------- function f()&#123; var temp&#x3D;666; &#125; f(); console.log(temp);&#x2F;&#x2F;Uncaught ReferenceError: temp is not defined 嵌套函数的作用域： 例1: 1234567891011var city &#x3D; &#39;beijing&#39;; function func()&#123; var city &#x3D; &#39;shanghai&#39;; function inner()&#123; var city &#x3D; &#39;shenzhen&#39;; console.log(city); &#125; inner(); &#125; func(); 例2:1234567891011var city &#x3D; &#39;beijing&#39;;function Bar()&#123; console.log(city);&#125;function func()&#123; var city &#x3D; &#39;shanghai&#39;; return Bar;&#125;var ret &#x3D; func();ret(); &#x2F;&#x2F;beijing 闭包：123456789101112var city &#x3D; &#39;beijing&#39;;function func()&#123; var city &#x3D; &quot;shanghai&quot;; function inner()&#123; &#x2F;&#x2F; var city &#x3D; &quot;langfang&quot;; console.log(city); &#125; return inner;&#125;var ret &#x3D; func();ret(); 思考题1： 12345678910111213141516171819202122232425262728293031var city &#x3D; &#39;beijing&#39;;function func()&#123; var city &#x3D; &quot;shanghai&quot;; function inner()&#123; &#x2F;&#x2F; var city &#x3D; &quot;langfang&quot;; console.log(city); &#125; return inner;&#125;var ret &#x3D; func();ret();var city &#x3D; &#39;beijing&#39;;function Bar()&#123; console.log(city);&#125;function func()&#123; var city &#x3D; &#39;shanghai&#39;; return Bar;&#125;var ret &#x3D; func();ret(); &#x2F;&#x2F;beijing 作用域链(Scope Chain)：​ 在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 123456789101112var x&#x3D;1;function foo() &#123; var y &#x3D; 2; function bar() &#123; var z &#x3D; 3; &#125;&#125;#bar的作用域链： barScopeChain&#x3D;[bar.AO, foo.AO, global.VO];#foo的作用域链： fooScopeChain&#x3D;[foo.Ao, global.VO]; 1234567891011121314什么是AO,VO? 在函数创建时，每个函数都会创建一个活动对象Active Object(AO)，全局对象为Global Object(VO)，创建函数的过程也就是为这个对象添加属性的过程，作用域链就是由这些绑定了属性的活动对象构成的。 例如：找x变量；bar函数在搜寻变量x的过程中，先从自身AO对象上找，如果bar.AO存在这个属性，那么会直接使用这个属性的值，如果不存在，则会转到父级函数的AO对象，也就是foo.AO 如果找到x属性则使用，找不到继续 在global.VO对象查找，找到x的属性，返回属性值。如果在global.VO中没有找到，则会抛出异常ReferenceError执行上下文。 函数在执行时会创建一个称为“执行上下文（execution context）”的内部对象，执行上下文定义了函数 执行时的环境。每个执行上下文都有自己的作用域链，用于标识符解析，当执行上下文被创建时，而它的作用 域链初始化为当前运行函数的[[Scope]]所包含的对象。函数执行 在函数执行过程中，每遇到一个变量，都会检索从哪里获取和存储数据，该过程从作用域链头部，也就是从活 动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没有则继续搜索作用域 链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义，函数执行过程中，每个标识符都 要经历这样的搜索过程。 创建作用域链的过程 123456789101112 函数进入全局，创建VO对象，绑定x属性&lt;入栈&gt; global.VO&#x3D;&#123;x&#x3D;underfind; foo:reference of function&#125;(这里只是预解析，为AO对象绑定声明的属性，函数执行时才会执行赋值语句，所以值是underfind) 遇到foo函数，创建foo.AO，绑定y属性&lt;入栈&gt; foo.AO&#x3D;&#123;y&#x3D;underfind, bar:reference of function&#125; 遇到bar函数，创建bar.AO，绑定z属性&lt;入栈&gt; bar.AO&#x3D;&#123;z:underfind&#125;作用域链和执行上下文都会保存在堆栈中，所以：bar函数的scope chain为：[0]bar.AO--&gt;[1]foo.AO--&gt;[2]global.VO foo函数的scope chain为：[0]foo.AO--&gt;[1]global.Vo&#x2F;&#x2F;建议：少定义全局变量&#x2F;&#x2F;理由：因为作用域链是栈的结构，全局变量在栈底，每次访问全局变量都会遍历一次栈，&#x2F;&#x2F;这样会影响效率 函数的scope等于自身的AO对象加上父级的scope，也可以理解为一个函数的作用域等于自身活动对象加上父级作用域. 函数执行前后的作用域链： 注意：作用域链的非自己部分在函数对象被建立（函数声明、函数表达式）的时候建立，而不需要等到执行 思考题2: 123456789101112131415 for (var i&#x3D;1; i&lt;&#x3D;9; i++) &#123; setTimeout( function timer()&#123; console.log( i ); &#125;,1000 ); &#125;&#x2F;&#x2F;＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝for (var i&#x3D;1; i&lt;&#x3D;9; i++) &#123; (function()&#123; var j &#x3D; i; setTimeout( function timer()&#123; console.log( j ); &#125;, 1000 ); &#125;)(); BOM对象BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。 使 JavaScript 有能力与浏览器“对话”。 window对象12345window对象 所有浏览器都支持 window 对象。 概念上讲.一个html文档对应一个window对象. 功能上讲: 控制浏览器窗口的. 使用上讲: window对象不需要创建对象,直接使用即可. Window 对象方法1234567891011alert() 显示带有一段消息和一个确认按钮的警告框。confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。prompt() 显示可提示用户输入的对话框。open() 打开一个新的浏览器窗口或查找一个已命名的窗口。close() 关闭浏览器窗口。setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval() 取消由 setInterval() 设置的 timeout。setTimeout() 在指定的毫秒数后调用函数或计算表达式。clearTimeout() 取消由 setTimeout() 方法设置的 timeout。scrollTo() 把内容滚动到指定的坐标。 交互方法： 1234567891011121314151617181920212223方法讲解: &#x2F;&#x2F;----------alert confirm prompt---------------------------- &#x2F;&#x2F;alert(&#39;aaa&#39;); &#x2F;* var result &#x3D; confirm(&quot;您确定要删除吗?&quot;); alert(result); *&#x2F; &#x2F;&#x2F;prompt 参数1 : 提示信息. 参数2:输入框的默认值. 返回值是用户输入的内容. &#x2F;&#x2F; var result &#x3D; prompt(&quot;请输入一个数字!&quot;,&quot;haha&quot;); &#x2F;&#x2F; alert(result); 方法讲解: &#x2F;&#x2F;open方法 打开和一个新的窗口 并 进入指定网址.参数1 : 网址. &#x2F;&#x2F;调用方式1 &#x2F;&#x2F;open(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;); &#x2F;&#x2F;参数1 什么都不填 就是打开一个新窗口. 参数2.填入新窗口的名字(一般可以不填). 参数3: 新打开窗口的参数. open(&#39;&#39;,&#39;&#39;,&#39;width&#x3D;200,resizable&#x3D;no,height&#x3D;100&#39;); &#x2F;&#x2F; 新打开一个宽为200 高为100的窗口 &#x2F;&#x2F;close方法 将当前文档窗口关闭. &#x2F;&#x2F;close(); 练习： 123456789101112131415161718192021222324252627282930var num &#x3D; Math.round(Math.random()*100);function acceptInput()&#123;&#x2F;&#x2F;2.让用户输入(prompt) 并接受 用户输入结果var userNum &#x3D; prompt(&quot;请输入一个0~100之间的数字!&quot;,&quot;0&quot;);&#x2F;&#x2F;3.将用户输入的值与 随机数进行比较 if(isNaN(+userNum))&#123; &#x2F;&#x2F;用户输入的无效(重复2,3步骤) alert(&quot;请输入有效数字!&quot;); acceptInput(); &#125; else if(userNum &gt; num)&#123; &#x2F;&#x2F;大了&#x3D;&#x3D;&gt; 提示用户大了,让用户重新输入(重复2,3步骤) alert(&quot;您输入的大了!&quot;); acceptInput(); &#125;else if(userNum &lt; num)&#123; &#x2F;&#x2F;小了&#x3D;&#x3D;&gt; 提示用户小了,让用户重新输入(重复2,3步骤) alert(&quot;您输入的小了!&quot;); acceptInput(); &#125;else&#123; &#x2F;&#x2F;答对了&#x3D;&#x3D;&gt;提示用户答对了 , 询问用户是否继续游戏(confirm). var result &#x3D; confirm(&quot;恭喜您!答对了,是否继续游戏?&quot;); if(result)&#123; &#x2F;&#x2F;是 &#x3D;&#x3D;&gt; 重复123步骤. num &#x3D; Math.round(Math.random()*100); acceptInput(); &#125;else&#123; &#x2F;&#x2F;否&#x3D;&#x3D;&gt; 关闭窗口(close方法). close(); &#125; &#125; setInterval clearInterval 1234567891011121314151617181920212223242526272829303132&lt;input id&#x3D;&quot;ID1&quot; type&#x3D;&quot;text&quot; onclick&#x3D;&quot;begin()&quot;&gt;&lt;button onclick&#x3D;&quot;end()&quot;&gt;停止&lt;&#x2F;button&gt;&lt;script&gt; function showTime()&#123; var nowd2&#x3D;new Date().toLocaleString(); var temp&#x3D;document.getElementById(&quot;ID1&quot;); temp.value&#x3D;nowd2; &#125; var clock; function begin()&#123; if (clock&#x3D;&#x3D;undefined)&#123; showTime(); clock&#x3D;setInterval(showTime,1000); &#125; &#125; function end()&#123; clearInterval(clock); &#125;&lt;&#x2F;script&gt; setTimeout clearTimeout 12345var ID &#x3D; setTimeout(abc,2000); &#x2F;&#x2F; 只调用一次对应函数. clearTimeout(ID); function abc()&#123; alert(&#39;aaa&#39;); &#125; History 对象History 对象属性History 对象包含用户（在浏览器窗口中）访问过的 URL。 History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。 1&#96;length 返回浏览器历史列表中的 URL 数量。&#96; History 对象方法123back() 加载 history 列表中的前一个 URL。forward() 加载 history 列表中的下一个 URL。go() 加载 history 列表中的某个具体页面。 1234&lt;a href&#x3D;&quot;rrr.html&quot;&gt;click&lt;&#x2F;a&gt;&lt;button onclick&#x3D;&quot; history.forward()&quot;&gt;&gt;&gt;&gt;&lt;&#x2F;button&gt;&lt;button onclick&#x3D;&quot;history.back()&quot;&gt;back&lt;&#x2F;button&gt;&lt;button onclick&#x3D;&quot;history.go()&quot;&gt;back&lt;&#x2F;button&gt; Location 对象Location 对象包含有关当前 URL 的信息。 Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。 Location 对象方法123location.assign(URL)location.reload()location.replace(newURL)&#x2F;&#x2F;注意与assign的区别 DOM对象(DHTML)什么是 DOM？DOM 是 W3C（万维网联盟）的标准。DOM 定义了访问 HTML 和 XML 文档的标准： “W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。” W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 什么是 XML DOM？ －－－－&gt;XML DOM 定义了所有 XML 元素的对象和属性，以及访问它们的方法。 什么是 HTML DOM？－－－－&gt;HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。 DOM 节点根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点(NODE)： 整个文档是一个文档节点(document对象) 每个 HTML 元素是元素节点(element 对象) HTML 元素内的文本是文本节点(text对象) 每个 HTML 属性是属性节点(attribute对象) 注释是注释节点(comment对象) 画dom树是为了展示文档中各个对象之间的关系，用于对象的导航。 节点(自身)属性: attributes - 节点（元素）的属性节点 nodeType – 节点类型 nodeValue – 节点值 nodeName – 节点名称 innerHTML - 节点（元素）的文本值 导航属性: parentNode - 节点（元素）的父节点 (推荐) firstChild – 节点下第一个子元素 lastChild – 节点下最后一个子元素 childNodes - 节点（元素）的子节点 注意： 12345678910&lt;div id&#x3D;&quot;div1&quot;&gt; &lt;div id&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt; &lt;p&gt;hello yuan&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script&gt; var div&#x3D;document.getElementById(&quot;div2&quot;); console.log(div.nextSibling.nodeName); &#x2F;&#x2F;思考:为什么不是P?&lt;&#x2F;script&gt; 推荐导航属性： 1234567891011parentElement &#x2F;&#x2F; 父节点标签元素children &#x2F;&#x2F; 所有子标签 firstElementChild &#x2F;&#x2F; 第一个子标签元素lastElementChild &#x2F;&#x2F; 最后一个子标签元素nextElementtSibling &#x2F;&#x2F; 下一个兄弟标签元素previousElementSibling &#x2F;&#x2F; 上一个兄弟标签元素 节点树中的节点彼此拥有层级关系。 父(parent),子(child)和同胞(sibling)等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）。 在节点树中，顶端节点被称为根（root） 每个节点都有父节点、除了根（它没有父节点） 一个节点可拥有任意数量的子 同胞是拥有相同父节点的节点 下面的图片展示了节点树的一部分，以及节点之间的关系： ​ 访问 HTML 元素（节点）,访问 HTML 元素等同于访问节点,我们能够以不同的方式来访问 HTML 元素： 页面查找： 通过使用 getElementById() 方法 通过使用 getElementsByTagName() 方法 通过使用 getElementsByClassName() 方法 通过使用 getElementsByName() 方法 局部查找： 1234567891011121314151617181920212223242526&lt;div id&#x3D;&quot;div1&quot;&gt; &lt;div class&#x3D;&quot;div2&quot;&gt;i am div2&lt;&#x2F;div&gt; &lt;div name&#x3D;&quot;yuan&quot;&gt;i am div2&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;div3&quot;&gt;i am div2&lt;&#x2F;div&gt; &lt;p&gt;hello p&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script&gt; var div1&#x3D;document.getElementById(&quot;div1&quot;);&#x2F;&#x2F;&#x2F;&#x2F;支持;&#x2F;&#x2F; var ele&#x3D; div1.getElementsByTagName(&quot;p&quot;);&#x2F;&#x2F; alert(ele.length);&#x2F;&#x2F;&#x2F;&#x2F;支持&#x2F;&#x2F; var ele2&#x3D;div1.getElementsByClassName(&quot;div2&quot;);&#x2F;&#x2F; alert(ele2.length);&#x2F;&#x2F;&#x2F;&#x2F;不支持&#x2F;&#x2F; var ele3&#x3D;div1.getElementById(&quot;div3&quot;);&#x2F;&#x2F; alert(ele3.length);&#x2F;&#x2F;&#x2F;&#x2F;不支持&#x2F;&#x2F; var ele4&#x3D;div1.getElementsByName(&quot;yuan&quot;);&#x2F;&#x2F; alert(ele4.length)&lt;&#x2F;script&gt; HTML DOM Event(事件)HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。 12345678910111213141516171819onclick 当用户点击某个对象时调用的事件句柄。ondblclick 当用户双击某个对象时调用的事件句柄。onfocus 元素获得焦点。 &#x2F;&#x2F;练习：输入框onblur 元素失去焦点。 应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.onchange 域的内容被改变。 应用场景：通常用于表单元素,当元素内容被改变时触发.（三级联动）onkeydown 某个键盘按键被按下。 应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.onkeypress 某个键盘按键被按下并松开。onkeyup 某个键盘按键被松开。onload 一张页面或一幅图像完成加载。onmousedown 鼠标按钮被按下。onmousemove 鼠标被移动。onmouseout 鼠标从某元素移开。onmouseover 鼠标移到某元素之上。onmouseleave 鼠标从元素离开onselect 文本被选中。onsubmit 确认按钮被点击。 两种为元素附加事件属性的方式 123456789101112&lt;div onclick&#x3D;&quot;alert(123)&quot;&gt;点我呀&lt;&#x2F;div&gt;&lt;p id&#x3D;&quot;abc&quot;&gt;试一试!&lt;&#x2F;p&gt;&lt;script&gt; var ele&#x3D;document.getElementById(&quot;abc&quot;); ele.onclick&#x3D;function()&#123; alert(&quot;hi&quot;); &#125;;&lt;&#x2F;script&gt; 注意： 12345678910111213141516&lt;div id&#x3D;&quot;abc&quot; onclick&#x3D;&quot;func1(this)&quot;&gt;事件绑定方式1&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;id123&quot;&gt;事件绑定方式2&lt;&#x2F;div&gt;&lt;script&gt; function func1(self)&#123; console.log(self.id) &#125; &#x2F;&#x2F;jquery下是$(self), 这种方式this参数必须填写;&#x2F;&#x2F;------------------------------------------ var ele&#x3D;document.getElementById(&quot;id123&quot;).onclick&#x3D;function()&#123; console.log(this.id); &#x2F;&#x2F;jquery下是$(this), 这种方式不需要this参数; &#125; &lt;&#x2F;script&gt; onload： onload 属性开发中 只给 body元素加.这个属性的触发 标志着 页面内容被加载完成.应用场景: 当有些事情我们希望页面加载完立刻执行,那么可以使用该事件属性. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script&gt;&#x2F;&#x2F; window.onload&#x3D;function()&#123;&#x2F;&#x2F; var ele&#x3D;document.getElementById(&quot;ppp&quot;);&#x2F;&#x2F; ele.onclick&#x3D;function()&#123;&#x2F;&#x2F; alert(123)&#x2F;&#x2F; &#125;;&#x2F;&#x2F; &#125;; function fun1() &#123; var ele&#x3D;document.getElementById(&quot;ppp&quot;); ele.onclick&#x3D;function()&#123; alert(123) &#125;; &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body onload&#x3D;&quot;fun1()&quot;&gt;&lt;p id&#x3D;&quot;ppp&quot;&gt;hello p&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; onsubmit: 是当表单在提交时触发. 该属性也只能给form元素使用.应用场景: 在表单提交前验证用户输入是否正确.如果验证失败.在该方法中我们应该阻止表单的提交. 12345678910111213141516171819&lt;form id&#x3D;&quot;form&quot;&gt; &lt;input type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;点我!&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;&#x2F;阻止表单提交方式1(). &#x2F;&#x2F;onsubmit 命名的事件函数,可以接受返回值. 其中返回false表示拦截表单提交.其他为放行. var ele&#x3D;document.getElementById(&quot;form&quot;); ele.onsubmit&#x3D;function(event) &#123;&#x2F;&#x2F; alert(&quot;验证失败 表单不会提交!&quot;);&#x2F;&#x2F; return false; &#x2F;&#x2F; 阻止表单提交方式2 event.preventDefault(); &#x3D;&#x3D;&gt;通知浏览器不要执行与事件关联的默认动作。 alert(&quot;验证失败 表单不会提交!&quot;); event.preventDefault(); &#125; Event 对象 Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！event对象在事件发生时系统已经创建好了,并且会在事件函数被调用时传给事件函数.我们获得仅仅需要接收一下即可. 比如onkeydown,我们想知道哪个键被按下了，需要问下event对象的属性，这里就时KeyCode； 思考：onclick＝function(event){};这个方法是谁调用的？ 事件传播： 123456789101112131415&lt;div id&#x3D;&quot;abc_1&quot; style&#x3D;&quot;border:1px solid red;width:300px;height:300px;&quot;&gt; &lt;div id&#x3D;&quot;abc_2&quot; style&#x3D;&quot;border:1px solid red;width:200px;height:200px;&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; document.getElementById(&quot;abc_1&quot;).onclick&#x3D;function()&#123; alert(&#39;111&#39;); &#125; document.getElementById(&quot;abc_2&quot;).onclick&#x3D;function(event)&#123; alert(&#39;222&#39;); event.stopPropagation(); &#x2F;&#x2F;阻止事件向外层div传播. &#125; &lt;&#x2F;script&gt; 增删改查演示node的CURD：增: 12&#96;createElement(name)创建元素appendChild();将元素添加&#96; 删: 12&#96;获得要删除的元素&#96;&#96;获得它的父元素使用removeChild()方法删除&#96; 改: 第一种方式: ​ 使用上面增和删结合完成修改 第二种方式: 使用setAttribute();方法修改属性 使用innerHTML属性修改元素的内容 查: 使用之前介绍的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&#x2F;&#x2F;在第一个div中动态增加一个a标签. 该a标签点击之后跳转到百度首页. function addNode()&#123; &#x2F;&#x2F;1.获得 第一个div var div &#x3D; document.getElementById(&quot;div_1&quot;); &#x2F;&#x2F;2.创建a标签 createElement&#x3D;&#x3D;&gt;创建一个a标签 &lt;a&gt;&lt;&#x2F;a&gt; var eleA &#x3D; document.createElement(&quot;a&quot;); &#x2F;&#x2F;3.为a标签添加属性 &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;&lt;&#x2F;a&gt; eleA.setAttribute(&quot;href&quot;, &quot;http:&#x2F;&#x2F;www.baidu.com&quot;); &#x2F;&#x2F;4.为a标签添加内容 &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt; eleA.innerHTML &#x3D; &quot;百度&quot;; &#x2F;&#x2F;5.将a标签添加到div中 div.appendChild(eleA); &#125; &#x2F;&#x2F;点击后 删除div区域2 function deleteNode()&#123; &#x2F;&#x2F;1 获得要删除的div区域 var div &#x3D; document.getElementById(&quot;div_2&quot;); &#x2F;&#x2F;2.获得父亲 var parent &#x3D; div.parentNode; &#x2F;&#x2F;3 由父亲操刀 parent.removeChild(div); &#125; &#x2F;&#x2F;点击后 替换div区域3 为一个美女 function updateNode()&#123; &#x2F;&#x2F;1 获得要替换的div区域3 var div &#x3D; document.getElementById(&quot;div_3&quot;); &#x2F;&#x2F;2创建img标签对象 &lt;img &#x2F;&gt; var img &#x3D; document.createElement(&quot;img&quot;); &#x2F;&#x2F;3添加属性 &lt;img src&#x3D;&quot;001.jpg&quot; &#x2F;&gt; img.setAttribute(&quot;src&quot;, &quot;001.JPG&quot;); &#x2F;&#x2F;4.获得父节点 var parent &#x3D; div.parentNode; &#x2F;&#x2F;5.替换 parent.replaceChild(img, div); &#125; &#x2F;&#x2F;点击后 将div区域4 克隆一份 添加到页面底部 function copyNode()&#123; &#x2F;&#x2F;1.获取要克隆的div var div &#x3D; document.getElementById(&quot;div_4&quot;); &#x2F;&#x2F;2.克隆 参数为true 那么克隆时克隆所有子元素. false 只克隆自己 var div_copy &#x3D; div.cloneNode(true); &#x2F;&#x2F;3.获得父亲 var parent &#x3D; div.parentNode; &#x2F;&#x2F;4.添加 parent.appendChild(div_copy); &#125; &lt;&#x2F;script&gt; 修改 HTML DOM 改变 HTML 内容 ​ 改变元素内容的最简答的方法是使用 innerHTML ，innerText。 改变 CSS 样式 1&#96;&lt;p id&#x3D;&#96;&#96;&quot;p2&quot;&#96;&#96;&gt;Hello world!&lt;&#x2F;p&gt;&#96;&#96;document.getElementById(&#96;&#96;&quot;p2&quot;&#96;&#96;).style.color&#x3D;&#96;&#96;&quot;blue&quot;&#96;&#96;;&lt;br&gt; .style.fontSize&#x3D;48px&#96; 改变 HTML 属性 ​ elementNode.setAttribute(name,value) ​ elementNode.getAttribute(name)&lt;————–&gt;elementNode.value(DHTML) 创建新的 HTML 元素 ​ createElement(name) 删除已有的 HTML 元素 ​ elementNode.removeChild(node) 关于class的操作 ​ elementNode.className ​ elementNode.classList.add ​ elementNode.classList.remove 实例练习搜索框12345678910111213141516171819202122232425&lt;input id&#x3D;&quot;ID1&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;请输入用户名&quot; onblur&#x3D;&quot;Blurs()&quot; onfocus&#x3D;&quot;Focus()&quot;&gt;&lt;script&gt;function Focus()&#123; var input&#x3D;document.getElementById(&quot;ID1&quot;); if (input.value&#x3D;&#x3D;&quot;请输入用户名&quot;)&#123; input.value&#x3D;&quot;&quot;; &#125;&#125;;function Blurs()&#123; var ele&#x3D;document.getElementById(&quot;ID1&quot;); var val&#x3D;ele.value; if(!val.trim())&#123; ele.value&#x3D;&quot;请输入用户名&quot;; &#125;&#125;&lt;&#x2F;script&gt; 模态对话框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; .back&#123; background-color: rebeccapurple; height: 2000px; &#125; .shade&#123; position: fixed; top: 0; bottom: 0; left:0; right: 0; background-color: coral; opacity: 0.4; &#125; .hide&#123; display: none; &#125; .models&#123; position: fixed; top: 50%; left: 50%; margin-left: -100px; margin-top: -100px; height: 200px; width: 200px; background-color: gold; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;back&quot;&gt; &lt;input id&#x3D;&quot;ID1&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;click&quot; onclick&#x3D;&quot;action(&#39;show&#39;)&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;shade hide&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;models hide&quot;&gt; &lt;input id&#x3D;&quot;ID2&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;cancel&quot; onclick&#x3D;&quot;action(&#39;hide&#39;)&quot;&gt;&lt;&#x2F;div&gt;&lt;script&gt; function action(act)&#123; var ele&#x3D;document.getElementsByClassName(&quot;shade&quot;)[0]; var ele2&#x3D;document.getElementsByClassName(&quot;models&quot;)[0]; if(act&#x3D;&#x3D;&quot;show&quot;)&#123; ele.classList.remove(&quot;hide&quot;); ele2.classList.remove(&quot;hide&quot;); &#125;else &#123; ele.classList.add(&quot;hide&quot;); ele2.classList.add(&quot;hide&quot;); &#125; &#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 全选反选取消1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;button onclick&#x3D;&quot;select(&#39;all&#39;);&quot;&gt;全选&lt;&#x2F;button&gt; &lt;button onclick&#x3D;&quot;select(&#39;cancel&#39;);&quot;&gt;取消&lt;&#x2F;button&gt; &lt;button onclick&#x3D;&quot;select(&#39;reverse&#39;);&quot;&gt;反选&lt;&#x2F;button&gt; &lt;table border&#x3D;&quot;1&quot; id&#x3D;&quot;Table&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;111&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;222&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;333&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;444&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt;&lt;script&gt; function select(choice)&#123; var ele&#x3D;document.getElementById(&quot;Table&quot;); var inputs&#x3D;ele.getElementsByTagName(&quot;input&quot;); for (var i&#x3D;0;i&lt;inputs.length;i&#x3D;i+1)&#123; var ele2&#x3D;inputs[i]; if (choice&#x3D;&#x3D;&quot;all&quot;)&#123; ele2.checked&#x3D;true; &#125;else if(choice&#x3D;&#x3D;&quot;cancel&quot;)&#123; ele2.checked&#x3D;false; &#125; else &#123; if (ele2.checked)&#123; ele2.checked&#x3D;false; &#125;else &#123; ele2.checked&#x3D;true; &#125; &#125; &#125; &#125;&lt;&#x2F;script&gt; 两级联动1234567891011121314151617181920212223242526272829303132333435363738&lt;select id&#x3D;&quot;province&quot;&gt; &lt;option&gt;请选择省:&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;select id&#x3D;&quot;city&quot;&gt; &lt;option&gt;请选择市:&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;script&gt; data&#x3D;&#123;&quot;河北省&quot;:[&quot;廊坊&quot;,&quot;邯郸&quot;],&quot;北京&quot;:[&quot;朝阳区&quot;,&quot;海淀区&quot;]&#125;; var p&#x3D;document.getElementById(&quot;province&quot;); var c&#x3D;document.getElementById(&quot;city&quot;); for(var i in data)&#123; var option_pro&#x3D;document.createElement(&quot;option&quot;); option_pro.innerHTML&#x3D;i; p.appendChild(option_pro); &#125; p.onchange&#x3D;function()&#123; pro&#x3D;(this.options[this.selectedIndex]).innerHTML; citys&#x3D;data[pro]; c.options.length&#x3D;0; for (var i in citys)&#123; var option_city&#x3D;document.createElement(&quot;option&quot;); option_city.innerHTML&#x3D;citys[i]; c.appendChild(option_city); &#125; &#125;&lt;&#x2F;script&gt; select左右移12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;div id&#x3D;&quot;box1&quot;&gt; &lt;select multiple&#x3D;&quot;multiple&quot; size&#x3D;&quot;10&quot; id&#x3D;&quot;left&quot;&gt; &lt;option&gt;book&lt;&#x2F;option&gt; &lt;option&gt;book2&lt;&#x2F;option&gt; &lt;option&gt;book3&lt;&#x2F;option&gt; &lt;option&gt;book4&lt;&#x2F;option&gt; &lt;option&gt;book5&lt;&#x2F;option&gt; &lt;option&gt;book6&lt;&#x2F;option&gt; &lt;&#x2F;select&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;choice&quot;&gt; &lt;input class&#x3D;&quot;add&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;---&gt;&quot; onclick&#x3D;&quot;add()&quot;&gt;&lt;br&gt; &lt;input class&#x3D;&quot;remove&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;&lt;---&quot; onclick&#x3D;&quot;remove();&quot;&gt;&lt;br&gt; &lt;input class&#x3D;&quot;add-all&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; onclick&#x3D;&quot;ADDall()&quot;&gt;&lt;br&gt; &lt;input class&#x3D;&quot;remove-all&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;&lt;&#x3D;&#x3D;&#x3D;&quot; onclick&#x3D;&quot;remall()&quot;&gt;&lt;&#x2F;div&gt;&lt;div&gt; &lt;select multiple&#x3D;&quot;multiple&quot; size&#x3D;&quot;10&quot; id&#x3D;&quot;right&quot;&gt; &lt;option&gt;book9&lt;&#x2F;option&gt; &lt;&#x2F;select&gt;&lt;&#x2F;div&gt;&lt;script&gt; function add()&#123; var right&#x3D;document.getElementById(&quot;right&quot;); var options&#x3D;document.getElementById(&quot;left&quot;).getElementsByTagName(&quot;option&quot;); for (var i&#x3D;0; i&lt;options.length;i++)&#123; var option&#x3D;options[i]; if(option.selected&#x3D;&#x3D;true)&#123; right.appendChild(option); i--; &#125; &#125; &#125; function ADDall()&#123; var right&#x3D;document.getElementById(&quot;right&quot;); var options&#x3D;document.getElementById(&quot;left&quot;).getElementsByTagName(&quot;option&quot;); for (var i&#x3D;0; i&lt;options.length;i++)&#123; var option&#x3D;options[i]; right.appendChild(option); i--; &#125; &#125;&lt;&#x2F;script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://sjtu-xx.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"pyqt5","slug":"pyqt5","date":"2020-06-29T13:24:56.000Z","updated":"2021-02-19T02:26:06.551Z","comments":true,"path":"2020/06/29/pyqt5/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/pyqt5/","excerpt":"PYQT5","text":"PYQT5 pyqt5下，dialog用exec_()方法，widget用show()方法; 1.QDockWidgetDock嵌套布局 QDockWidget是一个可以停靠在QMainWindow内的窗口控件，它可以保持浮动状态或在指定位置作为子窗口附加到主窗口中。其常用方法有：setWidget()，用于设置在DockWidget内显示的QWidget及其子类对象。setFloating()，设置DockWidget是否可以浮动，参数为True或False。setAllowedArea()，设置可以停靠的区域，可用参数为Qt.DockWidgetAreas{LeftDockWidgetArea, RightDockWidgetArea, TopDockWidgetArea, BottomDockWidgetArea, AllDockWidgetAreas, NoDockWidgetArea}。setFeatures()，设置停靠窗口的功能属性（有些属性决定了显示哪些按钮），可用参数为QDockWidget.DockWidgetFeatures{DockWidgetClosable, DockWidgetMovable, DockWidgetFloatable, DockWidgetVerticalTitleBar, AllDockWidgetFeatures, NoDockWidgetFeatures}。其常用信号有：topLevelChanged(bool topLevel)：当浮动状态变化时发生，参数为True时为浮动状态。void visibilityChanged(bool visible)：当显示状态变化时发生（一般是在以Tab方式显示时使用），参数为True时可见。 QMainWindow类中包含了有关DockWidget的一些函数方法，主要有：addDockWidget(Qt.DockWidgetArea area, QDockWidget dockwidget)，将DockWidget添加到主窗口，第一个参数为停靠位置，第二个参数为要添加的DockWidget。setDockOptions()，设置停靠属性，参数类型为QMainWindow.DockOptions { AnimatedDocks, AllowNestedDocks, AllowTabbedDocks, ForceTabbedDocks, VerticalTabs, GroupedDragging }setTabPosition(Qt.DockWidgetAreas areas, QTabWidget.TabPosition position)，设置停靠和标题位置，第一个参数为停靠位置，第二个参数为标题位置，取值范围QtabWidget.TabPosition { North, South, West, East }。tabifyDockWidget(QDockWidget first, QDockWidget second)，以Tab方式显示DockWidget，其中第二个窗体排在第一个之后。setTabShape(QTabWidget.TabShape shape)，设置Tab标签样式，取值范围QTabWidget.TabShape { Rounded, Triangular }。 2.右键菜单12item_widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)item_widget.customContextMenuRequested[QtCore.QPoint].connect(lambda pos: main_window.cad_item_right_click_menu(pos, item, item_widget)) 将菜单在当前位置显示 123456789方法一： self.TextContextMenu.move(QtGui.QCursor.pos()) self.TextContextMenu.show() 方法二： #在当前坐标下显示，但是菜单停止不走动 self.TextContextMenu.exec_(QtGui.QCursor.pos()) #将菜单在右上方显示 self.TextContextMenu.move(self.pos() + pos) 3.自定义list itemhttps://stackoverflow.com/questions/25187444/pyqt-qlistwidget-custom-items 4.Margin(left, top, right, bottom) 5.信号额外参数传递https://blog.csdn.net/fengyu09/article/details/39498777 传递额外参数但是不影响默认信号 6.拖放技术拖放技术 使用拖放技术可实现在不同控件或应用之间的数据交换。使用该技术的典型示例是在Windows资源管理器中移动文件。要将文件移动到另一个目录，只需用鼠标左键单击文件图标差按住不放，将文件拖动到目标目录图标，然后释放鼠标按钮。如果要复制文件，而不是移动文件，则还要按住键。1.拖动(1) 在mousePressEvent()中，记录鼠标按下时的位置；(2) 在mouseMoveEvent ()中，计算鼠标移动的距离，可用来防止无意的拖动。QApplication的下列静态方法可用来控制延迟量： 1234setstartDragDistance (Distance) - 拖动开始的最小移动量；startDragDistance() - 返回拖动开始的最小移动量；setstartDragTime (Time) -拖动开始的按压毫秒数；startDragTime () - 返回拖动开始的按压毫秒数； (3) 鼠标移动超过最小移动值或按压鼠标超过最小毫秒数，拖动操作开始。此时，创建一个QDrag对象，调用exce()方法进行相关操作。QDrag有以下方法：12345678910111213141516171819202122exec( ) - 开始拖放操作,返回一个代表放置操作的枚举值。有两个格式：exec(supportedActions &#x3D; Qt.MoveAction)exec(supportedActions, defaultDropAction)详细用法参见http:&#x2F;&#x2F;doc.qt.io&#x2F;qt-5&#x2F;qdrag.html#execsetMimeData (QMimeData qmd) - 设置拖放中传输的数据, 参数为QMimeData类型。传输文本的例子：data &#x3D; QtCore.QMimeData ()data.setText (&quot;Drag text&quot;)drag &#x3D; QtGui.QDrag (self)drag.setMimeData (data)mimeData () - 返回拖放过程中传输数据的QMimeData 对象；setPixmap(QPixmap qpix) - 设定拖放过程鼠标显示的图像。如：drag.setPixmap (QtGui.QPixmap (&quot;dd representer.png&quot;))pixmap() - 返回拖放过程中鼠标显示图像的QPixmap对象；setHotSpot (QPoint pt) - 设置图像的热点位置。drag.setHotSpot (QtCore.QPoint (20, 20))hotSpot() - 返回热点位置的QPoint对象；setDragCursor (QPixmap pix, Qt.DropAction dact) - 设置拖放的鼠标形状。第一个参数为鼠标形状的QPixmap对象；第二参数为相关操作的枚举值，只能是 CopyAction, MoveAction 或LinkAction。drag.setDragCursor (QtGui.QPixmap (&quot;move_cursor.png&quot;), QtCore.Qt.MoveAction)dragCursor ( Qt.DropAction dact) - 返回dact操作的鼠标形状的QPixmap对象;source() - 返回源控件的引用；target() - 返回目标控件的引用。如果拖放的目标对象为另一应用，返回值为None.supportedActions () - 返回当前有效操作的组合值。defaultAction () - 返回缺省的操作。QDrag有两个信号：actionChanged (Qt.DropAction dact) - 当拖放的行为被该变时，发射该信号；targetchanged (QWidget obj) - 当目标控件被改变时，将会发射该信号； 2.QMineData类拖放过过程中的MIME类型的数据传递通过将QMineData对象作为参数调用QDrag的setMimeData()函数实现。创建QMimeData方法：data=QtCore.QMimeData()QMimeData类支持以下方法（详见http://doc.qt.io/qt-5/qmimedata.html): 12345678910111213141516171819202122232425setText(text) - 设置文本数据（MIME型文本&#x2F;文本格式）:data.setText(&quot;拖动文本&quot;)text( ) - 返回文本数据;hasText( ) - 如果对象包含文本数据，则返回True，否则返回False。setHtml(HTML-text) - 以HTML格式设置文本数据（MIME型文本 &#x2F; html格式）:data.setHtml(&quot;拖动HTML文本&lt;&#x2F; b&gt;&quot;)html( ) - 返回HTML格式的文本数据;hasHtml( ) - 如果对象包含HTML格式的文本数据，则返回True，否则为False.setUrls( QList url) - 设置地址列表，参数为QUrl类的列表；data.setUrls ([QtCore.QUrl (&quot;http:&#x2F;&#x2F;www.google.com&#x2F;&quot;)])urls () - 返回地址列表:url &#x3D; e.mimeData (). urls () [0] .toString ()hasUrls () - 如果对象包Url地址，则返回True，否则为False.setlmageData(QVarinat img) - 设置图像数据，可以是QImage或QPixmap实例：data.setlmageData (QtGui.Qlmage(&quot;pixmap.png&quot;))data.setlmageData (QtGui.QPixmap(&quot;pixmap.png&quot;))imageData( ) - 返回图像对象;haslmage( ) - 如果对象包含图像数据，则返回True，否则为False.setData(QString mimetype, QCore.QByteData data) 设置任意类型的MIME类型数据；参数1为QString类型，指定MIME类型；参数2为QByteData类实例。该方法可以用MIME不同类型，多次调用：data.setData(&quot;text&#x2F;plain&quot;,QtCore.QByteArray (bytes (&quot;Data&quot;, &quot;utf-8&quot;)))data(QString mimetype) - 返回mimetype类型的QByteData数据对象;hasFormat(QString mimetype) - 如果对象包含mimetype类型数据，则返回True，否则为False.formats ( ) - 返回包括的mimetype类型列表；removeFormat (QString mimetype) - 删除mimetype类型的数据;clear ( ) - 删除所有数据。 如果要实现特殊类型数据的拖放，需要创建一个QMimeData子类，并重载retrieveData( ) 和 formats ( )方法。详细内容，请参考Qt文档。 3.放置操作在处理拖放对象之前，必须告诉系统该组件可以处理这些事件。 为此，要在组件的构造函数中，调用继承自QWidget类的setAcceptDrops方法，参数值为True：self.setAcceptDrops（True）拖放对象的过程执行如下：在控件的dragEnterEvent()方法中，检查拖动的MIME类型数据。如果该控件能处理此类型数据，则调用事件对象的acceptProposedAction( )方法。如果要变更操作，则将新事件传递给事件对象的setDropAction( )方法，然后调用accept( )方法，而不是调用acceptProposedAction( )方法。如果要限制控件的特定区域才能放置操作，必须在dragMoveEvent( )方法中处理。即当拖放进入到特定的区域，调用accept( QRect rect)方法，参数rect为特定区域的QRect对象。在控件的dropEvent()方法中，完成相关操作。 QWidget类的下列方法可以处理在拖放过程中发生的事件： dragEnterEvent (self,event) - 当拖动进入到控件区域时调用。通过event参数， 可取得QDragEnterEvent实例; dragLeaveEvent(self,event) - 当拖动离开控件区域时调用。通过event参数， 可取得QDragLeaveEvent实例; dragMoveEvent (self, event) -当拖动在控件区域移动时调用。通过event参数， 可取得QDragMoveEvent实例; dropEvent (self, event) - 当拖动在控件区域放开时调用。通过event参数， 可取得QDropEvent实例; QDragLeaveEvent类继承自QEvent类，不附带任何其他信息。因为在该类中只要知道拖动的对象已经离开组件区域就够了。相关类的继承顺序为：QEvent - QDropEvent - QDragMoveEvent - QDragEnterEventQDragEnterEvent类中没有增加新方法。QDropEvent类有下列方法： 123456789101112131415mimeData( ) - 返回含有所传输数据和MIME类型信息的QMimeData类的实例；pos( ) - 返回QPoint类的实例，为拖放对象放置的整数坐标;posF( ) - 返回QPointF类的实例，为拖放对象放置的浮点坐标;possibleAction( ) - 返回拖放可能的操作组合,如:if e.possibleActions () &amp; QtCore.Qt.MoveAction: print (&quot;MoveAction&quot;)if e.possibleActions () &amp; QtCore.Qt.CopyAction: print (&quot;CopyAction&quot;)proposedAction( ) - 返回默认的放置操作；acceptProposedAction( ) - 表示已准备好接受传输的数据和由proposalAction( )返回的默认操作。该方法(或者accept()方法)必须在dragEnterEvent()中调用，否则，dropEvent()不会被调用。setDropAction (action) - 允许在放置时指定为action. 作了此设置后，必须调用accept( )方法, 而不是acceptProposedAction( )方法;dropAction( ) - 返回放置时进行的操作。如果用setDropAction( )进行了更改，可能与proposedAction ()的返回值不一致。keyboardModifiers( ) - 用于判断按下了哪些修饰键 (, , , 等.) ，可参考“PyQt5编程(18)：键盘事件”中的对应函数。mouseButtons () - 用于判断在拖放过程中按下的鼠标键;source( ) - 如果拖放是从另一个应用程来的，返回为None；否则，返回对拖放源控件的引用。 QDragMoveEvent类的方法有：123accept (QRect rect) - 表明允许后续的移动操作。 rect用来指定可接受拖放操作的区域；ignore (QRect rect) - 表明不允许后续的移动操作。 rect用来指定不接受拖放操作的区域；;answerRect () - 返回可接受拖放操作区域的QRect对象。PyQt中的有些控件，如单行文本控件，已有拖放功能。因此，在自己实现拖放功能之前，请仔细阅读相关控件的文档。 7.List和Tree之间的拖拽事件list和tree之间的拖拽 listwidget中自定义widget的drag&amp;drop listview的使用 pyqt model/view drag&amp;drop example 8. show和exec的区别Pyqt中 QDialog show和exec的区别 QDialog的显示有两个函数show()和exec()。他们的区别在参考文档上的解释如下： show():显示一个非模式对话框。控制权即刻返回给调用函数。弹出窗口是否模式对话框，取决于modal属性的值。 原文：Shows the dialog as a modeless dialog. Control returns immediately to the calling code.The dialog will be modal or modeless according to the value of the modal property. exec():显示一个模式对话框，并且锁住程序直到用户关闭该对话框为止。函数返回一个DialogCode结果。在对话框弹出期间，用户不可以切换同程序下的其它窗口，直到该对话框被关闭。原文：Shows the dialog as a modal dialog, blocking until the user closes it. The function returns a DialogCode result.Users cannot interact with any other window in the same application until they close the dialog. 模式与非模式 模式对话框，就是在弹出窗口的时候，整个程序就被锁定了，处于等待状态，直到对话框被关闭。这时往往是需要对话框的返回值进行下面的操作。如：确认窗口（选择“是”或“否”）。非模式对话框，在调用弹出窗口之后，调用即刻返回，继续下面的操作。这里只是一个调用指令的发出，不等待也不做任何处理。如：查找框。 简单的理解： 首先这两个方法返回值不同。exec()有返回值，show()没有返回值。 其次这两个方法的作用也不同。调用show()的作用仅仅是将widget及其上的内容都显示出来，控制权即刻返回给调用函数。而调用exec()后，调用线程将会被阻塞，锁住程序直到用户关闭该对话框，期间用户不可以切换同程序下的其它窗口直到Dialog关闭。 9.只接受数字&amp;密文123456self.kernel1_size_text &#x3D; QtWidgets.QLineEdit()self.kernel1_size_text.setPlaceholderText(&#39;k-size&#39;)self.kernel1_size_text.setToolTip(&#39;kernel size(odd,odd)&#39;)self.kernel1_size_text.setValidator(QtGui.QIntValidator()) QtGui.QDoubleValidataself.kernel1_size_text.setEchoMode(QtWidgets.QLineEdit.Password)self.kernel1_size_text.setText(&#39;3&#39;) 10.自定义信号和槽自定义信号槽 自定义信号必须放在类中函数的定义外 12345_signal = QtCore.pyqtSignal(str) # 定义信号,定义参数为str类型self._signal.emit(\"正在打印，请稍候...\")self._signal.connect(self.mySignal)def mySignal(self, string): pass","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[]},{"title":"git命令","slug":"git命令","date":"2020-06-29T12:50:59.000Z","updated":"2021-02-19T02:26:06.414Z","comments":true,"path":"2020/06/29/git命令/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/git%E5%91%BD%E4%BB%A4/","excerpt":"廖雪峰的教程https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304","text":"廖雪峰的教程https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304创建忽略文件 1.gitignore文件，文件中填写需要忽略文件的正则表达式 创建版本库 1git init 提交到暂存区 1git add &lt;file&gt; 提交到版本库 1git commit -m &quot;提示信息&quot; 查看状态 1git status 查看修改 1git diff &lt;filename&gt; 查看日志文件 12git log &#x2F;&#x2F;可以加参数 --pretty&#x3D;onelinegit reflog &#x2F;&#x2F; 版本回退 12git reset --hard HEAD^ &#x2F;&#x2F;回退到上个版本 HEAD指向当前版本git reset --hard &lt;commit id&gt; &#x2F;&#x2F;回退到指定commit 丢弃工作区的修改 1git checkout -- readme.txt &#x2F;&#x2F;让这个文件回到最近一次git commit或git add时的状态。 撤销暂存区的修改 1git reset HEAD &lt;file&gt; 删除文件 1git rm &lt;file&gt; 远程仓库 1.创建ssh密钥 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 2.本地与远程关联 1git remote add origin git@github.com:michaelliao&#x2F;learngit.git 3.当前分支所有内容推送到远程 1git push -u origin master &#x2F;&#x2F;-u参数：推送的同时将本地的master分支与远程的master分支关联 4.克隆 1git clone 查看远程库的信息： 1$ git remote git remote -v显示更详细的信息 推送dev分支到远程 1git push origin dev 分支 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 分支合并图：git log --graph 合并dev分支，请注意--no-ff参数，表示禁用Fast forward:git merge --no-ff -m &quot;merge with no-ff&quot; dev BUG分支： 把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 12345git stash &#x2F;&#x2F;储存git stash list &#x2F;&#x2F;查看git stash apply &#x2F;&#x2F;恢复，不删除git stash drop &#x2F;&#x2F;删除git stash pop &#x2F;&#x2F;恢复并删除 创建远程origin的dev分支到本地 1git checkout -b dev origin&#x2F;dev 删除远程分支：$ git push origin :heads/[name] 标签 git tag查看所有标签 git tag &lt;name&gt;就可以打一个新标签 默认标签是打在最新提交的commit上的 git tag v0.9 f52c633给指定commit打标签 git show &lt;tagname&gt;查看标签信息 创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 删除标签 1git tag -d v0.1 上传空文件夹： 1find . -type d -empty -exec touch &#123;&#125;&#x2F;.gitignore \\; 一、创建与合并分支 1、 从master分支创建dev分支并切换到dev分支 12git checkout mastergit checkout -b dev 其中，git checkout -b dev 等价于: 12git branch devgit checkout dev （1） 1git branch 查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。 （2） 1git branch -a 查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。 2、修改代码、提交代码（当前的操作是在dev分支上进行） 12git add a.htmlgit commit -m &quot;提交文件a.html&quot; 3、分支合并(将dev合并到master) 12git checkout mastergit merge dev 4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支) 1git branch -d dev 5、删除后，查看分支(此时看不到dev分支了) 1git branch 6、总结 ：工作中经常从master创建新的分支，具体操作如下: 123456master创建新分支：git checkout mastergit checkout -b issues1234 &#x2F;&#x2F; 从master分支创建issues1234分支git push origin issues1234git add ..git commit -m &quot;***&quot;git push origin issues1234 注意：将本地分支branch1推到远端的branch2操作步骤： 1git push origin branch1:branch2 7、删除分支： 12git branch -D issues1234 &#x2F;&#x2F; 本地强制删除分支issues1234git push origin :issues1234 &#x2F;&#x2F; 推到远程 二、解决冲突 1、发生冲突的文件 1&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 其中，git使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件中自己和别人产生冲突的部分。 在 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======之间为自己的代码；=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。 如果保留自己的代码，将别人的代码删掉即可。 2、冲突解决后提交 1234git statusgit add ***git commit -m &quot;fix conflict&quot;git push origin 分支名 三、Bug分支 1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用 1git stash 2、恢复储藏的代码 1git stash pop &#x2F;&#x2F; 恢复的同时把stash内容删掉 或者 123456&#x2F;&#x2F; 通过 git stash list，查看本地所有的stash,如果我要恢复第一个就执行：git stash apply stash@&#123;0&#125;git stash apply &#x2F;&#x2F; 恢复stash，但是stash内容并不删除git stash drop &#x2F;&#x2F; 在上面操作的基础上，以此来删除stash注： git stash list &#x2F;&#x2F; 查看全部的stash列表 3、将stash空间清空 1git stash clear 4、git stash pop 和 git stash apply 区别 1原来git stash pop stash@&#123;id&#125;命令会在执行后将对应的stash id 从stash list里删除，而 git stash apply stash@&#123;id&#125; 命令则会继续保存stash id。 四、版本回退 1、回退至上一个版本 1git reset --hard HEAD 2、回退至指定版本 1git reset --hard 版本号 3、查看以往版本号(本地的commit) 1git reflog 4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit) 1git log 五、撤销修改 1、撤销修改 1git checkout -- a.html 分两种情况分析： 12①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态 注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。 2、撤销新建文件 比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行： 1git clean -f ..&#x2F;aa.html 3、撤销新建文件夹 比如新建一个文件夹”demo”，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行： 1git clean -df .&#x2F;demo 六、对已push版本进行回退 1、第一步： 1git reset --hard 版本号 &#x2F;&#x2F; 本地回退到指定的版本 2、第二步： 1git push -f origin dev &#x2F;&#x2F;将远程的也回退到指定版本 七、本地同步远程删除的分支 1git fetch origin -p &#x2F;&#x2F; 用来清除已经没有远程信息的分支，这样git branch -a 就不会拉取远程已经删除的分支了 八、删掉未与远程分支对应的本地分支 从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支： 1git fetch -p 九、查看远程库与本地分支的信息 1git remote show origin 十、标签管理 1、给当前分支最新commit打标签 1git tag v1.0.0 2、比如现在周五，要给周一某个commit打标签，应执行以下步骤： （1）、查看log日志，找到相应的commit版本号 12git log --pretty&#x3D;oneline --abbrev-commit&#x2F;&#x2F; 显示如下commit，比如我想在 &quot;34372b05&quot;这个commit打标签44d2e20b fix bug34372b05 fix bug29554931 fix bug （2）、给指定的commit打标签 1git tag v1.0.0 34372b05 （3）、创建的标签只存在本地，推至远程 1git push origin v1.0.0 （4）、一次性推送未推至远程的本地标签 1git push origin --tags （5）、查询所有标签 1git tag （6）、查询标签详细信息 1git show v1.0.0 （7）、删除本地标签 1git tag -d v1.0.0 （8）、删除远程标签 12&#x2F;&#x2F; 先从本地删除git tag -d v1.0.0&#x2F;&#x2F; 然后从远程删除git push origin :refs&#x2F;tags&#x2F;v1.0.0&#x2F;&#x2F; 最后可以在gitlab上查看是否真正的删除了标签 3、创建带有说明的标签，用-a指定标签名，-m指定说明文字 12&#x2F;&#x2F; git tag -a 版本号 -m 说明信息 commit版本号git tag -a v1.0.0 -m &quot;version 1.0.0 released&quot; 34372b05(commit版本号) &#x2F;&#x2F; 查看标签详细信息git show v1.0.0","categories":[{"name":"CODE工具","slug":"CODE工具","permalink":"https://sjtu-xx.github.io/categories/CODE%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"计算机网络","slug":"计算机网络","date":"2020-06-29T12:49:08.000Z","updated":"2021-02-19T02:26:07.186Z","comments":true,"path":"2020/06/29/计算机网络/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"http://www.cnblogs.com/linhaifeng/articles/5937962.html#_label4","text":"http://www.cnblogs.com/linhaifeng/articles/5937962.html#_label4 一.操作系统基础 操作系统:(Operating System，简称OS)是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。 注：计算机(硬件)－&gt;os－&gt;应用软件 二.网络通信原理2.1 互联网的本质就是一系列的网络协议一台硬设有了操作系统，然后装上软件你就可以正常使用了，然而你也只能自己使用 像这样，每个人都拥有一台自己的机器，然而彼此孤立 如何能大家一起玩耍 然而internet为何物？ 其实两台计算机之间通信与两个人打电话之间通信的原理是一样的（中国有很多地区，不同的地区有不同的方言，为了全中国人都可以听懂，大家统一讲普通话） 普通话属于中国国内人与人之间通信的标准，那如果是两个国家的人交流呢？ 问题是，你不可能要求一个人／计算机掌握全世界的语言／标准，于是有了世界统一的通信标准：英语 结论：英语成为世界上所有人通信的统一标准，如果把计算机看成分布于世界各地的人，那么连接两台计算机之间的internet实际上就是 一系列统一的标准，这些标准称之为互联网协议，互联网的本质就是一系列的协议，总称为‘互联网协议’（Internet Protocol Suite). 互联网协议的功能：定义计算机如何接入internet，以及接入internet的计算机通信的标准。 2.2 osi七层协议互联网协议按照功能不同分为osi七层或tcp/ip五层或tcp/ip四层 每层运行常见物理设备 2.3 tcp/ip五层模型讲解我们将应用层，表示层，会话层并作应用层，从tcp／ip五层协议的角度来阐述每层的由来与功能，搞清楚了每层的主要协议 就理解了整个互联网通信的原理。 首先，用户感知到的只是最上面一层应用层，自上而下每层都依赖于下一层，所以我们从最下一层开始切入，比较好理解 每层都运行特定的协议，越往上越靠近用户，越往下越靠近硬件 2.3.1 物理层物理层由来：上面提到，孤立的计算机之间要想一起玩，就必须接入internet，言外之意就是计算机之间必须完成组网 物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0 2.3.2 数据链路层数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思 数据链路层的功能：定义了电信号的分组方式 以太网协议： 早期的时候各个公司都有自己的分组方式，后来形成了统一的标准，即以太网协议ethernet ethernet规定 一组电信号构成一个数据包，叫做‘帧’ 每一数据帧分成：报头head和数据data两部分 head data head包含：(固定18个字节) 发送者／源地址，6个字节 接收者／目标地址，6个字节 数据类型，6个字节 data包含：(最短46字节，最长1500字节) 数据包的具体内容 head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送 mac地址： head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址 mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号） 广播： 有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址） ethernet采用最原始的方式，广播的方式进行通信，即计算机通信基本靠吼 2.3.3 网络层网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机就可以彼此通信了，问题是世界范围的互联网是由 一个个彼此隔离的小的局域网组成的，那么如果所有的通信都采用以太网的广播方式，那么一台机器发送的包全世界都会收到， 这就不仅仅是效率低的问题了，这会是一种灾难 上图结论：必须找出一种方法来区分哪些计算机属于同一广播域，哪些不是，如果是就采用广播的方式发送，如果不是， 就采用路由的方式（向不同广播域／子网分发数据包），mac地址是无法区分的，它只跟厂商有关 网络层功能：引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址 IP协议： 规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示 范围0.0.0.0-255.255.255.255 一个ip地址通常写成四段十进制数，例：172.16.10.1 ip地址分成两部分 网络部分：标识子网 主机部分：标识主机 注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网 例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网 子网掩码 所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算， 172.16.10.1：10101100.00010000.00001010.000000001 255255.255.255.0:11111111.11111111.11111111.00000000 AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0 172.16.10.2：10101100.00010000.00001010.000000010 255255.255.255.0:11111111.11111111.11111111.00000000 AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0 结果都是172.16.10.0，因此它们在同一个子网络。 总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 ip数据包 ip数据包也分为head和data部分，无须为ip包定义单独的栏位，直接放入以太网包的data部分 head：长度为20到60字节 data：最长为65,515字节。 而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。 以太网头 ip 头 ip数据 ARP协议 arp协议由来：计算机通信基本靠吼，即广播的方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送，在谈及以太网协议时候，我门了解到 通信是基于mac的广播方式实现，计算机在发包时，获取自身的mac是容易的，如何获取目标主机的mac，就需要通过arp协议 arp协议功能：广播的方式发送数据包，获取目标主机的mac地址 协议工作方式：每台主机ip都是已知的 例如：主机172.16.10.10/24访问172.16.10.11/24 一：首先通过ip地址和子网掩码区分出自己所处的子网 场景 数据包地址 同一子网 目标主机mac，目标主机ip 不同子网 网关mac，目标主机ip 二：分析172.16.10.10/24与172.16.10.11/24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.1,通过arp获取的是网关的mac) 源mac 目标mac 源ip 目标ip 数据部分 发送端主机 发送端mac FF:FF:FF:FF:FF:FF 172.16.10.10/24 172.16.10.11/24 数据 三：这个包会以广播的方式在发送端所处的自网内传输，所有主机接收后拆开包，发现目标ip为自己的，就响应，返回自己的mac 2.3.4 传输层传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序， 那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。 传输层功能：建立端口到端口的通信 补充：端口范围0-65535，0-1023为系统占用端口 tcp协议： 可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 以太网头 ip 头 tcp头 数据 udp协议： 不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。 以太网头 ip头 udp头 数据 tcp报文 tcp三次握手和四次挥手 发送端接受到接收端的ack响应后才会清空发送端内核态的缓存。 TCP协议与UDP协议的区别12首先咱们弄清楚，TCP协议和UCP协议与TCP&#x2F;IP协议的联系，很多人犯糊涂了，一直都是说TCP协议与UDP协议的区别，我觉得这是没有从本质上弄清楚网络通信！ TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。 TCP/IP协议集包括应用层,传输层，网络层，网络访问层。 其中应用层包括:1、超文本传输协议（HTTP）:万维网的基本协议；2、文件传输（TFTP简单文件传输协议）；3、远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；4、网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；5、域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。 其次网络层包括:1、Internet协议（IP）；2、Internet控制信息协议（ICMP）；3、地址解析协议（ARP）；4、反向地址解析协议（RARP）。 最后说网络访问层:网络访问层又称作主机到网络层（host-to-network），网络访问层的功能包括IP地址与物理地址硬件的映射， 以及将IP封装成帧.基于不同硬件类型的网络接口，网络访问层定义了和物理介质的连接. 当然我这里说得不够完善，TCP/IP协议本来就是一门学问，每一个分支都是一个很复杂的流程， 但我相信每位学习软件开发的同学都有必要去仔细了解一番。 下面着重讲解一下TCP协议和UDP协议的区别TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂， 只简单的描述下这三次对话的简单过程： 1）主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话； 2）主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话； 3）主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。 三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。 TCP三次握手过程第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。 第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我 第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：”我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。 3次握手的特点没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。 、 TCP建立连接要进行3次握手，而断开连接要进行4次第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ； 第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1； 第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ； 第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。 由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。 名词解释1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。 2、SYN 同步序列号，TCP建立连接时将这个位置1。 3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。 TCP的包头结构：源端口 16位； 目标端口 16位； 序列号 32位； 回应序号 32位； TCP头长度 4位； reserved 6位； 控制代码 6位； 窗口大小 16位； 偏移量 16位； 校验和 16位； 选项 32位(可选)； 这样我们得出了TCP包头的最小长度，为20字节。 UDP（User Data Protocol，用户数据报协议）1、UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 2、 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。 3、UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。 4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。 5、UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。 6、UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。 我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。 ping命令是用来探测主机到主机之间是否可通信，如果不能ping到某台主机，表明不能和这台主机建立连接。ping命令是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机。 ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。 UDP的包头结构：源端口 16位 目的端口 16位 长度 16位 校验和 16位 小结TCP与UDP的区别：1、基于连接与无连接； 2、对系统资源的要求（TCP较多，UDP少）； 3、UDP程序结构较简单； 4、流模式与数据报模式 ； 5、TCP保证数据正确性，UDP可能丢包； 6、TCP保证数据顺序，UDP不保证。 2.3.5 应用层应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 应用层功能：规定应用程序的数据格式。 例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。 2.3.6 socket我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。 能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。 三.网络通信实现想实现网络通信，每台主机需具备四要素 本机的IP地址 子网掩码 网关的IP地址 DNS的IP地址 获取这四要素分两种方式 1.静态获取 即手动配置 2.动态获取 通过dhcp获取 以太网头 ip头 udp头 dhcp数据包 （1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。 （2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。 （3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。 这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。 新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数 四.网络通信流程1.本机获取 本机的IP地址：192.168.1.100 子网掩码：255.255.255.0 网关的IP地址：192.168.1.1 DNS的IP地址：8.8.8.8 2.打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。 3.dns协议(基于udp协议) 13台根dns： A.root-servers.net198.41.0.4美国B.root-servers.net192.228.79.201美国（另支持IPv6）C.root-servers.net192.33.4.12法国D.root-servers.net128.8.10.90美国E.root-servers.net192.203.230.10美国F.root-servers.net192.5.5.241美国（另支持IPv6）G.root-servers.net192.112.36.4美国H.root-servers.net128.63.2.53美国（另支持IPv6）I.root-servers.net192.36.148.17瑞典J.root-servers.net192.58.128.30美国K.root-servers.net193.0.14.129英国（另支持IPv6）L.root-servers.net198.32.64.12美国M.root-servers.net202.12.27.33日本（另支持IPv6） 域名定义：http://jingyan.baidu.com/article/1974b289a649daf4b1f774cb.html 顶级域名：以.com,.net,.org,.cn等等属于国际顶级域名，根据目前的国际互联网域名体系，国际顶级域名分为两类：类别顶级域名(gTLD)和地理顶级域名(ccTLD)两种。类别顶级域名是 以”COM”、”NET”、”ORG”、”BIZ”、”INFO”等结尾的域名，均由国外公司负责管理。地理顶级域名是以国家或地区代码为结尾的域名，如”CN”代表中国，”UK”代表英国。地理顶级域名一般由各个国家或地区负责管理。 二级域名：二级域名是以顶级域名为基础的地理域名，比喻中国的二级域有，.com.cn,.net.cn,.org.cn,.gd.cn等.子域名是其父域名的子域名，比喻父域名是abc.com,子域名就是www.abc.com或者.abc.com.一般来说，二级域名是域名的一条记录，比如alidiedie.com是一个域名，www.alidiedie.com是其中比较常用的记录，一般默认是用这个，但是类似.alidiedie.com的域名全部称作是alidiedie.com的二级 4.HTTP部分的内容，类似于下面这样： GET / HTTP/1.1Host: www.google.comConnection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 6.1) ……Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3Cookie: … … 我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。 5 TCP协议 TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。 TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。 6 IP协议 然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。 IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。 7 以太网协议 最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。 以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。 8 服务器端响应 经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。 根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。 本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://sjtu-xx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"html","slug":"html","date":"2020-06-29T12:29:05.000Z","updated":"2021-02-20T10:20:12.077Z","comments":true,"path":"2020/06/29/html/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/html/","excerpt":"前端概述","text":"前端概述 1234567891011121314151617181920import socketdef main(): sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind((&#39;localhost&#39;,8089)) sock.listen(5) while True: connection, address &#x3D; sock.accept() buf &#x3D; connection.recv(1024) connection.sendall(bytes(&quot;HTTP&#x2F;1.1 201 OK\\r\\n\\r\\n&quot;,&quot;utf8&quot;)) connection.sendall(bytes(&quot;&lt;h1&gt;Hello,World&lt;&#x2F;h1&gt;&quot;,&quot;utf8&quot;)) connection.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() html css 以及js的关系 HTML的学习HTML 是什么？htyper text markup language 即超文本标记语言 超文本: 就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。 标记语言: 标记（标签）构成的语言. 网页==HTML文档，由浏览器解析，用来展示的 静态网页：静态的资源，如xxx.html 动态网页：html代码是由某种开发语言根据用户请求动态生成的 html文档树形结构图： 什么是标签 是由一对尖括号包裹的单词构成 例如: &lt;html&gt; *所有标签中的单词不可能以数字开头. 标签不区分大小写.&lt;html&gt; 和 &lt;HTML&gt;. 推荐使用小写. 标签分为两部分: 开始标签&lt;a&gt; 和 结束标签&lt;/a&gt;. 两个标签之间的部分 我们叫做标签体. 有些标签功能比较简单.使用一个标签即可.这种标签叫做自闭和标签.例如: &lt;br/&gt; &lt;hr/&gt; &lt;input /&gt; &lt;img /&gt; 标签可以嵌套.但是不能交叉嵌套. &lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 标签的属性 通常是以键值对形式出现的. 例如 name=”alex” 属性只能出现在开始标签 或 自闭和标签中. 属性名字全部小写. *属性值必须使用双引号或单引号包裹 例如 name=”alex” 如果属性值和属性名完全一样.直接写属性名即可. 例如 readonly &lt;!DOCTYPE html&gt;标签​ 由于历史的原因，各个浏览器在对页面的渲染上存在差异，甚至同一浏览器在不同版本中，对页面的渲染也不同。在W3C标准出台以前，浏览器在对页面的渲染上没有统一规范，产生了差异(Quirks mode或者称为CompatibilityMode)；由于W3C标准的推出，浏览器渲染页面有了统一的标准(CSScompat或称为Strict mode也有叫做Standarsmode)，这就是二者最简单的区别。​ W3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。这样浏览器渲染上就产生了Quircks mode和Standars mode，两种渲染方法共存在一个浏览器上。 123window.top.document.compatMode：&#x2F;&#x2F;BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。 &#x2F;&#x2F;CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 ​ 这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat, 这也就是恶魔的开始 – 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。 ​ 如果你的页面添加了&lt;!DOCTYPE html&gt;那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的 标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。 这就是&lt;!DOCTYPE html&gt;的作用。 head标签&lt;meta&gt;​ meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 ​ 1: name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 ​ 2: http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content, content中的内容其实就是各个参数的变量值。 注意：X-UA-Compatible 1234567891011121314151617181920212223242526272829每个主要版本IE新增的功能都是为了让浏览器更容易使用、增加安全性及更支持业界标准。以这些作为IE的特色，其中一个风险就是旧版本网站无法正确的显示。为了将这个风险降到最低，IE6允许网页开发人员选择IE编译和显示他们网页的方式。&quot;Quirks mode&quot;为预设，这会使页面以旧版本浏览器的视点显示，&quot;Standards mode&quot;(也称为&quot;strict mode&quot;)特点是支持业界标准最为完善。然而要利用这个增强的支持功能，网页必须包含恰当的&lt;!DOCTYPE&gt;指令。若一个网页没有包含&lt;!DOCTYPE&gt;指令，IE6会将它以quirks mode显示。若网页包含有效的&lt;!DOCTYPE&gt;指令但浏览器无法辨识，IE6会将它以IE6 standards mode显示。因为少数网站已经包含&lt;!DOCTYPE&gt;指令，兼容性模式的切换相当成功。这使网页开发人员能选择将他们的网页转移为standards mode的最佳时机。随著时间经过，更多网站开始使用standards mode。它们也开始使用IE6的特性和功能来检测IE。举例来说，IE6不支持universal selector(即css之全局选择器 * &#123;&#125;)，一些网站便使用它来针对IE做特定的对应。当 IE7增加了对全域选择器的支持，那些依赖IE6特点的网站便无法侦测出这个新版本的浏览器。因此那些针对IE的特定对应无法应用于IE7，造成这些网站便无法如他们预期的显示。由于&lt;!DOCTYPE&gt;只支持两种兼容性模式，受到影响的网站拥有者被迫更新他们的网站使其能支持IE7。IE8 比之前的任何版本浏览器都更支持业界标准，因此针对旧版本浏览器设计的网页可能无法如预期般呈现。为了帮助减轻所有问题，IE8引入文件兼容性的概念，使你能选择你的网页设计要对应的特定IE版本。文件兼容性在IE8增加了一些新的模式，这些模式能告诉浏览器如何解析和编译一个网页。若你的网页无法在 ie8正确的显示，你可以更新你的网站使它支持最新的网页标准(优先选项)或在你的页面上新增一个meta元素用于告诉IE8如何依照旧版本浏览器编译你的页面。这能让你选择将你的网站更新支持IE8新特点的时机。当 Internet Explorer 8 遇到未包含 X-UA-Compatible 标头的网页时，它将使用 &lt;!DOCTYPE&gt; 指令来确定如何显示该网页。 如果该指令丢失或未指定基于标准的文档类型，则 Internet Explorer 8 将以 IE5 模式（Quirks 模式）显示该网页。 非meta标签 1234&lt;title&gt;oldboy&lt;&#x2F;title&gt;&lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.jd.com&#x2F;favicon.ico&quot;&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css.css&quot;&gt;&lt;script src&#x3D;&quot;hello.js&quot;&gt;&lt;&#x2F;script&gt; body标签一 基本标签（块级标签和内联标签）1234567891011121314151617&lt;hn&gt;: n的取值范围是1~6; 从大到小. 用来表示标题.&lt;p&gt;: 段落标签. 包裹的内容被换行.并且也上下内容之间有一行空白.&lt;b&gt; &lt;strong&gt;: 加粗标签.&lt;strike&gt;: 为文字加上一条中线.&lt;em&gt;: 文字变成斜体.&lt;sup&gt;和&lt;sub&gt;: 上角标 和 下角表.&lt;br&gt;:换行.&lt;hr&gt;:水平线&lt;div&gt;&lt;span&gt; 块级标签：&lt;p&gt;&lt;h1&gt;&lt;table&gt;&lt;ol&gt;&lt;ul&gt;&lt;form&gt;&lt;div&gt; 内联标签：&lt;a&gt;&lt;input&gt;&lt;img&gt;&lt;sub&gt;&lt;sup&gt;&lt;textarea&gt;&lt;span&gt; block（块）元素的特点 总是在新行上开始； 宽度缺省是它的容器的100%，除非设定一个宽度。 它可以容纳内联元素和其他块元素 inline元素的特点 和其他元素都在一行上；宽度就是它的文字或图片的宽度，不可改变内联元素只能容纳文本或者其他内联元素 特殊字符 ​ &amp;lt; &amp;gt；&amp;quot；\\&amp;copy;\\&amp;reg; 标签属性 id 标签的属性！！！！！ 用#符号来引用 二 图形标签: &lt;img&gt;123456789src: 要显示图片的路径.alt: 图片没有加载成功时的提示.title: 鼠标悬浮时的提示信息.width: 图片的宽height:图片的高 (宽高两个属性只用一个会自动等比缩放.) 三 超链接标签(锚标签)&lt;a&gt;1234567href:要连接的资源路径 格式如下: href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; target: _blank : 在新的窗口打开超链接. 框架名称: 在指定框架中打开连接内容.name: 定义一个页面的书签.用于跳转 href : #id.（锚） 四 列表标签：123456789&lt;ul&gt;: 无序列表&lt;ol&gt;: 有序列表 &lt;li&gt;:列表中的每一项.&lt;dl&gt; 定义列表 &lt;dt&gt; 列表标题 &lt;dd&gt; 列表项 五 表格标签: &lt;table&gt;12345678910111213141516171819border: 表格边框.cellpadding: 内边距cellspacing: 外边距.width: 像素 百分比.（最好通过css来设置长宽）&lt;tr&gt;: table rowc&lt;th&gt;: table head cell&lt;td&gt;: table data cellrowspan: 单元格竖跨多少行colspan: 单元格横跨多少列（即合并单元格）&lt;th&gt;: table header &lt;tbody&gt;(不常用): 为表格进行分区. 六 表单标签&lt;form&gt;​ 表单用于向服务器传输数据。 ​ 表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等。 ​ 表单还可以包含textarea、select、fieldset和 label 元素。 1.表单属性 HTML 表单用于接收不同类型的用户输入，用户提交表单时向服务器传输数据，从而实现用户与Web服务器的交互。表单标签, 要提交的所有内容都应该在该标签中. ​ action: 表单提交到哪. 一般指向服务器端一个程序,程序接收到表单提交过来的数据（即表单元素值）作相应处理，比如https://www.sogou.com/web ​ method: 表单的提交方式 post/get 默认取值 就是 get（信封） ​ get: 1.提交的键值对.放在地址栏中url后面. 2.安全性相对较差. 3.对提交内容的长度有限制.4.请求或查看数据时使用。 ​ post:1.提交的键值对 不在地址栏. 2.安全性相对较高. 3.对提交内容的长度理论上无限制. ​ get/post是常见的两种请求方式. 2.表单元素 ​ &lt;input&gt; 标签的属性和对应值 123456789101112131415type: text 文本输入框 password 密码输入框 radio 单选框 checkbox 多选框 submit 提交按钮（submit的value属性只是用于显示） button 按钮(需要配合js使用.) button和submit的区别？ file 提交文件：form表单需要加上属性enctype&#x3D;&quot;multipart&#x2F;form-data&quot; reset 重置：value为按钮上显示的字符 123456name: 表单提交项的键.注意和id属性的区别：name属性是和服务器通信时使用的名称；而id属性是浏览器端使用的名称，该属性主要是为了方便客户端编程，而在css和javascript中使用的value: 表单提交项的值.对于不同的输入类型，value 属性的用法也不同placeholder：放在输入框后checked: radio 和 checkbox 默认被选中readonly: 只读. text 和 passworddisabled: 对所用input都好使. 上传文件注意两点： 1 请求方式必须是post 2 enctype=”multipart/form-data” 123456789101112def index(request): print request.POST print request.GET print request.FILES for item in request.FILES: fileObj &#x3D; request.FILES.get(item) f &#x3D; open(fileObj.name, &#39;wb&#39;) iter_file &#x3D; fileObj.chunks() for line in iter_file: f.write(line) f.close() return HttpResponse(&#39;ok&#39;) &lt;select&gt; 下拉选标签属性 123456789101112name:表单提交项的键.size：选项个数multiple：multiple &lt;option&gt; 下拉选中的每一项 属性： value:表单提交项的值. selected: selected下拉选默认被选中 &lt;optgroup&gt;为每一项加上分组 &lt;optgroup label &#x3D; &quot;name&quot;&gt; &lt;textarea&gt; 文本域 12345name: 表单提交项的键.cols: 文本域默认有多少列rows: 文本域默认有多少行 ​ &lt;label&gt; 获得对应id焦点 12&lt;label for = \"wwww\"&gt;&lt;/lable&gt;&lt;input id = \"www\" type=\"text\"&gt;&lt;/input&gt; ​ &lt;fieldset&gt; 123456&lt;fieldset&gt; &lt;legend&gt; 登录吧 &lt;/legend&gt; &lt;input type=\"text\"&gt;&lt;/fieldset&gt; CSScss概述CSS是Cascading Style Sheets的简称，中文称为层叠样式表，用来控制网页数据的表现，可以使网页的表现与数据内容分离。 基本语法： selector{ property:value } 属性大于1个之后，属性之间用分号隔开 值大于1个单词，需要加上引号 一 css的四种引入方式1.行内式 行内式是在标记的style属性中设定CSS样式。这种方式没有体现出CSS的优势，不推荐使用。 1&lt;p style&#x3D;&quot;background-color: rebeccapurple&quot;&gt;hello yuan&lt;&#x2F;p&gt; 2.嵌入式 嵌入式是将CSS样式集中写在网页的标签对的标签对中。格式如下： 123456789&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; p&#123; background-color: #2b99ff; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt; 3 链接式 将一个.css文件引入到HTML文件中 1&lt;link href&#x3D;&quot;mystyle.css&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot;&#x2F;&gt; 4.导入式 将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，&lt;style&gt;标记也是写在&lt;head&gt;标记中，使用的语法如下： 12345&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; @import&quot;mystyle.css&quot;; 此处要注意.css文件的路径 &lt;&#x2F;style&gt; 注意： ​ 导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。使用链接式时与导入式不同的是它会以网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样式的效果的，它不会象导入式那样先显示无样式的网页，然后再显示有样式的网页，这是链接式的优点。 二 css的选择器（Selector）“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素 1 基础选择器1234567＊ ：通用元素选择器，匹配任何元素 * &#123; margin:0; padding:0; &#125;E ：标签选择器，匹配所有使用E标签的元素 p &#123; color:green; &#125;.info和E.info: class选择器，匹配所有class属性中包含info的元素 .info &#123; background:#ff0; &#125; p.info &#123; background:blue; &#125;#info和E#info id选择器，匹配所有id属性等于footer的元素 #info &#123; background:#ff0; &#125; p#info &#123; background:#ff0; &#125; 2 组合选择器1234E,F 多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔 div,p &#123; color:#f00; &#125;E F 后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔 li a &#123; font-weight:bold;E &gt; F 子元素选择器，匹配所有E元素的子元素F div &gt; p &#123; color:#f00; &#125;E + F 毗邻元素选择器，匹配紧随E元素之后的同级元素F div + p &#123; color:#f00; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; .div1&gt;p&#123; background-color: aqua; color: deeppink; &#125; .main2&gt;div&#123; background-color: blueviolet; color: chartreuse; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;div1&quot;&gt;hello1 &lt;div class&#x3D;&quot;div2&quot;&gt;hello2 &lt;div&gt;hello4&lt;&#x2F;div&gt; &lt;p&gt;hello5&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;p&gt;hello3&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;p&gt;hello6&lt;&#x2F;p&gt;&lt;hr&gt; &lt;div class&#x3D;&quot;main2&quot;&gt;1 &lt;div&gt;2 &lt;div&gt; 4 &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div&gt; 3 &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 注意嵌套规则： 块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。 有几个特殊的块级元素只能包含内联元素，不能包含块级元素。如h1,h2,h3,h4,h5,h6,p,dt li内可以包含div 块级元素与块级元素并列、内联元素与内联元素并列。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; [suoning]&#123; color: blueviolet; &#125; .he&gt;div&#123; color: bisque; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;he&quot;&gt;111 &lt;p class&#x3D;&quot;fr&quot;&gt;222 &lt;div&gt;333&lt;&#x2F;div&gt; &lt;&#x2F;p&gt; &lt;div&gt;444&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;***************************&lt;div suoning&#x3D;&quot;sb&quot;&gt;ddd &lt;p&gt;pppp&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;p suoning&#x3D;&quot;sb2&quot;&gt;ddd2 &lt;p&gt;pppp2&lt;&#x2F;p&gt; &lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 3 属性选择器多个属性 class = “div1 div2”表示设定css样式时，class属性为div1或div2均可 12345678910111213141516 E[att] 匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如“[cheacked]”。以下同。） p[title] &#123; color:#f00; &#125; E[att&#x3D;val] 匹配所有att属性等于“val”的E元素 div[class&#x3D;”error”] &#123; color:#f00; &#125; E[att~&#x3D;val] 匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素 td[class~&#x3D;”name”] &#123; color:#f00; &#125; E[attr^&#x3D;val] 匹配属性值以指定值开头的每个元素 div[class^&#x3D;&quot;test&quot;]&#123;background:#ffff00;&#125; E[attr$&#x3D;val] 匹配属性值以指定值结尾的每个元素 div[class$&#x3D;&quot;test&quot;]&#123;background:#ffff00;&#125; E[attr*&#x3D;val] 匹配属性值中包含指定值的每个元素 div[class*&#x3D;&quot;test&quot;]&#123;background:#ffff00;&#125; 为了将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色，可以这样写：a[href][title] &#123;color:red;&#125; 4 伪类(Pseudo-classes)CSS伪类是用来给选择器添加一些特殊效果。 anchor伪类：专用于控制链接的显示效果 1234567891011a:link（没有接触过的链接）,用于定义了链接的常规状态。a:hover（鼠标放在链接上的状态）,用于产生视觉效果。a:visited（访问过的链接）,用于阅读文章，能清楚的判断已经访问过的链接。a:active（在链接上按下鼠标时的状态）,用于表现鼠标按下时的链接状态。伪类选择器 : 伪类指的是标签的不同状态:a &#x3D;&#x3D;&gt; 点过状态 没有点过的状态 鼠标悬浮状态 激活状态 12345678910111213141516171819&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; a:link&#123; color: red; &#125; a:visited &#123; color: blue; &#125; a:hover &#123; color: green; &#125; a:active &#123; color: yellow; &#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;a href&#x3D;&quot;01-hello-world.html&quot;&gt;hello-world&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 补充： 1.outer:hover .right&#123;color: red&#125; outer下的right类进行渲染 before after伪类 ： 1234:before p:before 在每个&lt;p&gt;元素之前插入内容:after p:after 在每个&lt;p&gt;元素之后插入内容 p:before 在每个 &lt;p&gt; 元素的内容之前插入内容 p:before&#123;content:&quot;hello&quot;;color:red&#125; p:after 在每个 &lt;p&gt; 元素的内容之前插入内容 p:after&#123; content:&quot;hello&quot;；color:red&#125; 5 css优先级和继承CSS优先级: 所谓CSS优先级，即是指CSS样式在浏览器中被解析的先后顺序。 12345样式表中的特殊性描述了不同规则的相对权重，它的基本规则是： 1 内联样式表的权值最高 style&#x3D;&quot;&quot;-------------------1000； 2 统计选择符中的ID属性个数。 #id －－－－－－－－－－－－－100 3 统计选择符中的CLASS属性个数。 .class －－－－－－－－－－－－－10 4 统计选择符中的HTML标签名个数。 p －－－－－－－－－－－－－-1 按这些规则将数字符串逐位相加，就得到最终的权重，然后在比较取舍时按照从左到右的顺序逐位比较。 123456789101112&lt;style&gt; #p&#123; color: rebeccapurple; &#125; .p&#123; color: #2459a2; &#125; p&#123; color: yellow; &#125; &lt;&#x2F;style&gt;&lt;p id&#x3D;&quot;p&quot; class&#x3D;&quot;p&quot; style&#x3D;&quot;color: deeppink&quot;&gt;hello yuan&lt;&#x2F;p&gt; CSS的继承性: ​ 继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个BODY定义了的颜色值也会应用到段落的文本中。 1body&#123;color:red;&#125; &lt;p&gt;helloyuan&lt;&#x2F;p&gt; 这段文字都继承了由body {color:red;}样式定义的颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。 1p&#123;color:green&#125; 发现只需要给加个颜色值就能覆盖掉它继承的样式颜色。由此可见：任何显示申明的规则都可以覆盖其继承样式。 ​ 此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin, padding, background等。 12345div&#123; border:1px solid #222&#125;&lt;div&gt;hello &lt;p&gt;yuan&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; 附加说明: 1234567891、文内的样式优先级为1,0,0,0，所以始终高于外部定义。这里文内样式指形如&lt;div style&#x3D;&quot;color:red&gt;blah&lt;&#x2F;div&gt;的样式，而外部定义指经由&lt;link&gt;或&lt;style&gt;卷标定义的规则。 2、有!important声明的规则高于一切。 3、如果!important声明冲突，则比较优先权。 4、如果优先权一样，则按照在源码中出现的顺序决定，后来者居上。 5、由继承而得到的样式没有specificity的计算，它低于一切其它规则(比如全局选择符*定义的规则)。 三 CSS的常用属性1 颜色属性1234567&lt;div style&#x3D;&quot;color:blueviolet&quot;&gt;ppppp&lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;color:#ffee33&quot;&gt;ppppp&lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;color:rgb(255,0,0)&quot;&gt;ppppp&lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;color:rgba(255,0,0,0.5)&quot;&gt;ppppp&lt;&#x2F;div&gt; 2 字体属性1234567font-size: 20px&#x2F;50%&#x2F;larger font-family:&#39;Lucida Bright&#39; font-weight: lighter&#x2F;bold&#x2F;border&#x2F; &lt;h1 style&#x3D;&quot;font-style: oblique&quot;&gt;老男孩&lt;&#x2F;h1&gt; 3 背景属性1234567891011background-color: cornflowerbluebackground-image: url(&#39;1.jpg&#39;);background-repeat: no-repeat;(repeat:平铺满)background-position: right top（20px 20px）;(横向：left center right)(纵向：top center bottom) 简写：&lt;body style&#x3D;&quot;background: 20px 20px no-repeat #ff4 url(&#39;1.jpg&#39;)&quot;&gt; &lt;div style&#x3D;&quot;width: 300px;height: 300px;background: 20px 20px no-repeat #ff4 url(&#39;1.jpg&#39;)&quot;&gt; 注意：如果将背景属性加在body上，要记得给body加上一个height，否则结果异常，这是因为body为空，无法撑起背景图片；另外，如果此时要设置一个width＝100px，你也看不出效果，除非你设置出html。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; html&#123; background-color: antiquewhite; &#125; body&#123; width: 100px; height: 600px; background-color: deeppink; background-image: url(1.jpg); background-repeat: no-repeat; background-position: center center; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; eg:123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; span&#123; display: inline-block; width: 18px; height: 20px; background-image: url(&quot;http:&#x2F;&#x2F;dig.chouti.com&#x2F;images&#x2F;icon_18_118.png?v&#x3D;2.13&quot;); background-position: 0 -100px; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 4 文本属性123456789font-size: 10px;text-align: center; 横向排列line-height: 200px; 文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比vertical-align:－4px 设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效text-indent: 150px; 首行缩进letter-spacing: 10px;word-spacing: 20px;text-transform: capitalize; 思考：1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; .outer .item &#123; width: 300px; height: 200px; background-color: chartreuse; display: inline-block; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;outer&quot;&gt; &lt;div class&#x3D;&quot;item&quot; style&#x3D;&quot;vertical-align: top&quot;&gt;ll &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 5 边框属性123456789border-style: solid; border-color: chartreuse; border-width: 20px; 简写：border: 30px rebeccapurple solid;控制某一条边：border-left 6 列表属性1234ul,ol&#123; list-style: decimal-leading-zero; list-style: none; &lt;br&gt; list-style: circle; list-style: upper-alpha; list-style: disc; &#125; 7 dispaly属性1&#96;none&#96;&#96;block&#96;&#96;inline&#96; display:inline-block可做列表布局，其中的类似于图片间的间隙小bug可以通过如下设置解决： 123#outer&#123; border: 3px dashed; word-spacing: -5px;&#125; 8 外边距和内边 margin: 用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。 padding: 用于控制内容与边框之间的距离； Border(边框) 围绕在内边距和内容外的边框。 Content(内容) 盒子的内容，显示文本和图像。 元素的宽度和高度: 重要: 当您指定一个CSS元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完全大小的元素，你还必须添加填充，边框和边距。. 1234margin:10px 5px 15px 20px;-----------上 右 下 左margin:10px 5px 15px;----------------上 右左 下margin:10px 5px;---------------------上下 右左margin:10px; ---------------------上右下左 下面的例子中的元素的总宽度为300px： 1234width:250px;padding:10px;border:5px solid gray;margin:10px; 练习： 300px300px的盒子装着100px100px的盒子，分别通过margin和padding设置将小盒子 移到大盒子的中间 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; .div1&#123; background-color: aqua; width: 300px; height: 300px; &#125; .div2&#123; background-color: blueviolet; width: 100px; height: 100px; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;div1&quot;&gt; &lt;div class&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 思考1: ​ 边框在默认情况下会定位于浏览器窗口的左上角，但是并没有紧贴着浏览器的窗口的边框，这是因为body本身也是一个盒子（外层还有html），在默认情况下， body距离html会有若干像素的margin，具体数值因各个浏览器不尽相同，所以body中的盒子不会紧贴浏览器窗口的边框了，为了验证这一点，加上： 1234body&#123; border: 1px solid; background-color: cadetblue;&#125; &gt;&gt;&gt;&gt;解决方法： 123body&#123; margin: 0;&#125; 思考2： ​ margin collapse（边界塌陷或者说边界重叠） ​ 外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段 落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。又比如停车场 ​ 1兄弟div：上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值 ​ 2父子div ​ if 父级div中没有 border，padding，inline content，子级div的margin会一直向上找，直到找到某个标签包括border，padding，inline content 中的其中一个，然后按此div 进行margin ； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot; style&#x3D;&quot;padding: 0px&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; body&#123; margin: 0px; &#125; .div1&#123; background-color: aqua; width: 300px; height: 300px; &#125; .div2&#123; background-color: blueviolet; width: 100px; height: 100px; margin: 20px; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div style&#x3D;&quot;background-color: cadetblue;width: 300px;height: 300px&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;div1&quot;&gt; &lt;div class&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 解决方法： 1231: border:1px solid transparent2: padding:1px3: over-flow:hidden; 9 float属性先来了解一下block元素和inline元素在文档流中的排列方式。 block元素通常被现实为独立的一块，独占一行，多个block元素会各自新起一行，默认block元素宽度自动填满其父元素宽度。block元素可以设置width、height、margin、padding属性； inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。inline元素设置width、height属性无效。inline元素的margin和padding属性。水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 常见的块级元素有 div、form、table、p、pre、h1～h5、dl、ol、ul 等。 常见的内联元素有span、a、strong、em、label、input、select、textarea、img、br等 所谓的文档流，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。 脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。 只有绝对定位absolute和浮动float才会脱离文档流。 ​ —部分无视和完全无视的区别？需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围(可以说是部分无视)。而对于使用absolute position脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。(可以说是完全无视) 浮动的表现​ 定义：浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的浮动框之后的块框表现得就像浮动框不存在一样。（注意这里是块框而不是内联元素；浮动框只对它后面的元素造成影响） 注意 当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，即float是一种不彻底的脱离文档流方式。无论多么复杂的布局，其基本出发点均是：“如何在一行显示多个div元素”。 现象1: ​ 假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。此外，浮动的框之后的block元素元素会认为这个框不存在，但其中的文本依然会为这个元素让出位置。 浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列。 现象2: (1)左右结构div盒子重叠现象，一般是由于相邻两个DIV一个使用浮动一个没有使用浮动。如上面的例1：相邻的两个盒子box2向左浮动、box3未浮动。一个使用浮动一个没有导致DIV不是在同个“平面”上，但内容不会照成覆盖现象，只有DIV形成覆盖现象。 解决方法：要么都不使用浮动；要么都使用float浮动；要么对没有使用float浮动的DIV设置margin样式。 (2)上下结构div盒子重叠现象 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; * &#123; margin:0;padding:0; &#125; .container&#123; border:1px solid red;width:300px; &#125; #box1&#123; background-color:green;float:left;width:100px;height:100px; &#125; #box2&#123; background-color:deeppink; float:right;width:100px;height:100px; &#125; #box3&#123; background-color:pink;height:40px; &#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div id&#x3D;&quot;box1&quot;&gt;box1 向左浮动&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;box2&quot;&gt;box2 向右浮动&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;box3&quot;&gt;box3&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 例子如上：.container和box3的布局是上下结构，上图发现box3跑到了上面，与.container产生了重叠，但文本内容没有发生覆盖，只有div发生覆盖现象。这个原因是因为第一个大盒子里的子元素使用了浮动，脱离了文档流，导致.container没有被撑开。box3认为.container没有高度（未被撑开），因此跑上去了。 解决方法： 1、要么给.container设置固定高度，一般情况下文字内容不确定多少就不能设置固定高度，所以一般不能设置“.container”高度(当然能确定内容多高，这种情况下“.container是可以设置一个高度即可解决覆盖问题。 2、要么清除浮动。 清除浮动：在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。 clear语法：clear : none | left | right | both 取值：none : 默认值。允许两边都可以有浮动对象left : 不允许左边有浮动对象right : 不允许右边有浮动对象both : 不允许有浮动对象 但是需要注意的是：clear属性只会对自身起作用，而不会影响其他元素。如果一个元素的右侧有一浮动对象，而这个元素设置了不允许右边有浮动对象，即clear：right，则这个元素会自动下移一格，达到本元素右边没有浮动对象的目的。 方式1(推荐): 12345678910.clearfix:after &#123; &lt;----在类名为“clearfix”的元素内最后面加入内容； content: &quot;.&quot;; &lt;----内容为“.”就是一个英文的句号而已。也可以不写。 display: block; &lt;----加入的这个元素转换为块级元素。 clear: both; &lt;----清除左右两边浮动。 visibility: hidden; &lt;----可见度设为隐藏。注意它和display:none;是有区别的。visibility:hidden;仍然占据空间，只是看不到而已； line-height: 0; &lt;----行高为0； height: 0; &lt;----高度为0； font-size:0; &lt;----字体大小为0； &#125; .clearfix &#123; *zoom:1;&#125; &lt;----这是针对于IE6的，因为IE6不支持:after伪类，这个神奇的zoom:1让IE6的元素可以清除浮动来包裹内部元素。 整段代码就相当于在浮动元素后面跟了个宽高为0的空div，然后设定它clear:both来达到清除浮动的效果。之所以用它，是因为，你不必在html文件中写入大量无意义的空标签，又能清除浮动。 话说回来，你这段代码真是个累赘啊，这样写不利于维护。只要写一个.clearfix就行了，然后在需要清浮动的元素中 添加clearfix类名就好了。如： 1&lt;div class&#x3D;&quot;head clearfix&quot;&gt;&lt;&#x2F;div&gt; 方式2： 1overflow:hidden; overflow：hidden的含义是超出的部分要裁切隐藏，float的元素虽然不在普通流中，但是他是浮动在普通流之上的，可以把普通流元素+浮动元素想象成一个立方体。如果没有明确设定包含容器高度的情况下，它要计算内容的全部高度才能确定在什么位置hidden，这样浮动元素的高度就要被计算进去。这样包含容器就会被撑开，清除浮动。 10 position(定位)1 staticstatic 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。 2 position: relative／absolute​ relative 相对定位。相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。 注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。 absolute 绝对定位。​ 定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。 ​ 另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。 总结：参照物用相对定位，子元素用绝对定位，并且保证相对定位参照物不会偏移即可。 3 position:fixed​ fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是“定位流”。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。 ​ 在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。 4 仅使用margin属性布局绝对定位元素此情况，margin-bottom 和margin-right的值不再对文档流中的元素产生影响，因为该元素已经脱离了文档流。另外，不管它的祖先元素有没有定位，都是以文档流中原来所在的位置上偏移参照物。 图9中，使用margin属性布局相对定位元素。 层级关系为： 1234567 &lt;div ——————————— position:relative; &lt;div—————————-没有设置为定位元素，不是参照物 &lt;div———————-没有设置为定位元素，不是参照物 &lt;div box1 &lt;div box2 ——–position:absolute; margin-top:50px; margin-left:120px; &lt;div box3 效果图： 11 关于css的拾遗11.1 inline-block 的间隙12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; a&#123; display: inline-block; background-color: #2459a2; width: 100px; height: 100px; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;a&gt;111&lt;&#x2F;a&gt;&lt;a&gt;222&lt;&#x2F;a&gt;&lt;a&gt;333&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; inline-block默认的空格符就是标签与标签之间的空隙造成的。 (1) 我们可以通过margin:-3px来解决，但是 1.我们布局肯定很多元素，不可能每个都添加margin负这样维护成本太大了 2.我们线上代码如果压缩，那么我们就不存在哪个4px的问题了，那么我们的margin负就回造成布局混乱！ (2)我们可以给几个标签加一个父级div，然后： 1&#96;div&#123;word-spacing: -5px;&#125; &#96; 11.2 word-wrap &amp; word-break:word-wrap: the word-wrap CSS property is used to specify whether or not the browser is allowd tobreak lines within words in order to prevent overflow when an otherwise unbreakablestring is too long to fit. The word-wrap property was invented by Microsoft and added to CSS3. It allows long words to be able to be broken and wrap onto the next line. It takes in two values; normal or break-word. word-break: The word-break CSS property is used to specify how (or if) to break lines within words 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style&gt; .p1&#123; width: 100px; background-color: #84a42b; word-wrap: break-word; word-break: break-all; &#125; .p2&#123; width: 100px; background-color: darkgoldenrod; word-wrap: break-word; word-break: break-all; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p class&#x3D;&quot;p1&quot;&gt;hello yuan hello yuan hello yuan hello yuan hello yuan&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;p2&quot;&gt;helloyuanhelloyuanhelloyuanhelloyuanhelloyuanhelloyuan&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 1.3​ 一旦给元素加上absolute或float就相当于给元素加上了display:block;。什么意思呢？比如内联元素span默认宽度是自适应的，你给其加上width是不起作用的。要想width定宽，你需要将span设成display:block。但如果你给span加上absolute或float，那span的display属性自动就变成block，就可以指定width了。 1.4 快写123div tab a tabdiv.main&gt;ul&gt;li.c*4 tab 1.5 display:flex1.6 响应式布局1.7水平居中margin: 0 auto; 1.8 float和position公用https://www.cnblogs.com/coffeedeveloper/p/3145790.html#float 1.9 连用1background: url(\"img.png\") no-repeat 0 -100px","categories":[{"name":"前端","slug":"前端","permalink":"https://sjtu-xx.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"python基础","slug":"python基础","date":"2020-06-29T11:36:53.000Z","updated":"2021-02-19T02:26:06.556Z","comments":true,"path":"2020/06/29/python基础/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/29/python%E5%9F%BA%E7%A1%80/","excerpt":"零零","text":"零零 小东西星号的作用传递实参和定义形参（所谓实参就是调用函数时传入的参数，形参则是定义函数是定义的参数）的时候，你还可以使用两个特殊的语法：、* 。 调用函数时使用 ，* test(args)中 的作用：其实就是把序列 args 中的每个元素，当作位置参数传进去。比如上面这个代码，如果 args 等于 (1,2,3) ，那么这个代码就等价于 test(1, 2, 3) 。 test(**kwargs)中 的作用：则是把字典 kwargs 变成关键字参数传递。比如上面这个代码，如果 kwargs 等于 {‘a’:1,’b’:2,’c’:3} ，那这个代码就等价于 test(a=1,b=2,c=3) 。 定义函数参数时使用 、* def test(args): …定义函数参数时 的含义又要有所不同，在这里 *args 表示把传进来的位置参数都装在元组 args 里面。比如说上面这个函数，调用 test(1, 2, 3) 的话， args 的值就是 (1, 2, 3) 。: def test(**kwargs): …类似的， 就是针对关键字参数和字典的了。 调用 test(a=1,b=2,c=3) 的话， kwargs 的值就是 {‘a’:1,’b’:2,’c’:3} 了。 普通的参数定义和传递方式和 们都可以和平共处，不过显然 必须放在所有位置参数的最后，而 ** 则必须放在所有关键字参数的最后，否则就要产生歧义了。 exec12345678910111213141516171819202122232425#exec：三个参数#参数一：包含一系列python代码的字符串#参数二：全局作用域（字典形式），如果不指定，默认为globals()#参数三：局部作用域（字典形式），如果不指定，默认为locals()#可以把exec命令的执行当成是一个函数的执行，会将执行期间产生的名字存放于局部名称空间中g=&#123; 'x':1, 'y':2&#125;l=&#123;&#125;exec('''global x,zx=100z=200m=300''',g,l)print(g) #&#123;'x': 100, 'y': 2,'z':200,......&#125;print(l) #&#123;'m': 300&#125; 字符串编码方式 ASCII：8位二进制数，第一位为0，有128个符号 Unicode：有许多种不同的二进制格式，可以用来表示 Unicode UTF-8：是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 字符串前的urb字母u/U:表示unicode字符串不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。建议所有编码方式采用utf8 r/R:非转义的原始字符串与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\\n”表示换行，”\\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。以r开头的字符，常用于正则表达式，对应着re模块。 b:bytespython3.x里默认的str是(py2.x里的)unicode, bytes是(py2.x)的str, b”“前缀代表的就是bytes 列表123l =[1,2,3,4]l.pop(2) 按照索引删除l.remove(2) 按照值删除 深拷贝，浅拷贝https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 字典浅拷贝实例实例 a = {1: [1,2,3]}b = a.copy()a, b({1: [1, 2, 3]}, {1: [1, 2, 3]})a[1].append(4)a, b({1: [1, 2, 3, 4]}, {1: [1, 2, 3, 4]}) 深度拷贝需要引入 copy 模块： 实例 import copyc = copy.deepcopy(a)a, c({1: [1, 2, 3, 4]}, {1: [1, 2, 3, 4]})a[1].append(5)a, c({1: [1, 2, 3, 4, 5]}, {1: [1, 2, 3, 4]}) 解析1、b = a: 赋值引用，a 和 b 都指向同一个对象。 2、b = a.copy(): 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。 b = copy.deepcopy(a): 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。 更多实例以下实例是使用 copy 模块的 copy.copy（ 浅拷贝 ）和（copy.deepcopy ）: 实例12345678910111213#!/usr/bin/python# -*-coding:utf-8 -*- import copy a = [1, 2, 3, 4, ['a', 'b']] #原始对象 b = a #赋值，传对象的引用 c = copy.copy(a) #对象拷贝，浅拷贝 d = copy.deepcopy(a) #对象拷贝，深拷贝 a.append(5) #修改对象a a[4].append('c') #修改对象a中的['a', 'b']数组对象 print( 'a = ', a ) print( 'b = ', b ) print( 'c = ', c ) print( 'd = ', d ) 以上实例执行输出结果为： 1234(&#39;a &#x3D; &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5])(&#39;b &#x3D; &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5])(&#39;c &#x3D; &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]])(&#39;d &#x3D; &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]]) 字典循环12for key,value in dic.items(): pass print颜色1print('\\033[32;1mcontent\\033[0m') 类设置属性12setattr(obj,key,value)obj.__dict__[key] = value 零、文件文件读写 一读一写 12with open(file1,'r') as x, open(file2, 'w') as y: y.write(x.read()) 有文件句柄，写完文件之后一定要close() 如果直接config.write(open(‘1.txt’,’w’))不用close 文件操作 123456import osimport shutilos.remove(path) #删除文件os.removedirs(path) #删除空文件夹shutil.rmtree(path) #递归删除文件夹 shutil python 中使用 shutil 实现文件或目录的复制、删除、移动 一、函数global x 全局nonlocal x上一级的x 1、匿名函数 lambda函数用完即在内存中删除。 lambda x: x+1 lambda &lt;参数&gt;：&lt;返回值&gt; lambda只能有一个返回值 应用： 12func &#x3D; lambda x: x+1func(10) 2.函数尾调用在函数执行的最后一步调用另一个函数。尾递归调用优化：在函数调用的最后一步进行递归调用 3.高阶函数高阶函数：函数的传入参数/返回值是一个函数名（1）map函数依次处理列表中的每一个元素 123456def test(func, args): ret &#x3D; [] for i in args: ret.append(func(args)) return rettest(lambda x:x+1, args) map的第一个参数为函数对象（匿名函数或函数名均可），第二个参数为可迭代对象，返回结果为一个list，迭代器，只能迭代一次。 12res &#x3D; map(lambda x:x+1, num_l)print(res) （2）filter函数获取符合条件的数据，返回值为True的值 1res &#x3D; filter(lambda x:x.endswith(&#39;sb&#39;), num_l) （3）reduce函数将整体的数据进行压缩(处理一个序列，对序列进行合并操作) 123from functools import reducereduce(lambda x,y:x*y,num_list)reduce(lambda x,y:x*y,num_list, start_num) 4.内置函数 eval()提取字符串中的数据结构可hash的即为不可变数据类型zip()拉链 将两个序列组成元组序列。如果两个序列长度不等，则根据最小长度的序列进行返回。max()可以指定方法list = [{‘name’:’xx’,’age’:30},{‘name’:’yy’,’age’:34}]max(list,key= lambda dict: dict[‘age’])pow(x,y) → x,ypow(x,y,z) → x**y%zs1 = slice(1,5,2) l = [1,2,3,4,5] l[s1]sorted(list,key = lambda x:dic[x]) 模块就是一个.py文件导入字符串类型的模块: 123module_name = 'test'm = __import__(module_name)m.sayhi() 二、文件处理1.基本操作123f = open(file_name,encoding = 'utf-8','w') #根据操作系统的文件编码方式决定 win：gbk mac:utf-8 f.read() #读取所有的文件内容f.close() 2.打开方式w写，r读，a追加(默认以文本方式打开，即wt，rt，at) 读 1234f.read() #读取所有的文件内容f.readable() #判断是否可读f.readline() #读取一行f.readlines() #读取所有行，放在一个列表中 写 1234#'w'模式，无论文件是否存在，新建空文件，进行写操作#写的参数必须是字符串类型f.write('text\\n')f.writelines(['text\\n','text2\\n']) +标识可以同时读写 ，使用：w+,r+,a+均可，均为读写文件没有修改的说法，都是将数据进行覆盖。 使用 1234with open(file_name,'w',newline='') as f: #newline=''读取文件真正的换行符号 #使用with打开文件不需要进行close()操作 f.read() linux中读取文件，vim将文件读取到内存中进行操作，cat不读取到内存中b模式以字节的模型对文件进行操作，不能指定编码方式可用：wb,rb,ab,w+b,r+b,a+bwin平台的回车\\r\\n 12f.write(bytes('xx',encoding='utf-8'))f.write('xx'.encoding('utf-8')) 其他操作 12345f.flush() #刷新，将内存中的东西写入到文件中f.read(4) #读取4个字符f.tell() #光标当前所在的位置（除了read()方法，其余方法以byte为单位）f.seek(1) #控制光标的移动f.truncate(10) #截取，留下源文件的前10个bytes seek的高级操作 基于相对位置的seek 123f.seek(10,0) #0：（默认模式）相对于文件开头f.seek(10,1) #1：相对于上一次的光标位置f.seek(-10,2) #2：从文件末尾开始seek，第一个参数应该为负数（日志文件中使用） 日志文件的读取（读取文件最后一行） 123456789for i in f: offs = -10 #偏移量的估算 while True: f.seek(offs,2) data = f.readlines() if len(data)&gt;1: print('文件的最后一行是&#123;&#125;'.format(data[-1].decode('utf-8'))) break offs*=2 循环文件的推荐方式 123# 一行一行的获取for i in f: print(i) 三.迭代器协议林海峰博客 1.迭代器协议迭代器协议：对象必须提供一个next方法，执行该方法要么返回迭代器中的下一项，要么就引起一个Stopiteration异常，以终止迭代（只能往后，不能往前） 可迭代对象：实现了迭代器协议的对象（实现方法：对象内部定义一个__iter__()方法） 迭代器运行 12next(t)t.__next__() 2.for循环机制for循环的工作原理1：执行in后对象的dic.__iter__()方法，得到一个迭代器对象iter_dic2: 执行next(iter_dic),将得到的值赋值给k,然后执行循环体代码3: 重复过程2，直到捕捉到异常StopIteration,结束循环 3.生成器和列表解析生成器只能遍历一次 只要函数内部包含有yield关键字，那么函数名()的到的结果就是生成器，并且不会执行函数内部代码 生成器自动实现了可迭代协议，不用调用__iter__()方法 三元表达式： 1'xx' if name =='xuexuan' else 'yy' 列表解析(会生成列表，会占用内存) 1l = [i for i in range(10) if i &gt;5] 生成器表达式(节省内存) 1l = (i for i in range(10)) sum参数中的加入生成器不需要小括号 yield的作用： 1) 相当于return控制函数的返回值，x = yield num 2）接受send传过来的值 x = yield test().send(value) 3）函数中有yield，则调用func()不会执行函数中的内容，使用next() 四、装饰器本质就是函数，功能是为其他函数添加附加功能 装饰器 = 高阶函数 + 函数嵌套 + 闭包 1234def func2(func1): def wrapper(*args,**kwargs): return func1(*args,**kwargs) return wrapper @func2相当于 func1 = func2(func1) 带参数的装饰器，外面添加一层 123456def func3(para): def func2(func1): def wrapper(*args,**kwargs): func1(*args,**kwargs) return wrapper return func2 1.原则（1）不修改被修饰函数的运行方式（2）不修改被修饰函数的源代码 *解压序列1234l = [10,15,45,8,78,687,9,87987,987,78,7]a,*_,c = l # *_去掉中间的元素a,*b,c = l # 将中间的元素储存在b中a,b = b,a # 交换两个变量 五、模块http://www.cnblogs.com/yuanchenqi/articles/5732581.html tips(1) from a import b 会执行a中所有的语句(2) sys path获取 import的路径(3) input()接受str，eval()取出(4) os.rename(xx.bak)备份(5) tag（执行标记）的用法(6) from a import 不推荐(7) 程序入口一般bin.py(8) main.py:逻辑相关函数(9)from a import 不会导入下划线开头的属性 临时修改环境变量，sys.path.append() 1.内置模块time,sys等模块是C语言实现的，嵌入到python解释器中，调用时一定会有限调用。 1.1 time模块12345678910111213141516171819202122#时间戳time.time() #1970年1月1日0点至今的秒数，用于计时#结构化时间time.localtime() #返回结构化时间（当地时间）time.localtime().tm_year #返回年份（tm_mon:月,tm_wday:星期，tm_hour:小时等）time.gmtime() #返回结构化时间（0时区的时间）#字符串时间#结构化时间转化为时间戳time.mktime(time.localtime())#结构化时间转化为字符串时间time.strftime(\"%Y-%m-%d %X\",time.localtime()) #%X为时间#字符串时间转成结构化时间time.strptime('2016:12:24:17:50:36','%Y:%m:%d:%X')#直接给定直观的时间time.asctime() #结构化时间转化为字符串时间time.ctime() #时间戳转换为字符串时间time.sleep() 12import datetimedatetime.datetime.now() # year-month-day h:m:s 1.2 random模块12345678randomprint(random.random())#(0,1)----floatprint(random.randint(1,3)) #[1,3]print(random.randrange(1,3)) #[1,3) -- intprint(random.choice([1,'23',[4,5]]))#23print(random.sample([1,'23',[4,5]],2))#[[4, 5], '23']print(random.uniform(1,3)) #1.927109612082716print(random.shuffle([123,4,5234,5])) #洗牌 1.3 os模块os模块只能删除空文件夹，不能删除非空文件夹 删除文件用os.remove() 12345678910111213141516171819202122232425262728293031os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径os.getpid() 获得进程的进程idos.getppid() 获得父进程的进程idos.chdir(\"dirname\") 改变当前脚本工作目录；相当于shell下cdos.curdir 返回当前目录: ('.')os.pardir 获取当前目录的父目录字符串名：('..')os.makedirs('dirname1/dirname2') 可生成多层递归目录os.removedirs('dirname1') 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推os.mkdir('dirname') 生成单级目录；相当于shell中mkdir dirnameos.rmdir('dirname') 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirnameos.listdir('dirname') 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印os.remove() 删除一个文件os.rename(\"oldname\",\"newname\") 重命名文件/目录os.stat('path/filename') #获取文件/目录信息 st_atime上一次查看时间 st_mtime上一次修改时间，st_ctime创建时间os.sep 输出操作系统特定的路径分隔符，win下为\"\\\\\",Linux下为\"/\"os.linesep 输出当前平台使用的行终止符，win下为\"\\r\\n\",Linux下为\"\\n\"os.pathsep 输出用于分割文件路径的字符串 win下为;,Linux下为:os.name 输出字符串指示当前使用平台。win-&gt;'nt'; Linux-&gt;'posix'os.system(\"bash command\") 运行shell命令，直接显示 (推荐使用：subprocess模块)os.environ 获取系统环境变量os.path.abspath(path) 返回path规范化的绝对路径os.path.split(path) 将path分割成目录和文件名二元组返回os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素os.path.exists(path) 如果path存在，返回True；如果path不存在，返回Falseos.path.isabs(path) 如果path是绝对路径，返回Trueos.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回Falseos.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回Falseos.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略os.path.getatime(path) 返回path所指向的文件或者目录的最后存取时间os.path.getmtime(path) 返回path所指向的文件或者目录的最后修改时间 1.4 sys模块1234567sys.argv 命令行参数List，第一个元素是程序本身路径（文件名）sys.exit(n) 退出程序，正常退出时exit(0)sys.version 获取Python解释程序的版本信息sys.maxint 最大的Int值sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值sys.platform 返回操作系统平台名称sys.stdout.write('#') 向屏幕显示相应的内容 进度条 12sys.stdout.write(&#39;#&#39;) #写入缓存sys.stdout.flush() #将缓存中的文件显示在屏幕 1.5 Json&amp;Pickel json可以进行任何语言间的数据交换，将变量改变为字符串。最多储存到函数级别 只要是js字符串就可以被loads，不一定需要dump Pickle写入文件需要wb模式， python中对象依托于类存在，pickle load时必须有相应的类才能load 序列化 我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。 序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 json 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下： 12345678910111213141516#----------------------------序列化import json dic=&#123;'name':'alvin','age':23,'sex':'male'&#125;print(type(dic))#&lt;class 'dict'&gt; j=json.dumps(dic)print(type(j))#&lt;class 'str'&gt; f=open('序列化对象','w')f.write(j) #-------------------等价于json.dump(dic,f)f.close()#-----------------------------反序列化&lt;br&gt;import jsonf=open('序列化对象')data=json.loads(f.read())# 等价于data=json.load(f) Pickle与json的用法完全相同 Pickle是python特有的，支持的数据类型更多。 Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。 1.5 shelveopen函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型 1234567891011import shelvef &#x3D; shelve.open(r&#39;shelve.txt&#39;)# f[&#39;stu1_info&#39;]&#x3D;&#123;&#39;name&#39;:&#39;alex&#39;,&#39;age&#39;:&#39;18&#39;&#125;# f[&#39;stu2_info&#39;]&#x3D;&#123;&#39;name&#39;:&#39;alvin&#39;,&#39;age&#39;:&#39;20&#39;&#125;# f[&#39;school_info&#39;]&#x3D;&#123;&#39;website&#39;:&#39;oldboyedu.com&#39;,&#39;city&#39;:&#39;beijing&#39;&#125;### f.close()print&#96;&#96;(f.get(&#96;&#96;&#39;stu_info&#39;&#96;&#96;)[&#96;&#96;&#39;age&#39;&#96;&#96;]) 1.6 XML模块xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。 1234567891011121314151617181920212223&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;data&gt; &lt;country name&#x3D;&quot;Liechtenstein&quot;&gt; &lt;rank updated&#x3D;&quot;yes&quot;&gt;2&lt;&#x2F;rank&gt; &lt;year&gt;2008&lt;&#x2F;year&gt; &lt;gdppc&gt;141100&lt;&#x2F;gdppc&gt; &lt;neighbor name&#x3D;&quot;Austria&quot; direction&#x3D;&quot;E&quot;&#x2F;&gt; &lt;neighbor name&#x3D;&quot;Switzerland&quot; direction&#x3D;&quot;W&quot;&#x2F;&gt; &lt;&#x2F;country&gt; &lt;country name&#x3D;&quot;Singapore&quot;&gt; &lt;rank updated&#x3D;&quot;yes&quot;&gt;5&lt;&#x2F;rank&gt; &lt;year&gt;2011&lt;&#x2F;year&gt; &lt;gdppc&gt;59900&lt;&#x2F;gdppc&gt; &lt;neighbor name&#x3D;&quot;Malaysia&quot; direction&#x3D;&quot;N&quot;&#x2F;&gt; &lt;&#x2F;country&gt; &lt;country name&#x3D;&quot;Panama&quot;&gt; &lt;rank updated&#x3D;&quot;yes&quot;&gt;69&lt;&#x2F;rank&gt; &lt;year&gt;2011&lt;&#x2F;year&gt; &lt;gdppc&gt;13600&lt;&#x2F;gdppc&gt; &lt;neighbor name&#x3D;&quot;Costa Rica&quot; direction&#x3D;&quot;W&quot;&#x2F;&gt; &lt;neighbor name&#x3D;&quot;Colombia&quot; direction&#x3D;&quot;E&quot;&#x2F;&gt; &lt;&#x2F;country&gt;&lt;&#x2F;data&gt; 操作xml 12345678910111213141516171819202122232425262728293031323334353637import xml.etree.ElementTree as ET tree = ET.parse(\"xmltest.xml\") #解析root = tree.getroot()print(root.tag) #遍历xml文档for child in root: print(child.tag, child.attrib) for i in child: print(i.tag,i.text) #只遍历year 节点for node in root.iter('year'): print(node.tag,node.text)#---------------------------------------import xml.etree.ElementTree as ET tree = ET.parse(\"xmltest.xml\")root = tree.getroot() #修改for node in root.iter('year'): new_year = int(node.text) + 1 node.text = str(new_year) #修改文本 node.set(\"updated\",\"yes\") #设置属性tree.write(\"xmltest.xml\") #删除nodefor country in root.findall('country'): rank = int(country.find('rank').text) if rank &gt; 50: root.remove(country) tree.write('output.xml') 创建xml文件 12345678910111213141516import xml.etree.ElementTree as ET new_xml = ET.Element(\"namelist\")name = ET.SubElement(new_xml,\"name\",attrib=&#123;\"enrolled\":\"yes\"&#125;)age = ET.SubElement(name,\"age\",attrib=&#123;\"checked\":\"no\"&#125;)sex = ET.SubElement(name,\"sex\")sex.text = '33'name2 = ET.SubElement(new_xml,\"name\",attrib=&#123;\"enrolled\":\"no\"&#125;)age = ET.SubElement(name2,\"age\")age.text = '19' et = ET.ElementTree(new_xml) #生成文档对象et.write(\"test.xml\", encoding=\"utf-8\",xml_declaration=True) ET.dump(new_xml) #打印生成的格式 1.7 re模块正则表达式 字符匹配（普通字符，元字符）： 1 普通字符：大多数字符和字母都会和自身匹配 >&gt;&gt; re.findall(‘alvin’,’yuanaleSxalexwupeiqi’) [‘alvin’] 2 元字符：. ^ $ * + ? { } [ ] | ( ) \\ 12345678910111213141516171819202122232425262728293031323334353637383940414243. 通配符（一个字符）^ 以xxx开头$ 以xxx结尾*+?&#123;&#125;* 按照紧挨的字符重复 0~∞次(注意是0次开始)+ 按照紧挨的字符重复 1~∞次(注意是1次开始)? 按照紧挨的字符重复 0或1次&#123;&#125; 按照紧挨的字符重复 &#123;0,&#125;:* &#123;1,&#125;:+*+?都是贪婪匹配，后面加?为变为惰性匹配元字符之转义符\\反斜杠后边跟元字符去除特殊功能,比如\\.反斜杠后边跟普通字符实现特殊功能,比如\\d\\d 匹配任何十进制数；它相当于类 [0-9]。\\D 匹配任何非数字字符；它相当于类 [^0-9]。\\s 匹配任何空白字符；它相当于类 [ \\t\\n\\r\\f\\v]。\\S 匹配任何非空白字符；它相当于类 [^ \\t\\n\\r\\f\\v]。\\w 匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。\\W 匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]\\b 匹配一个特殊字符边界，比如空格 ，&amp;，＃等在“”中使用转义字符时，需要进行r&quot;&quot;.python str --&gt; python解释器---&gt;re层&quot;&quot;进行匹配#-----------------------------eg1:import reret&#x3D;re.findall(&#39;c\\l&#39;,&#39;abc\\le&#39;)print(ret)#[]ret&#x3D;re.findall(&#39;c\\\\l&#39;,&#39;abc\\le&#39;)print(ret)#[]ret&#x3D;re.findall(&#39;c\\\\\\\\l&#39;,&#39;abc\\le&#39;)print(ret)#[&#39;c\\\\l&#39;]ret&#x3D;re.findall(r&#39;c\\\\l&#39;,&#39;abc\\le&#39;)print(ret)#[&#39;c\\\\l&#39;] #-----------------------------eg2:#之所以选择\\b是因为\\b在ASCII表中是有意义的m &#x3D; re.findall(&#39;\\bblow&#39;, &#39;blow&#39;)print(m)m &#x3D; re.findall(r&#39;\\bblow&#39;, &#39;blow&#39;)print(m) [] 字符集 123456789101112131415161718192021#--------------------------------------------字符集[]ret=re.findall('a[bc]d','acd')print(ret)#['acd'] ret=re.findall('[a-z]','acd')print(ret)#['a', 'c', 'd']# []没有特殊符号ret=re.findall('[.*+]','a.cd+')print(ret)#['.', '+'] #在字符集里有功能的符号: - ^ \\# - 范围ret=re.findall('[1-9]','45dha3')print(ret)#['4', '5', '3']# ^ 非ret=re.findall('[^ab]','45bdha3')print(ret)#['4', '5', 'd', 'h', '3'] ret=re.findall('[\\d]','45bdha3')print(ret)#['4', '5', '3'] | 或 12ret=re.search('(ab)|\\d','rabhdg8sd')print(ret.group())#ab （）分组 当匹配中有分组时，findall优先返回分组中的匹配机制， 如果要返回所有的匹配结果，使用(?:xxxxx) 12345678m = re.findall(r'(ad)+', 'add')print(m) m = re.findall('(?:abc)+','abcabcabc') #abcabcabc ret=re.search('(?P&lt;id&gt;\\d&#123;2&#125;)/(?P&lt;name&gt;\\w&#123;3&#125;)','23/com')print(ret.group())#23/comprint(ret.group('id'))#23 re下的常用方法 123456789101112131415161718192021222324252627282930import re#1re.findall('a','alvin yuan') #返回所有满足匹配条件的结果,放在列表里#2re.search('a','alvin yuan').group() #函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。#3re.match('a','abc').group() #同search,不过尽在字符串开始处进行匹配，返回的是一个对象#4ret=re.split('[ab]','abcd') #先按'a'分割得到''和'bcd',在对''和'bcd'分别按'b'分割print(ret)#['', '', 'cd'] #5 替换ret=re.sub('\\d','abc','alvin5yuan6',1) #匹配的次数print(ret)#alvinabcyuan6ret=re.subn('\\d','abc','alvin5yuan6') #返回元组，一为结果，二为匹配的次数print(ret)#('alvinabcyuanabc', 2) #6 模板obj=re.compile('\\d&#123;3&#125;')ret=obj.search('abc123eeee')print(ret.group())#123import reret=re.finditer('\\d','ds3sy4784a')print(ret) #&lt;callable_iterator object at 0x10195f940&gt; print(next(ret).group())print(next(ret).group()) 1.8 logging模块1234567import logging # 级别从低到高logging.debug('debug message') logging.info('info message') logging.warning('warning message') logging.error('error message') logging.critical('critical message') 默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET），默认的日志格式为日志级别：Logger名称：用户输出消息。 二 灵活配置日志级别，日志格式，输出位置 123456789101112import logging logging.basicConfig(level&#x3D;logging.DEBUG, format&#x3D;&#39;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#39;, datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S&#39;, filename&#x3D;&#39;&#x2F;tmp&#x2F;test.log&#39;, filemode&#x3D;&#39;w&#39;) logging.debug(&#39;debug message&#39;) logging.info(&#39;info message&#39;) logging.warning(&#39;warning message&#39;) logging.error(&#39;error message&#39;) logging.critical(&#39;critical message&#39;) 在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。format：指定handler使用的日志显示格式。datefmt：指定日期时间格式。level：设置rootlogger（后边会讲解具体概念）的日志级别stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。 format参数中可能用到的格式化串：%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名%(funcName)s 调用日志输出函数的函数名%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s用户输出的消息 三 logger对象 ​ 上述几个例子中我们了解到了logging.debug()、logging.info()、logging.warning()、logging.error()、logging.critical()（分别用以记录不同级别的日志信息），logging.basicConfig()（用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到root logger（根Logger）中）这几个logging模块级别的函数，另外还有一个模块级别的函数是logging.getLogger([name])（返回一个logger对象，如果没有指定名字将返回root logger） ​ 先看一个最简单的过程： 12345678910111213141516171819202122import logginglogger = logging.getLogger()# 创建一个handler，用于写入日志文件fh = logging.FileHandler('test.log')# 再创建一个handler，用于输出到控制台ch = logging.StreamHandler()formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')fh.setFormatter(formatter)ch.setFormatter(formatter)logger.addHandler(fh) #logger对象可以添加多个fh和ch对象logger.addHandler(ch)logger.debug('logger debug message')logger.info('logger info message')logger.warning('logger warning message')logger.error('logger error message')logger.critical('logger critical message') 四、两个logger对象 123456789101112131415161718192021222324##################################################logger1 = logging.getLogger('mylogger')logger1.setLevel(logging.DEBUG)logger2 = logging.getLogger('mylogger') #与logger名称相同，为同一个对象logger2.setLevel(logging.INFO)logger1.addHandler(fh)logger1.addHandler(ch)logger2.addHandler(fh)logger2.addHandler(ch)logger1.debug('logger1 debug message')logger1.info('logger1 info message')logger1.warning('logger1 warning message')logger1.error('logger1 error message')logger1.critical('logger1 critical message') logger2.debug('logger2 debug message')logger2.info('logger2 info message')logger2.warning('logger2 warning message')logger2.error('logger2 error message')logger2.critical('logger2 critical message') (1)我们明明通过logger1.setLevel(logging.DEBUG)将logger1的日志级别设置为了DEBUG，为何显示的时候没有显示出DEBUG级别的日志信息，而是从INFO级别的日志开始显示呢？ ​ 原来logger1和logger2对应的是同一个Logger实例，只要logging.getLogger（name）中名称参数name相同则返回的Logger实例就是同一个，且仅有一个，也即name与Logger实例一一对应。在logger2实例中通过logger2.setLevel(logging.INFO)设置mylogger的日志级别为logging.INFO，所以最后logger1的输出遵从了后来设置的日志级别。 (2)为什么logger1、logger2对应的每个输出分别显示两次?这是因为我们通过logger = logging.getLogger()显示的创建了root Logger，而logger1 = logging.getLogger(‘mylogger’)创建了root Logger的孩子(root.)mylogger,logger2同样。而孩子,孙子，重孙……既会将消息分发给他的handler进行处理也会传递给所有的祖先Logger处理。 1.9 configparser模块好多软件的常见文档格式如下： 123456789101112[DEFAULT]ServerAliveInterval &#x3D; 45Compression &#x3D; yesCompressionLevel &#x3D; 9ForwardX11 &#x3D; yes [bitbucket.org]User &#x3D; hg [topsecret.server.com]Port &#x3D; 50022ForwardX11 &#x3D; no 如果想用python生成一个这样的文档怎么做呢？ 12345678910111213141516import configparser config &#x3D; configparser.ConfigParser()config[&quot;DEFAULT&quot;] &#x3D; &#123;&#39;ServerAliveInterval&#39;: &#39;45&#39;, &#39;Compression&#39;: &#39;yes&#39;, &#39;CompressionLevel&#39;: &#39;9&#39;&#125; config[&#39;bitbucket.org&#39;] &#x3D; &#123;&#125;config[&#39;bitbucket.org&#39;][&#39;User&#39;] &#x3D; &#39;hg&#39;config[&#39;topsecret.server.com&#39;] &#x3D; &#123;&#125;topsecret &#x3D; config[&#39;topsecret.server.com&#39;]topsecret[&#39;Host Port&#39;] &#x3D; &#39;50022&#39; # mutates the parsertopsecret[&#39;ForwardX11&#39;] &#x3D; &#39;no&#39; # same hereconfig[&#39;DEFAULT&#39;][&#39;ForwardX11&#39;] &#x3D; &#39;yes&#39;&lt;br&gt;with open(&#39;example.ini&#39;, &#39;w&#39;) as configfile: config.write(configfile) config section名称不区分大小写 1234567891011121314151617181920212223242526272829303132333435363738import configparserconfig = configparser.ConfigParser()#---------------------------------------------查print(config.sections()) #[]config.read('example.ini')print(config.sections()) #['bitbucket.org', 'topsecret.server.com']print('bytebong.com' in config)# Falseprint(config['bitbucket.org']['User']) # hgprint(config['DEFAULT']['Compression']) #yesprint(config['topsecret.server.com']['ForwardX11']) #nofor key in config['bitbucket.org']: print(key)# user# serveraliveinterval# compression# compressionlevel# forwardx11print(config.options('bitbucket.org'))#['user', 'serveraliveinterval', 'compression', 'compressionlevel', 'forwardx11']print(config.items('bitbucket.org')) #[('serveraliveinterval', '45'), ('compression', 'yes'), ('compressionlevel', '9'), ('forwardx11', 'yes'), ('user', 'hg')]print(config.get('bitbucket.org','compression'))#yes#---------------------------------------------删,改,增(config.write(open('i.cfg', \"w\")))config.add_section('yuan')config.remove_section('topsecret.server.com')config.remove_option('bitbucket.org','user')config.set('bitbucket.org','k1','11111')config.write(open('i.cfg', \"w\")) 1.10 hashlib模块摘要算法：md5，sha256等。只能将明文变为密文，不是可逆操作。 密码操作将所有的明文都变成密文在进行比较 1234567891011121314import hashlib m=hashlib.md5()# m=hashlib.sha256() m.update('hello'.encode('utf8'))print(m.hexdigest()) #5d41402abc4b2a76b9719d911017c592 m.update('alvin'.encode('utf8')) print(m.hexdigest()) #92a7e713c30abbb0319fa07da2a5c4af m2=hashlib.md5()m2.update('helloalvin'.encode('utf8'))print(m2.hexdigest()) #92a7e713c30abbb0319fa07da2a5c4af hash 1234567import hashlib # ######## 256 ######## hash = hashlib.sha256('898oaFs09f'.encode('utf8'))hash.update('alvin'.encode('utf8'))print (hash.hexdigest())#e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7 不同对象的区分 1234567891011import hashlibimport timedef create_md5(): m = hashlib.md5() m.update(str(time.time()).encode(utf-8)) return m.hexdigest()class school: def __init__(self): self.id = create_md5() # 通过id区分 #通过pickle保存到文件 1.11 subprocess模块我们需要调用系统的命令的时候，最先考虑的os模块。用os.system()和os.popen()来进行操作。但是这两个命令过于简单，不能完成一些复杂的操作，如给运行的命令提供输入或者读取命令的输出，判断该命令的运行状态，管理多个命令的并行等等。这时subprocess中的Popen命令就能有效的完成我们需要的操作。 ​ subprocess模块允许一个进程创建一个新的子进程，通过管道连接到子进程的stdin/stdout/stderr，获取子进程的返回值等操作。 这个模块一个类：Popen。 1&#96;#Popen它的构造函数如下：&#96; &#96;subprocess.Popen(args, bufsize&#96;&#96;&#x3D;&#96;&#96;0&#96;&#96;, executable&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;, stdin&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;, stdout&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;,stderr&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;, preexec_fn&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;, close_fds&#96;&#96;&#x3D;&#96;&#96;False&#96;&#96;, shell&#96;&#96;&#x3D;&#96;&#96;False&#96;&#96;,&lt;br&gt; &#96; 12345subprocess.Popen('dir',shell=True) #shell：命令解释器res = subprocess.Popen('dir',shell=True)res.stdout.read().decode() stdout--&gt;输出给管道管道中对象只能取一次 1234567891011res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stderr&#x3D;subprocess.PIPE, stdout&#x3D;subprocess.PIPE, stdin&#x3D;subprocess.PIPE)err &#x3D; res.stderr.read()if err:msg &#x3D; errelse:msg &#x3D; res.stdout.read()print(msg.decode(&#39;utf-8&#39;))if msg:self.send_bytes(msg)else:self.send_msg(&#39;No return msg.&#39;) 简单命令： 123456789101112131415161718import subprocess a=subprocess.Popen('ls')# 创建一个新的进程,与主进程不同步 print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;',a)#a是Popen的一个实例对象 '''&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;subprocess.Popen object at 0x10185f860&gt;__init__.py__pycache__log.pymain.py ''' # subprocess.Popen('ls -l',shell=True) # subprocess.Popen(['ls','-l']) subprocess.PIPE 在创建Popen对象时，subprocess.PIPE可以初始化stdin, stdout或stderr参数。表示与子进程通信的标准流。 123456import subprocess # subprocess.Popen('ls')p=subprocess.Popen('ls',stdout=subprocess.PIPE)#结果跑哪去啦?print(p.stdout.read())#这这呢:b'__pycache__\\nhello.py\\nok.py\\nweb\\n' 这是因为subprocess创建了子进程，结果本在子进程中，if 想要执行结果转到主进程中，就得需要一个管道，即 ： stdout=subprocess.PIPE subprocess.STDOUT 创建Popen对象时，用于初始化stderr参数，表示将错误通过标准输出流输出。 Popen的方法 1234567891011121314151617181920212223242526272829303132Popen.poll() 用于检查子进程是否已经结束。设置并返回returncode属性。Popen.wait() 等待子进程结束。设置并返回returncode属性。Popen.communicate(input&#x3D;None)与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。 Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如 果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。Popen.send_signal(signal) 向子进程发送信号。Popen.terminate()停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。Popen.kill()杀死子进程。Popen.stdin 如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。Popen.stdout 如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。Popen.stderr 如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。Popen.pid 获取子进程的进程ID。Popen.returncode 获取进程的返回值。如果进程还没有结束，返回None。 supprocess模块的工具函数 12345678910111213supprocess模块提供了一些函数，方便我们用于创建进程来实现一些简单的功能。 subprocess.call(*popenargs, **kwargs)运行命令。该函数将一直等待到子进程运行结束，并返回进程的returncode。如果子进程不需要进行交 互,就可以使用该函数来创建。 subprocess.check_call(*popenargs, **kwargs)与subprocess.call(*popenargs, **kwargs)功能一样，只是如果子进程返回的returncode不为0的话，将触发CalledProcessError异常。在异常对象中，包 括进程的returncode信息。 check_output(*popenargs, **kwargs)与call()方法类似，以byte string的方式返回子进程的输出，如果子进程的返回值不是0，它抛出CalledProcessError异常，这个异常中的returncode包含返回码，output属性包含已有的输出。 getstatusoutput(cmd)/getoutput(cmd)这两个函数仅仅在Unix下可用，它们在shell中执行指定的命令cmd，前者返回(status, output)，后者返回output。其中，这里的output包括子进程的stdout和stderr。 1234567891011121314151617181920212223242526272829303132333435363738394041import subprocess#1# subprocess.call('ls',shell=True)'''hello.pyok.pyweb'''# data=subprocess.call('ls',shell=True)# print(data)'''hello.pyok.pyweb'''#2# subprocess.check_call('ls',shell=True)'''hello.pyok.pyweb'''# data=subprocess.check_call('ls',shell=True)# print(data)'''hello.pyok.pyweb'''# 两个函数区别:只是如果子进程返回的returncode不为0的话，将触发CalledProcessError异常#3# subprocess.check_output('ls')#无结果# data=subprocess.check_output('ls')# print(data) #b'hello.py\\nok.py\\nweb\\n' 1.12 struct 模块123import structl = struct.pack('i',123) #将数字打包为4字节struct.unpack('i',l) #返回元组 1.13 partial模块为函数提供参数 1234567def test(x,y): return x+yimport partialfunc = partial(test,1)func(3) #4 1.14 optparse模块1234567891011import optparsex = optparse.OptionParser()x.add_option('-s','--s',dest='server')x.add_option('-P','--port',dest='port')options,args = x.parse_args()# options为形似字典的对象，储存绑定的参数# args为列表，储存盈余的信息options.server #返回server对应的参数 1.15 uuid12import uuid uuid.uuid4() 生成随机数 1.16 concurrent1234567891011121314151617from concurrent.futures import ThreadPoolExectorimport requestdef task(url): response &#x3D; request.get(url) print(response) return responsedef func(future,*args,**kwargs): future 默认为task的返回值pool &#x3D; ThreadPoolExector(5)v &#x3D; pool.submit(task,url)v.add_done_callback(func,args)concurrent有参数xx 1.XX iter的参数12345678l = [12,41,25,5]def test(): return l.pop()iiii = iter(test,41) 41为终止参数iiii.__next__()iiii.__next__()iiii.__next__() 返回41时报错iterstop 六、面向对象面向对象https://www.cnblogs.com/linhaifeng/articles/6182264.html &lt;classname&gt;.__dict__ 返回属性字典 函数的输入输出要分开，类中函数只包含逻辑 类中变量调用 点调用：在实例属性—》类属性中寻找 非点调用：在类外寻找 静态属性 12345678@property将函数变为静态属性，调用时直接点调用静态属性即可class yy: @property def test(self): return xxa = yy()print(a.test) 类方法 与类绑定，不与实例绑定 不需要实例化类，可以直接使用 类方法不能调用实例属性，即不能使用self.xxx 1234567class yy: tmp = 1 @classmethod def test(cls): ## cls为类名 return cls.tmpprint(yy.test()) 静态方法 不与类绑定，也不与实例绑定，只是类的工具包 实例无法调用 123456class yy: @staticmethod def test(a): return ay.a 组合 软件重用的重要方式除了继承之外还有另外一种方式，即：组合 组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合 类与类之间的关联 123456789101112131415161718192021222324252627class School: def __init__(self,name,addr): self.name=name self.addr=addr def zhao_sheng(self): print('%s 正在招生' %self.name)class Course: def __init__(self,name,price,period,school): self.name=name self.price=price self.period=period self.school=schools1=School('oldboy','北京')s2=School('oldboy','南京')s3=School('oldboy','东京')# c1=Course('linux',10,'1h','oldboy 北京')c1=Course('linux',10,'1h',s1)print(c1.__dict__)print(c1.school.name)print(s1) 1. 三大特性继承、封装、多态 1.1继承继承与派生 当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好。 当类之间有很多相通的功能，提取这些共同的功能做成基类，用继承比较好。 继承有两种含义 含义一：继承基类的方法，并且做出自己的改变或拓展（代码重用） —-》有害，代码之间存在耦合含义二(接口继承)：声明某个子类兼容于某基类，定义一个接口类（父类中定义函数，但不实现，由子类实现，import abs, @abc.abstractmethod），子类继承接口类，并在实现接口中定义的方法 在python中根本就没有一个叫做interface的关键字，如果非要去模仿接口的概念可以借助第三方模块：http://pypi.python.org/pypi/zope.interface 抽象类 与java一样，python也有抽象类的概念但是同样需要借助模块实现，抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化 抽象类与接口 抽象类的本质还是类，指的是一组类的相似性，包括数据属性（如all_type）和函数属性（如read、write），而接口只强调函数属性的相似性。 抽象类是一个介于类和接口直接的一个概念，同时具备类和接口的部分特性，可以用来实现归一化设计 接口继承 1234567891011121314151617181920212223242526272829303132333435import abcclass All_file(metaclass=abc.ABCMeta): @abc.abstractmethod ###接口类 def read(self): pass @abc.abstractmethod def write(self): passclass Disk(All_file): def read(self): print('disk read') def write(self): print('disk write')class Cdrom(All_file): def read(self): print('cdrom read') def write(self): print('cdrom write')class Mem(All_file): def read(self): print('mem read') def write(self): print('mem write')#m1=Mem()m1.read()m1.write() 归一化设计 接口继承实质上要求“作出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理是吸纳了特定接口的所有对象”—-这在程序设计上叫做归一化。 派生 当然子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了。 继承顺序 在Java和C#中子类只能继承一个父类，而Python中子类可以同时继承多个父类，如A(B,C,D) 如果继承关系为非菱形结构，则会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性 如果继承关系为菱形结构，那么属性的查找方式有两种，分别是：深度优先和广度优先 1234567891011121314151617181920212223242526272829303132class A(object): def test(self): print('from A')class B(A): def test(self): print('from B')class C(A): def test(self): print('from C')class D(B): def test(self): print('from D')class E(C): def test(self): print('from E')class F(D,E): # def test(self): # print('from F') passf1=F()f1.test()print(F.__mro__) #只有新式才有这个属性可以查看线性列表，经典类没有这个属性#新式类继承顺序:F-&gt;D-&gt;B-&gt;E-&gt;C-&gt;A#经典类继承顺序:F-&gt;D-&gt;B-&gt;A-&gt;E-&gt;C#python3中统一都是新式类#pyhon2中才分新式类与经典类 继承原理（python如何实现的继承） python到底是如何实现继承的，对于你定义的每一个类，python会计算出一个方法解析顺序(MRO)列表，这个MRO列表就是一个简单的所有基类的线性顺序列表，例如 12&gt;&gt;&gt; F.mro() #等同于F.__mro__[&lt;class &#39;__main__.F&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.E&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;] 为了实现继承,python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:1.子类会先于父类被检查2.多个父类会根据它们在列表中的顺序被检查3.如果对下一个类存在两个合法的选择,选择第一个父类 1.2 子类中调用父类方法需要先执行_init_()方法一：指名道姓，即父类名.父类方法() 12345678910111213141516171819202122232425#_*_coding:utf-8_*___author__ = 'Linhaifeng'class Vehicle: #定义交通工具类 Country='China' def __init__(self,name,speed,load,power): self.name=name self.speed=speed self.load=load self.power=power def run(self): print('开动啦...')class Subway(Vehicle): #地铁 def __init__(self,name,speed,load,power,line): Vehicle.__init__(self,name,speed,load,power) self.line=line def run(self): print('地铁%s号线欢迎您' %self.line) Vehicle.run(self)line13=Subway('中国地铁','180m/s','1000人/箱','电',13)line13.run() 方法二：super() 1234567891011121314151617181920212223class Vehicle: #定义交通工具类 Country='China' def __init__(self,name,speed,load,power): self.name=name self.speed=speed self.load=load self.power=power def run(self): print('开动啦...')class Subway(Vehicle): #地铁 def __init__(self,name,speed,load,power,line): #super(Subway,self) 就相当于实例本身 在python3中super()等同于super(Subway,self) super().__init__(name,speed,load,power) self.line=line def run(self): print('地铁%s号线欢迎您' %self.line) super(Subway,self).run()line13=Subway('中国地铁','180m/s','1000人/箱','电',13)line13.run() 二者使用哪一种都可以，但最好不要混合使用 即使没有直接继承关系，super仍然会按照mro继续往后查找指名道姓与super()的区别 1.2 多态http://www.cnblogs.com/linhaifeng/articles/7340687.html 定义在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。 比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同 1.3 封装http://www.cnblogs.com/linhaifeng/articles/7340801.html x.python OOP的常用术语抽象/实现 抽象指对现实世界问题和实体的本质表现,行为和特征建模,建立一个相关的子集,可以用于 绘程序结构,从而实现这种模型。抽象不仅包括这种模型的数据属性,还定义了这些数据的接口。 对某种抽象的实现就是对此数据及与之相关接口的现实化(realization)。现实化这个过程对于客户 程序应当是透明而且无关的。 封装/接口 封装描述了对数据/信息进行隐藏的观念,它对数据属性提供接口和访问函数。通过任何客户端直接对数据的访问,无视接口,与封装性都是背道而驰的,除非程序员允许这些操作。作为实现的 一部分,客户端根本就不需要知道在封装之后,数据属性是如何组织的。在Python中,所有的类属性都是公开的,但名字可能被“混淆”了,以阻止未经授权的访问,但仅此而已,再没有其他预防措施了。这就需要在设计时,对数据提供相应的接口,以免客户程序通过不规范的操作来存取封装的数据属性。 注意：封装绝不是等于“把不想让别人看到、以后可能修改的东西用private隐藏起来” 真正的封装是，经过深入的思考，做出良好的抽象，给出“完整且最小”的接口，并使得内部细节可以对外透明 （注意：对外透明的意思是，外部调用者可以顺利的得到自己想要的任何功能，完全意识不到内部细节的存在） 合成 合成扩充了对类的 述,使得多个不同的类合成为一个大的类,来解决现实问题。合成 述了 一个异常复杂的系统,比如一个类由其它类组成,更小的组件也可能是其它的类,数据属性及行为, 所有这些合在一起,彼此是“有一个”的关系。 派生/继承/继承结构 派生描述了子类衍生出新的特性,新类保留已存类类型中所有需要的数据和行为,但允许修改或者其它的自定义操作,都不会修改原类的定义。继承描述了子类属性从祖先类继承这样一种方式继承结构表示多“代”派生,可以述成一个“族谱”,连续的子类,与祖先类都有关系。 泛化/特化 基于继承泛化表示所有子类与其父类及祖先类有一样的特点。特化描述所有子类的自定义,也就是,什么属性让它与其祖先类不同。 多态与多态性 多态指的是同一种事物的多种状态：水这种事物有多种不同的状态：冰，水蒸气 多态性的概念指出了对象如何通过他们共同的属性和动作来操作及访问,而不需考虑他们具体的类。 冰，水蒸气，都继承于水，它们都有一个同名的方法就是变成云，但是冰.变云(),与水蒸气.变云()是截然不同的过程，虽然调用的方法都一样 自省/反射 自省也称作反射，这个性质展示了某对象是如何在运行期取得自身信息的。如果传一个对象给你,你可以查出它有什么能力,这是一项强大的特性。如果Python不支持某种形式的自省功能,dir和type内建函数,将很难正常工作。还有那些特殊属性,像__dict__,__name__及__doc__hasattr() getattr() 1.4 面向对象进阶https://www.cnblogs.com/linhaifeng/articles/6204014.html 1.4.1动态导入模块123456module_t = __import__(m1.t) ## 无论通过点调用多少层，最后导入的实际上是m1module_t等价于 m1import importlibm = importlib.import_module(m1.t)m等价于m1.t 导入包时，会自动执行__init__.py文件 1.4.2 双下划线开头的attr方法1234567891011121314151617181920212223242526272829303132class Foo: x=1 def __init__(self,y): self.y=y def __getattr__(self, item): print('----&gt; from getattr:你找的属性不存在') def __setattr__(self, key, value): print('----&gt; from setattr') # self.key=value #这就无限递归了,你好好想想 # self.__dict__[key]=value #应该使用它 def __delattr__(self, item): print('----&gt; from delattr') # del self.item #无限递归了 self.__dict__.pop(item)#__setattr__添加/修改属性会触发它的执行f1=Foo(10)print(f1.__dict__) # 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值f1.z=3print(f1.__dict__)#__delattr__删除属性的时候会触发f1.__dict__['a']=3#我们可以直接修改属性字典,来完成添加/修改属性的操作del f1.aprint(f1.__dict__)#__getattr__只有在使用点调用属性且属性不存在的时候才会触发f1.xxxxxx 1.4.3 __getattribute__无论属性是否存在，都会触发__getattribute__当抛出AttributeError异常时，触发__getattr__ 1.4.4 授权12345678910111213141516import timeclass FileHandle: def __init__(self,filename,mode='r',encoding='utf-8'): self.file=open(filename,mode,encoding=encoding) def write(self,line): t=time.strftime('%Y-%m-%d %T') self.file.write('%s %s' %(t,line)) def __getattr__(self, item): return getattr(self.file,item)f1=FileHandle('b.txt','w+')f1.write('你好啊')f1.seek(0)print(f1.read())f1.close() 1.4.5 isinstance(obj,cls)和issubclass(sub,super)12345678910class Foo(object): passobj = Foo()isinstance(obj, Foo) #trueclass Foo(object): passclass Bar(Foo): passissubclass(Bar, Foo) #true 1.4.6 __setitem__,__getitem__,__delitem__字典（中括号）方式触发的是item操作 点操作触发的是attr操作 1234567891011121314151617181920212223class Foo: def __init__(self,name): self.name=name def __getitem__(self, item): print(self.__dict__[item]) def __setitem__(self, key, value): self.__dict__[key]=value def __delitem__(self, key): print('del obj[key]时,我执行') self.__dict__.pop(key) def __delattr__(self, item): print('del obj.key时,我执行') self.__dict__.pop(item)f1=Foo('sb')f1['age']=18 ##__setitem__f1['age1']=19 del f1.age1 del f1['age'] f1['name']='alex'print(f1.__dict__) 1.4.7 __str__,__repr__,__format__12345678910111213141516171819202122232425262728293031323334353637383940#_*_coding:utf-8_*___author__ = 'Linhaifeng'format_dict=&#123; 'nat':'&#123;obj.name&#125;-&#123;obj.addr&#125;-&#123;obj.type&#125;',#学校名-学校地址-学校类型 'tna':'&#123;obj.type&#125;:&#123;obj.name&#125;:&#123;obj.addr&#125;',#学校类型:学校名:学校地址 'tan':'&#123;obj.type&#125;/&#123;obj.addr&#125;/&#123;obj.name&#125;',#学校类型/学校地址/学校名&#125;class School: def __init__(self,name,addr,type): self.name=name self.addr=addr self.type=type def __repr__(self): return 'School(%s,%s)' %(self.name,self.addr) def __str__(self): return '(%s,%s)' %(self.name,self.addr) def __format__(self, format_spec): # if format_spec if not format_spec or format_spec not in format_dict: format_spec='nat' fmt=format_dict[format_spec] return fmt.format(obj=self)s1=School('oldboy1','北京','私立')print('from repr: ',repr(s1))print('from str: ',str(s1))print(s1)'''str函数或者print函数---&gt;obj.__str__()repr或者交互式解释器---&gt;obj.__repr__()如果__str__没有被定义,那么就会使用__repr__来代替输出注意:这俩方法的返回值必须是字符串,否则抛出异常'''print(format(s1,'nat'))print(format(s1,'tna'))print(format(s1,'tan'))print(format(s1,'asfdasdffd')) 自定义format 1234567891011121314151617181920date_dic=&#123; 'ymd':'&#123;0.year&#125;:&#123;0.month&#125;:&#123;0.day&#125;', 'dmy':'&#123;0.day&#125;/&#123;0.month&#125;/&#123;0.year&#125;', 'mdy':'&#123;0.month&#125;-&#123;0.day&#125;-&#123;0.year&#125;',&#125;class Date: def __init__(self,year,month,day): self.year=year self.month=month self.day=day def __format__(self, format_spec): if not format_spec or format_spec not in date_dic: format_spec='ymd' fmt=date_dic[format_spec] return fmt.format(self)d1=Date(2016,12,29)print(format(d1))print('&#123;:mdy&#125;'.format(d1)) 1.4.8 __slot__类的数据属性 1234567891011121314151617181920212223242526272829'''1.__slots__是什么:是一个类变量,变量值可以是列表,元组,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性)2.引子:使用点来访问属性本质就是在访问类或者对象的__dict__属性字典(类的字典是共享的,而每个实例的是独立的)3.为何使用__slots__:字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用__slots__取代实例的__dict__当你定义__slots__后,__slots__就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个字典,这跟元组或列表很类似。在__slots__中列出的属性名在内部被映射到这个数组的指定小标上。使用__slots__一个不好的地方就是我们不能再给实例添加新的属性了,只能使用在__slots__中定义的那些属性名。4.注意事项:__slots__的很多特性都依赖于普通的基于字典的实现。另外,定义了__slots__后的类不再 支持一些普通类特性了,比如多继承。大多数情况下,你应该只在那些经常被使用到 的用作数据结构的类上定义__slots__比如在程序中需要创建某个类的几百万个实例对象 。关于__slots__的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用__slots__可以达到这样的目的,但是这个并不是它的初衷。 更多的是用来作为一个内存优化工具。'''class Foo: __slots__='x'f1=Foo()f1.x=1f1.y=2#报错print(f1.__slots__) #f1不再有__dict__class Bar: __slots__=['x','y'] n=Bar()n.x,n.y=1,2n.z=3#报错__slots__使用 1.4.9 __doc__无法继承给子类 1234567class Foo: '我是描述信息' passclass Bar(Foo): passprint(Bar.__doc__) #该属性无法继承给子类 1.4.10 __module__和__class____module__表示当前操作的对象在那个模块 __class__ 表示当前操作的对象的类是什么 12345from lib.aa import Cobj = C()print obj.__module__ # 输出 lib.aa，即：输出模块print obj.__class__ # 输出 lib.aa.C，即：输出类 1.4.11 __del__析构方法，当对象在内存中被释放时，自动触发执行。 注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义__del__,如果产生的对象的同时还会向操作系统发起系统调用，即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了__del__ 123456789101112class Foo: def __del__(self): print('执行我啦')f1=Foo()del f1print('-------&gt;')#输出结果执行我啦-------&gt; 1.4.12 __call__对象后面加括号，触发执行。 注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 __call__方法的执行是由对象后加括号触发的，即：对象() 或者 类()() 12345678910class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__')obj = Foo() # 执行 __init__obj() # 执行 __call__ 1.4.13 迭代器协议12345678910111213141516171819class Foo: def __init__(self,start,stop): self.num=start self.stop=stop def __iter__(self): return self def __next__(self): if self.num &gt;= self.stop: raise StopIteration n=self.num self.num+=1 return nf=Foo(1,5)from collections import Iterable,Iteratorprint(isinstance(f,Iterator))for i in Foo(1,5): print(i) 斐波那契数列 12345678910111213141516171819202122class Fib: def __init__(self): self._a=0 self._b=1 def __iter__(self): return self def __next__(self): self._a,self._b=self._b,self._a + self._b return self._af1=Fib()print(f1.__next__())print(next(f1))print(next(f1))for i in f1: if i &gt; 100: break print('%s ' %i,end='') 1.4.14 描述符（__get__,__set__,__delete__）1 描述符是什么:描述符本质就是一个新式类,在这个新式类中,至少实现了__get__(),__set__(),__delete__()中的一个,这也被称为描述符协议__get__():调用一个属性时,触发__set__():为一个属性赋值时,触发__delete__():采用del删除属性时,触发 123456789class Foo: #在python3中Foo是新式类,它实现了三种方法,这个类就被称作一个描述符 def __get__(self, instance, owner): pass def __set__(self, instance, value): pass def __delete__(self, instance): pass定义一个描述符 2 描述符是干什么的:描述符的作用是用来代理另外一个类的属性的(必须把描述符定义成这个类的类属性，不能定义到构造函数中) 12345678910111213141516class Foo: def __get__(self, instance, owner): print('触发get') def __set__(self, instance, value): print('触发set') def __delete__(self, instance): print('触发delete')#包含这三个方法的新式类称为描述符,由这个类产生的实例进行属性的调用/赋值/删除,并不会触发这三个方法f1=Foo()f1.name='egon'f1.namedel f1.name#疑问:何时,何地,会触发这三个方法的执行引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行 描述符的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#描述符Strclass Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...')#描述符Intclass Int: def __get__(self, instance, owner): print('Int调用') def __set__(self, instance, value): print('Int设置...') def __delete__(self, instance): print('Int删除...')class People: name=Str() age=Int() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age#何地？：定义成另外一个类的类属性#何时？：且看下列演示p1=People('alex',18)#描述符Str的使用p1.namep1.name='egon'del p1.name#描述符Int的使用p1.agep1.age=18del p1.age#我们来瞅瞅到底发生了什么print(p1.__dict__)print(People.__dict__)#补充print(type(p1) == People) #type(obj)其实是查看obj是由哪个类实例化来的print(type(p1).__dict__ == People.__dict__) 3 描述符分两种一 数据描述符:至少实现了get()和set() 123451 class Foo:2 def __set__(self, instance, value):3 print(&#39;set&#39;)4 def __get__(self, instance, owner):5 print(&#39;get&#39;) 二 非数据描述符:没有实现set() 1231 class Foo:2 def __get__(self, instance, owner):3 print(&#39;get&#39;) 4 注意事项:一 描述符本身应该定义成新式类,被代理的类也应该是新式类二 必须把描述符定义成这个类的类属性，不能为定义到构造函数中三 要严格遵循该优先级,优先级由高到底分别是1.类属性2.数据描述符3.实例属性4.非数据描述符5.找不到的属性触发getattr() 类属性&gt;数据描述符 1234567891011121314151617181920212223242526272829303132#描述符Strclass Str: def __get__(self, instance, owner): print(&#39;Str调用&#39;) def __set__(self, instance, value): print(&#39;Str设置...&#39;) def __delete__(self, instance): print(&#39;Str删除...&#39;)class People: name&#x3D;Str() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name&#x3D;name self.age&#x3D;age#基于上面的演示,我们已经知道,在一个类中定义描述符它就是一个类属性,存在于类的属性字典中,而不是实例的属性字典#那既然描述符被定义成了一个类属性,直接通过类名也一定可以调用吧,没错People.name #恩,调用类属性name,本质就是在调用描述符Str,触发了__get__()People.name&#x3D;&#39;egon&#39; #那赋值呢,我去,并没有触发__set__()del People.name #赶紧试试del,我去,也没有触发__delete__()#结论:描述符对类没有作用--------&gt;傻逼到家的结论&#39;&#39;&#39;原因:描述符在使用时被定义成另外一个类的类属性,因而类属性比二次加工的描述符伪装而来的类属性有更高的优先级People.name #恩,调用类属性name,找不到就去找描述符伪装的类属性name,触发了__get__()People.name&#x3D;&#39;egon&#39; #那赋值呢,直接赋值了一个类属性,它拥有更高的优先级,相当于覆盖了描述符,肯定不会触发描述符的__set__()del People.name #同上&#39;&#39;&#39; 数据描述符&gt;实例属性1234567891011121314151617181920212223#描述符Strclass Str: def __get__(self, instance, owner): print(&#39;Str调用&#39;) def __set__(self, instance, value): print(&#39;Str设置...&#39;) def __delete__(self, instance): print(&#39;Str删除...&#39;)class People: name&#x3D;Str() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name&#x3D;name self.age&#x3D;agep1&#x3D;People(&#39;egon&#39;,18)#如果描述符是一个数据描述符(即有__get__又有__set__),那么p1.name的调用与赋值都是触发描述符的操作,于p1本身无关了,相当于覆盖了实例的属性p1.name&#x3D;&#39;egonnnnnn&#39;p1.nameprint(p1.__dict__)#实例的属性字典中没有name,因为name是一个数据描述符,优先级高于实例属性,查看&#x2F;赋值&#x2F;删除都是跟描述符有关,与实例无关了del p1.name实例属性&gt;非数据描述符 123456789101112131415161718192021class Foo: def func(self): print(&#39;我胡汉三又回来了&#39;)f1&#x3D;Foo()f1.func() #调用类的方法,也可以说是调用非数据描述符#函数是一个非数据描述符对象(一切皆对象么)print(dir(Foo.func))print(hasattr(Foo.func,&#39;__set__&#39;))print(hasattr(Foo.func,&#39;__get__&#39;))print(hasattr(Foo.func,&#39;__delete__&#39;))#有人可能会问,描述符不都是类么,函数怎么算也应该是一个对象啊,怎么就是描述符了#笨蛋哥,描述符是类没问题,描述符在应用的时候不都是实例化成一个类属性么#函数就是一个由非描述符类实例化得到的对象#没错，字符串也一样f1.func&#x3D;&#39;这是实例属性啊&#39;print(f1.func)del f1.func #删掉了非数据f1.func() 再次验证：实例属性&gt;非数据描述符12345678910111213141516171819202122232425262728293031323334353637class Foo: def __set__(self, instance, value): print(&#39;set&#39;) def __get__(self, instance, owner): print(&#39;get&#39;)class Room: name&#x3D;Foo() def __init__(self,name,width,length): self.name&#x3D;name self.width&#x3D;width self.length&#x3D;length#name是一个数据描述符,因为name&#x3D;Foo()而Foo实现了get和set方法,因而比实例属性有更高的优先级#对实例的属性操作,触发的都是描述符的r1&#x3D;Room(&#39;厕所&#39;,1,1)r1.namer1.name&#x3D;&#39;厨房&#39;class Foo: def __get__(self, instance, owner): print(&#39;get&#39;)class Room: name&#x3D;Foo() def __init__(self,name,width,length): self.name&#x3D;name self.width&#x3D;width self.length&#x3D;length#name是一个非数据描述符,因为name&#x3D;Foo()而Foo没有实现set方法,因而比实例属性有更低的优先级#对实例的属性操作,触发的都是实例自己的r1&#x3D;Room(&#39;厕所&#39;,1,1)r1.namer1.name&#x3D;&#39;厨房&#39;非数据描述符&gt;找不到123456789class Foo: def func(self): print(&#39;我胡汉三又回来了&#39;) def __getattr__(self, item): print(&#39;找不到了当然是来找我啦&#39;,item)f1&#x3D;Foo()f1.xxxxxxxxxxx 描述符的使用(类型检查) 12345678910111213141516171819202122232425262728293031323334class Typed: def __init__(self,name,expected_type): self.name=name self.expected_type=expected_type def __get__(self, instance, owner): print('get---&gt;',instance,owner) if instance is None: return self return instance.__dict__[self.name] def __set__(self, instance, value): print('set---&gt;',instance,value) if not isinstance(value,self.expected_type): raise TypeError('Expected %s' %str(self.expected_type)) instance.__dict__[self.name]=value def __delete__(self, instance): print('delete---&gt;',instance) instance.__dict__.pop(self.name)class People: name=Typed('name',str) age=Typed('name',int) salary=Typed('name',float) def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salaryp1=People(123,18,3333.3)p1=People('egon','18',3333.3)p1=People('egon',18,3333)大刀阔斧 描述符+类装饰器 12345678910111213141516171819202122232425262728293031323334353637class Typed: def __init__(self,name,expected_type): self.name=name self.expected_type=expected_type def __get__(self, instance, owner): print('get---&gt;',instance,owner) if instance is None: return self return instance.__dict__[self.name] def __set__(self, instance, value): print('set---&gt;',instance,value) if not isinstance(value,self.expected_type): raise TypeError('Expected %s' %str(self.expected_type)) instance.__dict__[self.name]=value def __delete__(self, instance): print('delete---&gt;',instance) instance.__dict__.pop(self.name)def typeassert(**kwargs): def decorate(cls): print('类的装饰器开始运行啦------&gt;',kwargs) for name,expected_type in kwargs.items(): setattr(cls,name,Typed(name,expected_type)) return cls return decorate@typeassert(name=str,age=int,salary=float) #有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People)class People: def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salaryprint(People.__dict__)p1=People('egon',18,3333.3)刀光剑影 property底层魔法的实现 1234567891011121314151617181920212223class Lazyproperty: def __init__(self,func): self.func=func def __get__(self, instance, owner): print('这是我们自己定制的静态属性,r1.area实际是要执行r1.area()') if instance is None: return self return self.func(instance) #此时你应该明白,到底是谁在为你做自动传递self的事情class Room: def __init__(self,name,width,length): self.name=name self.width=width self.length=length @Lazyproperty #area=Lazyproperty(area) 相当于定义了一个类属性,即描述符 def area(self): return self.width * self.lengthr1=Room('alex',1,1)print(r1.area)自己做一个@property 延迟计算 12345678910111213141516171819202122232425262728class Lazyproperty: def __init__(self,func): self.func=func def __get__(self, instance, owner): print('这是我们自己定制的静态属性,r1.area实际是要执行r1.area()') if instance is None: return self else: print('---&gt;') value=self.func(instance) setattr(instance,self.func.__name__,value) #计算一次就缓存到实例的属性字典中 return valueclass Room: def __init__(self,name,width,length): self.name=name self.width=width self.length=length @Lazyproperty #area=Lazyproperty(area) 相当于'定义了一个类属性,即描述符' def area(self): return self.width * self.lengthr1=Room('alex',1,1)print(r1.area) #先从自己的属性字典找,没有再去类的中找,然后出发了area的__get__方法print(r1.area) #先从自己的属性字典找,找到了,是上次计算的结果,这样就不用每执行一次都去计算实现延迟计算功能 1.4.15 __enter__/__exit__我们知道在操作文件对象的时候可以这么写 121 with open(&#39;a.txt&#39;) as f:2 &#39;代码块&#39; 上述叫做上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象的类中声明__enter__和__exit__方法 12345678910111213141516class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') # return self def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊')with Open('a.txt') as f: print('=====&gt;执行代码块') # print(f,f.name)上下文管理协议 __exit__()中的三个参数分别代表异常类型，异常值和追溯信息,with语句中代码块出现异常，则with后的代码都无法执行 12345678910111213141516171819class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') print(exc_type) print(exc_val) print(exc_tb)with Open('a.txt') as f: print('=====&gt;执行代码块') raise AttributeError('***着火啦,救火啊***')print('0'*100) #-------------------------------&gt;不会执行 如果__exit__()返回值为True,那么异常会被清空，就好像啥都没发生一样，with后的语句正常执行 1234567891011121314151617181920class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') print(exc_type) print(exc_val) print(exc_tb) return Truewith Open('a.txt') as f: print('=====&gt;执行代码块') raise AttributeError('***着火啦,救火啊***')print('0'*100) #-------------------------------&gt;会执行 模拟open 123456789101112131415161718192021222324class Open: def __init__(self,filepath,mode='r',encoding='utf-8'): self.filepath=filepath self.mode=mode self.encoding=encoding def __enter__(self): # print('enter') self.f=open(self.filepath,mode=self.mode,encoding=self.encoding) return self.f def __exit__(self, exc_type, exc_val, exc_tb): # print('exit') self.f.close() return True def __getattr__(self, item): return getattr(self.f,item)with Open('a.txt','w') as f: print(f) f.write('aaaaaa') f.wasdf #抛出异常，交给__exit__处理练习：模拟Open 1.4.16 类的装饰器无参数 123456789101112def decorate(cls): print('类的装饰器开始运行啦------&gt;') return cls@decorate #无参:People=decorate(People)class People: def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salaryp1=People('egon',18,3333.3) 带参数 12345678910111213def typeassert(**kwargs): def decorate(cls): print('类的装饰器开始运行啦------&gt;',kwargs) return cls return decorate@typeassert(name=str,age=int,salary=float) #有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People)class People: def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salaryp1=People('egon',18,3333.3) 1.4.17 再看property用法一 1234567891011121314151617181920class Foo: @property def AAA(self): print('get的时候运行我啊') @AAA.setter def AAA(self,value): print('set的时候运行我啊') @AAA.deleter def AAA(self): print('delete的时候运行我啊')#只有在属性AAA定义property后才能定义AAA.setter,AAA.deleterf1=Foo()f1.AAAf1.AAA='aaa'del f1.AAA用法一 用法二 1234567891011121314151617class Foo: def get_AAA(self): print('get的时候运行我啊') def set_AAA(self,value): print('set的时候运行我啊') def delete_AAA(self): print('delete的时候运行我啊') AAA=property(get_AAA,set_AAA,delete_AAA) #内置property三个参数与get,set,delete一一对应f1=Foo()f1.AAAf1.AAA='aaa'del f1.AAA用法二 1.4.18 元类 metaclasshttp://www.cnblogs.com/linhaifeng/articles/8029564.html class关键字创建类的流程分析上文我们基于python中一切皆为对象的概念分析出：我们用class关键字定义的类本身也是一个对象，负责产生该对象的类称之为元类（元类可以简称为类的类），内置的元类为type class关键字在帮我们创建类时，必然帮我们调用了元类OldboyTeacher=type(…)，那调用type时传入的参数是什么呢？必然是类的关键组成部分，一个类有三大组成部分，分别是1、类名class_name=’OldboyTeacher’2、基类们class_bases=(object,)3、类的名称空间class_dic，类的名称空间是执行类体代码而得到的调用type时会依次传入以上三个参数综上，class关键字帮我们创建一个类应该细分为以下四个过程 自定义元类 1234567891011121314151617181920212223242526class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类 def __call__(self, *args, **kwargs): #self=&lt;class '__main__.OldboyTeacher'&gt; #1、调用__new__产生一个空对象obj obj=self.__new__(self) # 此处的self是类OldoyTeacher，必须传参，代表创建一个OldboyTeacher的对象obj #2、调用__init__初始化空对象obj self.__init__(obj,*args,**kwargs) # 在初始化之后，obj.__dict__里就有值了 obj.__dict__=&#123;'_%s__%s' %(self.__name__,k):v for k,v in obj.__dict__.items()&#125; #3、返回初始化好的对象obj return objclass OldboyTeacher(object,metaclass=Mymeta): school='oldboy' def __init__(self,name,age): self.name=name self.age=age def say(self): print('%s says welcome to the oldboy to learn Python' %self.name)t1=OldboyTeacher('egon',18)print(t1.__dict__) #&#123;'_OldboyTeacher__name': 'egon', '_OldboyTeacher__age': 18&#125; 自定义元类控制类OldboyTeacher的调用储备知识：call12345678910class Foo: def __call__(self, *args, **kwargs): print(self) print(args) print(kwargs)obj&#x3D;Foo()#1、要想让obj这个对象变成一个可调用的对象，需要在该对象的类中定义一个方法__call__方法，该方法会在调用对象时自动触发#2、调用obj的返回值就是__call__方法的返回值res&#x3D;obj(1,2,3,x&#x3D;1,y&#x3D;2) 由上例得知，调用一个对象，就是触发对象所在类中的call方法的执行，如果把OldboyTeacher也当做一个对象，那么在OldboyTeacher这个对象的类中也必然存在一个call方法 123456789101112131415161718192021222324class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类 def __call__(self, *args, **kwargs): print(self) #&lt;class &#39;__main__.OldboyTeacher&#39;&gt; print(args) #(&#39;egon&#39;, 18) print(kwargs) #&#123;&#125; return 123class OldboyTeacher(object,metaclass&#x3D;Mymeta): school&#x3D;&#39;oldboy&#39; def __init__(self,name,age): self.name&#x3D;name self.age&#x3D;age def say(self): print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name)# 调用OldboyTeacher就是在调用OldboyTeacher类中的__call__方法# 然后将OldboyTeacher传给self,溢出的位置参数传给*，溢出的关键字参数传给**# 调用OldboyTeacher的返回值就是调用__call__的返回值t1&#x3D;OldboyTeacher(&#39;egon&#39;,18)print(t1) #123 默认地，调用t1=OldboyTeacher(‘egon’,18)会做三件事1、产生一个空对象obj2、调用init方法初始化对象obj3、返回初始化好的obj对应着，OldboyTeacher类中的call方法也应该做这三件事 1234567891011121314151617181920212223class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类 def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.OldboyTeacher&#39;&gt; #1、调用__new__产生一个空对象obj obj&#x3D;self.__new__(self) # 此处的self是类OldoyTeacher，必须传参，代表创建一个OldboyTeacher的对象obj #2、调用__init__初始化空对象obj self.__init__(obj,*args,**kwargs) #3、返回初始化好的对象obj return objclass OldboyTeacher(object,metaclass&#x3D;Mymeta): school&#x3D;&#39;oldboy&#39; def __init__(self,name,age): self.name&#x3D;name self.age&#x3D;age def say(self): print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name)t1&#x3D;OldboyTeacher(&#39;egon&#39;,18)print(t1.__dict__) #&#123;&#39;name&#39;: &#39;egon&#39;, &#39;age&#39;: 18&#125; 上例的call相当于一个模板，我们可以在该基础上改写call的逻辑从而控制调用OldboyTeacher的过程，比如将OldboyTeacher的对象的所有属性都变成私有的 12345678910111213141516171819202122232425class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类 def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.OldboyTeacher&#39;&gt; #1、调用__new__产生一个空对象obj obj&#x3D;self.__new__(self) # 此处的self是类OldoyTeacher，必须传参，代表创建一个OldboyTeacher的对象obj #2、调用__init__初始化空对象obj self.__init__(obj,*args,**kwargs) # 在初始化之后，obj.__dict__里就有值了 obj.__dict__&#x3D;&#123;&#39;_%s__%s&#39; %(self.__name__,k):v for k,v in obj.__dict__.items()&#125; #3、返回初始化好的对象obj return objclass OldboyTeacher(object,metaclass&#x3D;Mymeta): school&#x3D;&#39;oldboy&#39; def __init__(self,name,age): self.name&#x3D;name self.age&#x3D;age def say(self): print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name)t1&#x3D;OldboyTeacher(&#39;egon&#39;,18)print(t1.__dict__) #&#123;&#39;_OldboyTeacher__name&#39;: &#39;egon&#39;, &#39;_OldboyTeacher__age&#39;: 18&#125; 上例中涉及到查找属性的问题，比如self.new，请看下一小节 再看属性查找结合python继承的实现原理+元类重新看属性的查找应该是什么样子呢？？？在学习完元类后，其实我们用class自定义的类也全都是对象（包括object类本身也是元类type的 一个实例，可以用type(object)查看），我们学习过继承的实现原理，如果把类当成对象去看，将下述继承应该说成是：对象OldboyTeacher继承对象Foo，对象Foo继承对象Bar，对象Bar继承对象object 12345678910111213141516171819202122232425262728class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类 n&#x3D;444 def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.OldboyTeacher&#39;&gt; obj&#x3D;self.__new__(self) self.__init__(obj,*args,**kwargs) return objclass Bar(object): n&#x3D;333class Foo(Bar): n&#x3D;222class OldboyTeacher(Foo,metaclass&#x3D;Mymeta): n&#x3D;111 school&#x3D;&#39;oldboy&#39; def __init__(self,name,age): self.name&#x3D;name self.age&#x3D;age def say(self): print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name)print(OldboyTeacher.n) #自下而上依次注释各个类中的n&#x3D;xxx，然后重新运行程序，发现n的查找顺序为OldboyTeacher-&gt;Foo-&gt;Bar-&gt;object-&gt;Mymeta-&gt;type 于是属性查找应该分成两层，一层是对象层（基于c3算法的MRO）的查找，另外一个层则是类层（即元类层）的查找 123#查找顺序：#1、先对象层：OldoyTeacher-&gt;Foo-&gt;Bar-&gt;object#2、然后元类层：Mymeta-&gt;type 依据上述总结，我们来分析下元类Mymeta中call里的self.new的查找 1234567891011121314151617181920212223242526272829303132333435363738class Mymeta(type): n&#x3D;444 def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.OldboyTeacher&#39;&gt; obj&#x3D;self.__new__(self) print(self.__new__ is object.__new__) #Trueclass Bar(object): n&#x3D;333 # def __new__(cls, *args, **kwargs): # print(&#39;Bar.__new__&#39;)class Foo(Bar): n&#x3D;222 # def __new__(cls, *args, **kwargs): # print(&#39;Foo.__new__&#39;)class OldboyTeacher(Foo,metaclass&#x3D;Mymeta): n&#x3D;111 school&#x3D;&#39;oldboy&#39; def __init__(self,name,age): self.name&#x3D;name self.age&#x3D;age def say(self): print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name) # def __new__(cls, *args, **kwargs): # print(&#39;OldboyTeacher.__new__&#39;)OldboyTeacher(&#39;egon&#39;,18) #触发OldboyTeacher的类中的__call__方法的执行，进而执行self.__new__开始查找 总结，Mymeta下的__call__里的self.__new__在OldboyTeacher、Foo、Bar里都没有找到__new__的情况下，会去找object里的__new__，而object下默认就有一个__new__，所以即便是之前的类均未实现__new__,也一定会在object中找到一个，根本不会、也根本没必要再去找元类Mymeta-&gt;type中查找__new__ 我们在元类的call中也可以用object.new(self)去造对象 但我们还是推荐在__call__中使用self.__new__（self）去创造空对象，因为这种方式会检索三个类OldboyTeacher-&gt;Foo-&gt;Bar,而object.__new__则是直接跨过了他们三个 最后说明一点 12345678910111213141516171819202122232425262728293031323334class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类 n=444 def __new__(cls, *args, **kwargs): obj=type.__new__(cls,*args,**kwargs) # 必须按照这种传值方式 print(obj.__dict__) # return obj # 只有在返回值是type的对象时，才会触发下面的__init__ return 123 def __init__(self,class_name,class_bases,class_dic): print('run。。。')class OldboyTeacher(object,metaclass=Mymeta): #OldboyTeacher=Mymeta('OldboyTeacher',(object),&#123;...&#125;) n=111 school='oldboy' def __init__(self,name,age): self.name=name self.age=age def say(self): print('%s says welcome to the oldboy to learn Python' %self.name)print(type(Mymeta)) #&lt;class 'type'&gt;# 产生类OldboyTeacher的过程就是在调用Mymeta，而Mymeta也是type类的一个对象，那么Mymeta之所以可以调用，一定是在元类type中有一个__call__方法# 该方法中同样需要做至少三件事：# class type:# def __call__(self, *args, **kwargs): #self=&lt;class '__main__.Mymeta'&gt;# obj=self.__new__(self,*args,**kwargs) # 产生Mymeta的一个对象# self.__init__(obj,*args,**kwargs) # return obj 2. 软件目录结构规范为什么要设计好目录结构?“设计项目目录结构”，就和”代码编码风格”一样，属于个人风格问题。对于这种风格上的规范，一直都存在两种态度: 一类同学认为，这种个人风格问题”无关紧要”。理由是能让程序work就好，风格问题根本不是问题。 另一类同学认为，规范化能更好的控制程序结构，让程序具有更高的可读性。 我是比较偏向于后者的，因为我是前一类同学思想行为下的直接受害者。我曾经维护过一个非常不好读的项目，其实现的逻辑并不复杂，但是却耗费了我非常长的时间去理解它想表达的意思。从此我个人对于提高项目可读性、可维护性的要求就很高了。”项目目录结构”其实也是属于”可读性和可维护性”的范畴，我们设计一个层次清晰的目录结构，就是为了达到以下两点: 可读性高: 不熟悉这个项目的代码的人，一眼就能看懂目录结构，知道程序启动脚本是哪个，测试目录在哪儿，配置文件在哪儿等等。从而非常快速的了解这个项目。 可维护性高: 定义好组织规则后，维护者就能很明确地知道，新增的哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，仍然能够组织良好。 所以，我认为，保持一个层次清晰的目录结构是有必要的。更何况组织一个良好的工程目录，其实是一件很简单的事儿。 目录组织方式12345678910111213Foo|-- bin/ | |-- #执行文件，启动脚本，初始化脚本（小的脚本文件，相当于程序入口）|-- conf/| |-- #配置文件|-- db/| |-- #保存数据,可以细分|-- lib/| |-- #公共的类库|-- log/| |-- #日志信息，调试信息，报错信息|-- src/ #core/| |-- #核心的逻辑 关于如何组织一个较好的Python工程目录结构，已经有一些得到了共识的目录结构。在Stackoverflow的这个问题上，能看到大家对Python目录结构的讨论。 这里面说的已经很好了，我也不打算重新造轮子列举各种不同的方式，这里面我说一下我的理解和体会。 假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了: 12345678910111213141516171819Foo&#x2F;|-- bin&#x2F;| |-- foo||-- foo&#x2F;| |-- tests&#x2F;| | |-- __init__.py| | |-- test_main.py| || |-- __init__.py| |-- main.py||-- docs&#x2F;| |-- conf.py| |-- abc.rst||-- setup.py|-- requirements.txt|-- README 简要解释一下: bin/: 存放项目的一些可执行文件，当然你可以起名script/之类的也行。 foo/: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录tests/存放单元测试代码； (3) 程序的入口最好命名为main.py。 docs/: 存放一些文档。 setup.py: 安装、部署、打包的脚本。 requirements.txt: 存放软件依赖的外部Python包列表。 README: 项目说明文件。 除此之外，有一些方案给出了更加多的内容。比如LICENSE.txt,ChangeLog.txt文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考这篇文章。 下面，再简单讲一下我对这些目录的理解和个人要求吧。 关于README的内容这个我觉得是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。 它需要说明以下几个事项: 软件定位，软件的基本功能。 运行代码的方法: 安装环境、启动命令等。 简要的使用说明。 代码目录结构说明，更详细点可以说明软件的基本原理。 常见问题说明。 我觉得有以上几点是比较好的一个README。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。 可以参考Redis源码中Readme的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。 关于requirements.txt和setup.pysetup.py一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。 这个我是踩过坑的。 我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题: 安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。 Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。 如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。 新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。 setup.py可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。 setuptools的文档比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: setup.py 当然，简单点自己写个安装脚本（deploy.sh）替代setup.py也未尝不可。 requirements.txt这个文件存在的目的是: 方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在setup.py安装依赖时漏掉软件包。 方便读者明确项目使用了哪些Python包。 这个文件的格式是每一行包含一个包依赖的说明，通常是flask&gt;=0.10这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 pip install -r requirements.txt来把所有Python包依赖都装好了。具体格式说明： 点这里。 关于配置文件的使用方法注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。很多项目对配置文件的使用做法是: 配置文件写在一个或多个python文件中，比如此处的conf.py。 项目中哪个模块用到这个配置文件就直接通过import conf这种形式来在代码中使用配置。 这种做法我不太赞同: 这让单元测试变得困难（因为模块内部依赖了外部配置） 另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。 程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖conf.py这个文件。 所以，我认为配置的使用，更好的方式是， 模块的配置都是可以灵活配置的，不受外部配置文件的影响。 程序的配置也是可以灵活控制的。 能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。 所以，不应当在代码中直接import conf来使用配置文件。上面目录结构中的conf.py，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给main.py启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的conf.py你可以换个类似的名字，比如settings.py。或者你也可以使用其他格式的内容来编写配置文件，比如settings.yaml之类的。 七、异常处理http://www.cnblogs.com/linhaifeng/articles/6232220.html 常用的异常种类 12345678910111213AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性xIOError 输入/输出异常；基本上是无法打开文件ImportError 无法引入模块或包；基本上是路径问题或名称错误IndentationError 语法错误（的子类） ；代码没有正确对齐IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]KeyError 试图访问字典里不存在的键KeyboardInterrupt Ctrl+C被按下NameError 使用一个还未被赋予对象的变量SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）TypeError 传入对象类型与要求的不符合UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它ValueError 传入一个调用者不期望的值，即使值的类型是正确的 如果错误发生的条件是可预知的，我们需要用if进行处理：在错误发生之前进行预防 12345678AGE&#x3D;10while True: age&#x3D;input(&#39;&gt;&gt;: &#39;).strip() if age.isdigit(): #只有在age为字符串形式的整数时,下列代码才不会出错,该条件是可预知的 age&#x3D;int(age) if age &#x3D;&#x3D; AGE: print(&#39;you got it&#39;) break 如果错误发生的条件是不可预知的，则需要用到try…except：在错误发生之后进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#基本语法为try: 被检测的代码块except 异常类型： try中一旦检测到异常，就执行这个位置的逻辑#举例try: f&#x3D;open(&#39;a.txt&#39;) g&#x3D;(line.strip() for line in f) print(next(g)) print(next(g)) print(next(g)) print(next(g)) print(next(g))except StopIteration: f.close()#1 异常类只能用来处理指定的异常情况，如果非指定异常则无法处理。s1 &#x3D; &#39;hello&#39;try: int(s1)except IndexError as e: # 未捕获到异常，程序直接报错 print e#2 多分支s1 &#x3D; &#39;hello&#39;try: int(s1)except IndexError as e: print(e)except KeyError as e: print(e)except ValueError as e: print(e)#3 万能异常Exceptions1 &#x3D; &#39;hello&#39;try: int(s1)except Exception as e: print(e)#4 多分支异常与万能异常#4.1 如果你想要的效果是，无论出现什么异常，我们统一丢弃，或者使用同一段代码逻辑去处理他们，那么骚年，大胆的去做吧，只有一个Exception就足够了。#4.2 如果你想要的效果是，对于不同的异常我们需要定制不同的处理逻辑，那就需要用到多分支了。#5 也可以在多分支后来一个Exceptions1 &#x3D; &#39;hello&#39;try: int(s1)except IndexError as e: print(e)except KeyError as e: print(e)except ValueError as e: print(e)except Exception as e: print(e)#6 异常的其他机构s1 &#x3D; &#39;hello&#39;try: int(s1)except IndexError as e: print(e)except KeyError as e: print(e)except ValueError as e: print(e)#except Exception as e:# print(e)else: print(&#39;try内代码块没有异常则执行我&#39;)finally: print(&#39;无论异常与否,都会执行该模块,通常是进行清理工作&#39;)#7 主动触发异常try: raise TypeError(&#39;类型错误&#39;)except Exception as e: print(e)#8 自定义异常class EgonException(BaseException): def __init__(self,msg): self.msg&#x3D;msg def __str__(self): return self.msgtry: raise EgonException(&#39;类型错误&#39;)except EgonException as e: print(e)#9 断言:assert 条件assert 1 &#x3D;&#x3D; 1 assert 1 &#x3D;&#x3D; 2#10 总结try..except1：把错误处理和真正的工作分开来2：代码更易组织，更清晰，复杂的工作任务更容易实现；3：毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了； https://keelii.com/2018/09/24/socket-programming-in-python/(Python 中的Socket 编程（指南）) 八、socket编程https://www.cnblogs.com/linhaifeng/articles/6129246.html from socket import * listen(5) :tcp—-》back_log recv（）—-》等待内核态内存中的数据 send() —&gt;向内核态内存中发送数据 TCP双向连接，UDP不建立连接 一 客户端/服务器架构1.硬件C/S架构(打印机) 2.软件C/S架构 互联网中处处是C/S架构 如黄色网站是服务端，你的浏览器是客户端（B/S架构也是C/S架构的一种） 腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频） C/S架构与socket的关系： 我们学习socket就是为了完成C/S架构的开发 二 osi七层引子： 须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的） 如果你要跟别人一起玩，那你就需要上网了，什么是互联网？ 互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语 如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。 人们按照分工不同把互联网协议从逻辑上划分了层级， 详见网络通信原理：http://www.cnblogs.com/linhaifeng/articles/5937962.html 为何学习socket一定要先学习互联网协议： 1.首先：本节课程的目标就是教会你如何基于socket编程，来开发一款自己的C/S架构软件 2.其次：C/S架构的软件（软件属于应用层）是基于网络进行通信的 3.然后：网络的核心即一堆协议，协议即标准，你想开发一款基于网络通信的软件，就必须遵循这些标准。 4.最后：就让我们从这些标准开始研究，开启我们的socket编程之旅​ 图1 三 socket层在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。 图2 四 socket是什么Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。 123也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序而程序的pid是同一台机器上不同进程或者线程的标识 五 套接字发展史及分类套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 基于文件类型的套接字家族 套接字家族的名字：AF_UNIX unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信 基于网络类型的套接字家族 套接字家族的名字：AF_INET (还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET) 六 套接字工作流程​ 一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。 ​ 图3 先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束 socket()模块函数用法 1234567891011121314 1 import socket 2 socket.socket(socket_family,socket_type,protocal&#x3D;0) 3 socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 0。 ## AF_UNIX unix系统间通信（基于文件的传输），AF_INET 服务器之间通信（网络） ## stream流套接字tcp，datagram数据包套接字udp 4 5 获取tcp&#x2F;ip套接字 6 tcpSock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) 7 8 获取udp&#x2F;ip套接字 9 udpSock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)10 11 由于 socket 模块中有太多的属性。我们在这里破例使用了&#39;from module import *&#39;语句。使用 &#39;from socket import *&#39;,我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。12 例如tcpSock &#x3D; socket(AF_INET, SOCK_STREAM) 1234567891011121314151617181920212223242526272829服务端套接字函数s.bind() 绑定(主机,端口号)到套接字s.listen() 开始TCP监听s.accept() 被动接受TCP客户的连接,(阻塞式)等待连接的到来客户端套接字函数s.connect() 主动初始化TCP服务器连接s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常公共用途的套接字函数s.recv() 接收TCP数据s.send() 发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)s.sendall() 发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)s.recvfrom() 接收UDP数据s.sendto() 发送UDP数据s.getpeername() 连接到当前套接字的远端的地址s.getsockname() 当前套接字的地址s.getsockopt() 返回指定套接字的参数s.setsockopt() 设置指定套接字的参数s.close() 关闭套接字面向锁的套接字方法s.setblocking() 设置套接字的阻塞与非阻塞模式s.settimeout() 设置阻塞套接字操作的超时时间s.gettimeout() 得到阻塞套接字操作的超时时间面向文件的套接字的函数s.fileno() 套接字的文件描述符s.makefile() 创建一个与该套接字相关的文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551：用打电话的流程快速描述socket通信2：服务端和客户端加上基于一次链接的循环通信3：客户端发送空，卡主，证明是从哪个位置卡的服务端：from socket import *phone&#x3D;socket(AF_INET,SOCK_STREAM)phone.bind((&#39;127.0.0.1&#39;,8081))phone.listen(5)conn,addr&#x3D;phone.accept()while True: data&#x3D;conn.recv(1024) print(&#39;server&#x3D;&#x3D;&#x3D;&gt;&#39;) print(data) conn.send(data.upper())conn.close()phone.close()客户端：from socket import *phone&#x3D;socket(AF_INET,SOCK_STREAM)phone.connect((&#39;127.0.0.1&#39;,8081))while True: msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip() phone.send(msg.encode(&#39;utf-8&#39;)) print(&#39;client&#x3D;&#x3D;&#x3D;&#x3D;&gt;&#39;) data&#x3D;phone.recv(1024) print(data)说明卡的原因：缓冲区为空recv就卡住，引出原理图4.演示客户端断开链接，服务端的情况，提供解决方法5.演示服务端不能重复接受链接，而服务器都是正常运行不断来接受客户链接的6:简单演示udp服务端from socket import *phone&#x3D;socket(AF_INET,SOCK_DGRAM)phone.bind((&#39;127.0.0.1&#39;,8082))while True: msg,addr&#x3D;phone.recvfrom(1024) phone.sendto(msg.upper(),addr)客户端from socket import *phone&#x3D;socket(AF_INET,SOCK_DGRAM)while True: msg&#x3D;input(&#39;&gt;&gt;: &#39;) phone.sendto(msg.encode(&#39;utf-8&#39;),(&#39;127.0.0.1&#39;,8082)) msg,addr&#x3D;phone.recvfrom(1024) print(msg)udp客户端可以并发演示udp客户端可以输入为空演示，说出recvfrom与recv的区别，暂且不提tcp流和udp报的概念，留到粘包去说 七 基于TCP的套接字tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端 tcp服务端 1234567891 ss &#x3D; socket() #创建服务器套接字2 ss.bind() #把地址绑定到套接字3 ss.listen() #监听链接4 inf_loop: #服务器无限循环5 cs &#x3D; ss.accept() #接受客户端链接6 comm_loop: #通讯循环7 cs.recv()&#x2F;cs.send() #对话(接收与发送)8 cs.close() #关闭客户端套接字9 ss.close() #关闭服务器套接字(可选) tcp客户端 123451 cs &#x3D; socket() # 创建客户套接字2 cs.connect() # 尝试连接服务器3 comm_loop: # 通讯循环4 cs.send()&#x2F;cs.recv() # 对话(发送&#x2F;接收)5 cs.close() # 关闭客户套接字 socket通信流程与打电话流程类似，我们就以打电话为例来实现一个low版的套接字通信 12345678910111213141516171819202122#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,9000) #电话卡BUFSIZE&#x3D;1024 #收发消息的尺寸s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机s.bind(ip_port) #手机插卡s.listen(5) #手机待机conn,addr&#x3D;s.accept() #手机接电话# print(conn)# print(addr)print(&#39;接到来自%s的电话&#39; %addr[0])msg&#x3D;conn.recv(BUFSIZE) #听消息,听话print(msg,type(msg))conn.send(msg.upper()) #发消息,说话conn.close() #挂电话s.close() #手机关机 123456789101112131415#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,9000)BUFSIZE&#x3D;1024s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect_ex(ip_port) #拨电话s.send(&#39;linhaifeng nb&#39;.encode(&#39;utf-8&#39;)) #发消息,说话(只能发送字节类型)feedback&#x3D;s.recv(BUFSIZE) #收消息,听话print(feedback.decode(&#39;utf-8&#39;))s.close() #挂电话 加上链接循环与通信循环 123456789101112131415161718192021222324252627#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,8081)#电话卡BUFSIZE&#x3D;1024s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机s.bind(ip_port) #手机插卡s.listen(5) #手机待机while True: #新增接收链接循环,可以不停的接电话 conn,addr&#x3D;s.accept() #手机接电话 # print(conn) # print(addr) print(&#39;接到来自%s的电话&#39; %addr[0]) while True: #新增通信循环,可以不断的通信,收发消息 msg&#x3D;conn.recv(BUFSIZE) #听消息,听话 # if len(msg) &#x3D;&#x3D; 0:break #如果不加,那么正在链接的客户端突然断开,recv便不再阻塞,死循环发生 print(msg,type(msg)) conn.send(msg.upper()) #发消息,说话 conn.close() #挂电话s.close() #手机关机 123456789101112131415161718#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,8081)BUFSIZE&#x3D;1024s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect_ex(ip_port) #拨电话while True: #新增通信循环,客户端可以不断发收消息 msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip() if len(msg) &#x3D;&#x3D; 0:continue s.send(msg.encode(&#39;utf-8&#39;)) #发消息,说话(只能发送字节类型) feedback&#x3D;s.recv(BUFSIZE) #收消息,听话 print(feedback.decode(&#39;utf-8&#39;))s.close() #挂电话 问题： 有的同学在重启服务端时可能会遇到 这个是由于你的服务端仍然存在四次挥手的time_wait状态在占用地址（如果不懂，请深入研究1.tcp三次握手，四次挥手 2.syn洪水攻击 3.服务器高并发情况下会有大量的time_wait状态的优化方法） 解决方法： (1)重用端口 12345#加入一条socket配置，重用ip和端口phone&#x3D;socket(AF_INET,SOCK_STREAM)phone.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #就是它，在bind前加phone.bind((&#39;127.0.0.1&#39;,8080)) (2) 123456789101112131415161718发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决，vi &#x2F;etc&#x2F;sysctl.conf编辑文件，加入以下内容：net.ipv4.tcp_syncookies &#x3D; 1net.ipv4.tcp_tw_reuse &#x3D; 1net.ipv4.tcp_tw_recycle &#x3D; 1net.ipv4.tcp_fin_timeout &#x3D; 30 然后执行 &#x2F;sbin&#x2F;sysctl -p 让参数生效。 net.ipv4.tcp_syncookies &#x3D; 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；net.ipv4.tcp_tw_reuse &#x3D; 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间 八 基于UDP的套接字udp是无链接的，先启动哪一端都不会报错 udp服务端 123451 ss &#x3D; socket() #创建一个服务器的套接字2 ss.bind() #绑定服务器套接字3 inf_loop: #服务器无限循环4 cs &#x3D; ss.recvfrom()&#x2F;ss.sendto() # 对话(接收与发送)5 ss.close() # 关闭服务器套接字 udp客户端 1234cs &#x3D; socket() # 创建客户套接字comm_loop: # 通讯循环 cs.sendto()&#x2F;cs.recvfrom() # 对话(发送&#x2F;接收)cs.close() # 关闭客户套接字 udp套接字简单示例 1234567891011121314#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,9000)BUFSIZE&#x3D;1024udp_server_client&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)udp_server_client.bind(ip_port)while True: msg,addr&#x3D;udp_server_client.recvfrom(BUFSIZE) print(msg,addr) udp_server_client.sendto(msg.upper(),addr) 123456789101112131415#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,9000)BUFSIZE&#x3D;1024udp_server_client&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)while True: msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip() if not msg:continue udp_server_client.sendto(msg.encode(&#39;utf-8&#39;),ip_port) back_msg,addr&#x3D;udp_server_client.recvfrom(BUFSIZE) print(back_msg.decode(&#39;utf-8&#39;),addr) qq聊天(由于udp无连接，所以可以同时多个客户端去跟服务端通信) 12345678910111213#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketip_port&#x3D;(&#39;127.0.0.1&#39;,8081)udp_server_sock&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #买手机udp_server_sock.bind(ip_port)while True: qq_msg,addr&#x3D;udp_server_sock.recvfrom(1024) print(&#39;来自[%s:%s]的一条消息:\\033[1;44m%s\\033[0m&#39; %(addr[0],addr[1],qq_msg.decode(&#39;utf-8&#39;))) back_msg&#x3D;input(&#39;回复消息: &#39;).strip() udp_server_sock.sendto(back_msg.encode(&#39;utf-8&#39;),addr) 1234567891011121314151617181920212223242526#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024udp_client_socket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)qq_name_dic&#x3D;&#123; &#39;狗哥alex&#39;:(&#39;127.0.0.1&#39;,8081), &#39;瞎驴&#39;:(&#39;127.0.0.1&#39;,8081), &#39;一棵树&#39;:(&#39;127.0.0.1&#39;,8081), &#39;武大郎&#39;:(&#39;127.0.0.1&#39;,8081),&#125;while True: qq_name&#x3D;input(&#39;请选择聊天对象: &#39;).strip() while True: msg&#x3D;input(&#39;请输入消息,回车发送: &#39;).strip() if msg &#x3D;&#x3D; &#39;quit&#39;:break if not msg or not qq_name or qq_name not in qq_name_dic:continue udp_client_socket.sendto(msg.encode(&#39;utf-8&#39;),qq_name_dic[qq_name]) back_msg,addr&#x3D;udp_client_socket.recvfrom(BUFSIZE) print(&#39;来自[%s:%s]的一条消息:\\033[1;44m%s\\033[0m&#39; %(addr[0],addr[1],back_msg.decode(&#39;utf-8&#39;)))udp_client_socket.close() 1234567891011121314151617181920212223242526#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024udp_client_socket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)qq_name_dic&#x3D;&#123; &#39;狗哥alex&#39;:(&#39;127.0.0.1&#39;,8081), &#39;瞎驴&#39;:(&#39;127.0.0.1&#39;,8081), &#39;一棵树&#39;:(&#39;127.0.0.1&#39;,8081), &#39;武大郎&#39;:(&#39;127.0.0.1&#39;,8081),&#125;while True: qq_name&#x3D;input(&#39;请选择聊天对象: &#39;).strip() while True: msg&#x3D;input(&#39;请输入消息,回车发送: &#39;).strip() if msg &#x3D;&#x3D; &#39;quit&#39;:break if not msg or not qq_name or qq_name not in qq_name_dic:continue udp_client_socket.sendto(msg.encode(&#39;utf-8&#39;),qq_name_dic[qq_name]) back_msg,addr&#x3D;udp_client_socket.recvfrom(BUFSIZE) print(&#39;来自[%s:%s]的一条消息:\\033[1;44m%s\\033[0m&#39; %(addr[0],addr[1],back_msg.decode(&#39;utf-8&#39;)))udp_client_socket.close() 服务端运行结果 客户端1运行结果 客户端2运行结果 时间服务器 123456789101112131415161718192021222324#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *from time import strftimeip_port&#x3D;(&#39;127.0.0.1&#39;,9000)bufsize&#x3D;1024tcp_server&#x3D;socket(AF_INET,SOCK_DGRAM)tcp_server.bind(ip_port)while True: msg,addr&#x3D;tcp_server.recvfrom(bufsize) print(&#39;&#x3D;&#x3D;&#x3D;&gt;&#39;,msg) if not msg: time_fmt&#x3D;&#39;%Y-%m-%d %X&#39; else: time_fmt&#x3D;msg.decode(&#39;utf-8&#39;) back_msg&#x3D;strftime(time_fmt) tcp_server.sendto(back_msg.encode(&#39;utf-8&#39;),addr)tcp_server.close() 12345678910111213141516171819#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *ip_port&#x3D;(&#39;127.0.0.1&#39;,9000)bufsize&#x3D;1024tcp_client&#x3D;socket(AF_INET,SOCK_DGRAM)while True: msg&#x3D;input(&#39;请输入时间格式(例%Y %m %d)&gt;&gt;: &#39;).strip() tcp_client.sendto(msg.encode(&#39;utf-8&#39;),ip_port) data&#x3D;tcp_client.recv(bufsize) print(data.decode(&#39;utf-8&#39;))tcp_client.close() 九 粘包现象让我们基于tcp先制作一个远程执行命令的程序（1：执行错误命令 2：执行ls 3：执行ifconfig） 注意注意注意： res=subprocess.Popen(cmd.decode(‘utf-8’),shell=True,stderr=subprocess.PIPE,stdout=subprocess.PIPE) 的结果的编码是以当前所在的系统为准的，如果是windows，那么res.stdout.read()读出的就是GBK编码的，在接收端需要用GBK解码 且只能从管道里读一次结果 注意：命令ls -l ; lllllll ; pwd 的结果是既有正确stdout结果，又有错误stderr结果 1234567891011121314151617181920212223242526272829#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import subprocessip_port&#x3D;(&#39;127.0.0.1&#39;,8080)BUFSIZE&#x3D;1024tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)while True: conn,addr&#x3D;tcp_socket_server.accept() print(&#39;客户端&#39;,addr) while True: cmd&#x3D;conn.recv(BUFSIZE) if len(cmd) &#x3D;&#x3D; 0:break res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),shell&#x3D;True, stdout&#x3D;subprocess.PIPE, stdin&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.PIPE) stderr&#x3D;act_res.stderr.read() stdout&#x3D;act_res.stdout.read() conn.send(stderr) conn.send(stdout) 123456789101112131415161718#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex(ip_port)while True: msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip() if len(msg) &#x3D;&#x3D; 0:continue if msg &#x3D;&#x3D; &#39;quit&#39;:break s.send(msg.encode(&#39;utf-8&#39;)) act_res&#x3D;s.recv(BUFSIZE) print(act_res.decode(&#39;utf-8&#39;),end&#x3D;&#39;&#39;) 上述程序是基于tcp的socket，在运行时会发生粘包 让我们再基于udp制作一个远程执行命令的程序 12345678910111213141516171819202122232425262728#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import subprocessip_port&#x3D;(&#39;127.0.0.1&#39;,9003)bufsize&#x3D;1024udp_server&#x3D;socket(AF_INET,SOCK_DGRAM)udp_server.bind(ip_port)while True: #收消息 cmd,addr&#x3D;udp_server.recvfrom(bufsize) print(&#39;用户命令-----&gt;&#39;,cmd) #逻辑处理 res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),shell&#x3D;True,stderr&#x3D;subprocess.PIPE,stdin&#x3D;subprocess.PIPE,stdout&#x3D;subprocess.PIPE) stderr&#x3D;res.stderr.read() stdout&#x3D;res.stdout.read() #发消息 udp_server.sendto(stderr,addr) udp_server.sendto(stdout,addr)udp_server.close() 12345678910111213from socket import *ip_port&#x3D;(&#39;127.0.0.1&#39;,9003)bufsize&#x3D;1024udp_client&#x3D;socket(AF_INET,SOCK_DGRAM)while True: msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip() udp_client.sendto(msg.encode(&#39;utf-8&#39;),ip_port) data,addr&#x3D;udp_client.recvfrom(bufsize) print(data.decode(&#39;utf-8&#39;),end&#x3D;&#39;&#39;) 上述程序是基于udp的socket，在运行时永远不会发生粘包 十 什么是粘包须知：只有TCP有粘包现象，UDP永远不会粘包，为何，且听我娓娓道来 首先需要掌握一个socket收发消息的原理 发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。 例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束 所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。 此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。 TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。 UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。 tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略 udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠 tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。 两种情况下会发生粘包。 发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据量很小，会合到一起，产生粘包） 1234567891011121314151617181920#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)conn,addr&#x3D;tcp_socket_server.accept()data1&#x3D;conn.recv(10)data2&#x3D;conn.recv(10)print(&#39;-----&gt;&#39;,data1.decode(&#39;utf-8&#39;))print(&#39;-----&gt;&#39;,data2.decode(&#39;utf-8&#39;))conn.close() 123456789101112#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex(ip_port)s.send(&#39;hello&#39;.encode(&#39;utf-8&#39;))s.send(&#39;feng&#39;.encode(&#39;utf-8&#39;)) 接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） 1234567891011121314151617181920#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)conn,addr&#x3D;tcp_socket_server.accept()data1&#x3D;conn.recv(2) #一次没有收完整data2&#x3D;conn.recv(10)#下次收的时候,会先取旧的数据,然后取新的print(&#39;-----&gt;&#39;,data1.decode(&#39;utf-8&#39;))print(&#39;-----&gt;&#39;,data2.decode(&#39;utf-8&#39;))conn.close() 1234567891011#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socketBUFSIZE&#x3D;1024ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex(ip_port)s.send(&#39;hello feng&#39;.encode(&#39;utf-8&#39;)) 拆包的发生情况 当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。 补充问题一：为何tcp是可靠传输，udp是不可靠传输 基于tcp的数据传输请参考我的另一篇文章http://www.cnblogs.com/linhaifeng/articles/5937962.html，tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的 而udp发送数据，对端是不会返回确认信息的，因此不可靠 补充问题二：send(字节流)和recv(1024)及sendall recv里指定的1024意思是从缓存里一次拿出1024个字节的数据 send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失 十一 解决粘包的low比处理方法问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据 low版本的解决方法 12345678910111213141516171819202122232425262728293031#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socket,subprocessip_port&#x3D;(&#39;127.0.0.1&#39;,8080)s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)s.bind(ip_port)s.listen(5)while True: conn,addr&#x3D;s.accept() print(&#39;客户端&#39;,addr) while True: msg&#x3D;conn.recv(1024) if not msg:break res&#x3D;subprocess.Popen(msg.decode(&#39;utf-8&#39;),shell&#x3D;True,\\ stdin&#x3D;subprocess.PIPE,\\ stderr&#x3D;subprocess.PIPE,\\ stdout&#x3D;subprocess.PIPE) err&#x3D;res.stderr.read() if err: ret&#x3D;err else: ret&#x3D;res.stdout.read() data_length&#x3D;len(ret) conn.send(str(data_length).encode(&#39;utf-8&#39;)) data&#x3D;conn.recv(1024).decode(&#39;utf-8&#39;) if data &#x3D;&#x3D; &#39;recv_ready&#39;: conn.sendall(ret) conn.close() 1234567891011121314151617181920212223#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socket,times&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex((&#39;127.0.0.1&#39;,8080))while True: msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip() if len(msg) &#x3D;&#x3D; 0:continue if msg &#x3D;&#x3D; &#39;quit&#39;:break s.send(msg.encode(&#39;utf-8&#39;)) length&#x3D;int(s.recv(1024).decode(&#39;utf-8&#39;)) s.send(&#39;recv_ready&#39;.encode(&#39;utf-8&#39;)) send_size&#x3D;0 recv_size&#x3D;0 data&#x3D;b&#39;&#39; while recv_size &lt; length: data+&#x3D;s.recv(1024) recv_size+&#x3D;len(data) print(data.decode(&#39;utf-8&#39;)) 为何low： 程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗 十二 峰哥解决粘包的方法为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据 struct模块 该模块可以把一个类型，如数字，转成固定长度的bytes >&gt;&gt; struct.pack(‘i’,1111111111111) 。。。。。。。。。 struct.error: ‘i’ format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围 123456789101112131415161718192021222324252627import json,struct#假设通过客户端上传1T:1073741824000的文件a.txt#为避免粘包,必须自定制报头header&#x3D;&#123;&#39;file_size&#39;:1073741824000,&#39;file_name&#39;:&#39;&#x2F;a&#x2F;b&#x2F;c&#x2F;d&#x2F;e&#x2F;a.txt&#39;,&#39;md5&#39;:&#39;8f6fbf8347faa4924a76856701edb0f3&#39;&#125; #1T数据,文件路径和md5值#为了该报头能传送,需要序列化并且转为byteshead_bytes&#x3D;bytes(json.dumps(header),encoding&#x3D;&#39;utf-8&#39;) #序列化并转成bytes,用于传输#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节head_len_bytes&#x3D;struct.pack(&#39;i&#39;,len(head_bytes)) #这4个字节里只包含了一个数字,该数字是报头的长度#客户端开始发送conn.send(head_len_bytes) #先发报头的长度,4个bytesconn.send(head_bytes) #再发报头的字节格式conn.sendall(文件内容) #然后发真实内容的字节格式#服务端开始接收head_len_bytes&#x3D;s.recv(4) #先收报头4个bytes,得到报头长度的字节格式x&#x3D;struct.unpack(&#39;i&#39;,head_len_bytes)[0] #提取报头的长度head_bytes&#x3D;s.recv(x) #按照报头长度x,收取报头的bytes格式header&#x3D;json.loads(json.dumps(header)) #提取报头#最后根据报头的内容提取真实的数据,比如real_data_len&#x3D;s.recv(header[&#39;file_size&#39;])s.recv(real_data_len) 123456789101112131415161718192021222324252627282930#_*_coding:utf-8_*_#http:&#x2F;&#x2F;www.cnblogs.com&#x2F;coser&#x2F;archive&#x2F;2011&#x2F;12&#x2F;17&#x2F;2291160.html__author__ &#x3D; &#39;Linhaifeng&#39;import structimport binasciiimport ctypesvalues1 &#x3D; (1, &#39;abc&#39;.encode(&#39;utf-8&#39;), 2.7)values2 &#x3D; (&#39;defg&#39;.encode(&#39;utf-8&#39;),101)s1 &#x3D; struct.Struct(&#39;I3sf&#39;)s2 &#x3D; struct.Struct(&#39;4sI&#39;)print(s1.size,s2.size)prebuffer&#x3D;ctypes.create_string_buffer(s1.size+s2.size)print(&#39;Before : &#39;,binascii.hexlify(prebuffer))# t&#x3D;binascii.hexlify(&#39;asdfaf&#39;.encode(&#39;utf-8&#39;))# print(t)s1.pack_into(prebuffer,0,*values1)s2.pack_into(prebuffer,s1.size,*values2)print(&#39;After pack&#39;,binascii.hexlify(prebuffer))print(s1.unpack_from(prebuffer,0))print(s2.unpack_from(prebuffer,s1.size))s3&#x3D;struct.Struct(&#39;ii&#39;)s3.pack_into(prebuffer,0,123,123)print(&#39;After pack&#39;,binascii.hexlify(prebuffer))print(s3.unpack_from(prebuffer,0)) 1234567891011121314151617181920212223242526272829303132import socket,struct,jsonimport subprocessphone&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加phone.bind((&#39;127.0.0.1&#39;,8080))phone.listen(5)while True: conn,addr&#x3D;phone.accept() while True: cmd&#x3D;conn.recv(1024) if not cmd:break print(&#39;cmd: %s&#39; %cmd) res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;), shell&#x3D;True, stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.PIPE) err&#x3D;res.stderr.read() print(err) if err: back_msg&#x3D;err else: back_msg&#x3D;res.stdout.read() conn.send(struct.pack(&#39;i&#39;,len(back_msg))) #先发back_msg的长度 conn.sendall(back_msg) #在发真实的内容 conn.close() 1234567891011121314151617181920212223242526272829#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;import socket,time,structs&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)res&#x3D;s.connect_ex((&#39;127.0.0.1&#39;,8080))while True: msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip() if len(msg) &#x3D;&#x3D; 0:continue if msg &#x3D;&#x3D; &#39;quit&#39;:break s.send(msg.encode(&#39;utf-8&#39;)) l&#x3D;s.recv(4) x&#x3D;struct.unpack(&#39;i&#39;,l)[0] print(type(x),x) # print(struct.unpack(&#39;I&#39;,l)) r_s&#x3D;0 data&#x3D;b&#39;&#39; while r_s &lt; x: r_d&#x3D;s.recv(1024) data+&#x3D;r_d r_s+&#x3D;len(r_d) # print(data.decode(&#39;utf-8&#39;)) print(data.decode(&#39;gbk&#39;)) #windows默认gbk编码 我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了） 发送时：先发报头长度再编码报头内容然后发送最后发真实内容 接收时：先手报头长度，用struct取出来根据取出的长度收取报头内容，然后解码，反序列化从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容 123456789101112131415161718192021222324252627282930313233343536import socket,struct,jsonimport subprocessphone&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加phone.bind((&#39;127.0.0.1&#39;,8080))phone.listen(5)while True: conn,addr&#x3D;phone.accept() while True: cmd&#x3D;conn.recv(1024) if not cmd:break print(&#39;cmd: %s&#39; %cmd) res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;), shell&#x3D;True, stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.PIPE) err&#x3D;res.stderr.read() print(err) if err: back_msg&#x3D;err else: back_msg&#x3D;res.stdout.read() headers&#x3D;&#123;&#39;data_size&#39;:len(back_msg)&#125; head_json&#x3D;json.dumps(headers) head_json_bytes&#x3D;bytes(head_json,encoding&#x3D;&#39;utf-8&#39;) conn.send(struct.pack(&#39;i&#39;,len(head_json_bytes))) #先发报头的长度 conn.send(head_json_bytes) #再发报头 conn.sendall(back_msg) #在发真实的内容 conn.close() 12345678910111213141516171819202122232425from socket import *import struct,jsonip_port&#x3D;(&#39;127.0.0.1&#39;,8080)client&#x3D;socket(AF_INET,SOCK_STREAM)client.connect(ip_port)while True: cmd&#x3D;input(&#39;&gt;&gt;: &#39;) if not cmd:continue client.send(bytes(cmd,encoding&#x3D;&#39;utf-8&#39;)) head&#x3D;client.recv(4) head_json_len&#x3D;struct.unpack(&#39;i&#39;,head)[0] head_json&#x3D;json.loads(client.recv(head_json_len).decode(&#39;utf-8&#39;)) data_len&#x3D;head_json[&#39;data_size&#39;] recv_size&#x3D;0 recv_data&#x3D;b&#39;&#39; while recv_size &lt; data_len: recv_data+&#x3D;client.recv(1024) recv_size+&#x3D;len(recv_data) print(recv_data.decode(&#39;utf-8&#39;)) #print(recv_data.decode(&#39;gbk&#39;)) #windows默认gbk编码 FTP作业：上传下载文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import socketimport structimport jsonimport subprocessimport osclass MYTCPServer: address_family &#x3D; socket.AF_INET socket_type &#x3D; socket.SOCK_STREAM allow_reuse_address &#x3D; False max_packet_size &#x3D; 8192 coding&#x3D;&#39;utf-8&#39; request_queue_size &#x3D; 5 server_dir&#x3D;&#39;file_upload&#39; def __init__(self, server_address, bind_and_activate&#x3D;True): &quot;&quot;&quot;Constructor. May be extended, do not override.&quot;&quot;&quot; self.server_address&#x3D;server_address self.socket &#x3D; socket.socket(self.address_family, self.socket_type) if bind_and_activate: try: self.server_bind() self.server_activate() except: self.server_close() raise def server_bind(self): &quot;&quot;&quot;Called by constructor to bind the socket. &quot;&quot;&quot; if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_address) self.server_address &#x3D; self.socket.getsockname() def server_activate(self): &quot;&quot;&quot;Called by constructor to activate the server. &quot;&quot;&quot; self.socket.listen(self.request_queue_size) def server_close(self): &quot;&quot;&quot;Called to clean-up the server. &quot;&quot;&quot; self.socket.close() def get_request(self): &quot;&quot;&quot;Get the request and client address from the socket. &quot;&quot;&quot; return self.socket.accept() def close_request(self, request): &quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot; request.close() def run(self): while True: self.conn,self.client_addr&#x3D;self.get_request() print(&#39;from client &#39;,self.client_addr) while True: try: head_struct &#x3D; self.conn.recv(4) if not head_struct:break head_len &#x3D; struct.unpack(&#39;i&#39;, head_struct)[0] head_json &#x3D; self.conn.recv(head_len).decode(self.coding) head_dic &#x3D; json.loads(head_json) print(head_dic) #head_dic&#x3D;&#123;&#39;cmd&#39;:&#39;put&#39;,&#39;filename&#39;:&#39;a.txt&#39;,&#39;filesize&#39;:123123&#125; cmd&#x3D;head_dic[&#39;cmd&#39;] if hasattr(self,cmd): func&#x3D;getattr(self,cmd) func(head_dic) except Exception: break def put(self,args): file_path&#x3D;os.path.normpath(os.path.join( self.server_dir, args[&#39;filename&#39;] )) filesize&#x3D;args[&#39;filesize&#39;] recv_size&#x3D;0 print(&#39;-----&gt;&#39;,file_path) with open(file_path,&#39;wb&#39;) as f: while recv_size &lt; filesize: recv_data&#x3D;self.conn.recv(self.max_packet_size) f.write(recv_data) recv_size+&#x3D;len(recv_data) print(&#39;recvsize:%s filesize:%s&#39; %(recv_size,filesize))tcpserver1&#x3D;MYTCPServer((&#39;127.0.0.1&#39;,8080))tcpserver1.run()#下列代码与本题无关class MYUDPServer: &quot;&quot;&quot;UDP server class.&quot;&quot;&quot; address_family &#x3D; socket.AF_INET socket_type &#x3D; socket.SOCK_DGRAM allow_reuse_address &#x3D; False max_packet_size &#x3D; 8192 coding&#x3D;&#39;utf-8&#39; def get_request(self): data, client_addr &#x3D; self.socket.recvfrom(self.max_packet_size) return (data, self.socket), client_addr def server_activate(self): # No need to call listen() for UDP. pass def shutdown_request(self, request): # No need to shutdown anything. self.close_request(request) def close_request(self, request): # No need to close anything. pass 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import socketimport structimport jsonimport osclass MYTCPClient: address_family &#x3D; socket.AF_INET socket_type &#x3D; socket.SOCK_STREAM allow_reuse_address &#x3D; False max_packet_size &#x3D; 8192 coding&#x3D;&#39;utf-8&#39; request_queue_size &#x3D; 5 def __init__(self, server_address, connect&#x3D;True): self.server_address&#x3D;server_address self.socket &#x3D; socket.socket(self.address_family, self.socket_type) if connect: try: self.client_connect() except: self.client_close() raise def client_connect(self): self.socket.connect(self.server_address) def client_close(self): self.socket.close() def run(self): while True: inp&#x3D;input(&quot;&gt;&gt;: &quot;).strip() if not inp:continue l&#x3D;inp.split() cmd&#x3D;l[0] if hasattr(self,cmd): func&#x3D;getattr(self,cmd) func(l) def put(self,args): cmd&#x3D;args[0] filename&#x3D;args[1] if not os.path.isfile(filename): print(&#39;file:%s is not exists&#39; %filename) return else: filesize&#x3D;os.path.getsize(filename) head_dic&#x3D;&#123;&#39;cmd&#39;:cmd,&#39;filename&#39;:os.path.basename(filename),&#39;filesize&#39;:filesize&#125; print(head_dic) head_json&#x3D;json.dumps(head_dic) head_json_bytes&#x3D;bytes(head_json,encoding&#x3D;self.coding) head_struct&#x3D;struct.pack(&#39;i&#39;,len(head_json_bytes)) self.socket.send(head_struct) self.socket.send(head_json_bytes) send_size&#x3D;0 with open(filename,&#39;rb&#39;) as f: for line in f: self.socket.send(line) send_size+&#x3D;len(line) print(send_size) else: print(&#39;upload successful&#39;)client&#x3D;MYTCPClient((&#39;127.0.0.1&#39;,8080))client.run() 十三 认证客户端的链接合法性如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现 服务端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import hmac,ossecret_key&#x3D;b&#39;linhaifeng bang bang bang&#39;def conn_auth(conn): &#39;&#39;&#39; 认证客户端链接 :param conn: :return: &#39;&#39;&#39; print(&#39;开始验证新链接的合法性&#39;) msg&#x3D;os.urandom(32) conn.sendall(msg) h&#x3D;hmac.new(secret_key,msg) digest&#x3D;h.digest() respone&#x3D;conn.recv(len(digest)) return hmac.compare_digest(respone,digest)def data_handler(conn,bufsize&#x3D;1024): if not conn_auth(conn): print(&#39;该链接不合法,关闭&#39;) conn.close() return print(&#39;链接合法,开始通信&#39;) while True: data&#x3D;conn.recv(bufsize) if not data:break conn.sendall(data.upper())def server_handler(ip_port,bufsize,backlog&#x3D;5): &#39;&#39;&#39; 只处理链接 :param ip_port: :return: &#39;&#39;&#39; tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM) tcp_socket_server.bind(ip_port) tcp_socket_server.listen(backlog) while True: conn,addr&#x3D;tcp_socket_server.accept() print(&#39;新连接[%s:%s]&#39; %(addr[0],addr[1])) data_handler(conn,bufsize)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: ip_port&#x3D;(&#39;127.0.0.1&#39;,9999) bufsize&#x3D;1024 server_handler(ip_port,bufsize) 客户端（合法） 12345678910111213141516171819202122232425262728293031323334353637#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import hmac,ossecret_key&#x3D;b&#39;linhaifeng bang bang bang&#39;def conn_auth(conn): &#39;&#39;&#39; 验证客户端到服务器的链接 :param conn: :return: &#39;&#39;&#39; msg&#x3D;conn.recv(32) h&#x3D;hmac.new(secret_key,msg) digest&#x3D;h.digest() conn.sendall(digest)def client_handler(ip_port,bufsize&#x3D;1024): tcp_socket_client&#x3D;socket(AF_INET,SOCK_STREAM) tcp_socket_client.connect(ip_port) conn_auth(tcp_socket_client) while True: data&#x3D;input(&#39;&gt;&gt;: &#39;).strip() if not data:continue if data &#x3D;&#x3D; &#39;quit&#39;:break tcp_socket_client.sendall(data.encode(&#39;utf-8&#39;)) respone&#x3D;tcp_socket_client.recv(bufsize) print(respone.decode(&#39;utf-8&#39;)) tcp_socket_client.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: ip_port&#x3D;(&#39;127.0.0.1&#39;,9999) bufsize&#x3D;1024 client_handler(ip_port,bufsize) 客户端（非法，不知道加密） 12345678910111213141516171819202122#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *def client_handler(ip_port,bufsize&#x3D;1024): tcp_socket_client&#x3D;socket(AF_INET,SOCK_STREAM) tcp_socket_client.connect(ip_port) while True: data&#x3D;input(&#39;&gt;&gt;: &#39;).strip() if not data:continue if data &#x3D;&#x3D; &#39;quit&#39;:break tcp_socket_client.sendall(data.encode(&#39;utf-8&#39;)) respone&#x3D;tcp_socket_client.recv(bufsize) print(respone.decode(&#39;utf-8&#39;)) tcp_socket_client.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: ip_port&#x3D;(&#39;127.0.0.1&#39;,9999) bufsize&#x3D;1024 client_handler(ip_port,bufsize) 客户端（非法，不知道secretkey） 12345678910111213141516171819202122232425262728293031323334353637#_*_coding:utf-8_*___author__ &#x3D; &#39;Linhaifeng&#39;from socket import *import hmac,ossecret_key&#x3D;b&#39;linhaifeng bang bang bang1111&#39;def conn_auth(conn): &#39;&#39;&#39; 验证客户端到服务器的链接 :param conn: :return: &#39;&#39;&#39; msg&#x3D;conn.recv(32) h&#x3D;hmac.new(secret_key,msg) digest&#x3D;h.digest() conn.sendall(digest)def client_handler(ip_port,bufsize&#x3D;1024): tcp_socket_client&#x3D;socket(AF_INET,SOCK_STREAM) tcp_socket_client.connect(ip_port) conn_auth(tcp_socket_client) while True: data&#x3D;input(&#39;&gt;&gt;: &#39;).strip() if not data:continue if data &#x3D;&#x3D; &#39;quit&#39;:break tcp_socket_client.sendall(data.encode(&#39;utf-8&#39;)) respone&#x3D;tcp_socket_client.recv(bufsize) print(respone.decode(&#39;utf-8&#39;)) tcp_socket_client.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: ip_port&#x3D;(&#39;127.0.0.1&#39;,9999) bufsize&#x3D;1024 client_handler(ip_port,bufsize) 十四 socketserver实现并发基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环 socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题） server类： request类： 继承关系: 以下述代码为例，分析socketserver源码： 12ftpserver&#x3D;socketserver.ThreadingTCPServer((&#39;127.0.0.1&#39;,8080),FtpServer)ftpserver.serve_forever() 查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer 实例化得到ftpserver，先找类ThreadingTCPServer的init,在TCPServer中找到，进而执行server_bind,server_active 找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中 执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address) 在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address) 上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finishrequest,触发我们自己定义的类的实例化，去找_init方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找…. 源码分析总结： 基于tcp的socketserver我们自己定义的类中的 self.server即套接字对象 self.request即一个链接 self.client_address即客户端地址 基于udp的socketserver我们自己定义的类中的 self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b’adsf’, ) self.client_address即客户端地址 FTP1234567891011121314151617181920212223242526272829303132333435363738394041import socketserverimport structimport jsonimport osclass FtpServer(socketserver.BaseRequestHandler): coding&#x3D;&#39;utf-8&#39; server_dir&#x3D;&#39;file_upload&#39; max_packet_size&#x3D;1024 BASE_DIR&#x3D;os.path.dirname(os.path.abspath(__file__)) def handle(self): print(self.request) while True: data&#x3D;self.request.recv(4) data_len&#x3D;struct.unpack(&#39;i&#39;,data)[0] head_json&#x3D;self.request.recv(data_len).decode(self.coding) head_dic&#x3D;json.loads(head_json) # print(head_dic) cmd&#x3D;head_dic[&#39;cmd&#39;] if hasattr(self,cmd): func&#x3D;getattr(self,cmd) func(head_dic) def put(self,args): file_path &#x3D; os.path.normpath(os.path.join( self.BASE_DIR, self.server_dir, args[&#39;filename&#39;] )) filesize &#x3D; args[&#39;filesize&#39;] recv_size &#x3D; 0 print(&#39;-----&gt;&#39;, file_path) with open(file_path, &#39;wb&#39;) as f: while recv_size &lt; filesize: recv_data &#x3D; self.request.recv(self.max_packet_size) f.write(recv_data) recv_size +&#x3D; len(recv_data) print(&#39;recvsize:%s filesize:%s&#39; % (recv_size, filesize))ftpserver&#x3D;socketserver.ThreadingTCPServer((&#39;127.0.0.1&#39;,8080),FtpServer)ftpserver.serve_forever() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import socketimport structimport jsonimport osclass MYTCPClient: address_family &#x3D; socket.AF_INET socket_type &#x3D; socket.SOCK_STREAM allow_reuse_address &#x3D; False max_packet_size &#x3D; 8192 coding&#x3D;&#39;utf-8&#39; request_queue_size &#x3D; 5 def __init__(self, server_address, connect&#x3D;True): self.server_address&#x3D;server_address self.socket &#x3D; socket.socket(self.address_family, self.socket_type) if connect: try: self.client_connect() except: self.client_close() raise def client_connect(self): self.socket.connect(self.server_address) def client_close(self): self.socket.close() def run(self): while True: inp&#x3D;input(&quot;&gt;&gt;: &quot;).strip() if not inp:continue l&#x3D;inp.split() cmd&#x3D;l[0] if hasattr(self,cmd): func&#x3D;getattr(self,cmd) func(l) def put(self,args): cmd&#x3D;args[0] filename&#x3D;args[1] if not os.path.isfile(filename): print(&#39;file:%s is not exists&#39; %filename) return else: filesize&#x3D;os.path.getsize(filename) head_dic&#x3D;&#123;&#39;cmd&#39;:cmd,&#39;filename&#39;:os.path.basename(filename),&#39;filesize&#39;:filesize&#125; print(head_dic) head_json&#x3D;json.dumps(head_dic) head_json_bytes&#x3D;bytes(head_json,encoding&#x3D;self.coding) head_struct&#x3D;struct.pack(&#39;i&#39;,len(head_json_bytes)) self.socket.send(head_struct) self.socket.send(head_json_bytes) send_size&#x3D;0 with open(filename,&#39;rb&#39;) as f: for line in f: self.socket.send(line) send_size+&#x3D;len(line) print(send_size) else: print(&#39;upload successful&#39;)client&#x3D;MYTCPClient((&#39;127.0.0.1&#39;,8080))client.run() 补充： 两个程序之间通信:管道 九、并发https://www.cnblogs.com/yuanchenqi/articles/5733873.html 并发&amp;并行并发：系统具有处理多个任务（动作）的能力 并行：系统具有同时处理多个任务（动作）的能力 同步&amp;异步同步：当进程执行到一个IO操作的时候——-等：同步 异步：当进程执行到一个IO操作的时候——-不等：等到数据接收成功，再回来处理 python多进程多进程+协程 对于IO密集型任务，python多线程有用；对于计算密集型任务，不推荐多线程，可以使用多进程。 python的GILIn CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.) 上面的核心意思就是，无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行 十、python的线程与threading模块一 线程的两种调用方式 threading 模块建立在thread 模块之上。thread模块以低级、原始的方式来处理和控制线程，而threading 模块通过对thread进行二次封装， 提供了更方便的api来处理线程。 直接调用： 12345678910111213141516171819import threadingimport time def sayhi(num): #定义每个线程要运行的函数 print(&quot;running on number:%s&quot; %num) time.sleep(3) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: t1 &#x3D; threading.Thread(target&#x3D;sayhi,args&#x3D;(1,)) #生成一个线程实例 t2 &#x3D; threading.Thread(target&#x3D;sayhi,args&#x3D;(2,)) #生成另一个线程实例 t1.start() #启动线程 t2.start() #启动另一个线程 print(t1.getName()) #获取线程名 print(t2.getName()) 继承式调用： 1234567891011121314151617181920212223import threadingimport timeclass MyThread(threading.Thread): def __init__(self,num): threading.Thread.__init__(self) self.num &#x3D; num def run(self):#定义每个线程要运行的函数 print(&quot;running on number:%s&quot; %self.num) time.sleep(3)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: t1 &#x3D; MyThread(1) t2 &#x3D; MyThread(2) t1.start() t2.start() print(&quot;ending......&quot;) 二 threading.thread的实例方法join&amp;Daemon方法12345678910111213141516171819202122232425262728293031323334353637import threadingfrom time import ctime,sleepimport timedef ListenMusic(name): print (&quot;Begin listening to %s. %s&quot; %(name,ctime())) sleep(3) print(&quot;end listening %s&quot;%ctime())def RecordBlog(title): print (&quot;Begin recording the %s! %s&quot; %(title,ctime())) sleep(5) print(&#39;end recording %s&#39;%ctime())threads &#x3D; []t1 &#x3D; threading.Thread(target&#x3D;ListenMusic,args&#x3D;(&#39;水手&#39;,))t2 &#x3D; threading.Thread(target&#x3D;RecordBlog,args&#x3D;(&#39;python线程&#39;,))threads.append(t1)threads.append(t2)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: for t in threads: #t.setDaemon(True) #注意:一定在start之前设置 t.start() # t.join() # t1.join() t1.setDaemon(True) #t2.join()########考虑这三种join位置下的结果？ print (&quot;all over %s&quot; %ctime()) join()：在子线程完成运行之前，这个子线程的父线程将一直被阻塞。 daemon：无交互后台程序 setDaemon(True)：（使线程与主线程一起退出） 将线程声明为守护线程，必须在start() 方法调用之前设置， 如果不设置为守护线程程序会被无限挂起。这个方法基本和join是相反的。 当我们在程序运行中，执行一个主线程，如果主线程又创建一个子线程，主线程和子线程 就分兵两路，分别运行，那么当主线程完成想退出时，会检验子线程是否完成。如果子线程未完成，则主线程会等待子线程完成后再退出。但是有时候我们需要的是只要主线程完成了，不管子线程是否完成，都要和主线程一起退出，这时就可以用etDaemon方法啦 其它方法12345678910# run(): 线程被cpu调度后自动执行线程对象的run方法# start():启动线程活动。# isAlive(): 返回线程是否活动的。# getName(): 返回线程名。# setName(): 设置线程名。threading模块提供的一些方法：# threading.currentThread(): 返回当前的线程变量。# threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。# threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 三 同步锁(Lock)1234567891011121314151617181920212223import timeimport threadingdef addNum(): global num #在每个线程中都获取这个全局变量 #num-&#x3D;1 temp&#x3D;num #print(&#39;--get num:&#39;,num ) time.sleep(0.1) num &#x3D;temp-1 #对此公共变量进行-1操作num &#x3D; 100 #设定一个共享变量thread_list &#x3D; []for i in range(100): t &#x3D; threading.Thread(target&#x3D;addNum) t.start() thread_list.append(t)for t in thread_list: #等待所有线程执行完毕 t.join()print(&#39;final num:&#39;, num ) 观察：time.sleep(0.1) /0.001/0.0000001 结果分别是多少？ 多个线程都在同时操作同一个共享资源，所以造成了资源破坏，怎么办呢？(join会造成串行，失去所线程的意义) 我们可以通过同步锁来解决这种问题 12345678R&#x3D;threading.Lock()def sub(): global num R.acquire() temp&#x3D;num-1 time.sleep(0.1) num&#x3D;temp R.release() 四 线程死锁和递归锁在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去。下面是一个死锁的例子： 1234567891011121314151617181920212223242526272829303132333435import threading,timeclass myThread(threading.Thread): def doA(self): lockA.acquire() print(self.name,&quot;gotlockA&quot;,time.ctime()) time.sleep(3) lockB.acquire() print(self.name,&quot;gotlockB&quot;,time.ctime()) lockB.release() lockA.release() def doB(self): lockB.acquire() print(self.name,&quot;gotlockB&quot;,time.ctime()) time.sleep(2) lockA.acquire() print(self.name,&quot;gotlockA&quot;,time.ctime()) lockA.release() lockB.release() def run(self): self.doA() self.doB()if __name__&#x3D;&#x3D;&quot;__main__&quot;: lockA&#x3D;threading.Lock() lockB&#x3D;threading.Lock() threads&#x3D;[] for i in range(5): threads.append(myThread()) for t in threads: t.start() for t in threads: t.join()#等待线程结束，后面再讲。 解决办法：使用递归锁，将 1lock&#x3D;threading.RLock() 为了支持在同一线程中多次请求同一资源，python提供了“可重入锁”：threading.RLock。RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次acquire。直到一个线程所有的acquire都被release(count=0)，其他的线程才能获得资源。 应用 同步条件(Event)An event is a simple synchronization object;the event represents an internal flag, and threads can wait for the flag to be set, or set or clear the flag themselves. event = threading.Event() # a client thread can wait for the flag to be setevent.wait() # a server thread can set or reset itevent.set()event.clear() If the flag is set, the wait method doesn’t do anything.If the flag is cleared, wait will block until it becomes set again.Any number of threads may wait for the same event. 12345678910111213141516171819202122232425262728import threading,timeclass Boss(threading.Thread): def run(self): print(&quot;BOSS：今晚大家都要加班到22:00。&quot;) print(event.isSet()) event.set() time.sleep(5) print(&quot;BOSS：&lt;22:00&gt;可以下班了。&quot;) print(event.isSet()) event.set()class Worker(threading.Thread): def run(self): event.wait() print(&quot;Worker：哎……命苦啊！&quot;) time.sleep(1) event.clear() event.wait() print(&quot;Worker：OhYeah!&quot;)if __name__&#x3D;&#x3D;&quot;__main__&quot;: event&#x3D;threading.Event() threads&#x3D;[] for i in range(5): threads.append(Worker()) threads.append(Boss()) for t in threads: t.start() for t in threads: t.join() 信号量(Semaphore) 信号量用来控制线程并发数的，BoundedSemaphore或Semaphore管理一个内置的计数 器，每当调用acquire()时-1，调用release()时+1。 计数器不能小于0，当计数器为 0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。(类似于停车位的概念) BoundedSemaphore与Semaphore的唯一区别在于前者将在调用release()时检查计数器的值是否超过了计数器的初始值，如果超过了将抛出一个异常。 1234567891011121314import threading,timeclass myThread(threading.Thread): def run(self): if semaphore.acquire(): print(self.name) time.sleep(5) semaphore.release()if __name__&#x3D;&#x3D;&quot;__main__&quot;: semaphore&#x3D;threading.Semaphore(5) thrs&#x3D;[] for i in range(100): thrs.append(myThread()) for t in thrs: t.start() 多线程利器－－－队列(queue)列表是不安全的数据结构思考：如何通过对列来完成上述功能？ queue is especially useful in threaded programming when information must be exchanged safely between multiple threads. queue列队类的方法1234567891011121314151617181920212223242526272829303132创建一个“队列”对象import queueq &#x3D; queue.Queue(maxsize &#x3D; 10)Queue.Queue类即是一个队列的同步实现。队列长度可为无限或者有限。可通过Queue的构造函数的可选参数maxsize来设定队列长度。如果maxsize小于1就表示队列长度无限。将一个值放入队列中q.put(10)调用队列对象的put()方法在队尾插入一个项目。put()有两个参数，第一个item为必需的，为插入项目的值；第二个block为可选参数，默认为1。如果队列当前为空且block为1，put()方法就使调用线程暂停,直到空出一个数据单元。如果block为0，put方法将引发Full异常。将一个值从队列中取出q.get()调用队列对象的get()方法从队头删除并返回一个项目。可选参数为block，默认为True。如果队列为空且block为True，get()就使调用线程暂停，直至有项目可用。如果队列为空且block为False，队列将引发Empty异常。Python queue模块有三种队列及构造函数:1、Python Queue模块的FIFO队列先进先出。 class queue.Queue(maxsize)2、LIFO类似于堆，即先进后出。 class queue.LifoQueue(maxsize)3、还有一种是优先级队列级别越低越先出来。 class queue.PriorityQueue(maxsize)q.put([2,&quot;hello&quot;]) 【&lt;级别&gt;，信息】此包中的常用方法(q &#x3D; Queue.Queue()):q.qsize() 返回队列的大小q.empty() 如果队列为空，返回True,反之Falseq.full() 如果队列满了，返回True,反之Falseq.full 与 maxsize 大小对应q.get([block[, timeout]]) 获取队列，timeout等待时间q.get_nowait() 相当q.get(False)非阻塞 q.put(item) 写入队列，timeout等待时间q.put_nowait(item) 相当q.put(item, False)q.task_done() 在完成一项工作之后，q.task_done() 函数向任务已经完成的队列发送一个信号q.join() 实际上意味着等到队列为空，再执行别的操作 task_done()&amp;join()https://stackoverflow.com/questions/49637086/python-what-is-queue-task-done-used-for If I give you a box of work assignments, do I care about when you’ve taken everything out of the box? No. I care about when the work is done. Looking at an empty box doesn’t tell me that. You and 5 other guys might still be working on stuff you took out of the box. Queue.task_done lets workers say when a task is done. Someone waiting for all the work to be done with Queue.join will wait until enough task_done calls have been made, not when the queue is empty. 生产者消费者模型：为什么要使用生产者和消费者模式 在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。 什么是生产者消费者模式 生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 这就像，在餐厅，厨师做好菜，不需要直接和客户交流，而是交给前台，而客户去饭菜也不需要不找厨师，直接去前台领取即可，这也是一个结耦的过程。 1234567891011121314151617181920212223242526272829303132333435363738import time,randomimport queue,threadingq &#x3D; queue.Queue()def Producer(name): count &#x3D; 0 while count &lt;10: print(&quot;making........&quot;) time.sleep(random.randrange(3)) q.put(count) print(&#39;Producer %s has produced %s baozi..&#39; %(name, count)) count +&#x3D;1 #q.task_done() #q.join() print(&quot;ok......&quot;)def Consumer(name): count &#x3D; 0 while count &lt;10: time.sleep(random.randrange(4)) if not q.empty(): data &#x3D; q.get() #q.task_done() #q.join() print(data) print(&#39;\\033[32;1mConsumer %s has eat %s baozi...\\033[0m&#39; %(name, data)) else: print(&quot;-----no baozi anymore----&quot;) count +&#x3D;1p1 &#x3D; threading.Thread(target&#x3D;Producer, args&#x3D;(&#39;A&#39;,))c1 &#x3D; threading.Thread(target&#x3D;Consumer, args&#x3D;(&#39;B&#39;,))# c2 &#x3D; threading.Thread(target&#x3D;Consumer, args&#x3D;(&#39;C&#39;,))# c3 &#x3D; threading.Thread(target&#x3D;Consumer, args&#x3D;(&#39;D&#39;,))p1.start()c1.start()# c2.start()# c3.start() 多进程模块 multiprocessing十几个以内的多进程不用考虑资源消耗问题 Multiprocessing is a package that supports spawning processes using an API similar to the threading module. The multiprocessing package offers both local and remote concurrency,effectively side-stepping the Global Interpreter Lock by using subprocesses instead of threads. Due to this, the multiprocessing module allows the programmer to fully leverage multiple processors on a given machine. It runs on both Unix and Windows. 由于GIL的存在，python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。 multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。 一 进程的调用调用方式1123456789101112131415from multiprocessing import Processimport timedef f(name): time.sleep(1) print(&#39;hello&#39;, name,time.ctime())if __name__ &#x3D;&#x3D; &#39;__main__&#39;: p_list&#x3D;[] for i in range(3): p &#x3D; Process(target&#x3D;f, args&#x3D;(&#39;alvin&#39;,)) p_list.append(p) p.start() for i in p_list: p.join() print(&#39;end&#39;) 调用方式2123456789101112131415161718192021222324from multiprocessing import Processimport timeclass MyProcess(Process): def __init__(self): super(MyProcess, self).__init__() #self.name &#x3D; name def run(self): time.sleep(1) print (&#39;hello&#39;, self.name,time.ctime())if __name__ &#x3D;&#x3D; &#39;__main__&#39;: p_list&#x3D;[] for i in range(3): p &#x3D; MyProcess() p.start() p_list.append(p) for p in p_list: p.join() print(&#39;end&#39;) To show the individual process IDs involved, here is an expanded example:子进程—-》父进程—-》pycharm进程 1234567891011121314151617181920from multiprocessing import Processimport osimport timedef info(title): print(&quot;title:&quot;,title) print(&#39;parent process:&#39;, os.getppid()) print(&#39;process id:&#39;, os.getpid())def f(name): info(&#39;function f&#39;) print(&#39;hello&#39;, name)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: info(&#39;main process line&#39;) time.sleep(1) print(&quot;------------------&quot;) p &#x3D; Process(target&#x3D;info, args&#x3D;(&#39;yuan&#39;,)) p.start() p.join() 二 Process类构造方法： Process([group [, target [, name [, args [, kwargs]]]]]) group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 进程名； args/kwargs: 要传入方法的参数。 实例方法： is_alive()：返回进程是否在运行。 join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。 start()：进程准备就绪，等待CPU调度 run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。 terminate()：不管任务是否完成，立即停止工作进程 属性： daemon：和线程的setDeamon功能一样 name：进程名字。 pid：进程号。 三 进程间通讯 3.1 进程对列Queue12345678910111213141516171819from multiprocessing import Process, Queueimport queuedef f(q,n): #q.put([123, 456, &#39;hello&#39;]) q.put(n*n+1) print(&quot;son process&quot;,id(q))if __name__ &#x3D;&#x3D; &#39;__main__&#39;: q &#x3D; Queue() #try: q&#x3D;queue.Queue() print(&quot;main process&quot;,id(q)) for i in range(3): p &#x3D; Process(target&#x3D;f, args&#x3D;(q,i)) p.start() print(q.get()) print(q.get()) print(q.get()) 3.2 管道ThePipe() function returns a pair of connection objects connected by a pipe which by default is duplex (two-way). For example: 123456789101112131415161718from multiprocessing import Process, Pipedef f(conn): conn.send([12, &#123;&quot;name&quot;:&quot;yuan&quot;&#125;, &#39;hello&#39;]) response&#x3D;conn.recv() print(&quot;response&quot;,response) conn.close() print(&quot;q_ID2:&quot;,id(child_conn))if __name__ &#x3D;&#x3D; &#39;__main__&#39;: parent_conn, child_conn &#x3D; Pipe() print(&quot;q_ID1:&quot;,id(child_conn)) p &#x3D; Process(target&#x3D;f, args&#x3D;(child_conn,)) p.start() print(parent_conn.recv()) # prints &quot;[42, None, &#39;hello&#39;]&quot; parent_conn.send(&quot;儿子你好!&quot;) p.join() The two connection objects returned by Pipe() represent the two ends of the pipe. Each connection object has send() and recv() methods (among others). Note that data in a pipe may become corrupted if two processes (or threads) try to read from or write to the same end of the pipe at the same time. Of course there is no risk of corruption from processes using different ends of the pipe at the same time. 3.3 Managers(数据共享)Queue和pipe只是实现了数据交互，并没实现数据共享，即一个进程去更改另一个进程的数据。 A manager object returned by Manager() controls a server process which holds Python objects and allows other processes to manipulate them using proxies. A manager returned by Manager() will support types list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array. For example： 123456789101112131415161718192021222324252627282930313233from multiprocessing import Process, Managerdef f(d, l,n): d[n] &#x3D; &#39;1&#39; d[&#39;2&#39;] &#x3D; 2 d[0.25] &#x3D; None l.append(n) #print(l) print(&quot;son process:&quot;,id(d),id(l))if __name__ &#x3D;&#x3D; &#39;__main__&#39;: with Manager() as manager: d &#x3D; manager.dict() l &#x3D; manager.list(range(5)) print(&quot;main process:&quot;,id(d),id(l)) p_list &#x3D; [] for i in range(10): p &#x3D; Process(target&#x3D;f, args&#x3D;(d,l,i)) p.start() p_list.append(p) for res in p_list: res.join() print(d) print(l) 四 进程同步Without using the lock output from the different processes is liable to get all mixed up. 123456789101112from multiprocessing import Process, Lockdef f(l, i): with l.acquire(): print(&#39;hello world %s&#39;%i)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: lock &#x3D; Lock() for num in range(10): Process(target&#x3D;f, args&#x3D;(lock, num)).start() 五 进程池回调函数：https://www.zhihu.com/question/19801131 进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。 进程池中有两个方法： apply apply_async 123456789101112131415161718192021222324252627from multiprocessing import Process,Poolimport time,osdef Foo(i): time.sleep(1) print(i) return i+100def Bar(arg): print(os.getpid()) print(os.getppid()) print(&#39;logger:&#39;,arg)pool &#x3D; Pool(5)Bar(1)print(&quot;----------------&quot;)for i in range(10): #pool.apply(func&#x3D;Foo, args&#x3D;(i,)) # 串行，平时不用 #pool.apply_async(func&#x3D;Foo, args&#x3D;(i,)) pool.apply_async(func&#x3D;Foo, args&#x3D;(i,),callback&#x3D;Bar) #callback回调函数pool.close()pool.join() # join和close的调用顺序是固定的print(&#39;end&#39;) 四 Python中的上下文管理器(contextlib模块)上下文管理器的任务是：代码块执行前准备，代码块执行后收拾 1 如何使用上下文管理器：如何打开一个文件，并写入”hello world” 12345filename&#x3D;&quot;my.txt&quot;mode&#x3D;&quot;w&quot;f&#x3D;open(filename,mode)f.write(&quot;hello world&quot;)f.close() 当发生异常时（如磁盘写满），就没有机会执行第5行。当然，我们可以采用try-finally语句块进行包装： 12345writer&#x3D;open(filename,mode)try: writer.write(&quot;hello world&quot;)finally: writer.close() 当我们进行复杂的操作时，try-finally语句就会变得丑陋，采用with语句重写： 12with open(filename,mode) as writer: writer.write(&quot;hello world&quot;) as指代了从open()函数返回的内容，并把它赋给了新值。with完成了try-finally的任务。 2 自定义上下文管理器 with语句的作用类似于try-finally，提供一种上下文机制。要应用with语句的类，其内部必须提供两个内置函数enter和exit。前者在主体代码执行前执行，后者在主体代码执行后执行。as后面的变量，是在enter函数中返回的。 1234567891011121314151617181920class echo(): def output(self): print &quot;hello world&quot; def __enter__(self): print &quot;enter&quot; return self #可以返回任何希望返回的东西 def __exit__(self,exception_type,value,trackback): print &quot;exit&quot; if exception_type&#x3D;&#x3D;ValueError: return True else: return Flase &gt;&gt;&gt;with echo as e: e.output() 输出：enterhello worldexit 完备的exit函数如下： 1def __exit__(self,exc_type,exc_value,exc_tb) 其中，exc_type:异常类型；exc_value:异常值；exc_tb:异常追踪信息 当exit返回True时，异常不传播 3 contextlib模块 contextlib模块的作用是提供更易用的上下文管理器，它是通过Generator实现的。contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制，常用框架如下： 123456789101112131415161718from contextlib import contextmanager@contextmanagerdef make_context(): print &#39;enter&#39; try: yield &quot;ok&quot; except RuntimeError,err: print &#39;error&#39;,err finally: print &#39;exit&#39; &gt;&gt;&gt;with make_context() as value: print value 输出为： enter ok exit 其中，yield写入try-finally中是为了保证异常安全（能处理异常）as后的变量的值是由yield返回。yield前面的语句可看作代码块执行前操作，yield之后的操作可以看作在exit函数中的操作。 以线程锁为例： 1234567891011121314151617@contextlib.contextmanagerdef loudLock(): print &#39;Locking&#39; lock.acquire() yield print &#39;Releasing&#39; lock.release() with loudLock(): print &#39;Lock is locked: %s&#39; % lock.locked() print &#39;Doing something that needs locking&#39; #Output:#Locking#Lock is locked: True#Doing something that needs locking#Releasing 4 contextlib.nested:减少嵌套对于： 123with open(filename,mode) as reader: with open(filename1,mode1) as writer: writer.write(reader.read()) 可以通过contextlib.nested进行简化： 12with contextlib.nested(open(filename,mode),open(filename1,mode1)) as (reader,writer): writer.write(reader.read()) 在python 2.7及以后，被一种新的语法取代： 12with open(filename,mode) as reader,open(filename1,mode1) as writer: writer.write(reader.read()) 5 contextlib.closing() file类直接支持上下文管理器API，但有些表示打开句柄的对象并不支持，如urllib.urlopen()返回的对象。还有些遗留类，使用close()方法而不支持上下文管理器API。为了确保关闭句柄，需要使用closing()为它创建一个上下文管理器（调用类的close方法）。 1234567891011121314import contextlibclass myclass(): def __init__(self): print '__init__' def close(self): print 'close()' with contextlib.closing(myclass()): print 'ok' 输出：__init__okclose() 十一、协程协程主要面向IO操作 协程，又称微线程，纤程。英文名Coroutine。 优点1: 协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 优点2: 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 yield的简单实现12345678910111213141516171819202122232425262728import timeimport queuedef consumer(name): print(&quot;---&gt;ready to eat baozi...&quot;) while True: new_baozi &#x3D; yield print(&quot;[%s] is eating baozi %s&quot; % (name,new_baozi)) #time.sleep(1)def producer(): r &#x3D; con.__next__() r &#x3D; con2.__next__() n &#x3D; 0 while 1: time.sleep(1) print(&quot;\\033[32;1m[producer]\\033[0m is making baozi %s and %s&quot; %(n,n+1) ) con.send(n) con2.send(n+1) n +&#x3D;2if __name__ &#x3D;&#x3D; &#39;__main__&#39;: con &#x3D; consumer(&quot;c1&quot;) con2 &#x3D; consumer(&quot;c2&quot;) p &#x3D; producer() Greenletgreenlet是一个用C实现的协程模块，相比与python自带的yield，它可以使你在任意函数之间随意切换，而不需把这个函数先声明为generator 12345678910111213141516171819from greenlet import greenlet def test1(): print(12) gr2.switch() print(34) gr2.switch() def test2(): print(56) gr1.switch() print(78) gr1 &#x3D; greenlet(test1)gr2 &#x3D; greenlet(test2)gr1.switch() Gevent【https://softlns.github.io/2015/11/28/python-gevent/】 123456789101112131415161718192021222324252627282930import geventimport requests,timestart&#x3D;time.time()def f(url): print(&#39;GET: %s&#39; % url) resp &#x3D;requests.get(url) data &#x3D; resp.text print(&#39;%d bytes received from %s.&#39; % (len(data), url))gevent.joinall([ gevent.spawn(f, &#39;https:&#x2F;&#x2F;www.python.org&#x2F;&#39;), gevent.spawn(f, &#39;https:&#x2F;&#x2F;www.yahoo.com&#x2F;&#39;), gevent.spawn(f, &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;), gevent.spawn(f, &#39;https:&#x2F;&#x2F;www.sina.com.cn&#x2F;&#39;),])# f(&#39;https:&#x2F;&#x2F;www.python.org&#x2F;&#39;)## f(&#39;https:&#x2F;&#x2F;www.yahoo.com&#x2F;&#39;)## f(&#39;https:&#x2F;&#x2F;baidu.com&#x2F;&#39;)## f(&#39;https:&#x2F;&#x2F;www.sina.com.cn&#x2F;&#39;)print(&quot;cost time:&quot;,time.time()-start) http://www.cnblogs.com/yuanchenqi/articles/5722574.html 十二、IO模型事件驱动模型上节的问题：协程：遇到IO操作就切换。但什么时候切回去呢？怎么确定IO操作完了？ 传统的编程是如下线性模式的： 开始—-&gt;代码块A—-&gt;代码块B—-&gt;代码块C—-&gt;代码块D—-&gt;……—-&gt;结束 每一个代码块里是完成各种各样事情的代码，但编程者知道代码块A,B,C,D…的执行顺序，唯一能够改变这个流程的是数据。输入不同的数据，根据条件语句判断，流程或许就改为A—-&gt;C—-&gt;E…—-&gt;结束。每一次程序运行顺序或许都不同，但它的控制流程是由输入数据和你编写的程序决定的。如果你知道这个程序当前的运行状态（包括输入数据和程序本身），那你就知道接下来甚至一直到结束它的运行流程。 对于事件驱动型程序模型，它的流程大致如下： 开始—-&gt;初始化—-&gt;等待 与上面传统编程模式不同，事件驱动程序在启动之后，就在那等待，等待什么呢？等待被事件触发。传统编程下也有“等待”的时候，比如在代码块D中，你定义了一个input()，需要用户输入数据。但这与下面的等待不同，传统编程的“等待”，比如input()，你作为程序编写者是知道或者强制用户输入某个东西的，或许是数字，或许是文件名称，如果用户输入错误，你还需要提醒他，并请他重新输入。事件驱动程序的等待则是完全不知道，也不强制用户输入或者干什么。只要某一事件发生，那程序就会做出相应的“反应”。这些事件包括：输入信息、鼠标、敲击键盘上某个键还有系统内部定时器触发。 一、事件驱动模型介绍通常，我们写服务器处理模型的程序时，有以下几种模型： 123（1）每收到一个请求，创建一个新的进程，来处理该请求； （2）每收到一个请求，创建一个新的线程，来处理该请求； （3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I&#x2F;O方式来处理请求 第三种就是协程、事件驱动的方式，一般普遍认为第（3）种方式是大多数网络服务器采用的方式 论事件驱动模型 事件驱动之鼠标点击事件注册 在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？ 两种方式： 1创建一个线程循环检测是否有鼠标点击​ 那么这个方式有以下几个缺点： CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？ 如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘； 如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；所以，该方式是非常不好的。 2 就是事件驱动模型目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下： 有一个事件（消息）队列； 鼠标按下时，往这个队列中增加一个点击事件（消息）； 有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等； 事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。 让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了。 最初的问题：怎么确定IO操作完了切回去呢？通过回调函数 1234561.要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu.2.再说什么是事件驱动的程序。一个典型的事件驱动的程序，就是一个死循环，并以一个线程的形式存在，这个死循环包括两个部分，第一个部分是按照一定的条件接收并选择一个要处理的事件，第二个部分就是事件的处理过程。程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序会因查询事件队列失败而进入睡眠状态，从而释放cpu。3.事件驱动的程序，必定会直接或者间接拥有一个事件队列，用于存储未能及时处理的事件。4.事件驱动的程序的行为，完全受外部输入的事件控制，所以，事件驱动的系统中，存在大量这种程序，并以事件作为主要的通信方式。5.事件驱动的程序，还有一个最大的好处，就是可以按照一定的顺序处理队列中的事件，而这个顺序则是由事件的触发顺序决定的，这一特性往往被用于保证某些过程的原子化。6.目前windows,linux,nucleus,vxworks都是事件驱动的，只有一些单片机可能是非事件驱动的。 注意，事件驱动的监听事件是由操作系统调用的cpu来完成的 十三、IO多路复用前面是用协程实现的IO阻塞自动切换，那么协程又是怎么实现的，在原理是是怎么实现的。如何去实现事件驱动的情况下IO的自动阻塞的切换，这个学名叫什么呢？ =&gt; IO多路复用比如socketserver，多个客户端连接，单线程下实现并发效果，就叫多路复用。 同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。 本文讨论的背景是Linux环境下的network IO。 1 IO模型前戏准备在进行解释之前，首先要说明几个概念： 用户空间和内核空间 进程切换 进程的阻塞 文件描述符 缓存 I/O 用户空间与内核空间现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。 进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换，这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。注：总而言之就是很耗资源的 进程的阻塞正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。 文件描述符fd文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。 缓存 I/O缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。用户空间没法直接访问内核空间的，内核态到用户态的数据拷贝 思考：为什么数据一定要先到内核区，直接到用户内存不是更直接吗？内核不能信任任何用户空间的指针。必须对用户空间的指针指向的数据进行验证。如果只做验证不做拷贝的话，那么在随后的运行中要随时受到其它进／线程可能修改用户空间数据的威胁。所以必须做拷贝。 缓存 I/O 的缺点： 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。 ​ 同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，我先限定一下本文的上下文。本文讨论的背景是Linux环境下的network IO。 Stevens在文章中一共比较了五种IO Model： ​ blocking IO ​ nonblocking IO ​ IO multiplexing ​ signal driven IO ​ asynchronous IO 由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。再说一下IO发生时涉及的对象和步骤。 对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段： 1 等待数据准备 (Waiting for the data to be ready) 2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。 2 blocking IO （阻塞IO）在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样： ​ 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。所以，blocking IO的特点就是在IO执行的两个阶段都被block了。 3 non-blocking IO（非阻塞IO）linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子： ​ 从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。所以，用户进程其实是需要不断的主动询问kernel数据好了没有。 注意： ​ 在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。即每次recvform系统调用之间，cpu的权限还在进程手中，这段时间是可以做其他事情的， ​ 也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。 4 IO multiplexing（IO多路复用）​ IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图： ​ 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”select负责的所有socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。 注意1：select函数返回结果中如果有文件可读了，那么进程就可以通过调用accept()或recv()来让kernel将位于内核中准备到的数据copy到用户区。 注意2: select的优势在于可以处理多个连接，不适用于单个连接 5 Asynchronous I/O（异步IO）linux下的asynchronous IO其实用得很少。先看一下它的流程： 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 ​ 到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。 在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的： A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes; An asynchronous I/O operation does not cause the requesting process to be blocked; 两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。 ​ 注意：由于咱们接下来要讲的select，poll，epoll都属于IO多路复用，而IO多路复用又属于同步的范畴，故，epoll只是一个伪异步而已。 各个IO Model的比较如图所示： ​ 经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。 五种IO模型比较： ​ 6 select poll epoll IO多路复用介绍首先列一下，sellect、poll、epoll三者的区别 selectselect最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。select目前几乎在所有的平台上支持select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。 poll它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。一般也不用它，相当于过渡阶段 epoll直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll。被公认为Linux2.6下性能最好的多路I/O就绪通知方法。windows不支持 没有最大文件描述符数量的限制。比如100个连接，有两个活跃了，epoll会告诉用户这两个两个活跃了，直接取就ok了，而select是循环一遍。 （了解）epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。 所以市面上上见到的所谓的异步IO，比如nginx、Tornado、等，我们叫它异步IO，实际上是IO多路复用。 select与epoll 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# 首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I&#x2F;O操作的内核对象。# 不管是文件，还是套接字，还是管道，我们都可以把他们看作流。# 之后我们来讨论I&#x2F;O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假# 定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是# 服务器还没有把数据传回来），这时候该怎么办？# 阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干# （或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话# （假定一定能叫醒你）。# 非阻塞忙轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂# 个电话：“你到了没？”# 很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。# 大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，# 就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。## 为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I&#x2F;O事件解释清楚。缓冲区的引入是为# 了减少频繁I&#x2F;O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进# 行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。# 假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。# 假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变# 到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。# 但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写# 入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候# 会产生一个I&#x2F;O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。# 假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从# 长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”# 也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告# 诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。# 这四个情形涵盖了四个I&#x2F;O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四# 个术语都是我生造的，仅为解释其原理而造）。这四个I&#x2F;O事件是进行阻塞同步的根本。（如果不能理解“同步”是# 什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。## 然后我们来说说阻塞I&#x2F;O的缺点。但是阻塞I&#x2F;O模式下，一个线程只能处理一个流的I&#x2F;O事件。如果想要同时处理多# 个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。# 于是再来考虑非阻塞忙轮询的I&#x2F;O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞# 模式再此不予讨论）：# while true &#123;# for i in stream[]; &#123;# if i has data# read until unavailable# &#125;# &#125;# 我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为# 如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I&#x2F;O事件的处理是阻# 塞或者唤醒，而非阻塞模式下则把I&#x2F;O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。## 为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不# 过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I&#x2F;O事件，在空闲的时候，会把当前线程阻# 塞掉，当有一个或多个流有I&#x2F;O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可# 以把“忙”字去掉了）。代码长这样:# while true &#123;# select(streams[])# for i in streams[] &#123;# if i has data# read until unavailable# &#125;# &#125;# 于是，如果没有I&#x2F;O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知# 道了，有I&#x2F;O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，# 找出能读出数据，或者写入数据的流，对他们进行操作。# 但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次# 说了这么多，终于能好好解释epoll了# epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I&#x2F;O事件通知我# 们。此时我们对这些流的操作都是有意义的。# 在讨论epoll的实现细节之前，先把epoll的相关操作列出：# epoll_create 创建一个epoll对象，一般epollfd &#x3D; epoll_create()# epoll_ctl （epoll_add&#x2F;epoll_del的合体），往epoll对象中增加&#x2F;删除某一个流的某一个事件# 比如# epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);&#x2F;&#x2F;有缓冲区内有数据时epoll_wait返回# epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);&#x2F;&#x2F;缓冲区可写入时epoll_wait返回# epoll_wait(epollfd,...)等待直到注册的事件发生# （注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write&#x2F;read会返回-1，并设置errno&#x3D;EAGAIN。# 而epoll只关心缓冲区非满和缓冲区非空事件）。# 一个epoll模式的代码大概的样子是：# while true &#123;# active_stream[] &#x3D; epoll_wait(epollfd)# for i in active_stream[] &#123;# read or write till unavailable# &#125;# &#125;# 举个例子:# select:# 班里三十个同学在考试,谁先做完想交卷都要通过按钮来活动,他按按钮作为老师的我桌子上的灯就会变红.# 一旦灯变红,我(select)我就可以知道有人交卷了,但是我并不知道谁交的,所以,我必须跟个傻子似的轮询# 地去问:嘿,是你要交卷吗?然后我就可以以这种效率极低地方式找到要交卷的学生,然后把它的卷子收上来.## epoll:# 这次再有人按按钮,我这不光灯会亮,上面还会显示要交卷学生的名字.这样我就可以直接去对应学生那收卷就# 好了.当然,同时可以有多人交卷. IO多路复用的触发方式 123456789101112131415161718192021222324# 在linux的IO多路复用中有水平触发,边缘触发两种模式,这两种模式的区别如下:## 水平触发:如果文件描述符已经就绪可以非阻塞的执行IO操作了,此时会触发通知.允许在任意时刻重复检测IO的状态,# 没有必要每次描述符就绪后尽可能多的执行IO.select,poll就属于水平触发.## 边缘触发:如果文件描述符自上次状态改变后有新的IO活动到来,此时会触发通知.在收到一个IO事件通知后要尽可能# 多的执行IO操作,因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述# 符.信号驱动式IO就属于边缘触发.## epoll既可以采用水平触发,也可以采用边缘触发.## 大家可能还不能完全了解这两种模式的区别,我们可以举例说明:一个管道收到了1kb的数据,epoll会立即返回,此时# 读了512字节数据,然后再次调用epoll.这时如果是水平触发的,epoll会立即返回,因为有数据准备好了.如果是边# 缘触发的不会立即返回,因为此时虽然有数据可读但是已经触发了一次通知,在这次通知到现在还没有新的数据到来,# 直到有新的数据到来epoll才会返回,此时老的数据和新的数据都可以读取到(当然是需要这次你尽可能的多读取).# 下面我们还从电子的角度来解释一下:# # 水平触发:也就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知.上面提到的只要# 有数据可读(描述符就绪)那么水平触发的epoll就立即返回.# # 边缘触发:只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据# 可读,但是没有新的IO活动到来,epoll也不会立即返回. 简单实例实例1(non-blocking IO)： 12345678910111213141516171819202122232425262728293031import timeimport socketsk &#x3D; socket.socket(socket.AF_INET,socket.SOCK_STREAM)sk.setsockoptsk.bind((&#39;127.0.0.1&#39;,6667))sk.listen(5)sk.setblocking(False)while True: try: print (&#39;waiting client connection .......&#39;) connection,address &#x3D; sk.accept() # 进程主动轮询 print(&quot;+++&quot;,address) client_messge &#x3D; connection.recv(1024) print(str(client_messge,&#39;utf8&#39;)) connection.close() except Exception as e: print (e) time.sleep(4)#############################clientimport timeimport socketsk &#x3D; socket.socket(socket.AF_INET,socket.SOCK_STREAM)while True: sk.connect((&#39;127.0.0.1&#39;,6667)) print(&quot;hello&quot;) sk.sendall(bytes(&quot;hello&quot;,&quot;utf8&quot;)) time.sleep(2) break ​ 优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。 缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。 实例2(IO multiplexing): 在非阻塞实例中，轮询的主语是进程，而“后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。不过，这个监听的重任通过调用select等函数交给了内核去做。IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvfrom系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。 实例2: 1234567891011121314151617181920212223242526import socketimport selectsk&#x3D;socket.socket()sk.bind((&quot;127.0.0.1&quot;,9904))sk.listen(5)while True: r,w,e&#x3D;select.select([sk,],[],[],5) for i in r: # conn,add&#x3D;i.accept() #print(conn) print(&quot;hello&quot;) print(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&#39;) #*************************client.pyimport socketsk&#x3D;socket.socket()sk.connect((&quot;127.0.0.1&quot;,9904))while 1: inp&#x3D;input(&quot;&gt;&gt;&quot;).strip() sk.send(inp.encode(&quot;utf8&quot;)) data&#x3D;sk.recv(1024) print(data.decode(&quot;utf8&quot;)) 请思考：为什么不调用accept，会反复print？ 1select属于水平触发 实例3(server端并发聊天): 1234567891011121314151617181920212223242526272829303132333435#***********************server.pyimport socketimport selectsk&#x3D;socket.socket()sk.bind((&quot;127.0.0.1&quot;,8801))sk.listen(5)inputs&#x3D;[sk,]while True: r,w,e&#x3D;select.select(inputs,[],[],5) print(len(r)) for obj in r: if obj&#x3D;&#x3D;sk: conn,add&#x3D;obj.accept() print(conn) inputs.append(conn) else: data_byte&#x3D;obj.recv(1024) print(str(data_byte,&#39;utf8&#39;)) inp&#x3D;input(&#39;回答%s号客户&gt;&gt;&gt;&#39;%inputs.index(obj)) obj.sendall(bytes(inp,&#39;utf8&#39;)) print(&#39;&gt;&gt;&#39;,r)#***********************client.pyimport socketsk&#x3D;socket.socket()sk.connect((&#39;127.0.0.1&#39;,8801))while True: inp&#x3D;input(&quot;&gt;&gt;&gt;&gt;&quot;) sk.sendall(bytes(inp,&quot;utf8&quot;)) data&#x3D;sk.recv(1024) print(str(data,&#39;utf8&#39;)) 文件描述符其实就是咱们平时说的句柄，只不过文件描述符是linux中的概念。注意，我们的accept或recv调用时即向系统发出recvfrom请求 ​ (1) 如果内核缓冲区没有数据－－－&gt;等待－－－&gt;数据到了内核缓冲区，转到用户进程缓冲区； ​ (2) 如果先用select监听到某个文件描述符对应的内核缓冲区有了数据，当我们再调用accept或recv时，直接将数据转到用户缓冲区。 思考1：开启5个client，分别按54321的顺序发送消息，那么server端是按什么顺序回消息的呢？ 思考2: 如何在某一个client端退出后，不影响server端和其它客户端正常交流 linux： 123if not data_byte: inputs.remove(obj) continue win 1234567try: data_byte&#x3D;obj.recv(1024) print(str(data_byte,&#39;utf8&#39;)) inp&#x3D;input(&#39;回答%s号客户&gt;&gt;&gt;&#39;%inputs.index(obj)) obj.sendall(bytes(inp,&#39;utf8&#39;))except Exception: inputs.remove(obj) 延伸实例4: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#_*_coding:utf-8_*___author__ &#x3D; &#39;Alex Li&#39; import selectimport socketimport sysimport queue # Create a TCP&#x2F;IP socketserver &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.setblocking(False) # Bind the socket to the portserver_address &#x3D; (&#39;localhost&#39;, 10000)print(sys.stderr, &#39;starting up on %s port %s&#39; % server_address)server.bind(server_address) # Listen for incoming connectionsserver.listen(5) # Sockets from which we expect to readinputs &#x3D; [ server ] # Sockets to which we expect to writeoutputs &#x3D; [ ] message_queues &#x3D; &#123;&#125;while inputs: # Wait for at least one of the sockets to be ready for processing print( &#39;\\nwaiting for the next event&#39;) readable, writable, exceptional &#x3D; select.select(inputs, outputs, inputs) # Handle inputs for s in readable: if s is server: # A &quot;readable&quot; server socket is ready to accept a connection connection, client_address &#x3D; s.accept() print(&#39;new connection from&#39;, client_address) connection.setblocking(False) inputs.append(connection) # Give the connection a queue for data we want to send message_queues[connection] &#x3D; queue.Queue() else: data &#x3D; s.recv(1024) if data: # A readable client socket has data print(sys.stderr, &#39;received &quot;%s&quot; from %s&#39; % (data, s.getpeername()) ) message_queues[s].put(data) # Add output channel for response if s not in outputs: outputs.append(s) else: # Interpret empty result as closed connection print(&#39;closing&#39;, client_address, &#39;after reading no data&#39;) # Stop listening for input on the connection if s in outputs: outputs.remove(s) #既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉 inputs.remove(s) #inputs中也删除掉 s.close() #把这个连接关闭掉 # Remove message queue del message_queues[s] # Handle outputs for s in writable: try: next_msg &#x3D; message_queues[s].get_nowait() except queue.Empty: # No messages waiting so stop checking for writability. print(&#39;output queue for&#39;, s.getpeername(), &#39;is empty&#39;) outputs.remove(s) else: print( &#39;sending &quot;%s&quot; to %s&#39; % (next_msg, s.getpeername())) s.send(next_msg) # Handle &quot;exceptional conditions&quot; for s in exceptional: print(&#39;handling exceptional condition for&#39;, s.getpeername() ) # Stop listening for input on the connection inputs.remove(s) if s in outputs: outputs.remove(s) s.close() # Remove message queue del message_queues[s] 实例5: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# select 模拟一个socket server，注意socket必须在非阻塞情况下才能实现IO多路复用。# 接下来通过例子了解select 是如何通过单进程实现同时处理多个非阻塞的socket连接的。#server端import selectimport socketimport queueserver &#x3D; socket.socket()server.bind((&#39;localhost&#39;,9000))server.listen(1000)server.setblocking(False) # 设置成非阻塞模式，accept和recv都非阻塞# 这里如果直接 server.accept() ，如果没有连接会报错，所以有数据才调他们# BlockIOError：[WinError 10035] 无法立即完成一个非阻塞性套接字操作。msg_dic &#x3D; &#123;&#125;inputs &#x3D; [server,] # 交给内核、select检测的列表。# 必须有一个值，让select检测，否则报错提供无效参数。# 没有其他连接之前，自己就是个socket，自己就是个连接，检测自己。活动了说明有链接outputs &#x3D; [] # 你往里面放什么，下一次就出来了while True: readable, writeable, exceptional &#x3D; select.select(inputs, outputs, inputs) # 定义检测 #新来连接 检测列表 异常（断开） # 异常的也是inputs是： 检测那些连接的存在异常 print(readable,writeable,exceptional) for r in readable: if r is server: # 有数据，代表来了一个新连接 conn, addr &#x3D; server.accept() print(&quot;来了个新连接&quot;,addr) inputs.append(conn) # 把连接加到检测列表里，如果这个连接活动了，就说明数据来了 # inputs &#x3D; [server.conn] # 【conn】只返回活动的连接，但怎么确定是谁活动了 # 如果server活动，则来了新连接，conn活动则来数据 msg_dic[conn] &#x3D; queue.Queue() # 初始化一个队列，后面存要返回给这个客户端的数据 else: try : data &#x3D; r.recv(1024) # 注意这里是r，而不是conn，多个连接的情况 print(&quot;收到数据&quot;,data) # r.send(data) # 不能直接发，如果客户端不收，数据就没了 msg_dic[r].put(data) # 往里面放数据 outputs.append(r) # 放入返回的连接队列里 except ConnectionResetError as e: print(&quot;客户端断开了&quot;,r) if r in outputs: outputs.remove(r) #清理已断开的连接 inputs.remove(r) #清理已断开的连接 del msg_dic[r] ##清理已断开的连接 for w in writeable: # 要返回给客户端的连接列表 data_to_client &#x3D; msg_dic[w].get() # 在字典里取数据 w.send(data_to_client) # 返回给客户端 outputs.remove(w) # 删除这个数据，确保下次循环的时候不返回这个已经处理完的连接了。 for e in exceptional: # 如果连接断开，删除连接相关数据 if e in outputs: outputs.remove(e) inputs.remove(e) del msg_dic[e]#*************************clientimport socketclient &#x3D; socket.socket()client.connect((&#39;localhost&#39;, 9000))while True: cmd &#x3D; input(&#39;&gt;&gt;&gt; &#39;).strip() if len(cmd) &#x3D;&#x3D; 0 : continue client.send(cmd.encode(&#39;utf-8&#39;)) data &#x3D; client.recv(1024) print(data.decode())client.close() 实例6: 1234567891011121314151617181920212223242526272829303132import selectorsimport socketsel &#x3D; selectors.DefaultSelector()def accept(sock, mask): conn, addr &#x3D; sock.accept() # Should be ready print(&#39;accepted&#39;, conn, &#39;from&#39;, addr) conn.setblocking(False) sel.register(conn, selectors.EVENT_READ, read)def read(conn, mask): data &#x3D; conn.recv(1000) # Should be ready if data: print(&#39;echoing&#39;, repr(data), &#39;to&#39;, conn) conn.send(data) # Hope it won&#39;t block else: print(&#39;closing&#39;, conn) sel.unregister(conn) conn.close()sock &#x3D; socket.socket()sock.bind((&#39;localhost&#39;, 1234))sock.listen(100)sock.setblocking(False)sel.register(sock, selectors.EVENT_READ, accept)while True: events &#x3D; sel.select() for key, mask in events: callback &#x3D; key.data callback(key.fileobj, mask) 注：本文最重要的参考文献是Richard Stevens的“UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking ” http://mp.weixin.qq.com/s__biz=MzA4MjEyNTA5Mw==&amp;mid=2652563599&amp;idx=1&amp;sn=9781747e54d906c0c140228376e671ed&amp;scene=21#wecha t_redirect https://pymotw.com/2/select/#module-select http://blog.csdn.net/lingfengtengfei/article/details/12392449 http://www.jb51.net/article/37416.htm https://pymotw.com/2/select/#module-select","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://sjtu-xx.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"}]},{"title":"Abaqus有限元分析","slug":"Abaqus有限元分析","date":"2020-06-25T14:07:58.000Z","updated":"2021-02-03T15:59:45.474Z","comments":true,"path":"2020/06/25/Abaqus有限元分析/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/25/Abaqus%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90/","excerpt":"接触","text":"接触 ABAQUS中的两种接触方式小滑移（两接触面之间只有很小的滑动）分析的开始就确定了从面节点和主面的哪一部分发生接触，在整个分析过程中，这种接触关系不再发生变化。小滑移的计算代价小于有限滑移。 有限滑移（两个接触面之间任意滑动）要求主面是光滑的，否则会出现收敛问题 接触属性的定义1.法向作用：ABAQUS中的接触压力和间隙的关系默认是“硬接触”，即接触面之间能够传递的接触压力大小不受限制，当接触压力为负或零时，接触面发生分离。 定义两接触面的距离通过ADJUST关键字定义。小于ADJUST时认为接触 过盈接触（CONTACT INTERFERENCE）过盈量为负值表示过盈接触，正值表示两个面之间存在间隙 接触分析中的收敛问题MSG文件CONTACT CHANGE SUMMARY：1 closures 10 openings，从面的节点有闭合和开放两种状态。无法收敛的集中常见情况： 闭合与开放的数目不断减少，但不断出现1 closures 0 openings和0 closures 1 openings，这种情况无法通过减小时间增量步达到收敛。 闭合与开放时而减小时而增大。这种情况应当减小时间增量步再看。 闭合与开放减小速度慢。调整最大迭代次数。 出现收敛问题 检查接触关系，边界条件和约束View -&gt; ODB View -&gt; 显示连接 消除刚体位移出现不确定的刚体位移时，在MSG文件中会显示数值奇异警告信息，有时还会显示负特征值警告信息检查刚体的约束条件 使用绑定约束如果某一对接触面的接触状态对整个模型的影响不大，或者这一对接触面在整个分析过程中始终密切接触，就可以考虑将他们的接触关系改为绑定约束，从而大大减少计算接触状态所需的迭代。 建立平稳的接触关系不要在一个增量步施加所有的载荷。应先定义一个只有很小载荷的增量步，在下一步中再施加真实载荷。 细化网格一般圆角处至少10个单元 正确定义主面和从面 刚度大、网格粗的为主面 主面在发生接触的部位不要有大的尖角或凹角 如果主面和从面在几何位置上没有发生重叠，则一个面的法向应指向另一个面所在的一侧 如果是有限滑移，在整个分析过程中尽量不要让从面结点落到主面外 使用一阶单元 避免过约束 慎重定义摩擦 减小初始时间增量步 解决震颤问题 确保主面足够大 使用自动过盈接触限度有助于解决震颤 主面足够光滑 如果模型有较长的柔性部件，并且接触压力较小，就应将接触属性设置为软接触。如果只有很少的从面结点和主面接触，就应细化接触面网络，或将接触属性设置为软接触。 ABAQUS接触问题无法使用多线程进行计算 材料非线性 塑性 超弹性 粘弹性（时间硬化模型，应变硬化模型，双曲正弦模型） 结构模态分析动力学分析是将惯性力包含在动力学平衡方程式中： M\\ddot{u}+I-f=0其中M是结构质量，$\\ddot{u}$是加速度，I是内力，f是外力 无载荷情况下：$M\\ddot{u}+I=0$ 对于无阻尼系统上式可化为：$M\\ddot{u}+Ku=0$，方程解的形式为$u=\\phi exp(i\\bar{\\omega}t)$，将上式代入运动方程中就会得到特征值问题方程$K\\phi_i=\\lambda M\\phi_i$。该系统有n个特征值，此时n是有限元模型的自由度数。$\\bar{\\omega}_i$是结构的第i阶固有频率，$\\phi_i$是相应的第i阶特征向量。 阻尼的设定： 直接模态阻尼（定义每阶振型的临界阻尼比） Rayleigh阻尼（质量矩阵和刚度矩阵的线性组合） 复合阻尼（定义每种材料的临界阻尼比） 模态分析步骤 建模。必须定义密度，只能使用线性单元和线性材料，非线性性质将被忽略。 定义分析步。定义一个线性摄动步的频率提取分析步。模态提取选项和其他选项。 施加边界条件，载荷并求解 结构谐响应分析谐响应分析主要用来确定线性结构在承受持续的周期载荷时的周期性响应。在谐响应分析中的非线性特性将被忽略。 谐响应分析通常用于如下结构的设计与分析： 旋转设备的支座、固定装置和部件等 受涡流影响的结构，包括涡轮叶片，飞机机翼，桥和塔等。 结构多体系统分析注意： 在部件、装配模块或相互作用模块中定义连接单元和约束所需定义的参考点和基准坐标系。 在相互作用模块中定义连接属性，连接单元和约束 在载荷模块中定义载荷和边界条件，以及连接单元载荷和连接单元边界条件 在分析步模块中，默认的输出变量是不包括连接单元的，需要单独进行连接单元的历史输出变量。 是否考虑几何非线性 ABAQUS/Explicit显式分析显示方法与隐式方法的区别 所谓显式指的是增量步结束时的状态仅依赖于该增量步开始时的位移、速度和加速度，这种方法可以精确的积分常值的加速度。为了使该方法产生精确的结果，要求时间增量要足够小，所以在增量步中的加速度几乎为常数。由于时间增量必须很小，所以需要大量的增量步。由于在显式分析中不需要求解联立方程组，所以每一个增量步的计算成本很低。 显式算法最大优点是有较好的稳定性。 动态显式算法采用动力学方程的一些差分格式(如广泛使用的中心差分法、线性加速度法等),不用直接求解切线刚度,不需要进行平衡迭代,计算速度快,时间步长只要取的足够小,一般不存在收敛性问题。 显式算法不需要迭代,也不需要组集总刚,因此需要的内存也比隐式算法要少。并且数值计算过程可以很容易地进行并行计算,程序编制也相对简单。但显式算法要求质量矩阵为对角矩阵,而且只有在单元级计算尽可能少时速度优势才能发挥, 因而往往采用减缩积分方法,容易激发沙漏模式,影响应力和应变的计算精度。” 静态显式法基于率形式的平衡方程组与Euler向前差分法,不需要迭代求解。由于平衡方程式仅在率形式上得到满足,所以得出的结果会慢慢偏离正确值。为了减少相关误差,必须每步使用很小的增量。这个方法目前应用比较少。 显式算法和隐式算法比较 算法 显式算法 隐式算法 (01)适用问题 动力学(动态) 静力学(静态) (02)阻尼 人工阻尼 数值阻尼 (03)每步求解方法 矩阵乘法 线性方程组 (04)大矩阵(总刚) 否 是 (05)数据存贮量 小 大 (06)每步计算速度 快 慢 (07)迭代收敛性 无 有 (08)确定解 有确定解 可能是病态无确定解 (09)时步稳定性 有条件 无条件 (10)时间步 小 大 (11)计算精度 低 高 显式算法基于动力学方程无需迭代；静态隐式算法基于虚功原理需要迭代。 ABAQUS/Explicit显式分析解决的问题 复杂的接触问题 高速动力学事件 复杂的后屈曲问题（随着载荷增加，结构的刚度发生剧烈变化） 高度非线性的准静态问题（复杂的接触，如锻造、滚压、薄板成型） 材料的退化和失效问题（其常导致严重的收敛困难） ABAQUS用户子程序编写用户子程序的条件 用户子程序不能嵌套，任何用户子程序都不能调用任何其他用户子程序，但可以调用用户自己编写的Fortran子程序和ABAQUS应用程序。当用户编写Fortran子程序时，建议子程序名以K开头，以免和ABAQUS内部程序冲突。 ABAQUS应用程序必须由用户子程序调用。 当用户在用户子程序中利用open打开外部文档时：1.设备号只能选择15～18和大于100的设备号，其余的已经被ABAQUS占用；2.用户需要提供外部文件的绝对路径而不是相对路径。","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"Abaqus","slug":"Abaqus","permalink":"https://sjtu-xx.github.io/tags/Abaqus/"}]},{"title":"有限元","slug":"有限元","date":"2020-06-06T02:19:10.000Z","updated":"2021-02-03T15:59:46.449Z","comments":true,"path":"2020/06/06/有限元/","link":"","permalink":"https://sjtu-xx.github.io/2020/06/06/%E6%9C%89%E9%99%90%E5%85%83/","excerpt":"简介力学的分类","text":"简介力学的分类 描述航天器： 刚体：描述姿态 变形体：对姿态的耦合和影响 质点：描述轨道 力学的分类： 质点力学：使用牛顿三大定律求解 刚体力学（理论力学）：牛顿三大定律；刚体转动的牛顿方程（动量矩方程） 简单形状变形体： 几何变形 力的平衡 物理本构方程 复杂形状变形体（弹性力学）： 几何变形 力的平衡 物理本构方程（材料行为） 弹塑性力学： 几何变形 力的平衡 物理本构方程（材料行为） 微分方程的求解解析法差分法使用差分代替微分 \\frac{d^2u}{dx^2}=\\frac{u_{i-1}-2u_i+u_{i+1}}{\\Delta l^2}试函数法 选择试函数使其满足边界条件 带入控制方程使试函数残差最小 函数逼近问题 基于全域，使用傅里叶级数逼近。这种方法对于3D问题很难求解。 基于子域，分段展开。分片函数逼近：几何-&gt;几何离散-&gt;基本构件（单元） 弹性力学弹簧的力学分析原理 $$ \\left[\\begin{matrix}k & -k \\\\ -k & k\\end{matrix}\\right] \\left[\\begin{matrix}u_1 \\\\u_2\\end{matrix}\\right] = \\left[\\begin{matrix}F_1 \\\\F_2\\end{matrix}\\right] \\tag{1} $$ 弹性力学 弹性力学平面问题为了保持边界位移的连续性，假设单元内任意一点的位移为其坐标的线性函数，这样边界的变化就是线性的。形函数：任意一点的位移可以用单元节点的位移表示，系数称为形函数。单元的应力和应变都是常数。 弹性力学的变形体假设连续、均匀、各向同性、线弹性、小变形 指标记法F_i = [F_1,F_2,F_3]\\sum_{j=1}^{i}a_{ij}x_j=b_i\\ \\Rightarrow\\ a_{ij}x_j=b_iVoigt标记（将高阶自由指标张量写成低阶张量） $$\\sigma_{ij}=\\left[\\begin{matrix}\\sigma_{11} & \\sigma_{12}\\\\ \\sigma{21} & \\sigma_{22}\\end{matrix}\\right]\\ \\Rightarrow对称张量写一半 \\Rightarrow\\ \\sigma=\\left[\\begin{matrix}\\sigma_{11} \\\\ \\sigma_{22} \\\\ \\sigma_{12}\\end{matrix}\\right]$$ $$\\sigma_{ij}=\\left[\\begin{matrix}\\sigma_{11} & \\sigma_{12} & \\sigma_{13}\\\\ \\sigma_{21} & \\sigma_{22} & \\sigma_{23}\\\\ \\sigma_{31} & \\sigma_{32} & \\sigma_{33}\\\\\\end{matrix}\\right]\\ \\Rightarrow对称张量写一半 \\Rightarrow\\ \\sigma=\\left[\\begin{matrix}\\sigma_{11} \\\\ \\sigma_{22} \\\\ \\sigma_{33} \\\\ \\sigma_{23} \\\\ \\sigma_{13} \\\\ \\sigma_{12}\\end{matrix}\\right]$$ 三大类变量和三大类方程三大类变量：位移、应力、应变 三大类方程：几何方程、平衡方程、无理方程 平面问题的平衡方程力平衡方程 力平衡 力矩平衡 $$ \\left\\{ \\begin{array}{lr} \\frac{\\partial{\\sigma_{xx}}}{\\partial{x}}+\\frac{\\partial{\\tau_{xy}}}{\\partial{y}}+\\bar{b_x}=0 & \\\\ \\frac{\\partial{\\sigma_{xx}}}{\\partial{x}}+\\frac{\\partial{\\tau_{xy}}}{\\partial{y}}+\\bar{b_x}=0 \\end{array} \\right. \\Rightarrow 指标形式：\\sigma_{ij,j}+\\bar{b_i}=0 $$ 几何方程 $$\\left\\{\\begin{array}{lr}\\epsilon_{xx}=\\frac{\\partial{u}}{\\partial{x}}&\\\\ \\epsilon_{yy}=\\frac{\\partial{u}}{\\partial{y}} &\\\\ \\gamma_{xy} = \\frac{\\partial u}{\\partial y}+\\frac{\\partial u}{\\partial x}\\end{array}\\right.\\Rightarrow 指标形式（约定\\epsilon_{ij}=\\frac12\\gamma_{ij}\\ (i\\neq j)）：\\epsilon_{ij}=\\frac12(u_{i,j}+u_{j,i})$$ 物理方程 $$ \\left\\{\\begin{array}{lr} \\epsilon_{xx}=\\frac1E(\\sigma_{xx}-\\mu\\sigma_{yy}) \\\\ \\epsilon_{yy}=\\frac1E(\\sigma_{yy}-\\mu\\sigma_{xx}) \\\\ \\gamma_{xy}=\\frac1G\\tau_{xy} \\end{array} \\right. \\Rightarrow 指标形式: \\epsilon_{ij}=C_{ijkl}\\sigma_{kl} $$ 边界条件 位移边界$S_u$ 力边界$S_p$ 无边界区域对应（力为0的边界） 典型问题平面纯弯梁的描述3D问题 $$ \\left\\{\\begin{array}{lr} 位移（3个）\\\\应力（9个）\\\\应变（9个） \\end{array} \\right. \\stackrel{}{\\Rightarrow} \\left\\{\\begin{array}{lr} 位移（3个）\\\\应力（6个）\\\\应变（6个） \\end{array} \\right. (三组剪应力应变互等) $$ 维度 1D 2D 3D 平衡方程 1 2 3 几何方程 1 3 6 物理方程 1 2 3 边界条件（几何） 1 2 3 边界条件（外力） 1 2 3 张量坐标变换 $$ \\left[\\begin{matrix}x^{(2)} \\\\ y^{(2)}\\end{matrix}\\right]= \\left[\\begin{matrix}cos(x^{(2)},x^{(2)}) & cos(x^{(2)},y^{(1)}) \\\\ cos(y^{(2)},x^{(1)}) & cos(y^{(2)},y^{(1)}))\\end{matrix}\\right] \\left[\\begin{matrix}x^{(1)} \\\\ y^{(1)}\\end{matrix}\\right] = \\left[\\begin{matrix}cos\\alpha & sin\\alpha \\\\ -sin\\alpha & cos\\alpha)\\end{matrix}\\right] \\left[\\begin{matrix}x^{(1)} \\\\ y^{(1)}\\end{matrix}\\right] $$ $\\alpha$为两坐标系转动夹角,T为转置矩阵$\\left[\\begin{matrix}cos\\alpha & sin\\alpha \\\\ -sin\\alpha & cos\\alpha)\\end{matrix}\\right]$ 张量存在不变量，不随坐标系的变化而变化，这些变量是重要的分析对象二阶张量$\\sigma^{(2)}=T\\sigma^{(1)}T^T$ 虚功原理和最小势能原理弹性变形体力学方程的求解方法 直接求解：解析法、半解析、差分 间接求解 加权残值法（伽辽金加权残值、残值最小二乘法） 虚功原理 最小势能原理 变分方法 简介求解的关键是1.试函数的选择，2.试函数带入原方程求误差 伽辽金加权残值法试函数：将满足边界条件的试函数$\\phi_i(x)$组合为新的试函数$\\hat{v}(x)=c_1\\phi_1(x)+…+c_n\\phi_n(x)$,$c_i$为待定系数 伽辽金法的权值为试函数残值: $\\int\\Omega{w{ti}R(x,y,z)d\\Omega}$$w{t_i}=\\phi_i$ 残值最小二乘法的权值为$w_{t_i}=1$ 如何降低试函数对高阶导数及边界条件的要求将三大类变量（位移、应力、应变）代换为一类变量（位移） 弹性问题加权残值法的难点： 试函数要满足所有边界条件 -&gt; 只满足位移边界 试函数最高阶导数较高（梁弯曲问题要求4阶导数存在，一般弹性问题要求2阶导数存在）-&gt; 虚功原理和最小势能原理可以将最高阶导数降低一半 虚功原理虚功原理：虚功总和为0 \\delta W-\\delta U =0（W外力虚功，U内力虚功）截面惯性矩$I=\\int{y^2dA}$ 若试函数为$\\hat{v}(x)=C_1sin(\\frac{\\pi x}{l})$，虚位移场为$\\delta\\hat{v}(x)=\\delta C_1sin(\\frac{\\pi x}{l})$ 最小势能原理：$min(U-W)$ 能量原理加权残值法的试函数满足位移边界条件和力边界条件，最终加权残值满足控制方程。 能量方法的试函数只满足位移边界条件，但可以证明其最终的求解结果也满足力边界条件和控制方程 有限元方法基于试函数的经典方法与有限元方法有限元方法的思路：几何→几何离散→基本构件→集成→几何 离散方法 自然离散→规则桁架 逼近离散→连续体 混合离散 有限元方法的步骤 几何离散 单元研究 单元继承 边界条件处理 计算支反力 计算其他物理量 单元研究： 节点 节点基本变量：坐标、位移、力 单元 三大类变量描述：刚度方程→多项式从低阶到高阶，待定系数个数与节点自由度对应 位移场：$u(x)=Nq^{e}$ 应变场：$\\epsilon(x)=B(x)q^{e}$ 应力场：$\\sigma=DB(x)q^{e}$ 应变能：$U=\\frac12q^{e^T}K^eq^e$ 外力功：$W=p^{e^T}q^e$ 形函数的计算单元节点的自由度为4位移场函数$v(x)=a_0+a_1x+a_2x^2+a_3x^3$单元节点条件 $$ \\left\\{ \\begin{array}{lr} v(0)=v_1 & v^{'}(0)=\\theta_1 \\\\ v(l)=v_2 & v^{'}(l)=\\theta_2 \\end{array} \\right. $$ $v(x)=N(\\xi)q^e$ 分布力转换为节点处的等效载荷 常见平面单元平面三节点单元应变场为常数应力场为常数位移场为完全线性函数($u(x,y)=a_0+a_1x+a_2y$,$v(x,y)=b_0+b_1x+b_2y$) 基于整体坐标建立节点位移，没有坐标变换问题 对于应变梯度大的区域，加密或高阶单元 平面四节点单元位移场为完全线性+交叉项函数（$u(x,y)=a_0+a_1x+a_2y+a_3xy$）应变场为不完全线性: $$ \\epsilon = \\left[\\begin{matrix}a_1+a_3y\\\\ b_2+b_3x \\\\ a_2+b_1+a_3x+b_3y \\end{matrix}\\right] $$ 应力场：$\\sigma=D\\epsilon$ 空间单元空间四节点单元（与平面三节点单元类似）应变场为常数应力场为常数没有坐标变换问题 空间8节点正六面体单元与平面4节点单元类似参数单元基准单元：基准坐标系； 物理单元：物理坐标系需要进行几种映射：坐标函数映射、偏导数映射、面积（体积）映射 收敛性亚参元和等参数单元保证收敛；超参数单元不保证收敛 亚参元：几何形状插值函数阶次&lt;位移插值函数阶次等参数单元：几何形状插值函数阶次=位移插值函数阶次 形函数和刚度矩阵的性质形函数 $N_i$表示i节点位移为1，其他节点位移为0时的单元位移场函数 $\\sum_{i=0}^{n}N_i(x)=1$表明其能描述刚体位移 刚度矩阵 对角元素$k_{ii}$表示要使i节点产生单位位移($u_i=1$)，其他节点位移为0时，需要在节点i施加的力 非对角元素$k_{ij}$表示要使j节点产生单位位移($u_j=1$)，而其他节点位移为0时，需要在节点i施加的力 单元刚度矩阵是对称的 单元刚度矩阵是半正定的 单元刚度矩阵奇异（行列式=0） 总体刚度矩阵 对称 奇异 半正定 稀疏 非零元素带状分布 边界条件的处理与支反力的计算 直接法 置一法（针对($\\bar{q_r}=0$)） 乘大数法（针对($\\bar{q_r}=\\bar{u}$)） 罚函数法（大刚度的弹簧） 位移函数的构造与收敛性要求收敛性准则： 完备性要求（针对单元内部:常应变项与常位移项）。如果在势能泛函中所出现的位移函数的最高阶导数是m阶，则有限元解答收敛的条件之一是单元内位移场函数的试函数至少是m阶多项式。 协调性要求。如果势能泛函中位移函数最高阶是m阶，则位移势函数在单元交界面上必须具有直至m-1阶连续倒数 位移函数参数个数与节点自由度（DOF）相等。 -》 唯一性 C0与C1单元C0单元：势能泛函中位移函数出现的最高阶导数是1阶，在单元交界面上具有0阶连续导数，只要求位移连续 一般杆单元，平面问题单元，空间问题单元都是C0单元。 C1单元：势能泛函中位移函数出现的最高阶导数是2阶，在单元交界面上具有1阶连续导数 梁单元，板单元，壳单元都是C1单元。 单元拼片实验单元位移函数满足完备性要求-&gt;单元是完备的（容易满足）单元位移函数满足协调性要求-&gt;单元是协调的（C1型单元不容易满足）单元位移函数满足完整性和协调性要求-&gt;协调单元 非协调单元：某些情况下，可以放松对协调性的要求，只要单元通过拼片试验，解答仍收敛于正确解，这种单元称为非协调单元 近似解$|q_{appr}|&lt;|q_exact|$精确解 控制误差和提高精度的h方法和p方法h方法（high density）加密单元。数值稳定性和可靠性好，但收敛较慢，效率低 p方法（polynomial）增加单元基地函数阶次。收敛性优于h方法，但数值稳定性差。 自适应方法：利用上一步计算结果修改有限元模型，计算量小，精度高。对给定自由度求最有玩咯 子结构与超级单元结构的重复性：几何空间上，采用子结构；计算时间上，采用超级单元 非线性分析结构振动的有限元分析基本原理：变形体存在固有频率和振动模态 三大类变量：位移$u_i(\\xi,t)$、应变$\\epsilon_{ij}(\\xi,t)$、应力$\\sigma_{ij}(\\xi,t)$ 基本方程：平衡方程：由DAlembert原理$\\sigma_{ij,j}(t)+\\bar{b_i}(t)-\\rho\\ddot{u_i}(t)-v\\dot{u_i}=0$ 几何方程：与普通分析一致 物理方程：与普通分析一致 边界条件：与普通分析一致 初始条件：$u_i(\\xi,t=0)=u_i(\\xi)$ $\\dot{u_i}(\\xi,t=0)=\\dot{u_i}(\\xi)$ 单元的节点位移矩阵：$q_t^e(t)=\\left[\\begin{array}{lr}u_1(t) &amp; v_1(t) &amp; w_1(t)&amp;… &amp; u_n(t) &amp; v_n(t) &amp; w_n(t)\\end{array}\\right]^T$ 位移插值函数：$u^e(\\xi,t)=N(\\xi)q_i^e(t)$ $\\dot{u}^e(\\xi,t)=N(\\xi)\\dot{q}_i^e(t)$ $\\ddot{u}^e(\\xi,t)=N(\\xi)\\ddot{q}_i^e(t)$ 方程：$M^e\\ddot{q}_i^e(t)+C^e\\dot{q}_i^e(t)+K^eq_i^e(t)=P_t^e(t)$ 单元质量矩阵：$M^e=\\int_\\Omega\\rho N^TNd\\Omega$ 单元阻尼矩阵：$C^e=\\int_\\Omega v N^TNd\\Omega$ 单元刚度矩阵：$K^e=\\int_\\Omega B^T DBd\\Omega$ 力矩阵：$Pt^e=\\int\\Omega N^T\\bar{b}d\\Omega+\\int_{S_p}N^T\\bar{p}dA$ 对于无阻尼(v=0)自由(p=0)振动:$M\\ddot{q}+Kq=0$，这个方程的解的形式为$q_t=\\hat{q}e^{iwt}$。带入到方程中得到：$(-w^2M\\hat{q}+K\\hat{q})e^{iwt}=0$，即$(K-w^2M)\\hat{q}=0$。方程由非零解的条件为$|K-w^2M|=0$。 质量矩阵：一致质量矩阵；集中质量矩阵（将一直质量矩阵行/列集中到对角线） 非线性方程的求解 直接迭代 Newton-Raphson(NR)迭代。分步逼近，在每个载荷段内进行非线性方程的迭代，特点：在迭代中，非线性方程变为线性方程 改进的NR方法 传热问题传热问题的控制方程Fourier传热定律、能量守恒定律 三类边界条件给定的温度分布（第一类）、给定热流密度（第二类）、给定对流换热系数（第三类） 几个常见的问题线性分析与非线性分析线性分析：若K为常数矩阵，则外载荷与系统响应之间为线性关系非线性：K变化 非线性：材料非线性、几何非线性（大变形、大转动）、边界条件非线性（接触） 求解方法： 隐式求解。将分析过程分为一系列增量步，在每个增量步迭代至合理解。 显式求解。显式地从上一个增量步推算动力学平衡方程 一阶/二阶 完全/减缩 概念线性单元仅在角点处布置节点，在各方向采用线性插值。 二次单元不仅在节点处，在每边的中点也有节点，在各方向采用二次插值 完全积分：当单元具有规则形状时，所用高斯积分点数目足以对单元刚度矩阵多项式进行精确积分。 减缩积分：比完全积分每个方向少一个积分点（只有四边形和六面体单元才能使用减缩积分）。 可能出现的问题剪力自锁：存在于所有的线性完全积分单元中 原因：线性单元的边无法弯曲，使得应变作用下产生剪切变形而无法弯曲变形，单元过于刚硬。 改进:使用二次单元 沙漏：线性减缩积分单元由于沙漏问题，过于柔软 原因：在单元变形时，积分点处应力分量也可能为0，没有产生应变能，即这种弯曲是零能模式。这种零能模式会在网络中扩展。 二次减缩积分也存在沙漏，但在正常网格中不会扩展。 体积锁死：本应产生体积变化，却未变化 条件：完全积分，材料几乎不可压缩（v=0.5） 改进：细化网格 注意事项 线性完全积分单元容易出现剪切自锁和体积自锁，一般不使用 如果存在应力集中，需要计算较精确的应力，建议使用二阶完全积分单元 二阶减缩积分单元既可以较精确的模拟应力，又可以较准确的模拟小变形，因而是应力/位移模拟的最佳选择 如需要模拟大变形或接触分析，采用线性减缩积分是最好的选择。但应细化网络来避免沙漏，在厚度方向应大于4个单元 静力结构分析使用二阶完全积分单元。非线性分析/接触分析使用线性减缩积分单元 只有确信载荷只会在模型中产生很小的弯曲时，才能使用线性完全积分单元 在受轴向和剪切载荷时，线性完全积分单元表现很好 线性减缩积分单元能很好地承受扭曲变形 受弯：二次单元优于线性单元；； 受扭：线性单元优于二次单元 完全各向异性材料：$C_{ij}$，21个独立分量各向同性材料的刚度系数： $$ \\left[ \\begin{matrix} C_{11} & C_{12} & C_{12} & 0 & 0 &0\\\\ C_{12} & C_{11} & C_{12} & 0 & 0 &0\\\\ C_{12} & C_{12} & C_{11} & 0 & 0 &0\\\\ 0 & 0 & 0 & \\frac{C_{11}-C_{12}}2 & 0 &0\\\\ 0 & 0 & 0 &0 & \\frac{C_{11}-C_{12}}2 & 0\\\\ 0 & 0 & 0 &0&0 & \\frac{C_{11}-C_{12}}2\\\\ \\end{matrix} \\right] $$ 广义变分原理约束变分原理拉格朗日乘子法对于一个使泛函$\\Pi(\\textbf{u})$取驻值的问题，如果其场函数$\\textbf{u}$需满足的附加条件为： \\{C(\\textbf{u})\\}=\\{0\\}\\ (在域\\Omega内)则将其引用泛函$\\Pi(\\textbf{u})$得到一修正的泛函： $$\\Pi^{*}(\\textbf{u,}\\lambda)=\\Pi(\\textbf{u})+\\int_{\\Omega}\\{\\lambda\\}^T\\{C(\\textbf{u})\\}d\\Omega$$ $\\lambda$为一组独立的坐标函数，称为拉格朗日乘子。 拉格朗日乘子会导致待定系数的增加，从而增加了计算量。 罚函数法罚函数法与拉格朗日的区别是引入附加条件的形式不同，拉格朗日乘子法引入是附加条件的原型，即${C(\\textbf{u})}={0}$，而罚函数法则是附加条件乘积的形式。 $$\\{C(\\textbf{u})\\}^T\\{C(\\textbf{u})\\}=\\{C_1^2(\\textbf{u})\\}+\\{C_2^2(\\textbf{u})\\}+...+\\{C_n^2(\\textbf{u})\\}$$ 当附加条件得到满足时，上式为0，否则它大于0.显然上式的变分在满足:$\\delta({C(\\textbf{u})}^T{C(\\textbf{u})})=0$的条件下是最小的。因此，罚函数法利用一个充分大的系数将附加条件以乘积的形式引入泛函。 $$\\Pi^{**}(\\textbf{u})=\\Pi(\\textbf{u})+\\alpha\\int_\\Omega\\{C(\\textbf{u})\\}^T\\{C(\\textbf{u})\\}d\\Omega$$ $\\alpha$被称为罚函数，若泛函本身是极小值问题，则$\\alpha$取正数。罚函数选择很重要，如何选择合适的$\\alpha$不易。 非线性问题的求解方法直接迭代法每次迭代需要重新计算刚度矩阵并求逆，计算量较大。（割线刚度法） 收敛性：对刚度退化的系统，直接迭代法收敛。对刚度硬化的系统，直接迭代法不收敛。 牛顿-拉夫森方法每次迭代需要重新计算系数矩阵并求逆，计算量较大。（切线刚度法） 修正的牛顿-拉夫森方法迭代过程不需要重新计算系数矩阵，只计算一次。 增量法 求解线性方程组的迭代法雅可比迭代法每次迭代全部采用上次的迭代结果 高斯-赛尔德迭代法超松弛迭代法改善了高斯-赛尔德迭代法的收敛性 单元类型一维单元拉格朗日单元在n个节点上的函数值连续 Hermite单元在节点上的函数值和导数都连续 高阶Hermite单元在节点上的函数值和高阶导数连续。 求解算法中显式和隐式的区别隐式和显式有限元的最大区别在于是否迭代，所有的物理量是否在同一时刻获得。 采用隐式迭代求解平衡方程（位移、速度、加速度），不管是否采用隐式与显式的方式（前向、后向欧拉算法）求解本构方程（应力、应变），都叫做隐式有限元。 对于本构方程的求解，通常分为前向和后向欧拉算法。对于后向欧拉算法求解弹塑性问题，所有的物理量（包括等效塑性应变增量、N+1迭代步的应变和应力以及相关依赖于solution的状态变量）均是同时求解获得，因为涉及到多个物理量，而通常情况下他们是相互依赖、相互成为函数，所以必须通过牛顿迭代同时求解几个方程（如采用试应力方程、屈服函数径向返回算法（对于各向异性，也叫回映算法，最近点的投射算法）联合求解等效塑性应变增量）。对于前向欧拉，直接由N时刻的应力和应变求出N+1时刻的应力和应变，无需迭代。 https://blog.csdn.net/wu_nan_nan/article/details/53173302 前向欧拉（显式欧拉）：条件稳定.后向欧拉（隐式欧拉）：无条件稳定。 实际应用中，隐式欧拉需要求解隐式方程，通常也是使用逼近的方法（例如，Newton-Raphson）求解，因此实际的隐式欧拉方法并不是无条件稳定的。 对于平衡方程的求解，通常分为隐式和显式有限元算法。对于隐式有限元算法，由应力平衡方程+边界条件变分之后获得的刚度方程KU=F，隐式求解必须引入雅可比矩阵（二次收敛、只影响计算速率、不影响数值精度；K又称为雅可比），其是实时更新的，是N+1时刻的应力、应变以及状态变量（如损伤内变量）的函数，隐式求解是很robust的，确保了计算精度，但是不足之处在于计算非常expensive，每次迭代都要计算K的逆矩阵，也容易产生数值收敛性问题，目前解决的方法有弧长法、粘性阻尼法等，个人认为粘性阻尼法效果最好。 对于显示算法，采用时间积分，用t+1时刻的积分点应力、应变，获得t+1时刻的节点位移，无需迭代求解，也不需要雅可比矩阵（应力对应变偏导数）；如果硬是要有，连续雅可比，基于本构模型而不是刚度方程推导近似的连续雅可比。对于显示算法，单元高斯积分点应力、应变的求解可用前向或者后向欧拉方法，然后通过时间积分求取节点位移。本质上，平衡方程中位移的迭代求解与本构方程中的应力、应变求解没有关联，这点很容易造成误解，很多时候将前、后欧拉算法视为显式和隐式的区别，大大错误。通常应用较广的显示算法纽马克法、威尔逊-sita法，其中改变纽马克法中的两个参数，可以实现隐式与显式求解，其中alpha=0.5和beta=0是中心差分法(二阶精度)。目前一个大的误区认为只有显示算法可以求解动力学问题，隐式只能求解准静态问题（如低速冲击），alpha=0.5和beta=0.25就是隐式，所有的物理量在t+1时刻同时求解，通常ABAQUS软件中所说的隐式动力学求解采用了斯坦福大学Hilber、HUGHES院士（现在德克萨斯大学奥斯丁分校）和加州大学伯克利分校Taylor院士提出的无条件稳定隐式差分算法，可以求解低速动力学问题，缺点是不适合含阻尼的求解、计算效率不高；alpha=0.5和beta=0时的纽马克法更适合求解动力学问题，主要原因在于比隐式求解计算效率更高，不足之处在于其是条件稳定，时间增量过大位移解容易震荡，根本原因是差分算法的条件稳定导致的，时间增量必须非常小（其值越大，一方面不稳定、另一方面计算误差也更大），其依赖于波速、弹性模量和最小单元网格尺寸，这是显式算法计算最耗时的地方。相对于隐式算法，显式算法的功能更强大，通常计算依赖于率的变形和应力，也可以求解稳态问题，如alpha=0.5和beta=0时，对于刚度方程中引入阻尼矩阵后，叫做动态松弛法，可以解决静力学问题的一些稳态问题（如重力、预应力引起的初始应力）。此外，一些准静态的剪切自锁问题，本质上有解，但是用牛顿法求解失效，中心差分引入质量矩阵后，可以获得正常的解。需要注意的是，时间积分算法通常采用Lumped集中对角质量矩阵而不是一致质量矩阵，以提高计算效率。总体来说，由于计算效率的问题，隐式时间积分算法ABAQUS-Standard特别适合于低速冲击问题；对于高速冲击问题，由于存在不连续非线性接触的动响应过程，隐式算法解决不好，使用显式时间算法ABAQUS-Explicit更好。此外，对于瞬态和稳态热传导问题，半离散的抛物线方程，中心差分法可以较好获得温度分布。 对于依赖于率的粘塑性问题（对于本质上的粘性材料），与弹塑性材料的根本区别在于，一般来说是一致性条件不满足（排除弹塑性材料在高温下的软化问题，对于这种问题，屈服条件也可以满足），即屈服条件不满足，N+1时刻的物理量不用回映到N+1时刻的屈服面上，粘塑性模型成为过应力模型，显示和隐式算法都可以求解。对于依赖于率的本构模型，其可解决模拟高速冲击、爆炸、弹道射击问题时存在的动态应变局部化问题（对于动态问题，平衡方程丧失双曲线特性；对于静态问题，平衡方程失去椭圆性），解决网格尺寸效应，其实质上是引入了适当的阻尼迟滞效应。需要注意的是，对于大变形(又称为有限变形)问题，Cauchy应力率和速度梯度（包括客观和对称的扭曲张量率D、不客观和反对称的spin旋转张量W两个部分）均是不客观的，为解释刚体旋转（如纯剪切变形就包含刚体旋转），在共旋坐标系下面求解真实应力和应变，应力和应变积分求解的时候应首先求解客观性的Jaumann应力率(相对于真实应力，空间坐标系)，相对于Second Piola-Kirchhoff应力是Truesdell率（材料坐标系）。ABAQUS软件对于大变形问题已经做了旋转。 对于一些耦合场问题，由于计算量非常大，同时要求解太多物理量，如热-流-固耦合，要求解位移、压力、温度，采用纯隐式算法或显式算法基本不太获得收敛或准确的解，这时候可采用混合的隐式与显式有限元格式mixed implicit-explicit partitoning方法，将刚度矩阵和阻尼矩阵分成两个部分，在同一区域采取不同算法，提高计算效率和精度、稳定性和收敛性。","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"有限元","slug":"有限元","permalink":"https://sjtu-xx.github.io/tags/%E6%9C%89%E9%99%90%E5%85%83/"}]},{"title":"TinyXML2的使用（转）","slug":"TinyXML2的使用（转）","date":"2020-05-13T14:35:03.000Z","updated":"2021-02-19T02:26:06.344Z","comments":true,"path":"2020/05/13/TinyXML2的使用（转）/","link":"","permalink":"https://sjtu-xx.github.io/2020/05/13/TinyXML2%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E8%BD%AC%EF%BC%89/","excerpt":"1.TinyXML2概述","text":"1.TinyXML2概述 TinyXML2是simple、small、efficient开源的C++ XML文件解析库，可以很方便的应用到现有的项目之中。非常适合存储简单数据，配置文件，对象序列化等数据量不是很大的操作。 TinyXML2详细介绍与源码获取方法详见：TinyXML2官网。 2. TinyXML1与TinyXML2对比TinyXML1与TinyXML2这两个著名的开源XML文件解析库均出自Lee Thomason之手，向这位满怀开源精神的大家致敬。 TinyXML2适用于大部分的C/C++项目开发，经得住考验，是最好的选择。较TinyXML1而言，TinyXML2化繁为简，使用时只需要包含两个文件，而TinyXML1需要6个文件，一般生成静态链接库供项目的使用。TinyXML1详细介绍与源码见：TinyXML1官网。TinyXML1用法用例可以参考博文：TinyXML快速入门。 TinyXML2使用了与TinyXML1相似都可API，并且拥有丰富的测试案例。但TinyXML2解析器相对TinyXML1在代码上是完全重写，使其更适合于游戏开发中使用。它使用更少的内存，更快，并使用更少的内存分配。 TinyXML2无需STL，也放弃了对STL支持。所有字符串查询均使用C风格字符串“const char *”来表示，省去string类型对象的构造，并使代码更简单。 二者共同点： （1）都使用了简单易用的API。 （2）都是基于DOM（Document Object Model，文档对象模型）的解析器。 （3）都支持UTF-8编码。 TinyXML2的优点： （1）对大部分大部分的C/C++项目具有普适性。 （2）使用较少的内存（约TinyXML1的40%），速度变得更快。 （3）没有C++的STL的要求。 （4）更接近现代C++的特性，如使用了适当的命名空间。 （5）适当有效的处理了的空白字符（空格，TAB和回车）。 TinyXML1的优点： （1）可以报告分析错误的位置。 （2）提供一些C++ STL公约支持：流和字符串。 （3）拥有非常成熟和良好的调试代码库。 3. TinyXML2的用法用例TinyXML2的网上教程并不多见，醍醐灌顶，受益匪浅的教程更是凤毛麟角。有的也是蜻蜓点水、参差不齐的泛泛而谈。最终，所能参考的资料也就是官网的文档和示例代码，但却有点晦涩难懂。因此，本文就为了解决这个尴尬的局面，结合官网的资料和网上资源，尽量详细的列出TinyXML2的常见用法用例，不足之处，请留言补充，后续增加修改。 xml文件本质就是小型的数据库，换个角度来说就是，对数据库有什么操作，那么对xml文件就应能实现什么操作。一般而言，对数据库的操作包括以下几种：新建数据库和对数据库增删查改。那么对应xml文件就是新建xml文件、增加xml文件的节点，删除xml文件的指定节点，查询xml文件指定节点的值，修改xml文件中节点的值。 使用方法：将tinyxml2.cpp和tinyxml2.h拷贝至项目目录，使用时包含#include “tinyxml2.h”和using namespace tinyxml2。 使用场景：存储用户信息。 用户数据表设计如下：123456变量名 描述 类型 长度（字节） 不为空 主键UserName 用户名 Vchar 3-20 Y YPassword 密码 Char 32 Y NGender 性别 Int 1 N NMobile 电话 Char 11 N NEmail 电子邮箱 Varchar 1-50 N N 对应XML文件实现如下：123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;DBUSER&gt; &lt;User Name=”lvlv” Password =”123456”&gt; &lt;Gender&gt;&lt;/Gender&gt; &lt;Mobile &gt;&lt;/ Mobile&gt; &lt;Email &gt;&lt;/ Email &gt;&lt;/User&gt;&lt;DBUSER&gt; 从中可以看出，XML由三大部分组成，分别是声明、根节点和其它节点。其中xml文件的声明包括三方面的内容：Version、Standalone和Encoding。下面将详细列出常见tinyxml2的用法。 注意：以下示例代码针对本人下载使用的TinyXML2，官网的TinyXML2在不断的完善和更新当中，最新的TinyXML2和本人的示例代码可能会有出入。本人使用的TinyXML2是2015.9.23从官网下载的，已上传至CSDN下载，见：TinyXML2。 3.1创建XML文件示例代码：123456789101112131415161718//function：create a xml file//param：xmlPath:xml文件路径//return:0,成功，非0，失败int createXML(const char* xmlPath)&#123; const char* declaration =\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?&gt;\"; XMLDocument doc; doc.Parse(declaration);//会覆盖xml所有内容 //添加申明可以使用如下两行 //XMLDeclaration* declaration=doc.NewDeclaration(); //doc.InsertFirstChild(declaration); XMLElement* root=doc.NewElement(\"DBUSER\"); doc.InsertEndChild(root); return doc.SaveFile(xmlPath);&#125;创建结果：12&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;DBUSER/&gt; 3.2增加xml文件的节点示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//用户类class User&#123;public: User()&#123; gender=0; &#125;; User(const string&amp; userName, const string&amp; password, int gender, const string&amp; mobile, const string&amp; email)&#123; this-&gt;userName=userName; this-&gt;password=password; this-&gt;gender=gender; this-&gt;mobile=mobile; this-&gt;email=email; &#125;; string userName; string password; int gender; string mobile; string email;&#125;;//function:insert XML node//param:xmlPath:xml文件路径; user:用户对象//return:0:成功; 非0:失败int insertXMLNode(const char* xmlPath,const User&amp; user)&#123; XMLDocument doc; int res=doc.LoadFile(xmlPath); if(res!=0) &#123; cout&lt;&lt;\"load xml file failed\"&lt;&lt;endl; return res; &#125; XMLElement* root=doc.RootElement(); XMLElement* userNode = doc.NewElement(\"User\"); userNode-&gt;SetAttribute(\"Name\",user.userName.c_str()); userNode-&gt;SetAttribute(\"Password \",user.password.c_str()); root-&gt;InsertEndChild(userNode); XMLElement* gender = doc.NewElement(\"Gender\"); XMLText* genderText=doc.NewText(itoa(user.gender)); gender-&gt;InsertEndChild(genderText); userNode-&gt;InsertEndChild(gender); XMLElement* mobile = doc.NewElement(\"Mobile\"); mobile-&gt;InsertEndChild(doc.NewText(user.mobile.c_str())); userNode-&gt;InsertEndChild(mobile); XMLElement* email = doc.NewElement(\"Email\"); email-&gt;InsertEndChild(doc.NewText(user.email.c_str())); userNode-&gt;InsertEndChild(email); return doc.SaveFile(xmlPath);&#125;创建结果：12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;DBUSER&gt; &lt;User Name=\"lvlv\" Password =\"12346\"&gt; &lt;Gender&gt;1&lt;/Gender&gt; &lt;Mobile&gt;15813354926&lt;/Mobile&gt; &lt;Email&gt;1589276509@qq.com&lt;/Email&gt; &lt;/User&gt;&lt;/DBUSER&gt; 3.3查询xml文件的指定节点Xml文件中，一个用户节点存储一个用户的信息。因此，对用户信息的增删查改，即无论查询节点、删除节点、修改节点和增加节点，都需要获取需要操作的节点。那么先实现一个根据用户名获取节点指针的函数：123456789101112131415//function:根据用户名获取用户节点//param:root:xml文件根节点；userName：用户名//return：用户节点XMLElement* queryUserNodeByName(XMLElement* root,const string&amp; userName)&#123; XMLElement* userNode=root-&gt;FirstChildElement(\"User\"); while(userNode!=NULL) &#123; if(userNode-&gt;Attribute(\"Name\")==userName) break; userNode=userNode-&gt;NextSiblingElement();//下一个兄弟节点 &#125; return userNode;&#125;在以上函数的基础上，获取用户信息的函数：1234567891011121314151617181920212223242526User* queryUserByName(const char* xmlPath,const string&amp; userName)&#123; XMLDocument doc; if(doc.LoadFile(xmlPath)!=0) &#123; cout&lt;&lt;\"load xml file failed\"&lt;&lt;endl; return NULL; &#125; XMLElement* root=doc.RootElement(); XMLElement* userNode=queryUserNodeByName(root,userName); if(userNode!=NULL) //searched successfully &#123; User* user=new User(); user-&gt;userName=userName; user-&gt;password=userNode-&gt;Attribute(\"Password\"); XMLElement* genderNode=userNode-&gt;FirstChildElement(\"Gender\"); user-&gt;gender=atoi(genderNode-&gt;GetText()); XMLElement* mobileNode=userNode-&gt;FirstChildElement(\"Mobile\"); user-&gt;mobile=mobileNode-&gt;GetText(); XMLElement* emailNode=userNode-&gt;FirstChildElement(\"Email\"); user-&gt;email=emailNode-&gt;GetText(); return user; &#125; return NULL;&#125; 3.4修改xml文件的指定节点12345678910111213141516171819202122232425262728293031323334353637383940//function:修改指定节点内容//param:xmlPath:xml文件路径；user：用户对象//return：boolbool updateUser(const char* xmlPath,User* user)&#123; XMLDocument doc; if(doc.LoadFile(xmlPath)!=0) &#123; cout&lt;&lt;\"load xml file failed\"&lt;&lt;endl; return false; &#125; XMLElement* root=doc.RootElement(); XMLElement* userNode=queryUserNodeByName(root,user-&gt;userName); if(userNode!=NULL) &#123; if(user-&gt;password!=userNode-&gt;Attribute(\"Password\")) &#123; userNode-&gt;SetAttribute(\"Password\",user-&gt;password.c_str()); //修改属性 &#125; XMLElement* genderNode=userNode-&gt;FirstChildElement(\"Gender\"); if(user-&gt;gender!=atoi(genderNode-&gt;GetText())) &#123; genderNode-&gt;SetText(itoa(user-&gt;gender).c_str()); //修改节点内容 &#125; XMLElement* mobileNode=userNode-&gt;FirstChildElement(\"Mobile\"); if(user-&gt;mobile!=mobileNode-&gt;GetText()) &#123; mobileNode-&gt;SetText(user-&gt;mobile.c_str()); &#125; XMLElement* emailNode=userNode-&gt;FirstChildElement(\"Email\"); if(user-&gt;email!=emailNode-&gt;GetText()) &#123; emailNode-&gt;SetText(user-&gt;email.c_str()); &#125; if(doc.SaveFile(xmlPath)==0) return true; &#125; return false;&#125; 验证代码：1234567891011121314151617181920int main(int argc,char* argv[])&#123; //修改用户信息 User user(\"lvlv\",\"00001111\",0,\"13995648666\",\"1586666@qq.com\"); if(updateUser(\"./user.xml\",&amp;user)) cout&lt;&lt;\"update successfully\"&lt;&lt;endl; else cout&lt;&lt;\"update failed\"&lt;&lt;endl; return 0;&#125;修改结果：&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;DBUSER&gt; &lt;User Name=\"lvlv\" Password=\"00001111\"&gt; &lt;Gender&gt;0&lt;/Gender&gt; &lt;Mobile&gt;13995648666&lt;/Mobile&gt; &lt;Email&gt;1586666@qq.com&lt;/Email&gt;&lt;/User&gt;&lt;/DBUSER&gt; 3.5删除xml文件的指定节点的信息//function:删除指定节点内容//param:xmlPath:xml文件路径；userName：用户名称//return：boolbool deleteUserByName(const char xmlPath,const string&amp; userName){ XMLDocument doc; if(doc.LoadFile(xmlPath)!=0) { cout&lt;&lt;”load xml file failed”&lt;&lt;endl; return false; } XMLElement root=doc.RootElement(); //doc.DeleteNode(root);//删除xml所有节点 XMLElement userNode=queryUserNodeByName(root,userName); if(userNode!=NULL) { userNode-&gt;DeleteAttribute(“Password”);//删除属性 XMLElement emailNode=userNode-&gt;FirstChildElement(“Email”); userNode-&gt;DeleteChild(emailNode); //删除指定节点 //userNode-&gt;DeleteChildren();//删除节点的所有孩子节点 if(doc.SaveFile(xmlPath)==0) return true; } return false;}123456789101112验证代码：&#96;&#96;&#96;C++int main(int argc,char* argv[])&#123; &#x2F;&#x2F;删除用户某些信息 if(deleteUserByName(&quot;.&#x2F;user.xml&quot;,&quot;lvlv&quot;)) cout&lt;&lt;&quot;delete successfully&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;delete failed&quot;&lt;&lt;endl; return 0;&#125;删除结果：1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;DBUSER&gt; &lt;User Name=\"lvlv\"&gt; &lt;Gender&gt;10&lt;/Gender&gt; &lt;Mobile&gt;13995648666&lt;/Mobile&gt;&lt;/User&gt;&lt;/DBUSER&gt;4.其它常见用例4.1获取xml文件申明1234567891011121314151617181920212223//function:获取xml文件申明//param:xmlPath:xml文件路径；strDecl：xml申明//return：boolbool getXMLDeclaration(const char* xmlPath,string&amp; strDecl)&#123; XMLDocument doc; if(doc.LoadFile(xmlPath)!=0) &#123; cout&lt;&lt;\"load xml file failed\"&lt;&lt;endl; return false; &#125; XMLNode* decl=doc.FirstChild(); if (NULL!=decl) &#123; XMLDeclaration* declaration =decl-&gt;ToDeclaration(); if (NULL!=declaration) &#123; strDecl = declaration-&gt;Value(); return true; &#125; &#125; return false;&#125;验证代码：12345678910int main(int argc,char* argv[])&#123; //获取xml文件申明 string strDecl; if(getXMLDeclaration(\"./user.xml\",strDecl)) &#123; cout&lt;&lt;\"declaration:\"&lt;&lt;strDecl&lt;&lt;endl; &#125; return 0;&#125;验证结果：1declaration:xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;no&quot; 4.2打印xml文件至标准输出123456789101112//function:将xml文件内容输出到标准输出//param:xmlPath:xml文件路径void print(const char* xmlPath)&#123; XMLDocument doc; if(doc.LoadFile(\"./user.xml\")!=0) &#123; cout&lt;&lt;\"load xml file failed\"&lt;&lt;endl; return; &#125; doc.Print();&#125;4.3 xml文件内容输出至内存123XMLPrinter printer;doc.Print( &amp;printer );// printer.CStr() has a const char* to the XML4.4如何解析xml格式的字符串信息,不是文件中的采用tinyXML中的TiXmlDocument类的Parse方法即可。例如：123456const char * xmlString = \"&lt;?xml version=\\\"1.0\\\" standalone=no&gt;\\n&lt;!– Our to do list data –&gt;\\n&lt;ToDo&gt;\\n&lt;Item priority=\\\"1\\\"&gt; &lt;bold&gt;Toy store!&lt;/bold&gt;\\n&lt;/Item&gt;\\n&lt;Item priority=\\\"2\\\"&gt; Do bills&lt;/Item&gt;\\n&lt;/ToDo&gt; \";XMLDocument *doc = new XMLDocument();doc-&gt;Parse(xmlString); XMLElement * rootElement = doc-&gt;RootElement();const char * rootName = rootElement-&gt;Value();","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"vtk相关","slug":"vtk相关","date":"2020-05-08T01:15:43.000Z","updated":"2021-02-19T02:26:06.724Z","comments":true,"path":"2020/05/08/vtk相关/","link":"","permalink":"https://sjtu-xx.github.io/2020/05/08/vtk%E7%9B%B8%E5%85%B3/","excerpt":"Observer的使用","text":"Observer的使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;vtkPolyDataMapper.h&gt;#include &lt;vtkObjectFactory.h&gt;#include &lt;vtkCommand.h&gt;#include &lt;vtkActor.h&gt;#include &lt;vtkSmartPointer.h&gt;#include &lt;vtkRenderWindow.h&gt;#include &lt;vtkRenderer.h&gt;#include &lt;vtkRenderWindowInteractor.h&gt;#include &lt;vtkInteractorStyle.h&gt;#include &lt;vtkPolyData.h&gt;#include &lt;vtkSphereSource.h&gt;#include &lt;vtkInteractorStyleTrackballCamera.h&gt;// A class not derived from vtkObjectBaseclass MyClass&#123; public: void KeypressCallbackFunction(vtkObject*, long unsigned int vtkNotUsed(eventId), void* vtkNotUsed(callData)) &#123; std::cout &lt;&lt; \"Caught event in MyClass\" &lt;&lt; std::endl; &#125;&#125;;// A class that is derived from vtkObjectBaseclass MyInteractorStyle : public vtkInteractorStyleTrackballCamera&#123;public: static MyInteractorStyle* New(); vtkTypeMacro(MyInteractorStyle, vtkInteractorStyleTrackballCamera); void KeypressCallbackFunction(vtkObject*, long unsigned int vtkNotUsed(eventId), void* vtkNotUsed(callData) ) &#123; std::cout &lt;&lt; \"Caught event in MyInteractorStyle\" &lt;&lt; std::endl; &#125;&#125;;vtkStandardNewMacro(MyInteractorStyle);int main(int, char *[])&#123; // Create a sphere vtkSmartPointer&lt;vtkSphereSource&gt; sphereSource = vtkSmartPointer&lt;vtkSphereSource&gt;::New(); sphereSource-&gt;SetCenter(0.0, 0.0, 0.0); sphereSource-&gt;SetRadius(5.0); sphereSource-&gt;Update(); vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New(); mapper-&gt;SetInputConnection(sphereSource-&gt;GetOutputPort()); // Create an actor vtkSmartPointer&lt;vtkActor&gt; actor = vtkSmartPointer&lt;vtkActor&gt;::New(); actor-&gt;SetMapper(mapper); // A renderer and render window vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::New(); vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::New(); renderWindow-&gt;AddRenderer(renderer); // An interactor vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New(); renderWindowInteractor-&gt;SetRenderWindow(renderWindow); MyClass myClass; renderWindowInteractor-&gt;AddObserver(vtkCommand::KeyPressEvent, &amp;myClass, &amp;MyClass::KeypressCallbackFunction); MyInteractorStyle* style = MyInteractorStyle::New(); renderWindowInteractor-&gt;AddObserver(vtkCommand::KeyPressEvent, style, &amp;MyInteractorStyle::KeypressCallbackFunction); vtkSmartPointer&lt;MyInteractorStyle&gt; style2 = vtkSmartPointer&lt;MyInteractorStyle&gt;::New(); renderWindowInteractor-&gt;AddObserver(vtkCommand::KeyPressEvent, style2, &amp;MyInteractorStyle::KeypressCallbackFunction); renderer-&gt;AddActor(actor); renderer-&gt;SetBackground(1,1,1); // Background color white renderWindow-&gt;Render(); renderWindowInteractor-&gt;Start(); style-&gt;Delete(); return EXIT_SUCCESS; cell的拾取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;vtkAutoInit.h&gt;VTK_MODULE_INIT(vtkRenderingOpenGL)VTK_MODULE_INIT(vtkInteractionStyle)VTK_MODULE_INIT(vtkRenderingFreeType) #include &lt;vtkSmartPointer.h&gt;#include &lt;vtkSphereSource.h&gt;#include &lt;vtkPolyDataMapper.h&gt;#include &lt;vtkActor.h&gt;#include &lt;vtkProperty.h&gt;#include &lt;vtkRenderer.h&gt;#include &lt;vtkRenderWindow.h&gt;#include &lt;vtkRenderWindowInteractor.h&gt; #include &lt;vtkInteractorStyleTrackballCamera.h&gt;#include &lt;vtkDataSetMapper.h&gt;#include &lt;vtkCellPicker.h&gt;#include &lt;vtkSelectionNode.h&gt;#include &lt;vtkSelection.h&gt;#include &lt;vtkRendererCollection.h&gt;#include &lt;vtkExtractSelection.h&gt;#include &lt;vtkObjectFactory.h&gt; /**************************************************************************/class CellPickerInteractorStyle :public vtkInteractorStyleTrackballCamera&#123;public: static CellPickerInteractorStyle* New(); CellPickerInteractorStyle() &#123; selectedMapper = vtkSmartPointer&lt;vtkDataSetMapper&gt;::New(); selectedActor = vtkSmartPointer&lt;vtkActor&gt;::New(); &#125; virtual void OnLeftButtonDown() &#123; int* pos = this-&gt;GetInteractor()-&gt;GetEventPosition(); vtkSmartPointer&lt;vtkCellPicker&gt; picker = vtkSmartPointer&lt;vtkCellPicker&gt;::New(); picker-&gt;SetTolerance(0.0005); picker-&gt;Pick(pos[0], pos[1], 0, this-&gt;GetDefaultRenderer()); if (picker-&gt;GetCellId() != -1) &#123; vtkSmartPointer&lt;vtkIdTypeArray&gt; ids = vtkSmartPointer&lt;vtkIdTypeArray&gt;::New(); ids-&gt;SetNumberOfComponents(1); ids-&gt;InsertNextValue(picker-&gt;GetCellId()); vtkSmartPointer&lt;vtkSelectionNode&gt; selectionNode = vtkSmartPointer&lt;vtkSelectionNode&gt;::New(); selectionNode-&gt;SetFieldType(vtkSelectionNode::CELL); selectionNode-&gt;SetContentType(vtkSelectionNode::INDICES); selectionNode-&gt;SetSelectionList(ids); vtkSmartPointer&lt;vtkSelection&gt; selection = vtkSmartPointer&lt;vtkSelection&gt;::New(); selection-&gt;AddNode(selectionNode); vtkSmartPointer&lt;vtkExtractSelection&gt; extractSelection = vtkSmartPointer&lt;vtkExtractSelection&gt;::New(); extractSelection-&gt;SetInputData(0, polyData); extractSelection-&gt;SetInputData(1, selection); extractSelection-&gt;Update(); selectedMapper-&gt;SetInputData((vtkDataSet*)extractSelection-&gt;GetOutput()); selectedActor-&gt;SetMapper(selectedMapper); selectedActor-&gt;GetProperty()-&gt;EdgeVisibilityOn(); selectedActor-&gt;GetProperty()-&gt;SetEdgeColor(1, 0, 0); selectedActor-&gt;GetProperty()-&gt;SetLineWidth(3); this-&gt;Interactor-&gt;GetRenderWindow()-&gt;GetRenderers()-&gt;GetFirstRenderer()-&gt;AddActor(selectedActor); &#125; vtkInteractorStyleTrackballCamera::OnLeftButtonDown(); &#125;public:vtkSmartPointer&lt;vtkPolyData&gt; polyData; private: vtkSmartPointer&lt;vtkDataSetMapper&gt; selectedMapper; vtkSmartPointer&lt;vtkActor&gt; selectedActor;&#125;;/*********************************************************************************/ vtkStandardNewMacro(CellPickerInteractorStyle); int main()&#123; vtkSmartPointer&lt;vtkSphereSource&gt; sphereSource = vtkSmartPointer&lt;vtkSphereSource&gt;::New(); sphereSource-&gt;Update(); vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New(); mapper-&gt;SetInputData(sphereSource-&gt;GetOutput()); vtkSmartPointer&lt;vtkActor&gt; actor = vtkSmartPointer&lt;vtkActor&gt;::New(); actor-&gt;GetProperty()-&gt;SetColor(0, 1, 0); actor-&gt;SetMapper(mapper); vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::New(); renderer-&gt;AddActor(actor); renderer-&gt;SetBackground(1, 1, 1); vtkSmartPointer&lt;vtkRenderWindow&gt; rw = vtkSmartPointer&lt;vtkRenderWindow&gt;::New(); rw-&gt;Render(); rw-&gt;SetWindowName(\"CellPicker Interaction\"); rw-&gt;AddRenderer(renderer); vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; rwi = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New(); rwi-&gt;SetRenderWindow(rw);/****************************************************************************/ vtkSmartPointer&lt;CellPickerInteractorStyle&gt; style = vtkSmartPointer&lt;CellPickerInteractorStyle&gt;::New(); style-&gt;SetDefaultRenderer(renderer); style-&gt;polyData = sphereSource-&gt;GetOutput(); rwi-&gt;SetInteractorStyle(style); rw-&gt;Render(); rwi-&gt;Initialize(); rwi-&gt;Start(); return 0;&#125;————————————————版权声明：本文为CSDN博主「沈子恒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://shenchunxu.blog.csdn.net/article/details/54966221","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[]},{"title":"qt相关","slug":"QT相关","date":"2020-05-06T09:02:31.000Z","updated":"2021-02-19T02:26:06.331Z","comments":true,"path":"2020/05/06/QT相关/","link":"","permalink":"https://sjtu-xx.github.io/2020/05/06/QT%E7%9B%B8%E5%85%B3/","excerpt":"clion插件","text":"clion插件 External toolsIn “File -&gt; Settings -&gt; Tools -&gt; External Tools”, add 4 external tools: Qt Creator:12Program: &quot;PATH_TO_QT&#x2F;QT_VERSION&#x2F;QT_ARCH&#x2F;Tools&#x2F;QtCreator&#x2F;bin&#x2F;qtcreator&quot;Arguments: $FilePath$UI Designer:12Program: &quot;PATH_TO_QT&#x2F;QT_VERSION&#x2F;QT_ARCH&#x2F;lib&#x2F;bin&#x2F;designer&quot;)Arguments: $FilePath$LUpdate:12Program: &quot;PATH_TO_QT&#x2F;QT_VERSION&#x2F;QT_ARCH&#x2F;lib&#x2F;bin&#x2F;lupdate&quot;)Arguments: $FilePath$ -ts $FileNameWithoutExtension$.tsLinguist:12Program: &quot;PATH_TO_QT&#x2F;QT_VERSION&#x2F;QT_ARCH&#x2F;lib&#x2F;bin&#x2F;linguist&quot;)Arguments: $FilePath$Now you can right click these file types and under the external tool:For .ui select Qt Creator/Designer and start UI designingFor .qml select Qt Creator and design UI in QML editorFor .qrc select Qt Creator and use resource editorFor .cpp/.ui select LUpdate to create its translation fileFor .ts select Linguist and start the translating qt资源文件手动修改和编写qrc文件的方法。test.qrc文件：1234567891011121314151617181920212223&lt;!DOCTYPE RCC&gt;&lt;RCC version=\"1.0\"&gt;&lt;qresource&gt; &lt;file&gt;images/copy.png&lt;/file&gt; &lt;file&gt;images/cut.png&lt;/file&gt; &lt;file&gt;images/document.png&lt;/file&gt; &lt;file&gt;images/icon.png&lt;/file&gt; &lt;file&gt;images/new.png&lt;/file&gt; &lt;file&gt;images/open.png&lt;/file&gt; &lt;file&gt;images/paste.png&lt;/file&gt; &lt;file&gt;images/save.png&lt;/file&gt;&lt;/qresource&gt;&lt;/RCC&gt;.qrc 文件中列出的 资源文件 是程序的源码树的一部分。指定的路径是 .qrc 文件所在目录的相对路径。 注意，列出的资源文件必须位于 .qrc 文件所在目录或者其子目录下。程序中，可以用资源在源码树中的名称加一个 :/ 前缀 来访问它。例如，在程序的源码树中是 images/cut.png 的文件可以通过:/images/cut.png 来访问。 但也可以用file标签中的alias属性来指定：1&lt;file alias=\"cut-img.png\"&gt;images/cut.png&lt;/file&gt;这时该文件可以通过 :/cut-img.png 来访问。 也可以在 .qrc 文件中用 qresource 标签的 prefix 属性：它可以为 .qrc 文件中所有文件指定一个前缀：12345&lt;qresource prefix=\"/myresources\"&gt;&lt;file alias=\"cut-img.png\"&gt;images/cut.png&lt;/file&gt;&lt;/qresource&gt;这时该文件可以用 :/myresources/cut-img.png 访问。 QT路径比如我们有一个程序在：C:/Qt/examples/tools/regexp/regexp.exe 程序所在目录 QString QCoreApplication::applicationDirPath() 那么 qApp-&gt;applicationDirPath() 的结果是： 输出：C:/Qt/examples/tools/regexp 程序的完整名称。那么可以这么写： qApp-&gt;applicationFilePath() 输出：C:/Qt/examples/tools/regexp/regexp.exe 当前工作目录 QDir 提供了一个静态函数 currentPath() 可以获取当前工作目录 如果我们是双击一个程序运行的，那么程序的工作目录就是程序所在目录。 如果是在命令行下运行一个程序，那么运行程序时在命令行的哪个目录，那个目录就是当前目录。 用户目录路径 Qt 5 中引入的方法 QStandardPaths::writableLocation(QStandardPaths::HomeLocation); QStandardPaths::standardLocations(QStandardPaths::HomeLocation); 这两个方法的区别是 standardLocations() 返回值是 QStringList。当然对于 HomeLocation 来说这个 QStringList 中只有一个 QString。 还有另外一种方法，利用 QDir 类的一个静态函数： QDir::homePath(); 我的文档路径 Qt 5 中引入的方法。 QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation); QStandardPaths::standardLocations(QStandardPaths::DocumentsLocation); 桌面路径 QStandardPaths::writableLocation(QStandardPaths::DesktopLocation); QStandardPaths::standardLocations(QStandardPaths::DesktopLocation); 程序数据存放路径 通常我们会将程序所需的一些数据存入注册表。但是有时需要存储的数据太多，放在注册表中就不适合了。这时我们就要找个专门的地方来放数据。以前我喜欢将数据直接放到程序所在目录，但是后来发现我的程序运行时经常没有权限对这个目录下的文件进行写操作。后来发现其实 Qt 早就替我们考虑过这些问题了。 Qt 5 中引入的方法。 QStandardPaths::writableLocation(QStandardPaths::AppDataLocation); QStandardPaths::standardLocations(QStandardPaths::AppDataLocation); Qt 5.5 中引入了另一种方法： QStandardPaths::writableLocation(QStandardPaths::AppConfigLocation); QStandardPaths::standardLocations(QStandardPaths::AppConfigLocation); 这个方法一般来说和上面的方法得到的结果是相同的。按照 Qt 帮助文档的解释，这个方法可以确保返回的路径非空。所以我认为应该优先选用这个方法。 临时文件路径 Qt 5 中引入的方法。 QStandardPaths::writableLocation(QStandardPaths::TempLocation); QStandardPaths::standardLocations(QStandardPaths::TempLocation); 更传统的方法是利用 QDir 的一个静态函数 tempPath()。 QDir::tempPath(); 在这个目录下生成临时文件和临时目录需要用到另外两个类： QTemporaryFile 和 QTemporaryDir。就不展开介绍了，大家可以参考 qt 的帮助文档。 至此，常用的各种特殊路径就介绍的差不多了。剩下还有些不常用的，可以参考 QStandardPaths 类的介绍。 事件过滤器QT事件模块一个真正强大的特性是可以设置一个QObject的实例去监测另外一个QObject实例的事件,在被监测的实例see之前.返回true告诉Qt我们已经处理了这个事件. 如果我们返回false, Qt会发送这个event到它原来的目的地. 安装事件过滤器installEventFilter(parent); 事件过滤器123456789101112131415161718192021222324252627282930313233#include &lt;QEvent&gt;#include &lt;QObject&gt;class MyButton : public QPushButton &#123;Q_OBJECTpublic: MyButton(QWidget *parent) : QPushButton(parent) &#123; installEventFilter(parent); &#125;;&#125;;class MyWindow : public QMainWindow &#123;Q_OBJECTpublic: MyWindow() &#123; this-&gt;setWindowTitle(\"321\"); button = new MyButton(this); &#125;; bool eventFilter(QObject *obj, QEvent *event) override &#123; # 过滤事件 if (button == obj) &#123; if (event-&gt;type() == QEvent::Enter) &#123; this-&gt;setWindowTitle(\"123\"); return true; &#125; &#125;else&#123; return false; &#125; &#125;;private: MyButton *button;&#125;; QString to string 12QString qs;std::string utf8_text = qs.toUtf8().constData(); 带参数的信号与槽函数的绑定qt5中的用法：https://www.devbean.net/2012/09/qt-study-road-2-deep-qt5-signals-slots-syntax/ 一般情况12QObject::connect(&amp;a, &amp;Counter::valueChanged, &amp;b, &amp;Counter::setValue); 有重载的信号1234567891011121314151617//1void (Newspaper:: *newPaperNameDate)(const QString &amp;, const QDate &amp;) = &amp;Newspaper::newPaper;QObject::connect(&amp;newspaper, newPaperNameDate, &amp;reader, &amp;Reader::receiveNewspaper);//2 不推荐// 使用的是 C 风格的强制类型转换。此时，如果你改变了信号的类型，那么你就会有一个潜在的运行时错误。例如，如果我们把(const QString &amp;, const QDate &amp;)两个参数修改成(const QDate &amp;, const QString &amp;)，C 风格的强制类型转换就会失败，并且这个错误只能在运行时发现。QObject::connect(&amp;newspaper, (void (Newspaper:: *)(const QString &amp;, const QDate &amp;))&amp;Newspaper::newPaper, &amp;reader, &amp;Reader::receiveNewspaper);//3 C++ 推荐的风格，当参数类型改变时，编译器会检测到这个错误。QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)(const QString &amp;, const QDate &amp;)&gt;(&amp;Newspaper::newPaper), &amp;reader, &amp;Reader::receiveNewspaper); 参数个数不一致12345QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)(const QString &amp;)&gt;(&amp;Newspaper::newPaper),[=](const QString &amp;name) &#123; /* Your code here. */ &#125;); 拖放https://www.devbean.net/2013/05/qt-study-road-2-dnd/https://www.devbean.net/2013/05/qt-study-road-2-dnd-data/https://openhome.cc/Gossip/Qt4Gossip/DragExecAccept.html drag方需要重写：12345void dragMoveEvent(QDragMoveEvent *e) override;void mousePressEvent(QMouseEvent *event) override;void mouseMoveEvent(QMouseEvent *event) override; 123456789101112131415161718192021222324252627282930void CustomListWidget::mousePressEvent(QMouseEvent *event) &#123; if (event-&gt;button() == Qt::LeftButton) &#123; startPoint = event-&gt;pos(); &#125; QListWidget::mousePressEvent(event);&#125;void CustomListWidget::mouseMoveEvent(QMouseEvent *event) &#123; if (event-&gt;buttons() &amp; Qt::LeftButton) &#123; if ((event-&gt;pos() - startPoint).manhattanLength() &gt;= QApplication::startDragDistance()) &#123; performDrag(); &#125; &#125; QListWidget::mouseMoveEvent(event);&#125;void CustomListWidget::performDrag() &#123; QListWidgetItem *item = currentItem(); if (item) &#123; auto mimeData = new QMimeData; mimeData-&gt;setText(item-&gt;text()); mimeData-&gt;setImageData(item-&gt;icon()); auto drag = new QDrag(this); drag-&gt;setMimeData(mimeData); drag-&gt;setPixmap(item-&gt;icon().pixmap(QSize(22, 22))); drag-&gt;exec(Qt::CopyAction); &#125;&#125;void CustomListWidget::dragMoveEvent(QDragMoveEvent *e) &#123;&#125; drop方需要重写：12345void dragEnterEvent(QDragEnterEvent *e) override;void dragMoveEvent(QDragMoveEvent *e) override;void dropEvent(QDropEvent *e) override; 123456789101112131415161718192021222324void CustomTreeWidget::dropEvent(QDropEvent *e) &#123; qDebug() &lt;&lt; e-&gt;type(); qDebug() &lt;&lt; e-&gt;source(); qDebug() &lt;&lt; e-&gt;mimeData()-&gt;text(); qDebug() &lt;&lt; e-&gt;mimeData()-&gt;imageData(); qDebug() &lt;&lt; e-&gt;source()-&gt;objectName();// CustomListWidget *source = qobject_cast&lt;CustomListWidget *&gt;(e-&gt;source()); QIcon icon = e-&gt;mimeData()-&gt;imageData().value&lt;QIcon&gt;(); QString text = e-&gt;mimeData()-&gt;text(); auto item = new QTreeWidgetItem(); item-&gt;setIcon(0, icon); item-&gt;setText(1, text); addTopLevelItem(item); e-&gt;accept(); QTreeWidget::dropEvent(e);&#125;void CustomTreeWidget::dragEnterEvent(QDragEnterEvent *e) &#123; e-&gt;setDropAction(Qt::CopyAction); e-&gt;accept();&#125;void CustomTreeWidget::dragMoveEvent(QDragMoveEvent *event) &#123;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Django框架","slug":"Django框架","date":"2020-05-02T03:24:02.000Z","updated":"2021-02-19T02:26:06.042Z","comments":true,"path":"2020/05/02/Django框架/","link":"","permalink":"https://sjtu-xx.github.io/2020/05/02/Django%E6%A1%86%E6%9E%B6/","excerpt":"一个简单的web框架","text":"一个简单的web框架 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import socketdef f4(request): import pymysql # 创建连接 conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123', db='db666') cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) cursor.execute(\"select id,username,password from userinfo\") user_list = cursor.fetchall() cursor.close() conn.close() f = open('hostlist.html','r',encoding='utf-8') data = f.read() f.close() # 基于第三方工具实现的模板渲染 from jinja2 import Template template = Template(data) data = template.render(xxxxx=user_list, user='dsafsdfsdf') return data.encode('utf-8')# 路由系统routers = [ ('/host.html', f4),]def run(): sock = socket.socket() sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sock.bind(('127.0.0.1',8080)) sock.listen(5) while True: conn,addr = sock.accept() # hang住 # 有人来连接了 # 获取用户发送的数据 data = conn.recv(8096) data = str(data,encoding='utf-8') headers,bodys = data.split('\\r\\n\\r\\n') temp_list = headers.split('\\r\\n') method,url,protocal = temp_list[0].split(' ') conn.send(b\"HTTP/1.1 200 OK\\r\\n\\r\\n\") func_name = None for item in routers: if item[0] == url: func_name = item[1] break if func_name: response = func_name(data) else: response = b\"404\" conn.send(response) conn.close()if __name__ == '__main__': run() Django基础创建程序123456789101112131415161718192021222324# 创建django程序django-admin startproject &lt;sitename&gt;cd &lt;sitename&gt;# 创建app(后台和用户分开，多个不相关功能分开)python manage.py startapp xx# 启动服务python manage.py runserver 127.0.0.1:8080########## 配置# 配置模板路径settings.py中的template# 静态文件目录settings.py中添加STATICFILES_DIRS&#x3D;((path),)# 额外配置注释MIDDLEWARE &#x3D; [ &#39;django.middleware.security.SecurityMiddleware&#39;, &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;, &#39;django.middleware.common.CommonMiddleware&#39;, # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;, &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;, &#39;django.contrib.messages.middleware.MessageMiddleware&#39;, &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,] 程序目录1234567891011sitename settings.py # Django配置文件 urls.py # 路由系统：url-&gt;函数 wsgi.py # 定义用于django的socket，wsgiref | uwsgiapp admin.py # django自带后台管理 model.py # 写类，根据类创建数据库表 test.py # 写单元测试 apps.py # app配置 views.py # 也可以改成目录 manage.py # 对当前django的所有操作基于manage 模板123456789101112131415161718192021# 元素&#123;&#123;user&#125;&#125;# 列表元素&#123;&#123;users.0&#125;&#125;&#123;&#123;users.1&#125;&#125;# 字典元素&#123;&#123;users.key&#125;&#125;# 循环&#123;% for item in users %&#125; &lt;h3&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;h3&gt;&#123;% endfor %&#125;# 判断&#123;% if a&#x3D;&#x3D;b %&#125; &lt;asdfasdf&gt;&#123;% else %&#125; &lt;asfasdfadf&gt;&#123;% endif %&#125; 模态对话框Ajax模态对话框使用form表单提交会刷新页面，为了不刷新，可以使用ajax123456789101112131415161718192021&lt;script src=\"/static/jquery-3.2.0.js/\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script&gt; function ajax_add_teacher()&#123; $.ajax(&#123; url:'/modal_add_teacher/', type:'POST', data:&#123;'tname':$('#tname').val()&#125;, dataType:\"JSON\", //将data作为json字符串解析为json对象 traditional:true, //如果数据中有list或dict success: function (data) &#123; console.log(data); if (data == 'ok') &#123; location.href = '/teachers'; //页面跳转 location.reload(); //对当前页面进行刷新 &#125; else &#123; $('#errormsg').text(data); &#125; &#125; &#125;) &#125;&lt;/script&gt; 前端jsonJSON.parse(字符串) -&gt; 对象JSON.stringify(对象) -&gt; 字符串通过点取值。12dic = JSON.parse(args)dic.key js阻止默认事件发生1234567&lt;a href=\"www.baidu.com\" onclick=\"return funca();\"&gt;&lt;/a&gt;&lt;script&gt; function funca&#123; return False; &#125; &lt;/script&gt; js绑定事件12345678&lt;a id=\"xx\"&gt;&lt;/a&gt;&lt;script&gt; $(function()&#123; $(\"#xx\").click(function()&#123; &#125;) &#125;)&lt;/script&gt; bootstrap常用的样式 样式添加 &lt;link rel=&#39;stylesheet&#39; href=&#39;/static/bootstrap.css&#39;&gt;&lt;/link&gt;添加属性 class=‘xasdf’ 响应式根据窗口大小，自适应布局@media关键字 母版12345678//母版文件 muban.html&#123;% block xx %&#125;&#123;% endblock %&#125;//文件&#123;% extends 'muban.html'%&#125;&#123;% block xx %&#125; &lt;p&gt;&lt;/p&gt;&#123;% endblock %&#125; 一般css、content、js三个block fontawesome常用的图标 cookie保存在浏览器端的键值对123456789101112131415obj = redirect(\"/classes/\")obj.set_cookie(\"ticket\",\"kjaskldfjaskdf\",max_age=10,path=\"/\",domain=None) //生效时间10s 推荐, path表示cookie在哪个路径生效,domain对域名的划分（默认当前域名），import datetimecur_time = datetime.datetime.utcnow()time_delta = datetime.timdelta(seconds=123)obj.set_cookie(\"ticket\",\"kjaskldfjaskdf\",expires=cur_time+time_delta) //知道目标时间都生效set_salt_cookie(\"ticket\",\"kjaskldfjaskdf\",salt=\"asdf\")// 获取request.get_signed_cookie(\"ticket\",salt=\"asdf\")request.COOKIE.get(\"ticket\") 数据库django：路由、视图、母版、ORM()torando：路由、视图、母版、自由(mysql,SqlAchemy)flask：路由、视图、母版(第三方)、自由(mysql,SqlAchemy) 路由系统123456789101112131415161718192021222324252627# path第一个参数为正则表达式模板# 0path(r\"edit/\",views.edit)def edit(request): pass# 00path(r\"^edit$\",views.edit) # 匹配edit开头，终止的url地址def edit(request): pass# 1path(r\"edit/(w+)/(w+)/\",views.edit)def edit(request,a1,a2): # a1为正则表达式匹配的值，这里为(w+)中的内容，严格按照顺序从前到后 pass# 2path(r\"edit/(?P&lt;a2&gt;w+)/(?P&lt;a1&gt;w+)/\",views.edit)def edit(request,a1,a2): # a1为正则表达式匹配的值，这里为(w+)中的内容，按照&lt;&gt;中的进行赋值 pass 路由分发12345urls.py from django.shortcuts import include path('app01',include('app01.urls'))app01.urls.py path('index',views.index) 别名反向生成url12345678# 1from django.urls import reversepath(\"login/(?P&lt;a1&gt;\\w+)\",views.login,name=\"n1\")v = reverse(\"n1\",kwargs=&#123;'a1':1111&#125;)# 2path(\"login/\",views.login,name=\"m1\")&#123;% url 'm1' %&#125; CBV和FBVCBV一个URL对应一个类1234567891011121314151617181920# urls.pypath(r'^login.html$', views.Login.as_view()),# views.pyfrom django.views import Viewclass Login(View): # 继承View类作为父类 # #重写父类方法，该方法可作为装饰器功能 def dispatch(self, request, *args, **kwargs): # 自定制 dispatch方法，除了可以利用父类中原dispatch方法，还可以自定制处理逻辑 print('before') obj = super(Login,self).dispatch(request, *args, **kwargs) # 传入Login对象作为参数，调用父类中的方法 print('after') return obj def get(self,request): # 请求为get请求时，自动调用该方法 # return HttpResponse('Login.get') return render(request,'login.html') def post(self,request): # 请求是POST请求时，自动调用该方法 print(request.POST.get('user')) return HttpResponse('Login.post') ORM操作配置12345678910111213141516171819 __init__.py文件(ORM默认使用SQLlite连接数据库,需改成Mysql)添加：import pymysqlpymysql.install_as_MySQLdb()# 配置setting文件中重写数数据库配置DATABASES = &#123;'default': &#123;'ENGINE': 'django.db.backends.mysql','NAME':'s4day70db','USER': 'root','PASSWORD': '','HOST': 'localhost','PORT': 3306,&#125;&#125; 创建数据库12345678910111213141516# modelsfrom django.db import modelsclass UserInfo(models.Model): # 在数据库中的表名为模块名_UserInfo nid = models.BigAutoField(primary_key=True) #可不写，默认会生成表中的id字段 # 自增 主键 username = models.CharField(max_length=32) password = models.CharField(max_length=64)# settings配置文件中安装app01模块INSTALLED_APPS = [ …… 'app01',]# 执行语句python manage.py makemigrations #生成数据表配置文件，包含生成及修改等信息python manage.py migrate #执行生成的配置文件 修改表/删除表123456789# modelsclass UserInfo(models.Model): …… age = models.IntegerField(default=1) # 新增字段时需设置默认值/允许为空 # age = models.IntegerField(null=True)# 执行语句：python manage.py makemigrations #生成数据表配置文件，包含生成及修改等信息python manage.py migrate #执行生成的配置文件 创建外键关联12345678# modelsclass UserGroup(models.Model): #等同于主表，需将该类写在子表前面 title = models.CharField(max_length=32)class UserInfo(models.Model): # 外键所在的表等同于子表 …… ug = models.ForeignKey('UserGroup',null=True,on_delete='') # 外键关联字段关联UserGroup表中的Id字段，ug在UserInfo数据表中的字段为ug_id 单表操作123456789101112131415# 增from app01 import modelsmodels.UserGroup.objects.create(title='销售部')# 删models.UserGroup.objects.filter(id=2).delete()# 改 models.UserGroup.objects.filter(id=2).update(title='公关部') # 查group_list = models.UserGroup.objects.all() # 所有group_list = models.UserGroup.objects.filter(id=1)group_list = models.UserGroup.objects.filter(id__gt=1) #大于1group_list = models.UserGroup.objects.filter(id__lt=1) #小于1 连表操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 创建表from django.db import modelsclass UserType(models.Model): # 用户类型 title = models.CharField(max_length=32)class UserInfo(models.Model): # 用户表 name = models.CharField(max_length=16) age = models.IntegerField() ut = models.ForeignKey('UserType',on_delete='') # 关联UserType表中的id字段# 创建数据# models.UserType.objects.create(title='普通用户')# models.UserType.objects.create(title='二逼用户')# models.UserType.objects.create(title='牛逼用户')# models.UserInfo.objects.create(name='方少伟',age=18,ut_id=1)# models.UserInfo.objects.create(name='由秦兵',age=18,ut_id=2)# models.UserInfo.objects.create(name='刘庚',age=18,ut_id=2)# models.UserInfo.objects.create(name='陈涛',age=18,ut_id=3)# models.UserInfo.objects.create(name='王者',age=18,ut_id=3)# models.UserInfo.objects.create(name='杨涵',age=18,ut_id=1)# 一对多的正向操作（让存在外键的从表进行跨表，去查询关联主表中的字段）：# 获得Queryset对象格式数据（格式：对象名.外键字段名.关联表字段名）obj = models.UserInfo.objects.all().first() # 获取一条数据，无需再obj[0]来获取具体的对象print(obj.name,obj.age,obj.ut.title) # 获取跨表后的字段用obj.ut.title方式，ut是外键关联中的字段# 获得查询结果为字典格式组合成列表类型的Queryset数据,可用list方法转换成列表格式（从表中的外键字段名__主表中的字段名）v1 = models.UserInfo.objects.values('id','name','ut__title')# 获得查询结果为元组格式组合成列表类型的Queryset数据,可用List转换成列表（从表中的外键字段名__主表中的字段名）result = models.UserInfo.objects.all().values_list('id','name'.'ut__title')# 一对多的反向操作(让主表进行跨表，去查询（有外键关联字段）从表中相应的字段作为查询条件或查询结果)：# 获得Queryset对象格式的数据,(格式：主表的QuerySet对象名.从***表名__set.all()***)# （一个用户类型下可以有很多用户，获得所有用户类型对应的用户信息数据）：obj = models.UserType.objects.all().first()for row in obj.userinfo_set.all(): print(row.name,row.age)# 获得字典格式Queryset对象格式的数据,需要转换成json字符串格式通过ajax返回数据时，可用list方法转换成列表（从表表名小写__主表字段名）v2 = models.UserType.objects.values('id','title','userinfo__name')# 获得元组格式Queryset对象格式的数据,需要转换成json字符串格式通过ajax返回数据时，可用list方法转换成列表。（外键字段名__从表字段名）result = models.UserType.objects.all().values_list('id','name','userinfo__name')# 跨表# 正向查询：1. q = UserInfo.objects.all().first()q.ug.title2. UserInfo.objects.values('nid','ug_id') UserInfo.objects.values('nid','ug_id','ug__title') 3. UserInfo.objects.values_list('nid','ug_id','ug__title')# 反向查询：1. 小写的表名_setobj = UserGroup.objects.all().first() result = obj.userinfo_set.all() [userinfo对象,userinfo对象,] 2. 小写的表名v = UserGroup.objects.values('id','title') v = UserGroup.objects.values('id','title','小写的从表名称') v = UserGroup.objects.values('id','title','小写的从表名称__age') 3. 小写的表名v = UserGroup.objects.values_list('id','title') v = UserGroup.objects.values_list('id','title','小写的表名称') v = UserGroup.objects.values_list('id','title','小写的表名称__age') 排序12user_list = models.UserInfo.objects.all().order_by('-id','name') # —id代表降序，id代表升序 分组12345678910111213141516171819202122232425262728293031323334353637383940# group byfrom django.db.models import Count,Sum,Max,Minv =models.UserInfo.objects.values('ut_id').annotate(xxxx=Count('id'))# 等价于SELECT `app01_userinfo`.`ut_id`, COUNT(`app01_userinfo`.`id`) AS `xxxx` # FROM# `app01_userinfo` # GROUP BY `app01_userinfo`.`ut_id`# ORDER BY NULL# 带有having 分组条件过滤v =models.UserInfo.objects.values('ut_id').annotate(xxxx=Count('id')).filter(xxxx__gt=2)# 等价于SELECT `app01_userinfo`.`ut_id`, COUNT(`app01_userinfo`.`id`) AS `xxxx` # FROM# `app01_userinfo` GROUP BY `app01_userinfo`.`ut_id`# HAVING COUNT(`app01_userinfo`.`id`) &gt; 2 # ORDER BY NULLv =models.UserInfo.objects.filter(id__gt=2).values('ut_id').annotate(xxxx=Count('id')).filter(xxxx__gt=2)# 等价于SELECT `app01_userinfo`.`ut_id`, COUNT(`app01_userinfo`.`id`) AS `xxxx` # FROM # `app01_userinfo`# WHERE# `app01_userinfo`.`id` &gt; 2 # GROUP BY# `app01_userinfo`.`ut_id`# HAVING # COUNT(`app01_userinfo`.`id`) &gt; 2 ORDER BY NULL分组格式：model.类名.objects.values(显示的字段名).annotate(作为字段查结结果的别名=Count(字段id/1)) # annotate依赖于values# 条件过滤models.UserInfo.objects.filter(id__gt=1) # id&gt;1……（id__lt=1） # id&lt;1……(id__lte=1) #id&lt;=1……(id__gte=1) # id&gt;=1……(id__in=[1,2,3]) #id in [1,2,3]……(name__startswith='xxxx') #……(name__contains='xxxx') #……exclude(id=1) # not in (id=1) 其他操作 F 12from django.db.models import Fmodels.UserInfo.objects.all().update(age=F(\"age\")+1) # F()用来取对象中某列值 Q(构造复杂的查询条件) 12345# 对象方式(不推荐)from django.db.models import Qmodels.UserInfo.objects.filter(Q(id__gt=1))models.UserInfo.objects.filter(Q(id=8) | Q(id=2)) # ormodels.UserInfo.objects.filter(Q(id=8) &amp; Q(id=2)) # and 方法方式 12345678910111213141516171819202122from django.db.models import Qq1 = Q()q1.connector = 'OR'q1.children.append(('id__gt', 1))q1.children.append(('id', 10))# 通过OR将3个条件进行连接组装q2 = Q()q2.connector = 'OR'q2.children.append(('c1', 1))q2.children.append(('c1', 10))q3 = Q()q3.connector = 'AND' #通过AND将2个条件进行连接组装q3.children.append(('id', 1))q3.children.append(('id', 2))q1.add(q3,'OR') #还可将q3嵌入到q1条件组中# 将q1和q2条件组通过AND汇总到一起，q1和q2内部分别用or组合条件con = Q()con.add(q1, 'AND')con.add(q2, 'AND') 1234567891011121314151617181920212223242526272829303132333435363738condition_dict = &#123; #用户将选择的条件组合成字典格式 'k1':[1,2,3,4], 'k2':[1,],&#125;con = Q()for k,v in condition_dict.items(): q = Q() q.connector = 'OR' for i in v: q.children.append(('id', i)) con.add(q,'AND')models.UserInfo.objects.filter(con)***********************************************************************q1 = Q()q1.connector = 'OR'q1.children.append(('id', 1))q1.children.append(('id', 10))q1.children.append(('id', 9))q2 = Q()q2.connector = 'OR'q2.children.append(('c1', 1))q2.children.append(('c1', 10))q2.children.append(('c1', 9))q3 = Q()q3.connector = 'AND'q3.children.append(('id', 1))q3.children.append(('id', 2))q1.add(q3,'OR')con = Q()con.add(q1, 'AND')con.add(q2, 'AND')#以上构造结果等介于(id=1 or id = 10 or id=9 or (id=1 and id=2)) and (c1=1 or c1=10 or c1=9) extra(添加额外的自定义sql语句)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566models.UserInfo.objects.extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) a. 映射 select select_params=Noneselect 此处 from 表 b. 条件 where=None params=None, select * from 表 where 此处 c. 表 tables select * from 表,此处 c. 排序order_by=None select * from 表 order by 此处 v = models.UserInfo.objects.all().extra( select=&#123; 'n':\"select count(1) from app01_usertype where id=%s or id=%s\", 'm':\"select count(1) from app01_usertype where id=%s or id=%s\", &#125;, select_params=[1,2,3,4])for obj in v: print(obj.name,obj.id,obj.n) # 等价于将查询结果作为字段显示列：# select# id,# name,# (select count(1) from tb) as n# from xb where ....models.UserInfo.objects.extra(select=&#123;'newid':'select count(1) from app01_usertype where id&gt;%s'&#125;,select_params=[1,],where = ['age&gt;%s'],params=[18,],order_by=['-age'],tables=['app01_usertype'])# 等价于原生sql语句如下：# select # app01_userinfo.id,# (select count(1) from app01_usertype where id&gt;1) as newid# from app01_userinfo,app01_usertype# where # app01_userinfo.age &gt; 18# order by # app01_userinfo.age descresult = models.UserInfo.objects.filter(id__gt=1).extra(where=['app01_userinfo.id &lt; %s'],params=[100,],tables=['app01_usertype'],order_by=['-app01_userinfo.id'],select=&#123;'uid':1,'sw':\"select count(1) from app01_userinfo\"&#125; #添加查询字段)# SELECT (1) AS \"uid\", (select count(1) from app01_userinfo) AS \"sw\", \"app01_userinfo\".\"id\", \"app01_userinfo\".\"name\", \"app01_userinfo\".\"age\", \"app01_userinfo\".\"ut_id\" # FROM# \"app01_userinfo\" , \"app01_usertype\" # WHERE# (\"app01_userinfo\".\"id\" &gt; 1 AND (app01_userinfo.id &lt; 100))# ORDER BY (\"app01_userinfo\".id) # DESC 原生sql语句12345from django.db import connection, connectionscursor = connection.cursor() # cursor = connections['default'].cursor()cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1])row = cursor.fetchone() # fetchall()/fetchmany(..) 其他操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234################################################################### PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET ###################################################################def all(self) # 获取所有的数据对象def filter(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Qdef exclude(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Qdef select_related(self, *fields) 性能相关：表之间进行join连表操作，一次性获取关联的数据。 model.tb.objects.all().select_related() model.tb.objects.all().select_related('外键字段') model.tb.objects.all().select_related('外键字段__外键字段')def prefetch_related(self, *lookups) 性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。 # 获取所有用户表 # 获取用户类型表where id in (用户表中的查到的所有用户ID) models.UserInfo.objects.prefetch_related('外键字段') from django.db.models import Count, Case, When, IntegerField Article.objects.annotate( numviews=Count(Case( When(readership__what_time__lt=treshold, then=1), output_field=CharField(), )) ) students = Student.objects.all().annotate(num_excused_absences=models.Sum( models.Case( models.When(absence__type='Excused', then=1), default=0, output_field=models.IntegerField() )))def annotate(self, *args, **kwargs) # 用于实现聚合group by查询 from django.db.models import Count, Avg, Max, Min, Sum v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')) # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')).filter(uid__gt=1) # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &gt; 1 v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id',distinct=True)).filter(uid__gt=1) # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &gt; 1def distinct(self, *field_names) # 用于distinct去重 models.UserInfo.objects.values('nid').distinct() # select distinct nid from userinfo 注：只有在PostgreSQL中才能使用distinct进行去重def order_by(self, *field_names) # 用于排序 models.UserInfo.objects.all().order_by('-id','age')def extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) # 构造额外的查询条件或者映射，如：子查询 Entry.objects.extra(select=&#123;'new_id': \"select col from sometable where othercol &gt; %s\"&#125;, select_params=(1,)) Entry.objects.extra(where=['headline=%s'], params=['Lennon']) Entry.objects.extra(where=[\"foo='a' OR bar = 'a'\", \"baz = 'a'\"]) Entry.objects.extra(select=&#123;'new_id': \"select id from tb where id &gt; %s\"&#125;, select_params=(1,), order_by=['-nid']) def reverse(self): # 倒序 models.UserInfo.objects.all().order_by('-nid').reverse() # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序 def defer(self, *fields): models.UserInfo.objects.defer('username','id') 或 models.UserInfo.objects.filter(...).defer('username','id') #映射中排除某列数据 def only(self, *fields): #仅取某个表中的数据 models.UserInfo.objects.only('username','id') 或 models.UserInfo.objects.filter(...).only('username','id') def using(self, alias): 指定使用的数据库，参数为别名（setting中的设置）################################################### PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS ###################################################def raw(self, raw_query, params=None, translations=None, using=None): # 执行原生SQL models.UserInfo.objects.raw('select * from userinfo') # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名 models.UserInfo.objects.raw('select id as nid from 其他表') # 为原生SQL设置参数 models.UserInfo.objects.raw('select id as nid from userinfo where nid&gt;%s', params=[12,]) # 将获取的到列名转换为指定列名 name_map = &#123;'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'&#125; Person.objects.raw('SELECT * FROM some_other_table', translations=name_map) # 指定数据库 models.UserInfo.objects.raw('select * from userinfo', using=\"default\") ################### 原生SQL ################### from django.db import connection, connections cursor = connection.cursor() # cursor = connections['default'].cursor() cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) row = cursor.fetchone() # fetchall()/fetchmany(..)def values(self, *fields): # 获取每行数据为字典格式def values_list(self, *fields, **kwargs): # 获取每行数据为元祖def dates(self, field_name, kind, order='ASC'): # 根据时间进行某一部分进行去重查找并截取指定内容 # kind只能是：\"year\"（年）, \"month\"（年-月）, \"day\"（年-月-日） # order只能是：\"ASC\" \"DESC\" # 并获取转换后的时间 - year : 年-01-01 - month: 年-月-01 - day : 年-月-日 models.DatePlus.objects.dates('ctime','day','DESC')def datetimes(self, field_name, kind, order='ASC', tzinfo=None): # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间 # kind只能是 \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\" # order只能是：\"ASC\" \"DESC\" # tzinfo时区对象 models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.UTC) models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.timezone('Asia/Shanghai')) \"\"\" pip3 install pytz import pytz pytz.all_timezones pytz.timezone(‘Asia/Shanghai’) \"\"\"def none(self): # 空QuerySet对象##################################### METHODS THAT DO DATABASE QUERIES #####################################def aggregate(self, *args, **kwargs): # 聚合函数，获取字典类型聚合结果 from django.db.models import Count, Avg, Max, Min, Sum result = models.UserInfo.objects.aggregate(k=Count('u_id', distinct=True), n=Count('nid')) ===&gt; &#123;'k': 3, 'n': 4&#125;def count(self): # 获取个数def get(self, *args, **kwargs): # 获取单个对象def create(self, **kwargs): # 创建对象def bulk_create(self, objs, batch_size=None): # 批量插入 # batch_size表示一次插入的个数 objs = [ models.DDD(name='r11'), models.DDD(name='r22') ] models.DDD.objects.bulk_create(objs, 10)def get_or_create(self, defaults=None, **kwargs): # 如果存在，则获取，否则，创建 # defaults 指定创建时，其他字段的值 obj, created = models.UserInfo.objects.get_or_create(username='root1', defaults=&#123;'email': '1111111','u_id': 2, 't_id': 2&#125;)def update_or_create(self, defaults=None, **kwargs): # 如果存在，则更新，否则，创建 # defaults 指定创建时或更新时的其他字段 obj, created = models.UserInfo.objects.update_or_create(username='root1', defaults=&#123;'email': '1111111','u_id': 2, 't_id': 1&#125;)def first(self): # 获取第一个def last(self): # 获取最后一个def in_bulk(self, id_list=None): # 根据主键ID进行查找 id_list = [11,21,31] models.DDD.objects.in_bulk(id_list)def delete(self): # 删除def update(self, **kwargs): # 更新def exists(self): # 是否有结果# select_related:查询主动做连表，一次性获取所有连表中的数据（性能相关：数据量少的情况下使用）q = models.UserInfo.objects.all().select_related('ut','gp')#等价于select * from userinfo inner join usertype on ...for row in q: print(row.name,row.ut.title) #采用.的形式获取连表数据# prefetch_related：不做连表，但会做多次查询（性能相关：数据量多，查询频繁下使用） q = models.UserInfo.objects.all().prefetch_related('ut')# select * from userinfo;# Django内部：ut_id = [2,4]# select * from usertype where id in [2,4]for row in q: print(row.id,row.ut.title) 多对多操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# 手动创建第三张关联表（推荐，手动更灵活）# modelsfrom django.db import modelsclass Boy(models.Model): name = models.CharField(max_length=32)class Girl(models.Model): nick = models.CharField(max_length=32)class Love(models.Model): b = models.ForeignKey('Boy',on_delete='') g = models.ForeignKey('Girl',on_delete='')class Meta: #添加联合唯一字段 unique_together = [ ('b','g'), ]# views# 添加数据objs = [ models.Boy(name='方少伟'), models.Boy(name='由秦兵'), models.Boy(name='陈涛'), models.Boy(name='闫龙'), models.Boy(name='吴彦祖'),]models.Boy.objects.bulk_create(objs,5) # 批量添加数据objss = [ models.Girl(nick='小鱼'), models.Girl(nick='小周'), models.Girl(nick='小猫'), models.Girl(nick='小狗'),]models.Girl.objects.bulk_create(objss,5)# 1. 查询和方少伟有关系的姑娘# 第一种查询方式：跨表反向查询，获得对象# obj = models.Boy.objects.filter(name='方少伟').first()# love_list = obj.love_set.all() # 反向查询，获得所有love表中的对象# for row in love_list:# print(row.g.nick) # 获得对应的姑娘数据# 第二种查询方式：连表查询（正向查询），直接查询love表，获得对象# love_list = models.Love.objects.filter(b__name='方少伟') #获得Queryset对象# for row in love_list:# print(row.g.nick)# （推荐）第三种查询方式：只发送一次sql连接请求，获得字典,属于正向查询# love_list = models.Love.objects.filter(b__name='方少伟').values('g__nick')# for item in love_list: # 获得字典格式的列表，[&#123;'g__nick':'xxx&#125;,] # print(item['g__nick'])# （推荐）第四种查询方式：相当于inner join方式连表查询，只发送一次sql连接请求，获得对象# love_list = models.Love.objects.filter(b__name='方少伟').select_related('g')# for obj in love_list: # 获得对象# print(obj.g.nick)# 总结：多对多都是先获得关联表中的数据，再进行跨表操作# 对象格式用.（点）进行跨表 字典和元组采用_（双下划线）进行跨表# Django自动生成第三张关联表（无法再手动添加其它字段）# modelsclass Boy(models.Model): name = models.CharField(max_length=32) m = models.ManyToManyField('Girl') #自动生成关联表m，以两张表中的id字段作为关联字段class Girl(models.Model): nick = models.CharField(max_length=32)# views# 增# obj = models.Boy.objects.filter(name='方少伟').first()# obj.m.add(2)# obj.m.add(2,4) # 创建关联表的多条数据# obj.m.add(*[1,3]) # 以列表形式创建多条数据# 删# obj.m.remove(1)# obj.m.remove(2,3) # 删除关联表的多条数据# obj.m.remove(*[4,])# obj.m.set([1,]) # 覆盖数据库所有数据,重置# obj = models.Boy.objects.filter(name='方少伟').first()# obj.m.clear() # 删除所有与方少伟的关联数据# 查# 正向查询出单条数据# obj = models.Boy.objects.filter(name='方少伟').first()# # girl_list = obj.m.all() # girl_list = obj.m.filter(nick='小鱼') # 相当于从从表跨表到主表查询# print(girl_list)# 反向查询出多条数据# obj = models.Girl.objects.filter(nick='小鱼').first()# print(obj.id,obj.nick)# boy_list = obj.boy_set.all() # 相当于从主表跨表到从表反向查询# 手动与自动结合# modelsclass Boy(models.Model): name = models.CharField(max_length=32) m = models.ManyToManyField(to='Girl',through=\"Love\",through_fields=('b','g',)) # 可不写to关键字class Girl(models.Model): nick = models.CharField(max_length=32)class Love(models.Model): b = models.ForeignKey('Boy',on_delete='') g = models.ForeignKey('Girl',on_delete='') class Meta: unique_together = [ ('b','g'), ]# viewsobj = models.Boy.objects.filter(name='方少伟').first()obj.m.add(1)# obj.m.remove(1)# obj.m.clear() 可以v = obj.m.all()print(v) 连表操作（多对多自关联）原理：等同于复制出一张新表1234567891011121314151617181920212223242526class UserInfo(models.Model): nickname = models.CharField(max_length=32) username = models.CharField(max_length=32) password = models.CharField(max_length=64) gender_choices = ( (1,'男'), (2,'女'), ) gender = models.IntegerField(choices=gender_choices) m = models.ManyToManyField('UserInfo') # 多对多自关联字段，自动生成第二张表，字段分别为from_userinfo_id和to_userinfo_id; # 表中的m属性不会在userinfo表中生成m字段def test(request):# 查男生（通过m字段查询属于正向操作）xz = models.UserInfo.objects.filter(id=1).first() #id为1代表男生的1条数据u = xz.m.all()for row in u: print(row.nickname)# 查女生(通过表名称_set查询属于反向操作)xz = models.UserInfo.objects.filter(id=4).first() #id为4代表女生的1条数据v = xz.userinfo_set.all()for row in v: print(row.nickname)return HttpResponse('...')外键自关联（常用于评论表功能）等同于复制出一张新表，用原表中的外键作连表操作1234567891011121314151617181920212223242526272829class Comment(models.Model): \"\"\" 评论表 \"\"\" news_id = models.IntegerField() # 新闻ID content = models.CharField(max_length=32) # 评论内容 user = models.CharField(max_length=32) # 评论者 reply = models.ForeignKey('Comment',null=True,blank=True,related_name='xxxx') #related_name表示反向查询时，代替 表名_set 和 表名__字段名 \"\"\" 新闻ID reply_id1 1 别比比 root null2 1 就比比 root null3 1 瞎比比 shaowei null4 2 写的正好 root null5 1 拉倒吧 由清滨 26 1 拉倒吧1 xxxxx 27 1 拉倒吧2 xxxxx 5\"\"\"\"\"\"新闻1 别比比 就比比 - 拉倒吧 - 拉倒吧2 - 拉倒吧1 瞎比比新闻2： 写的正好\"\"\" 分页分组获取数据UserGroup.objects.all()[10:20] 内置分页123456789101112from django.core.paginator import Paginator,Page,PageNotAnInteger,EmptyPagedef index(request): user_list = models.UserInfo.objects.all() #获得所有数据库数据 paginator = Paginator(user_list,10) #设置每页显示的总条数 current_page = request.GET.get('page')# 获得当前页数 try: posts = paginator.page(current_page) #设置当前页数对应的数据 except PageNotAnInteger as e: #当前页面数非整数 posts = paginator.page(1) except EmptyPage as e: #当前页码数为空 posts = paginator.page(1) return render(request,'index.html',&#123;'posts':posts&#125;) 12345678910111213141516&lt;h1&gt;用户列表&lt;/h1&gt;&lt;ul&gt; &#123;% for row in posts.object_list %&#125; &lt;li&gt;&#123;&#123; row.name &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt;&lt;div&gt; &#123;% if posts.has_previous %&#125; #是否有上一页 &lt;a href=\"/index.html?page=&#123;&#123; posts.previous_page_number &#125;&#125;\"&gt;上一页&lt;/a&gt; &#123;% endif %&#125; &#123;% if posts.has_next %&#125; #是否有下一页 &lt;a href=\"/index.html?page=&#123;&#123; posts.next_page_number &#125;&#125;\"&gt;下一页&lt;/a&gt; &#123;% endif %&#125;&lt;/div&gt; 自定义分页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# views.pyfrom utils.pager import PageInfodef custom(request): all_count = models.UserInfo.objects.all().count() page_info = PageInfo(request.GET.get('page'),all_count,10,'/custom.html',11) user_list = models.UserInfo.objects.all()[page_info.start():page_info.end()] return render(request,'custom.html',&#123;'user_list':user_list,'page_info':page_info&#125;)# class PageInfo(object): def __init__(self,current_page,all_count,per_page,base_url,show_page=11): ''' :param current_page: :param all_count: 数据库总行数 :param per_page: 每页显示行数 :param base_url: :param show_page:分页码范围，默认为11 ''' try: self.current_page = int(current_page) except Exception as e: self.current_page = 1 self.per_page=per_page a,b = divmod(all_count,per_page) #返回一个包含商和余数的元组 if b: # 数据库总数/页面总数后还有多余的数据，所以还需要加1页来显示剩余的数据 a = a+1 self.all_pager= a # 总页数 self.show_page= show_page self.base_url= base_url # 页码数对应的展示数据内容 def start(self): return (self.current_page-1) * self.per_page # 起始数据位置 def end(self): return self.current_page * self.per_page # 组装分页模块 def pager(self): page_list=[] # 计算中间页码数显示起始数和结尾数 half = int((self.show_page-1)/2) # 中间页码数 # 如果数据总页数 &lt; 分页码范围11 if self.all_pager &lt; self.show_page: begin =1 stop=self.all_pager + 1 # 如果数据总页数 &gt; 分页码范围11 else: # 如果当前页 &lt;=5,永远显示1,11 if self.current_page &lt;= half: begin =1 stop = self.show_page + 1 else: if self.current_page + half &gt; self.all_pager: begin = self.all_pager - self.show_page + 1 stop = self.all_pager + 1 else: begin = self.current_page - half stop = self.current_page + half + 1 # 组装‘上一页’选项 if self.current_page &lt;= 1: prev = \"&lt;li&gt;&lt;a href='#'&gt;上一页&lt;/a&gt;&lt;/li&gt;\" else: prev = \"&lt;li&gt;&lt;a href='%s?page=%s'&gt;上一页&lt;/a&gt;&lt;/li&gt;\"%(self.base_url,self.current_page-1,) page_list.append(prev) # 组装中间页码数显示 for i in range(begin, stop): if i == self.current_page: temp = \"&lt;li class='active'&gt;&lt;a href='%s?page=%s'&gt;%s&lt;/a&gt;&lt;/li&gt;\" % (self.base_url, i, i,) else: temp = \"&lt;li&gt;&lt;a href='%s?page=%s'&gt;%s&lt;/a&gt;&lt;/li&gt;\" % (self.base_url, i, i,) page_list.append(temp) # 组装'下一页'选项 if self.current_page &gt;= self.all_pager: nex = \"&lt;li&gt;&lt;a href='#'&gt;下一页&lt;/a&gt;&lt;/li&gt;\" else: nex = \"&lt;li&gt;&lt;a href='%s?page=%s'&gt;下一页&lt;/a&gt;&lt;/li&gt;\" %(self.base_url,self.current_page+1,) page_list.append(nex) return ''.join(page_list) 1234567891011&lt;h1&gt;用户列表&lt;/h1&gt;&lt;ul&gt; &#123;% for row in user_list %&#125; &lt;li&gt;&#123;&#123; row.name &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt;&lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &#123;&#123; page_info.pager|safe &#125;&#125; &lt;/ul&gt;&lt;/nav&gt; XSS攻击(跨站脚本攻击)页面script代码攻击(如评论中的scrpt代码攻击)item中如果有script代码会自动执行1234&lt;h1&gt;评论&lt;/h1&gt;&#123;% for item in msg %&#125; &lt;div&gt;&#123;&#123; item|safe&#125;&#125;&lt;/div&gt; #需要给响应的值添加safe&#123;% endfor %&#125; CSRF(跨站请求伪装攻击)方法1123456&lt;form method=\"POST\" action=\"/csrf1.html\"&gt; &#123;% csrf_token %&#125; # 需添加服务器发送的csrf随机字符串，才能访问成功 &lt;input id=\"user\" type=\"text\" name=\"user\" /&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;a onclick=\"submitForm();\"&gt;Ajax提交&lt;/a&gt;&lt;/form&gt; 方法2123456789101112131415&lt;script&gt; function submitForm()&#123; var token = $.cookie('csrftoken'); # 获得浏览器里cookies中的csrf随机字符串 var user = $('#user').val(); $.ajax(&#123; url: '/csrf1.html', type: 'POST', headers:&#123;'X-CSRFToken': token&#125;, # 将数据添加到请求头中，让Django去取，硬性规定 data: &#123; \"user\":user&#125;, success:function(arg)&#123; console.log(arg); &#125; &#125;) &#125;&lt;/script&gt; simple_tag和filter1&#123;&#123; name|upper &#125;&#125; # upper表示内置函数,将所有字母变大写 自定义函数123456789101112131415161718192021222324252627282930313233343536# 步骤1 创建templatetags文件夹，再创建xx.py模块from django import templateregister = template.Library() # 规定写法，不能修改@register.filter # 该定义的方法只能传入2个参数def my_upper(value,arg): return value + arg@register.filter # 应用于html模版中的if判断语名def my_bool(value): return False@register.simple_tag # 推荐使用def my_lower(value,a1,a2,a3): return value + a1 + a2 + a3# 2.viewsdef test(request): return render(request,'test.html',&#123;'name':'aaaaAA'&#125;)# 3. html# &#123;% load xx %&#125;&#123;#导入加载xx模块#&#125;# &lt;h2&gt;filter&lt;/h2&gt;# &#123;&#123; name|my_upper:\"666\" &#125;&#125; # 最多支持2个参数# &#123;&#123; name|upper &#125;&#125;# &#123;% if name|my_bool %&#125;# &lt;h3&gt;真&lt;/h3&gt;# &#123;% else %&#125;# &lt;h3&gt;假&lt;/h3&gt;# &#123;% endif %&#125;# &lt;h2&gt;tag&lt;/h2&gt;# &#123;% my_lower \"ALEX\" \"x\" \"SB\" \"V\" %&#125;# 4. setting注册程序块 include小组件12345678910// pub.html&lt;div&gt; &lt;h3&gt;特别漂亮的组件&lt;/h3&gt; &lt;div class=\"title\"&gt;标题：&#123;&#123; name &#125;&#125;&lt;/div&gt; &lt;div class=\"content\"&gt;内容：&#123;&#123; name &#125;&#125;&lt;/div&gt;&lt;/div&gt;……&#123;% include 'pub.html' %&#125;…… adminadmindjango amdin是django提供的一个后台管理页面，改管理页面提供完善的html和css，使得你在通过Model创建完数据库表之后，就可以对数据进行增删改查，而使用django admin 则需要以下步骤：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 创建后台管理员# 配置url# 注册和配置django admin后台管理页面# 1、创建后台管理员# python manage.py createsuperuser# 2、配置后台管理url# url(r'^admin/', include(admin.site.urls))# 3、注册和配置django admin 后台管理页面# a、在admin中执行如下配置from django.contrib import adminfrom app01 import models admin.site.register(models.UserType)admin.site.register(models.UserInfo)admin.site.register(models.UserGroup)admin.site.register(models.Asset)# b、设置数据表名称class UserType(models.Model): name = models.CharField(max_length=50) class Meta: verbose_name = '用户类型' verbose_name_plural = '用户类型'# c、打开表之后，设定默认显示，需要在model中作如下配置class UserType(models.Model): name = models.CharField(max_length=50) def __unicode__(self): return self.namefrom django.contrib import admin from app01 import models class UserInfoAdmin(admin.ModelAdmin): list_display = ('username', 'password', 'email') admin.site.register(models.UserType)admin.site.register(models.UserInfo,UserInfoAdmin)admin.site.register(models.UserGroup)admin.site.register(models.Asset)# d、为数据表添加搜索功能from django.contrib import adminfrom app01 import models class UserInfoAdmin(admin.ModelAdmin): list_display = ('username', 'password', 'email') search_fields = ('username', 'email') admin.site.register(models.UserType)admin.site.register(models.UserInfo,UserInfoAdmin)admin.site.register(models.UserGroup)admin.site.register(models.Asset)# e、添加快速过滤from django.contrib import adminfrom app01 import models class UserInfoAdmin(admin.ModelAdmin): list_display = ('username', 'password', 'email') search_fields = ('username', 'email') list_filter = ('username', 'email') admin.site.register(models.UserType)admin.site.register(models.UserInfo,UserInfoAdmin)admin.site.register(models.UserGroup)admin.site.register(models.Asset) cookie和session cookie是保存在客户端浏览器上的键值对，Session是保存在服务端的数据（本质是键值对），用于保持会话因为单独使用cookies，它会保留用户具体的明文形式（不转化成字符串的敏感信息）发送给浏览器（不安全），所以推荐使用session，session发送的是随机字符串，不包含用户敏感信息（安全），其中session依赖于cookies,在服务端储存的是{随机字符串：键值对} 123456789101112131415161718192021222324252627def login(request): if request.method == 'GET': return render(request,'login.html') else: u = request.POST.get('user') p = request.POST.get('pwd') obj = models.UserAdmin.objects.filter(username=u,password=p).first() if obj: # 1. 生成随机字符串 # 2. 通过cookie发送给客户端 # 3. 服务端保存 # &#123; # 随机字符串1: &#123;'username':'alex','email':x''...&#125; # &#125; request.session['username'] = obj.username return redirect('/index/') else: return render(request,'login.html',&#123;'msg':'用户名或密码错误'&#125;)def index(request):# 获取客户端cookies中的随机字符串，去session中查找有无该字符串， 再通过字符串去session对应key的value中查看是有username，并获得它对应的值 v = request.session.get('username') # v为username对应的具体值 if v: return HttpResponse('登录成功:%s' %v) else: return redirect('/login/') session的方法12345678910111213141516171819202122232425262728293031323334def index(request): # 获取、设置、删除Session中数据 request.session['k1'] request.session.get('k1',None) request.session['k1'] = 123 request.session.setdefault('k1',123) # 存在则不设置 del request.session['k1'] # 所有 键、值、键值对 request.session.keys() request.session.values() request.session.items() request.session.iterkeys() request.session.itervalues() request.session.iteritems() # 用户session的随机字符串 request.session.session_key # 将所有Session失效日期小于当前日期的数据删除 request.session.clear_expired() # 检查 用户session的随机字符串 在数据库中是否 request.session.exists(\"session_key\") # 删除当前用户的所有Session数据 request.session.delete(\"session_key\") request.session.set_expiry(value) * 如果value是个整数，session会在些秒数后失效。 * 如果value是个datatime或timedelta，session就会在这个时间后失效。 * 如果value是0,用户关闭浏览器session就会失效。 * 如果value是None,session会依赖全局session失效策略。 settings12345678910111213141516# SESSION_COOKIE_NAME = \"sessionid\" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串# SESSION_COOKIE_PATH = \"/\" # Session的cookie保存的路径# SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名# SESSION_COOKIE_SECURE = False # 是否Https传输cookie# SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输# SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）# SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期# SESSION_SAVE_EVERY_REQUEST = False（推荐True） # 是否每次请求都保存Session，默认修改之后才保存SESSION_ENGINE = 'django.contrib.sessions.backends.db' # 数据库（默认）SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' #引擎，缓存+数据库，推荐使用SESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 缓存SESSION_ENGINE = 'django.contrib.sessions.backends.file' # 文件SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # cookieSESSION_CACHE_ALLAS ='default' # 使用缓存别名 用户登录demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# modelfrom django.db import modelsclass Boy(models.Model): nickname = models.CharField(max_length=32) username = models.CharField(max_length=32) password = models.CharField(max_length=63)class Girl(models.Model): nickname = models.CharField(max_length=32) username = models.CharField(max_length=32) password = models.CharField(max_length=63)class B2G(models.Model): b = models.ForeignKey(to='Boy', to_field='id',on_delete='') g = models.ForeignKey(to='Girl', to_field='id',on_delete='')# urlsurlpatterns = [ url('admin/', admin.site.urls), url(r'^login.html$', account.login), url(r'^index.html$', love.index), url(r'^loginout.html$',account.loginout), url(r'^others.html$',love.others),]# views/accountfrom django.shortcuts import render,HttpResponse,redirectfrom app01 import modelsdef login(request): \"\"\" 用户登陆 :param request: :return: \"\"\" if request.method == 'GET': return render(request,'login.html') else: user = request.POST.get('username') pwd = request.POST.get('password') gender = request.POST.get('gender') rmb = request.POST.get('rmb') # 性别判断 if gender == \"1\": obj = models.Boy.objects.filter(username=user,password=pwd).first() else: obj = models.Girl.objects.filter(username=user,password=pwd).first() if not obj: # 未登录 return render(request,'login.html',&#123;'msg': '用户名或密码错误'&#125;) else: request.session['user_info'] = &#123;'user_id':obj.id,'gender':gender,'username':user,'nickname':obj.nickname&#125; return redirect('/index.html')def loginout(request): \"\"\" 注销 :param request: :return: \"\"\" if request.session.get('user_info'): request.session.clear() # 清除服务端数据库session（推荐） # request.session.delete(request.session.session_key) # 清除客户端cookie中的session return redirect('/login.html')# views/lovefrom django.shortcuts import render,redirect,HttpResponsefrom app01 import modelsdef index(request): \"\"\" 首页信息展示 :param request: :return: \"\"\" if not request.session.get('user_info'): # 获取浏览器中的session随机字符串 return redirect('/login.html') else: # 男：女生列表 # 女：男生列表 gender = request.session.get('user_info').get('gender') if gender == '1': user_list = models.Girl.objects.all() else: user_list = models.Boy.objects.all() return render(request,'index.html',&#123;'user_list':user_list&#125;)def others(request): \"\"\" 获取与当前用户有关系的异性 :param request: :return: \"\"\" current_user_id = request.session.get('user_info').get('user_id') gender = request.session.get('user_info').get('gender') if gender == '1': user_list = models.B2G.objects.filter(b_id=current_user_id).values('g__nickname') else: user_list = models.B2G.objects.filter(g_id=current_user_id).values('b__nickname') print('result', user_list) return render(request,'others.html',&#123;'user_list':user_list&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142# login.html&lt;form method=\"POST\" action=\"/login.html\"&gt; &#123;% csrf_token %&#125; &lt;p&gt;用户：&lt;input type=\"text\" name=\"username\" /&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=\"password\" name=\"password\" /&gt;&lt;/p&gt; &lt;p&gt; 性别： 男&lt;input type=\"radio\" name=\"gender\" value=\"1\" /&gt; 女&lt;input type=\"radio\" name=\"gender\" value=\"2\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"checkbox\" name=\"rmb\" value=\"11\" /&gt; 一个月免登录 &lt;/p&gt; &lt;input type=\"submit\" value=\"提交\" /&gt;&#123;&#123; msg &#125;&#125;&lt;/form&gt;# 建立html组件：user_header&lt;h1&gt;当前用户:&#123;&#123; request.session.user_info.nickname &#125;&#125;&lt;/h1&gt;&lt;a href=\"/logout.html\"&gt;注销&lt;/a&gt;# index.html&#123;% include 'user_header.html' %&#125;&lt;h3&gt;异性列表&lt;/h3&gt;&lt;a href=\"/others.html\"&gt;查看和我有关系的异性&lt;/a&gt;&lt;ul&gt; &#123;% for row in user_list %&#125; &lt;li&gt;&#123;&#123; row.nickname &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt;# others.html&#123;% include 'user_header.html' %&#125;&lt;h1&gt;有关系的异性列表&lt;/h1&gt;&lt;ul&gt; &#123;% for row in user_list %&#125; &#123;% if row.g__nickname %&#125; &lt;li&gt;&#123;&#123; row.g__nickname &#125;&#125;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&#123;&#123; row.b__nickname &#125;&#125;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125;&lt;/ul&gt; 中间件中间件是django路由转发之前或返回response时进行的操作。用于对所有请求或一部分请求做批量处理。1234567891011121314class Middle1(MiddleMixin): def process_request(self,request): # 一般不要返回值，否则会阻止之后的中间件执行，从最后一个中间件的process_response返回，（旧版本从当前的request返回） print(\"asxafs\") def process_response(self,request,response): # 必须有返回值 print(\"print\") return response# process_request(self,request)# process_view(self, request, callback, callback_args, callback_kwargs)# process_template_response(self,request,response) # 视图函数中有render才会执行# process_exception(self, request, exception)# process_response(self, request, response) MVC和MTV文件划分方式MVC： model(数据库，模型) views(模版) controller(业务处理)MTV： model(数据库，模型) template(模板) views(业务逻辑) django ： MTV Form组件需要对请求的数据进行验证一般form提交，如果不满足要求： 判断后无法记住上次输出，页面会刷新。 一般Form组件的使用12345678910111213141516171819202122232425262728293031from django.forms import Form,fields# -------定义Form验证规则类class LoginForm(Form): # html标签name属性=Form类的字段名 # 正则验证: 不能为空,6-18 username = fields.CharField( max_length=18, min_length=6, required=True, error_messages=&#123; 'required': '用户名不能为空', 'min_length': '太短了', 'max_length': '太长了', &#125; ) # 正则验证: 不能为空，16+ password = fields.CharField(min_length=16,required=True)def login(request): #Form表单提交形式 if request.method == \"GET\": return render(request,'login.html') else: obj = LoginForm(request.POST) #将提交的数据交给Form组件验证 if obj.is_valid(): # 用户输入格式正确 print(obj.cleaned_data) # 字典类型,只包含Form组件校验后的字段数据 return redirect('http://www.baidu.com') else: # 用户输入格式错误 print(obj.errors) return render(request,'login.html',&#123;'obj':obj&#125;) 123456&lt;form method=\"post\" action=\"/login/\"&gt; &#123;% csrf_token %&#125; &lt;p&gt;username:&lt;input type=\"text\" name=\"username\"&gt;&#123;&#123;obj.errors.username.0 &#125;&#125;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"password\" name=\"password\"&gt;&#123;&#123;obj.errors.password.0 &#125;&#125;&lt;/p&gt; &lt;input type=\"submit\" value=\"submit\"&gt; &lt;/form&gt; Form和Ajax提交验证（Ajax提交不会刷新，上次内容自动保留）https://www.cnblogs.com/wupeiqi/articles/6144178.html12345678910111213141516171819202122232425262728293031323334353637&lt;h1&gt;用户登录&lt;/h1&gt;&lt;form id=\"f1\" action=\"/login/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; &lt;p&gt; &lt;input type=\"text\" name=\"user\" /&gt;&#123;&#123; obj.errors.user.0 &#125;&#125; &lt;/p&gt; &lt;p&gt; &lt;input type=\"password\" name=\"pwd\" /&gt;&#123;&#123; obj.errors.pwd.0 &#125;&#125; &lt;/p&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;a onclick=\"submitForm();\"&gt;提交&lt;/a&gt;&lt;/form&gt;&lt;script src=\"/static/jquery-1.12.4.js\"&gt;&lt;/script&gt;&lt;script&gt; function submitForm()&#123; $('.c1').remove(); $.ajax(&#123; url: '/ajax_login/', type: 'POST', data: $('#f1').serialize(),// 序列化：user=alex&amp;pwd=456&amp;csrftoen=dfdf dataType:\"JSON\", success:function(arg)&#123; console.log(arg); if(arg.status)&#123; &#125;else&#123; $.each(arg.msg,function(index,value)&#123; #index为字段名，value为错误值 var tag = document.createElement('span'); tag.innerHTML = value[0]; tag.className = 'c1'; $('#f1').find('input[name=\"'+ index +'\"]').after(tag); &#125;) &#125; &#125; &#125;) &#125;&lt;/script&gt; 123456789101112131415class LoginForm(Form): #定义Form组件类，用来验证请求数据 user = fields.CharField(required=True,min_length=6) pwd = fields.CharField(min_length=18)def ajax_login(request): import json ret=&#123;'status':True,'msg':None&#125; obj = LoginForm(request.POST) if obj.is_valid(): print(obj.cleaned_data) else: ret['status']=False ret['msg']=obj.errors # 获得字典，k为字段名，v为错误信息列表 v=json.dumps(ret) print(obj.errors) #print时，会自动调用__str__(),在该方法中将字典组装成了&lt;ul&gt;标签 return HttpResponse(v) Form组件常见字段123456789101112131415161718192021222324252627282930313233343536373839404142class TestForm(Form): t1 = fields.CharField( required=True, max_length=8, min_length=2, error_messages=&#123; 'required': '不能为空', 'max_length': '太长', 'min_length': '太短', &#125; ) t2 = fields.IntegerField( min_value=10, max_value=1000, error_messages=&#123; 'required': 't2不能为空', 'invalid': 't2格式错误，必须是数字', # 格式错误 'min_value': '必须大于10', 'max_value': '必须小于1000', &#125;, ) t3 = fields.EmailField( error_messages=&#123; 'required': 't3不能为空', 'invalid': 't3格式错误，必须是邮箱格式', &#125; ) # 为空，长度，格式，正则 t4=fields.URLField() t5=fields.SlugField() t6=fields.GenericIPAddressField() t7=fields.DateField() t8=fields.DateTimeField() t9=fields.RegexField('139\\d+') # 自定义正则表达式的字段验证规则widget=widgets.Select, # ******** 用于指定生成怎样的HTML，select，text,input/. # 插件 label='用户名', # 在前端可以通过obj.t1.label使用disabled=False, # 是否可以编辑label_suffix='---&gt;', # Label内容后缀 需要在html模版中添加&#123;&#123; obj.as_p &#125;&#125;来显示出所有Form类中定义的字段initial='666', # 无用，猜测有问题应该在input框中显示默认值help_text='。。。。。。', # 提供帮助信息 Form组件之保留上次输入框内容12345678910111213141516# 采用Form组件生成的表单组件作为页面标签才能完成保留上次输入框的数据&lt;form action=\"/register/\" method=\"POST\" novalidate&gt; #novalidate是忽略浏览器的表单验证规则 &#123;% csrf_token %&#125; &lt;p&gt; &#123;&#123; obj.user &#125;&#125; &#123;&#123; obj.errors.user.0 &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; obj.email &#125;&#125; &#123;&#123; obj.errors.email.0 &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; obj.password &#125;&#125; &#123;&#123; obj.errors.password.0 &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; obj.phone &#125;&#125; &#123;&#123; obj.errors.phone.0 &#125;&#125; &lt;/p&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; 1234567891011121314151617class RegiterForm(Form): user = fields.CharField(min_length=8) email = fields.EmailField() password = fields.CharField() phone = fields.RegexField('139\\d+') def register(request): if request.method == 'GET': obj = RegiterForm() return render(request,'register.html',&#123;'obj':obj&#125;) # 只返回表单组件类的HTML文本，无数值返回 else: obj = RegiterForm(request.POST) # 因用户提交了数据，Form组件会返回带有输入框值的HTML文本 if obj.is_valid(): print(obj.cleaned_data) else: print(obj.errors) return render(request,'register.html',&#123;'obj':obj&#125;)","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[]},{"title":"动态规划问题","slug":"动态规划问题","date":"2020-04-24T15:45:26.000Z","updated":"2021-02-19T02:26:06.901Z","comments":true,"path":"2020/04/24/动态规划问题/","link":"","permalink":"https://sjtu-xx.github.io/2020/04/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"动态规划问题的关键在于记住已经求过的解，记住求解的方式有两种：①自顶向下的备忘录法 ②自底向上。①自顶向下的备忘录法即在计算过程中，将中间结果记录在数组中，为下次使用作准备。②自底向上先计算出子结果，再进行计算。","categories":[{"name":"算法","slug":"算法","permalink":"https://sjtu-xx.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"数据挖掘复习","slug":"数据挖掘","date":"2020-04-21T07:24:45.000Z","updated":"2021-02-19T02:26:07.125Z","comments":true,"path":"2020/04/21/数据挖掘/","link":"","permalink":"https://sjtu-xx.github.io/2020/04/21/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/","excerpt":"PCA实际上选择最大的特征向量，进行PCA时，不考虑label，即为非监督的。这就可能会导致进行PCA后，将原本可分的数据变的不可分。这时需要进行LDA（线性判别分析）","text":"PCA实际上选择最大的特征向量，进行PCA时，不考虑label，即为非监督的。这就可能会导致进行PCA后，将原本可分的数据变的不可分。这时需要进行LDA（线性判别分析）SVM常用的核函数：多项式（映射到$m_2$维度）、高斯（映射到无穷维）、双曲正切函数 聚类结果好坏的判定：J（越小越好），直观的看见silhouette Sequential leader clustering 高斯混合算法，多个高斯分布，概率和为1。经典EM算法：期望最大,初值很重要，最后得到局部最优 基于密度的算法：DBSCAN（density-based spatial cluster of application with noise） 不用事先确定k，连通性（朋友的朋友） 层次聚类 关联规则：频繁集（Frequent itemsets）：两个同时被购买关联规则（association rule）：买了一本书会买另一本序列模式（Sequential pattern） 支持度（support）：即频率，即多少个transactions（itemset）中包含了该item或itemset置信度（confidence）：简单来说就是条件概率，即P（Y｜X）：num（包含itemset的transaction）/num（包含itemset中的某个item的transaction） 关联规则的挖掘：找到所有满足支持度大于阈值，置信度大于阈值的规则 误区：1.求的的置信度很大时，也有可能小于原始事件本身发生的概率2.当两个item出现概率差别很大时，会误认为出现概率高的item一定会是的概率低的item发生。3.两个时间相关，不代表两者之间有因果关系 The Apriori Methodkey idea：1.频繁集的子集必定频繁； 2.一个item不频繁则其超集不频繁； 步骤：1.生成确定大小的itemset2.扫描数据库，看看哪些是频繁的3.将已知频繁的itemset组合4.进行2 比如对于大小为2的频繁集，如果要生成大小为3的频繁集，不需要将大小为1的频繁集加到2中，只需要将大小为2的频繁集加上其中的频繁item。如{(2,3),(2,5),(3,5),(1,3)} -&gt; {(2,3,5)} 推荐算法TF-IDFTF（term frequency）：单词在特定文档中出现的频率IDF（inverse document frequency）：log（所有文档个数/包含特定词的个数）TF-IDF = TF*IDF Vector Space Model每一位表示一个单词比较相似度：$cos(\\theta)=\\frac{p·q}{|p|·|q|}$ Latent Semantic Analysis类似PCA的降维 PageRank指向别的网页少，指向其的网页PageRank的和 Collaborative filtering（协同过滤）User-based CF找类似的item做参考需要用到平均值作为基值Model-based CF将表格转换为分类问题，再训练 框架集成学习（ensemble）—-用于监督学习中的分类问题包含bagging和boosting 均值投票（可以加权）学习combiner bagging基于bootstrap的分类器：训练多个分类器，来个样本，多个分类器投票。如随机森林bootstrap sample有放回的采样 stacking学习分类器的权重 boosting串行的，根据生成的分类器，再生成第二个分类器，让后面的分类器学习第一个分类器分错的样本（或权重大的样本），第三个分类器学习前两个分类器分类不一致的样本。 adaboost修改权重 regionboost给权重增加了与输入的关联性 进化算法遗传算法https://blog.csdn.net/u010451580/article/details/51178225所以我们总结出遗传算法的一般步骤：开始循环直至找到满意的解。 1.评估每条染色体所对应个体的适应度。 2.遵照适应度越高，选择概率越大的原则，从种群中选择两个个体作为父方和母方。 3.抽取父母双方的染色体，进行交叉，产生子代。 4.对子代的染色体进行变异。 5.重复2，3，4步骤，直到新种群的产生。 结束循环。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://sjtu-xx.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"SQL经典案例（50题）","slug":"SQL经典案例（50题）","date":"2020-04-18T12:19:38.000Z","updated":"2021-02-19T02:26:06.338Z","comments":true,"path":"2020/04/18/SQL经典案例（50题）/","link":"","permalink":"https://sjtu-xx.github.io/2020/04/18/SQL%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%EF%BC%8850%E9%A2%98%EF%BC%89/","excerpt":"表结构","text":"表结构12345678910111213141516171819Student(Sid,Sname,Sage,Ssex)学生表sid：学号sname：学生姓名sbirth：学生年龄ssex：学生性别Course(Cid,Cname,T#)课程表cid：课程编号cname：课程名称tid：教师编号Score(Sid,Cid,score)成绩表sid：学号cid：课程编号score：成绩Teacher(Tid,Tname)教师表tid：教师编号：tname：教师名字 数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263CREATE TABLE `Student`(`sid` VARCHAR(20),`sname` VARCHAR(20) NOT NULL DEFAULT '',`sbirth` VARCHAR(20) NOT NULL DEFAULT '',`ssex` VARCHAR(10) NOT NULL DEFAULT '',PRIMARY KEY(`s_id`));CREATE TABLE `Course`(`cid` VARCHAR(20),`cname` VARCHAR(20) NOT NULL DEFAULT '',`tid` VARCHAR(20) NOT NULL,PRIMARY KEY(`c_id`));CREATE TABLE `Teacher`(`tid` VARCHAR(20),`tname` VARCHAR(20) NOT NULL DEFAULT '',PRIMARY KEY(`t_id`));CREATE TABLE `Score`(`sid` VARCHAR(20),`cid` VARCHAR(20),`score` INT(3),PRIMARY KEY(`s_id`,`c_id`));insert into Student values('01' , '赵雷' , '1990-01-01' , '男');insert into Student values('02' , '钱电' , '1990-12-21' , '男');insert into Student values('03' , '孙风' , '1990-05-20' , '男');insert into Student values('04' , '李云' , '1990-08-06' , '男');insert into Student values('05' , '周梅' , '1991-12-01' , '女');insert into Student values('06' , '吴兰' , '1992-03-01' , '女');insert into Student values('07' , '郑竹' , '1989-07-01' , '女');insert into Student values('08' , '王菊' , '1990-01-20' , '女');insert into Course values('01' , '语文' , '02');insert into Course values('02' , '数学' , '01');insert into Course values('03' , '英语' , '03');insert into Teacher values('01' , '张三');insert into Teacher values('02' , '李四');insert into Teacher values('03' , '王五');insert into Score values('01' , '01' , 80);insert into Score values('01' , '02' , 90);insert into Score values('01' , '03' , 99);insert into Score values('02' , '01' , 70);insert into Score values('02' , '02' , 60);insert into Score values('02' , '03' , 80);insert into Score values('03' , '01' , 80);insert into Score values('03' , '02' , 80);insert into Score values('03' , '03' , 80);insert into Score values('04' , '01' , 50);insert into Score values('04' , '02' , 30);insert into Score values('04' , '03' , 20);insert into Score values('05' , '01' , 76);insert into Score values('05' , '02' , 87);insert into Score values('06' , '01' , 31);insert into Score values('06' , '03' , 34);insert into Score values('07' , '02' , 89);insert into Score values('07' , '03' , 98); 1、查询“001”课程比“002”课程成绩高的所有学生的学号1234-- 查询“001”课程比“002”课程成绩高的所有学生的学号SELECT a.sid,a.score,b.score FROM (SELECT sid,score FROM Score WHERE cid='01') as a INNER JOIN (SELECT sid,score FROM Score WHERE cid='02') as b on a.sid=b.sid WHERE a.score&gt;b.score; 2、查询平均成绩大于60分的同学的学号和平均成绩1234SELECT sid,avg(score) as avgsFROM ScoreGROUP BY sidHAVING avgs&gt;60 3、查询所有同学的学号、姓名、选课数、总成绩12345SELECT s.sid,s.sname,sc.count_class,sc.sum_scoreFROM Student as sLEFT JOIN (SELECT sid,count(cid) as count_class,sum(score) as sum_score FROM Score GROUP BY sid) as scon s.sid=sc.sid 4、查询姓‘李’的老师的个数：123SELECT count(*)FROM TeacherWHERE tname LIKE \"李%\" 5、查询没有学过“叶平”老师可的同学的学号、姓名：12345678910SELECT s.sid,s.snameFROM Student as sWHERE sid NOT IN(SELECT DISTINCT sidFROM Score as scWHERE cid IN (SELECT cid FROM Course as c LEFT JOIN Teacher as t ON t.tid=c.tid WHERE t.tname='叶平')) 6、查询学过“叶平”老师所教的所有课的同学的学号、姓名：1234567891011SELECT s.sid,s.snameFROM Student as sWHERE s.sid IN(SELECT sidFROM Score as scINNER JOIN Course as c on sc.cid=c.cidINNER JOIN Teacher as t on c.tid=t.tidWHERE t.tname='叶平'GROUP BY sc.sidHAVING count(sc.cid)=(SELECT count(cc.cid) FROM Teacher as tt,Course as cc WHERE tt.tid=cc.cid and tt.tname='叶平')) 7、查询学过“011”并且也学过编号“002”课程的同学的学号、姓名：1234SELECT sid,snameFROM StudentWHERE sid IN (SELECT sid FROM Score WHERE cid='01')AND sid IN (SELECT sid FROM Score WHERE cid='01') 8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名：1234567891011SELECT s.sid,s.snameFROM Student as sWHERE s.sid IN(SELECT t1.sid FROM(SELECT *FROM ScoreWHERE cid='02') as t2,(SELECT *FROM ScoreWHERE cid='01') as t1WHERE t1.sid=t2.sid AND t1.score&gt;t2.score) 9、查询所有课程成绩小于60的同学的学号、姓名：12345SELECT *FROM StudentWHERE sid IN(SELECT sid FROM Score as scWHERE 60&gt; ALL(SELECT score FROM Score as sc2 WHERE sc.sid=sc2.sid)) 10、查询没有学全所有课的学生的学号、姓名1234567SELECT *FROM StudentWHERE sid IN(SELECT sidFROM Score as scGROUP BY sidHAVING count(cid)=(SELECT count(*) from Course)) 11、查询至少有一门课与学号为“1001”同学所学相同的同学的学号和姓名：12345678910SELECT *FROM StudentWHERE sid IN(SELECT DISTINCT sc.sidFROM Score as scWHERE sc.cid IN(SELECT cidFROM ScoreWHERE sid='01')) 12、查询和“01”号同学所学课程完全相同的其他同学的学号12345SELECT sidFROM ScoreWHERE cid in (SELECT sc.cid FROM Score as sc WHERE sc.sid='01')GROUP BY sidHAVING count(cid)=(SELECT count(sc2.cid) FROM Score as sc2 WHERE sc2.sid='01' GROUP BY sc2.sid) 13、把“SCORE”表中“张三”老师教的课的成绩都更改为此课程的平均成绩123456789-- 错误，更新出现在子查询中START TRANSACTION;UPDATE Score as scSET score=(SELECT AVG(b.score) FROM Score as b WHERE sc.cid=b.cid GROUP BY b.cid)WHERE sc.cid in (SELECT cidFROM Teacher as t,Course as cWHERE t.tname='张三' and t.tid=c.tid);ROLLBACK; 14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名：1234567891011121314SELECT *FROM StudentWHERE sid IN(SELECT sidFROM Score as scWHERE sc.cid in (SELECT cid FROM Score AS sc WHERE sc.sid='02')GROUP BY sc.sidHAVING count(sc.cid)=(SELECT count(cid)FROM Score AS scWHERE sc.sid='02')) 15、删除学习“张三”老师课的SC表记录123456789START TRANSACTION;DELETE FROM ScoreWHERE cid IN(SELECT cidFROM Course as cINNER JOIN Teacher as t on c.tid=t.tidWHERE t.tname='张三');SELECT * FROM Score;ROLLBACK; 16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、002号课的平均成绩：1234567START TRANSACTION;INSERT ScoreSELECT sid,'02',(SELECT AVG(sc2.score) FROM Score as sc2 WHERE sc2.cid='02')FROM StudentWHERE sid NOT IN (SELECT sid FROM Score WHERE cid='03');SELECT * FROM score;ROLLBACK; 17、按平均成绩从高到低显示所有学生的“语文”（c_id=’01’）、“数学”（c_id=’02’）、“英语”（c_id=’03’）三门课程成绩,按如下形式显示：学生ID，语文，数学，英语，有效课程数，有效平均分1234567SELECT sc2.sid,(SELECT score FROM Score as sc WHERE sc.cid='02' and sc.sid=sc2.sid) as '课程',count(*),AVG(sc2.score)FROM Score as sc2GROUP BY sidORDER BY AVG(sc2.score) 18、查询各科成绩最高和最低的分：以如下的形式显示：课程ID，最高分，最低分1234SELECT cid,(SELECT MAX(score) FROM Score as sc WHERE sc.cid=c.cid) as 最高分,(SELECT MIN(score) FROM Score as sc WHERE sc.cid=c.cid) as 最低分FROM Course as c 19、按各科平均成绩从低到高和及格率的百分数从高到低顺序：12345SELECT cid,MAX(score) as 最高分,MIN(score) as 最低分FROM score as scGROUP BY cid 20、查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）：123456SELECT sc.cid as 课程号,c.cname as 课程名,AVG(sc.score) as 平均成绩, (SELECT count(sid) FROM Score as sc2 WHERE sc.cid=sc2.cid and sc2.score&gt;60)/count(sid) as 及格率FROM Score as sc INNER JOIN Course as c ON sc.cid=c.cidWHERE sc.cid in ('01','02','03')GROUP BY sc.cidORDER BY 平均成绩,及格率 DESC; 21、查询不同老师所教不同课程平均分从高到低显示：123456SELECT sc.cid,t.tname,c.cname,avg(sc.score)FROM Score as scINNER JOIN Course as c on sc.cid=c.cidINNER JOIN Teacher as t on c.tid=t.tidGROUP BY cidORDER BY avg(sc.score) DESC 22、查询如下课程成绩第3名到第6名的学生成绩单：企业管理(001)，马克思(002)，UML(003)，数据库(004)：23、统计下列各科成绩，各分数段人数：课程ID，课程名称，[100-85],[85-70],[70-60],[ 小于60] ：123456789SELECT sc.cid,c.cname,sum(CASE WHEN sc.score&gt;85 THEN 1 ELSE 0 END) as '100-85',sum(CASE WHEN sc.score&gt;70 and sc.score&lt;=85 THEN 1 ELSE 0 END) as '85-70',sum(CASE WHEN sc.score&gt;60 and sc.score&lt;=70 THEN 1 ELSE 0 END) as '70-60',sum(CASE WHEN sc.score&lt;60 THEN 1 ELSE 0 END) as '&lt;60'FROM Score as scLEFT JOIN Course as cON sc.cid=c.cidGROUP BY sc.cid 24、查询学生平均成绩及其名次：123456789101112SELECT (SELECT 1+count(DISTINCT avgs)FROM(SELECT sc.sid,AVG(sc.score) as avgsFROM Score as scGROUP BY sid) as T1WHERE T1.avgs&gt;T2.avgs) as 名次,T2.sid,T2.avgsFROM (SELECT sid,avg(score) as avgsFROM ScoreGROUP BY sid) as T2ORDER BY avgs desc; 25、查询各科成绩前三名的记录（不考虑成绩并列情况）：1234567SELECT *FROM Score as aWHERE (SELECT count(*)FROM Score as bWHERE a.cid=b.cid and b.score&gt;a.score)&lt;3ORDER BY cid,score DESC 26、查询每门课程被选修的学生数：123SELECT cid,count(sid)FROM ScoreGROUP BY cid 27、查询出只选修一门课程的全部学生的学号和姓名：12345SELECT DISTINCT s.sid,s.sname,count(sc.cid)FROM Student as sLEFT JOIN Score as sc ON s.sid=sc.sidGROUP BY s.sidHAVING count(sc.cid)=1 28、查询男生、女生人数：123SELECT sum(case WHEN s.ssex='男' THEN 1 ELSE 0 END) as 男,sum(case WHEN s.ssex='女' THEN 1 ELSE 0 END) as 女FROM Student as s 29、查询姓“张”的学生名单：123SELECT *FROM StudentWHERE sname like '张%' 30、查询同名同姓的学生名单，并统计同名人数：123456789SELECT DISTINCT a.sname,count(*)FROM Student as a,Student as bWHERE a.sid&lt;&gt;b.sid and a.sname=b.snameGROUP BY a.snameSELECT sname,count(*)FROM StudentGROUP BY snameHAVING count(*)&gt;1 31、1981年出生的学生名单（注：student表中sage列的类型是datetime）:123SELECT *FROM Student as sWHERE YEAR(s.sbirth)='1990' 32、查询平均成绩大于85的所有学生的学号、姓名和平均成绩：12345SELECT sc.sid,s.sname,AVG(sc.score)FROM Score as scINNER JOIN Student as s on s.sid=sc.sidGROUP BY sidHAVING AVG(sc.score)&gt;85 33、查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列：1234SELECT cid,AVG(score)FROM ScoreGROUP BY cidORDER BY AVG(score),cid DESC; 34、查询课程名称为“数据库”，且分数低于60的学生名字和分数：12345SELECT s.sname,sc.scoreFROM Score as scINNER JOIN Course as c on sc.cid=c.cidINNER JOIN Student as s on s.sid=sc.sidWHERE c.cname='数据库' AND sc.score&lt;60 35、查询所有学生的选课情况：1234SELECT s.sname,sc.sid,c.cidFROM Score as scLEFT JOIN Course as c ON sc.cid=c.cidLEFT JOIN Student as s ON sc.sid=s.sid 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数：12345SELECT DISTINCT s.sname,sc.score,c.cnameFROM Student as sLEFT JOIN Score as sc ON s.sid=sc.sidLEFT JOIN Course as c ON sc.cid=c.cidWHERE sc.score&gt;70 37、查询不及格的课程，并按课程号从大到小的排列：1234SELECT *FROM ScoreWHERE score&lt;60ORDER BY cid 38、查询课程编号为“003”且课程成绩在80分以上的学生的学号和姓名：1234567SELECT s.sid,s.snameFROM Student as sWHERE s.sid IN(SELECT DISTINCT sidFROM ScoreWHERE score&gt;80 and cid='03') 39、求选了课程的学生人数：12SELECT count(DISTINCT sid) FROM Score 41、查询各个课程及相应的选修人数：123SELECT cid,count(*)FROM ScoreGROUP BY cid; 42、查询不同课程成绩相同的学生和学号、课程号、学生成绩：1234select DISTINCT a.sid,a.cid,a.scorefrom Score as a ,Score as b where a.score = b.scoreand a.cid &lt;&gt; b.cid; 43、查询每门课程成绩最好的前两名：123456SELECT *FROM Score as aWHERE (SELECT count(*) FROM Score as b WHERE a.cid=b.cid and b.score&gt;a.score)&lt;3ORDER BY cid,score desc; 44、统计每门课程的学生选修人数(超过10人的课程才统计)。要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序：12345SELECT cid,count(score) as csFROM ScoreGROUP BY cidHAVING cs &gt; 10ORDER BY cs DESC,cid; 45、检索至少选修两门课程的学生学号：1234SELECT sidFROM ScoreGROUP BY sidHAVING count(cid)&gt;=2 46、查询全部学生选修的课程和课程号和课程名：123SELECT cid,cnameFROM CourseWHERE cid IN(SELECT cid FROM Score) 47、查询没学过”叶平”老师讲授的任一门课程的学生姓名123456789101112SELECT s.snameFROM Student as sWHERE s.sid NOT IN(SELECT sidFROM Score as scWHERE sc.cid IN(SELECT cidFROM Course as cINNER JOIN Teacher as tWHERE c.tid=t.tid and t.tname='叶平')) 48、查询两门以上不及格课程的同学的学号以及其平均成绩：123456789SELECT sid,avg(score)FROM ScoreWHERE sid IN (SELECT sidFROM ScoreWHERE score&lt;60GROUP BY sidHAVING count(sid)&gt;2)GROUP BY sid 49、检索“004”课程分数小于60，按分数降序排列的同学学号：1234SELECT sidFROM ScoreWHERE cid='004' and score&lt;60ORDER BY score DESC; 50、删除“002”同学的“001”课程的成绩：12DELETE FROM ScoreWHERE sid='002' and cid='001'","categories":[{"name":"算法","slug":"算法","permalink":"https://sjtu-xx.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"十种排序算法","slug":"十种排序算法","date":"2020-04-14T02:43:15.000Z","updated":"2021-02-19T02:26:06.901Z","comments":true,"path":"2020/04/14/十种排序算法/","link":"","permalink":"https://sjtu-xx.github.io/2020/04/14/%E5%8D%81%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"0、算法概述","text":"0、算法概述 0.1 算法分类 十种常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 0.2 算法复杂度 0.3 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机 内执行时所需存储空间的度量，它也是数据规模n的函数。 1、 冒泡排序冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 2、 选择排序选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 表现最稳定的排序算法之一，因为无论什么数据进去都是O($n^2$)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 3、 插入排序它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 4、 希尔排序它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。算法步骤： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 5、 归并排序步骤： 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 6、 快速排序步骤： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 7、 堆排序通过大顶堆不断选出最大、次大、第三大。。。步骤： 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 8、 计数排序 9、 桶排序桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 10、 基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。","categories":[{"name":"算法","slug":"算法","permalink":"https://sjtu-xx.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Polar Mask分割算法【转载】","slug":"Polar-Mask分割算法","date":"2020-04-08T14:36:16.000Z","updated":"2021-02-19T02:26:06.314Z","comments":true,"path":"2020/04/08/Polar-Mask分割算法/","link":"","permalink":"https://sjtu-xx.github.io/2020/04/08/Polar-Mask%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95/","excerpt":"PolarMask的精度并不是很高，而且速度上也没有优势，但是它的思路是非常巧妙的，对后面的研究有着很大的启发意义。","text":"PolarMask的精度并不是很高，而且速度上也没有优势，但是它的思路是非常巧妙的，对后面的研究有着很大的启发意义。转载自：https://zhuanlan.zhihu.com/p/84890413 PolarMask, 一种single shot的实例分割框架，文章在https://arxiv.org/abs/1909.13226, 代码已经开源，在https://github.com/xieenze/PolarMask。欢迎大家多多指教。 PolarMask基于FCOS，把实例分割统一到了FCN的框架下。在4月份FCOS挂出来之后，我和沈老师就一直在讨论如何进把instance segmentation融合进FCN里。FCOS本质上是一种FCN的dense prediction的检测框架，可以在性能上不输anchor based的目标检测方法，让行业看到了anchor free方法的潜力。接下来要解决的问题是实例分割。 这个工作我个人觉得最大的贡献在于，把更复杂的实例分割问题，转化成在网络设计和计算量复杂度上和物体检测一样复杂的任务，把对实例分割的建模变得简单和高效。 Mask R-CNN首先回顾一下之前最经典的实例分割方法，‘先检测再分割’，在这方面做到极致的算法是Mask RCNN。 Mask R-CNN属于基于两阶段的检测算法，在检测框的基础上进行像素级的语义分割，简化了实例分割的难度，同时取得了stoa的性能，在’先检测再分割’ 这一范式上做到了极致。 **PolarMask **我们的PolarMask提出了一种新的instance segmentation建模方式，通过寻找物体的contour建模，提供了一种新的方法供大家选择。 **两种实例分割的建模方式： **1 像素级建模 类似于图b，在检测框中对每个pixel分类2 轮廓建模 类似于图c和图d，其中，图c是基于直角坐标系建模轮廓，图d是基于极坐标系建模轮廓 可以看到Mask R-CNN属于第一种建模方式，而我们提出的PolarMask属于图d建模方式。图c也会work，但是相比图d缺乏固定角度先验。换句话说，基于极坐标系的方式已经将固定角度设为先验，网络只需回归固定角度的长度即可，简化了问题的难度。 PolarMask 基于极坐标系建模轮廓，把实例分割问题转化为实例中心点分类(instance center classification)问题和密集距离回归(dense distance regression)问题。同时，我们还提出了两个有效的方法，用来优化high-quality正样本采样和dense distance regression的损失函数优化，分别是Polar CenterNess和 Polar IoU Loss。没有使用任何trick(多尺度训练，延长训练时间等)，PolarMask 在ResNext 101的配置下 在coco test-dev上取得了32.9的mAP。 这是首次，我们证明了更复杂的实例分割问题，可以在网络设计和计算复杂度上，和anchor free物体检测一样简单。我们希望PolarMask可以成为一个简单且强有效的single shot instance segmentation 的baseline。 PolarMask最重要的特点是:(1) anchor free and bbox free，不需要出检测框(2) fully convolutional network, 相比FCOS把4根射线散发到36根射线，将instance segmentation和object detection用同一种建模方式来表达。 我们选取FCOS嵌入我们的方法，主要是为了simple。FCOS是目前state-of-the-art的anchor-free检测器，并且十分simple。我们在FCOS的基础上，几乎不加任何计算量，就可以建模实例分割问题，并取得competitive的性能，证明了实例分割可以简化成和目标检测相同复杂的问题。此外，FCOS可以看成PolarMask的特殊形式，而PolarMask可以看作FCOS的通用形式，因为bbox本质上是最简单的Mask，只有0,90,180,270四个角度回归长度。 我们首次将instance segmentation和object detection用同一种建模方式来表达。 网络结构 整个网络和FCOS一样简单，首先是标准的backbone + fpn模型，其次是head部分，我们把fcos的bbox分支替换为mask分支，仅仅是把channel=4替换为channel=n, 这里n=36，相当于36根射线的长度。同时我们提出了一种新的Polar Centerness 用来替换FCOS的bbox centerness。可以看到，在网络复杂度上，PolarMask和FCOS并无明显差别。 Polar Segmentation建模 首先，输入一张原图，经过网络可以得到中心点的位置和n(n=36 is best in our setting)根射线的距离，其次，根据角度和长度计算出轮廓上的这些点的坐标，从0°开始连接这些点，最后把联通区域内的区域当做实例分割的结果。在实验中，我们以重心为基准，assign到feature map上，会在重心周围采样，作为正样本，别的地方当做负样本，训练方式和FCOS保持一致，采用Focal Loss, 在此，我们提出Polar CenterNess，用来选择出高质量的正样本，给低质量的正样本降低权重。 Polar CenterNess 如何在Polar Coordinate下定义高质量的正样本？我们通过如下公式定义 其中 d1 d2….dn指的是36根射线的长度，最好的正样本必须具备dmin ——&gt; dmax. 用一张图举例 以看到中间的图，会出现长度回归差别很大的问题，而右边的图中心点位置就较为合适，到所有轮廓的长度回归就较为接近，36根射线的距离会比较均衡。 Polar Centerness 可以给右边图的点较高的centerness分数，给中间图的点降低centerness分数，这样在infernece的时候右边图的点分数较高。 根据消融实验，Polar Centerness可以有效提高1.4的性能，同时不增加网络复杂度。结果如下图所展示 Polar IoU Loss 在PolarMask中，需要回归k(k=36)根射线的距离，这相比目标检测更为复杂，如何监督regression branch是一个问题。我们提出Polar IoU Loss近似计算出predict mask和gt mask的iou，通过Iou Loss 更好的优化mask的回归。通过实验证明，Polar IoU Loss相比Smooth L1loss可以明显提高2.6个点，同时Smooth L1loss还面临和其他loss不均衡的问题，需要精心调整权重，这是十分低效的，Polar IoU loss不需要调整权重就可以使mask分支快速且稳定收敛。那么，Polar IoU Loss如何计算呢？如下图所展示 可以看到 两个mask的Iou可以简化为在dθ下的三角形面积iou问题并对无数个三角形求和，最终可以推倒到如下形式： 其实最终的表达形式十分简单，但是相比smooth l1的确可以不用调参并裸涨2.6个点。说明loss func的设计对于深度神经网络呢意义重大。结果如下所展示 我们在论文中还做了如下消融实验：射线数量的选择，加不加bbox branch, backbone以及尺寸和速度的trade off. 细节在论文中都有，不一一展开。 上限分析 看到这里，很多人心里都会有一个疑问，射线这种建模方式，对于凹的物体会有性能损失，上限达不到100mAP，PolarMask怎么处理这个问题？答案是这样，PolarMask相比Mask R-CNN这种pixel建模的方法，对于形状特别奇怪的mask的确建模会失败，但是这并不代表polarmask毫无意义。原因有两个，(1)Mask R-CNN的上限也到不了100 mAP 因为有下采样这类操作使得信息损失。(2)不管Mask R-CNN还是PolarMask，他们的实际性能距离100mAP的上限都特别远。所以我们目前应该关注如何让实际网络性能去更好地趋近于上限。 定量分析分析射线建模的上限： 如图所示，当采用mass center做instance中心时，当射线数量不断提高，射线的gt和真实的gt的平均iou高达90%以上，这证明了对于射线建模的性能上限的忧虑还远远不需要担心。现阶段需要操心的问题是如何不断提高基于射线建模的网络性能。 实验 最终，配上一图一表展示一下相比sota的结果 可以看到, 没用采用任何trick的情况下，PolarMask在resnext101-fpn的情况下，取得了32.9的配置，虽然不是stoa，但是也比较有竞争力。我们目前并没有采用很多常用的能涨点的trick，比如 ms train和longer training epochs。相比之下，别的one stage方法都不约而同的采用了mstrain和longer training epoches。 我们会进一步改进，争取再提高性能。 后记： 我们会尽快完善并放出带多尺度训练和增长训练时间的代码和模型，以提供给大家并和上述模型公平比较，做instance segmentation非常费卡和时间，希望大家理解。 一些调参的碎碎念： 这个工作在今年4月FCOS出来的同时，我和沈春华老师就在讨论如何进行FCOS进行single shot anchor free实例分割，以及在CVPR开会的时候，和文海，彦伟, 宋林等小伙伴就论证过contour regression的可行性，因为大家可以看出，anchor free 物体检测已经是大势所趋，下一个领域必然是anchor free实例分割，预测一下，再下一个领域是全景分割。在和沈老师这么多月的讨论中以及一次又一次实验的失败中，polarmask逐渐成型。最开始mask regression无数次无法收敛，写mask iou loss又复杂效果还不怎么好，直到某一天想出了polar iou loss。发现性能很好，不用调参，一把出结果。感觉平时做研究还是需要多思考，而不是盲目的做实验。同时，polar centerness也是我在旅游的过程中想到的，然后立马找了个咖啡厅写代码调试，裸涨1.4个点。这两个方法在不增加计算量的情况下，充分发挥了polarmask的性能，看起来其实很简单，但是实际上是背后很多次思考和化简的结果。 总得来说，我最喜欢这篇文章就两点， 1 足够简单，不加任何trick, 也没有任何复杂的操作，比如deformable conv和roi align操作，有希望在工业界大规模应用 2 找到了一种表达方式，把bbox detection和mask segmentation统一了起来，和FCOS是一种传承的工作，FCOS理论上可以看成PolarMask的特殊版，而PolarMask是FCOS的泛化版，因为bbox本质上是最简单的Mask。 PolarMask本质上可以看成一个目标检测和实例分割统一的框架。只需要简单修改就可以退化到FCOS。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"实例分割","slug":"深度学习/实例分割","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"}],"tags":[]},{"title":"实例分割综述(2020.3)【转载】","slug":"实例分割综述-2020-3","date":"2020-04-08T09:01:36.000Z","updated":"2021-02-19T02:26:06.913Z","comments":true,"path":"2020/04/08/实例分割综述-2020-3/","link":"","permalink":"https://sjtu-xx.github.io/2020/04/08/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2%E7%BB%BC%E8%BF%B0-2020-3/","excerpt":"转载自：https://cloud.tencent.com/developer/article/1594081","text":"转载自：https://cloud.tencent.com/developer/article/1594081 前面的话实例分割（Instance Segmentation）是视觉经典四个任务中相对最难的一个，它既具备语义分割（Semantic Segmentation）的特点，需要做到像素层面上的分类，也具备目标检测（Object Detection）的一部分特点，即需要定位出不同实例，即使它们是同一种类。因此，实例分割的研究长期以来都有着两条线，分别是自下而上的基于语义分割的方法和自上而下的基于检测的方法，这两种方法都属于两阶段的方法，下面将分别简单介绍。 自上而下的实例分割方法 思路是：首先通过目标检测的方法找出实例所在的区域（bounding box），再在检测框内进行语义分割，每个分割结果都作为一个不同的实例输出。 自上而下的密集实例分割的开山鼻祖是DeepMask，它通过滑动窗口的方法，在每个空间区域上都预测一个mask proposal。这个方法存在以下三个缺点： mask与特征的联系（局部一致性）丢失了，如DeepMask中使用全连接网络去提取mask 特征的提取表示是冗余的， 如DeepMask对每个前景特征都会去提取一次mask 下采样（使用步长大于1的卷积）导致的位置信息丢失 自下而上的实例分割方法 思路是：首先进行像素级别的语义分割，再通过聚类、度量学习等手段区分不同的实例。这种方法虽然保持了更好的低层特征（细节信息和位置信息），但也存在以下缺点： 对密集分割的质量要求很高，会导致非最优的分割 泛化能力较差，无法应对类别多的复杂场景 后处理方法繁琐 单阶段实例分割（Single Shot Instance Segmentation），这方面工作其实也是受到了单阶段目标检测研究的影响，因此也有两种思路，一种是受one-stage, anchor-based 检测模型如YOLO，RetinaNet启发，代表作有YOLACT和SOLO；一种是受anchor-free检测模型如 FCOS 启发，代表作有PolarMask和AdaptIS。 下面是对其中一些方法在COCO数据集上的指标对比： Method AP AP50 AP75 APs APm APL FCIS 29.2 49.5 7.1 31.3 50.0 Mask R-CNN 37.1 60.0 39.4 16.9 39.9 53.5 YOLACT-700 31.2 50.6 32.8 12.1 33.3 47.1 PolarMask 32.9 55.4 33.8 15.5 35.1 46.3 SOLO 40.4 62.7 43.3 17.6 43.3 58.9 PointRend 40.9 BlendMask 41.3 63.1 44.6 22.7 44.1 54.5 下面详细介绍一下几个代表性方法： 1.双阶段的 Mask R-CNN （2017.3）Mask-RCNN通过增加不同的分支可以完成目标分类，目标检测，语义分割，实例分割，人体姿态估计等多种任务。对于实例分割来讲，就是在Faster-RCNN的基础上(分类+回归分支)增加了一个分支用于语义分割，其抽象结构如下图所示： 可以看到其结构与Faster RCNN非常类似，但有3点主要区别： 在基础网络中采用了较为优秀的ResNet-FPN结构，多层特征图有利于多尺度物体及小物体的检测。原始的FPN会输出P2、P3、P4与P54个阶段的特征图，但在Mask RCNN中又增加了一个P6。将P5进行最大值池化即可得到P6，目的是获得更大感受野的特征，该阶段仅仅用在RPN网络中。 提出了RoI Align方法来替代RoI Pooling，原因是RoI Pooling的取整做法损失了一些精度，而这对于分割任务来说较为致命。Maks RCNN提出的RoI Align取消了取整操作，而是保留所有的浮点，然后通过双线性插值的方法获得多个采样点的值，再将多个采样点进行最大值的池化，即可得到该点最终的值。 得到感兴趣区域的特征后，在原来分类与回归的基础上，增加了一个Mask分支来预测每一个像素的类别。具体实现时，采用了FCN（Fully Convolutional Network）的网络结构，利用卷积与反卷积构建端到端的网络，最后对每一个像素分类，实现了较好的分割效果。 Mask R-CNN算法的主要步骤为： 首先，将输入图片送入到特征提取网络得到特征图。 然后对特征图的每一个像素位置设定固定个数的ROI（也可以叫Anchor），然后将ROI区域送入RPN网络进行二分类(前景和背景)以及坐标回归，以获得精炼后的ROI区域。 对上个步骤中获得的ROI区域执行论文提出的ROIAlign操作，即先将原图和feature map的pixel对应起来，然后将feature map和固定的feature对应起来。 最后对这些ROI区域进行多类别分类，候选框回归和引入FCN生成Mask，完成分割任务。 总的来说，在Faster R-CNN和FPN的加持下，Mask R-CNN开启了R-CNN结构下多任务学习的序幕。它出现的时间比其他的一些实例分割方法（例如FCIS）要晚，但是依然让proposal-based instance segmentation的方式占据了主导地位（尽管先检测后分割的逻辑不是那么地自然）。 Mask R-CNN利用R-CNN得到的物体框来区分各个实例，然后针对各个物体框对其中的实例进行分割。显而易见的问题便是，如果框不准，分割结果也会不准。因此对于一些边缘精度要求高的任务而言，这不是一个较好的方案。同时由于依赖框的准确性，这也容易导致一些非方正的物体效果比较差。 2. 单阶段实例分割方法2.1 Instance-sensitive FCN（2016.3）该方法的思想是相对FCN在每个像素上输出语义的label，其需要输出是否在某个实例的相对位置上（以3x3的网格为例，即要确定像素点是在网格的哪个位置（9个位置对应9个通道））。虽然理解上不是特别直观，但其主要思想还是编码了位置信息（类似方向信息）以便区分同一语义下的实例。 当然在构造groundtruth时，也需要sliding window的方式把实例上各个像素分配到各个位置上去。 在推理阶段，仅仅依靠sliding window去生成结果是不够的。在相近位置上会得到相似的结果，这就需要对物体本身进行整体的判别，以确定物体（中心）的准确位置。如下instance sensitive FCN增加了物体检测分支，通过物体的外接框以及得分，利用NMS得到最终无重复的实例分割结果。 虽然该方法效果在当时并不突出，但请先记住这样的思想，后续SOLO会进一步升华。下面要讲到的R-FCN同样利用了单个像素编码（附带）相对位置信息的思路，除了类别信息外，该像素还需要判断自己在物体区域的相对位置，相对位置通过固定的通道得以表征。 2.2 FCIS（2017.4）FCN 最终输出的是类别的概率图，只有类别输出，没有单个对象输出，InstanceFCN输出33的位置信息图， 只有单个对象输出，没有类别信息，需要单独的downstream网络完成类别信息。FCIS通过*计算position-sensitive inside/outside score maps，同时输出 instance mask 和类别信息。 InstanceFCN提出了positive-sensitive score map，每个score表示一个像素在某个相对位置上属于某个物体实例的似然得分。所以FCIS也采用position-sensitive score maps，只不过在物体实例中区分inside/outside，目的是想引入一点context信息。 作者认为以往的SDS、Hypercolumn、CFM等算法，具有相似的结构：两个子网络分别用于对象分割和检测子任务，且两个网络的结构、参数、执行顺序随机。作者认为分离的网络没有真正挖掘到两个认为的联系，提出共同的 “position-sensitive score map” ，同时用于object segmentation and detection子任务。 除了加入背景部分的通道外，FCIS还基于ROI作了类别检测，而不是再引入另外一个分支作这项任务。 2.3 YOLCAT（2019.4）原文：https://arxiv.org/abs/1904.02689代码（官方）：https://github.com/dbolya/yolact YOLACT将掩模分支添加到现有的一阶段（one-stage）目标检测模型，其方式与Mask R-CNN对 Faster-CNN 操作相同，但没有明确的定位步骤。 YOLACT将实例分割任务拆分成两个并行的子任务：（1）通过一个Protonet网络， 为每张图片生成 k 个 原型mask;（2）对每个实例，预测k个的线性组合系数（Mask Coefficients）。最后通过线性组合，生成实例mask，在此过程中，网络学会了如何定位不同位置、颜色和语义实例的mask。 YOLACT将问题分解为两个并行的部分，利用 fc层（擅长产生语义向量）和 conv层（擅长产生空间相干掩模）来分别产生“掩模系数”和“原型掩模” 。然后，因为原型和掩模系数可以独立地计算，所以 backbone 检测器的计算开销主要来自合成（assembly）步骤，其可以实现为单个矩阵乘法。通过这种方式，我们可以在特征空间中保持空间一致性，同时仍然是一阶段和快速的。 Backbone：Resnet 101+FPN，与RetinaNet相同；Protonet：接在FPN输出的后面，是一个FCN网络，预测得到针对原图的原型mask；Prediction Head：相比RetinaNet的Head，多了一个Mask Cofficient分支，预测Mask系数，因此输出是4*c+k。 可以看到head上增加了一支mask系数分支用于将prototypes进行组合得到mask的结果。当然按NMS的位置看，其同样需要有bbox的准确预测才行，并且该流程里不太适合用soft NMS进行替代。需要注意的是，在训练过程中，其用groundtruth bbox对组合后的全图分割结果进行截取，再与groundtruth mask计算损失。这同样需要bbox结果在前作为前提，以缓解前后景的像素不均衡情况。 至于后续的YOLCAT++，则主要是加入了mask rescoring的概念和DCN结构，进一步提升精度。（1）参考Mask Scoring RCNN，添加fast mask re-scoring分支，更好地评价实例mask的好坏；（2）Backbone网络中引入可变形卷积DCN；（3）优化了Prediction Head中的anchor设计。 2.4 PolarMask（2019.10）原文：https://arxiv.org/abs/1909.13226 代码（官方）：https://github.com/xieenze/PolarMask 相比RetinaNet，FCOS将基于anchor的回归变成了中心点估计与上下左右四个边界距离的回归，而PolarMask则是进一步细化了边界的描述，使得其能够适应mask的问题。PolarMask最重要的特点是：(1) anchor free and bbox free，不需要出检测框；(2) fully convolutional network, 相比FCOS把4根射线散发到36根射线，将instance segmentation和object detection用同一种建模方式来表达。 两种实例分割的建模方式： 1 像素级建模 类似于图b，在检测框中对每个pixel分类 2 轮廓建模 类似于图c和图d，其中，图c是基于直角坐标系建模轮廓，图d是基于极坐标系建模轮廓 PolarMask 基于极坐标系建模轮廓，把实例分割问题转化为实例中心点分类(instance center classification)问题和密集距离回归(dense distance regression)问题。同时，我们还提出了两个有效的方法，用来优化high-quality正样本采样和dense distance regression的损失函数优化，分别是Polar CenterNess和 Polar IoU Loss。没有使用任何trick(多尺度训练，延长训练时间等)，PolarMask 在ResNext 101的配置下 在coco test-dev上取得了32.9的mAP。 这是首次，证明了更复杂的实例分割问题，可以在网络设计和计算复杂度上，和anchor free物体检测一样简单。 网络结构 整个网络和FCOS一样简单，首先是标准的backbone + fpn模型，其次是head部分，我们把fcos的bbox分支替换为mask分支，仅仅是把channel=4替换为channel=n, 这里n=36，相当于36根射线的长度。同时我们提出了一种新的Polar Centerness 用来替换FCOS的bbox centerness。可以看到，在网络复杂度上，PolarMask和FCOS并无明显差别。 建模方式 首先，输入一张原图，经过网络可以得到中心点的位置和n(n=36 is best in our setting)根射线的距离，其次，根据角度和长度计算出轮廓上的这些点的坐标，从0°开始连接这些点，最后把联通区域内的区域当做实例分割的结果。 实验结果 从实验结果可以看到，PolarMask的精度并不是很高，而且速度上也没有优势，但是它的思路是非常巧妙的，对后面的研究有着很大的启发意义。具体细节可参考论文原文。 2.5 SOLO（2019.12）原文：https://arxiv.org/abs/1912.04488 代码：https://github.com/WXinlong/SOLO 和FCIS的类似，单个像素不是单纯输出类别，而是带有位置信息的类别，同时考虑到尺度的问题，借助网络结构来解决。 要理解SOLO的思想，重点就是要理解SOLO提出的实例类别（Instance Category）的概念。作者指出，实例类别就是量化后的物体中心位置（location）和物体的尺寸（size)。下面就解释一下这两个部分。 位置（location） SOLO将一张图片划分S×S的网格，这就有了SS个位置。不同于TensorMask和DeepMask将mask放在了特征图的channel维度上，SOLO参照语义分割，*将定义的物体中心位置的类别放在了channel维度上，这样就保留了几何结构上的信息。 本质上来说，一个实例类别可以去近似一个实例的中心的位置。因此，通过将每个像素分类到对应的实例类别，就相当于逐像素地回归出物体的中心、这就将一个位置预测的问题从回归的问题转化成了分类的问题。这么做的意义是，分类问题能够更加直观和简单地用固定的channel数、同时不依赖后处理方法（如分组和学习像素嵌入embedding）对数量不定的实例进行建模。 尺寸（size） 对于尺寸的处理，SOLO使用了FPN来将不同尺寸的物体分配到不同层级的特征图上，依次作为物体的尺寸类别。这样，所有的实例都被分别开来，就可以去使用实例类别去分类物体了。 网络实现 SOLO将图片划分成S×S的网格，如果物体的中心（质心）落在了某个网格中，那么该网格就有了两个任务：（1）负责预测该物体语义类别（2）负责预测该物体的instance mask。这就对应了网络的两个分支Category Branch和Mask Branch。同时，SOLO在骨干网络后面使用了FPN，用来应对尺寸。FPN的每一层后都接上述两个并行的分支，进行类别和位置的预测，每个分支的网格数目也相应不同，小的实例对应更多的的网格。 Category Branch：Category Branch负责预测物体的语义类别，每个网格预测类别S×S×C，这部分跟YOLO是类似的。输入为Align后的S×S×C的网格图像，输出为S×S×C的类别。这个分支使用的损失函数是focal loss。 Mask Branch：预测instance mask的一个直观方法是类似语义分割使用FCN，但FCN是具有空间不变性（spatiallly invariant）的，而我们这边需要位置上的信息。因此，作者使用了CoordConv，将像素横纵坐标x，y（归一化到[-1,1]）与输入特征做了concat再输入网络中。这样输入的维度就是 HW(D+2）了。 实验结果 可以看到，SOLO的精度已经超越了Mask R-CNN，相较思路类似的PolarMask也有较大的优势。 2.6 RDSNet &amp; PointRend（2019.12）RDSNet方法的出发点是检测阻碍不应该成为分割效果的阻碍，两种应该循环相互促进。有可能存在的情况是分割本身是比较准确的，但是因为定位不准，导致分割结果也比较差；这时候如果能提前知道分割的结果，那么检测的结果也会更好些。 这里就有用到YOLCAT的方式，去获得提取获取分割结果。当然这里从embedding的角度出发，还结合了前后景的处理（实验中说明前后景correlation比单前景linear combination要好）。得到bbox预测结果后是需要进行NMS，以及expand操作的，以确保尽可能多的有效区域被选进来（训练时1.5，测试时1.2）。之后再通过Mask-based Boundary Refinement模块对物体的边框进行调整。为了使该过程可导，作者还设计了贝叶斯分布估计的方式，不太懂。 PointRend借鉴了Render的思想，在尺度方式变化时由于采样的方式（不是连续坐标的设定吗），使得锯齿现象不会很明显。因此PointRend是利用一种非均匀采样的方式来确定在分辨率提高的情况下，如何确定边界上的点，并对这些点归属进行判别。本质上其实是一个新型上采样方法，针对物体边缘的图像分割进行优化，使其在难以分割的物体边缘部分有更好的表现。 PointRend 方法要点总结来说是一个迭代上采样的过程： while 输出的分辨率 &lt; 图片分辨率： 对输出结果进行2倍双线性插值上采样得到 coarse prediction_i。 挑选出 N 个“难点”，即结果很有可能和周围点不一样的点（例如物体边缘）。 对于每个难点，获取其“表征向量”，“表征向量”由两个部分组成，其一是低层特征（fine-grained features），通过使用点的坐标，在低层的特征图上进行双线性插值获得（类似 RoI Align），其二是高层特征（coarse prediction），由步骤 1 获得。 使用 MLP 对“表征向量”计算得到新的预测，更新 coarse prediction_i 得到 coarse prediction_i+1。这个 MLP 其实可以看做一个只对“难点”的“表征向量”进行运算的由多个 conv1x1 组成的小网络。 2.7 BlendMask（2020.1）原文：https://arxiv.org/abs/2001.00309 代码：暂无（也不太需要） BlendMask是一阶段的密集实例分割方法，结合了Top-down和Bottom-up的方法的思路。它通过在anchor-free检测模型FCOS的基础上增加了Bottom Module提取low-level的细节特征，并在instance-level上预测一个attention；借鉴FCIS和YOLACT的融合方法，提出了Blender模块来更好地融合这两种特征。最终，BlendMask在COCO上的精度（41.3AP）与速度（BlendMask-RT 34.2mAP, 25FPS on 1080ti）都超越了Mask R-CNN。 detector module直接用的FCOS，BlendMask模块则由三部分组成：bottom module用来对底层特征进行处理，生成的score map称为Base；top layer串接在检测器的box head上，生成Base对应的top level attention；最后是blender来对Base和attention进行融合。 BlendMask 的优势： 计算量小：使用一阶段检测器FCOS，相比Mask R-CNN使用的RPN，省下了对positon-sensitive feature map及mask feature的计算， 还是计算量小：提出attention guided blender模块来计算全局特征（global map representation），相比FCN和FCIS中使用的较复杂的hard alignment在相同分辨率的条件下，减少了十倍的计算量； mask质量更高：BlendMask属于密集像素预测的方法，输出的分辨率不会受到 top-level 采样的限制。在Mask R-CNN中，如果要得到更准确的mask特征，就必须增加RoIPooler的分辨率，这样变回成倍增加head的计算时间和head的网络深度； 推理时间稳定：Mask R-CNN的推理时间随着检测的bbox数量增多而增多，BlendMask的推理速度更快且增加的时间可以忽略不计 Flexible：可以加到其他检测算法里面 总结综上所述，我们大致可以看出两个趋势：一个是YOLCAT，RDSNet，BlendMask（RetinaNet, FCOS，PolarMask发展而来）单阶段基于硬编码（embedding）的实例分割；另一个是SOLO(FCIS)区分位置信息的方式。 两者没有特别大的区别，特别当embedding的通道数等于位置数目时。剩下的PointRend其实可以引出一个计算资源分配的问题，如何在有限次计算的情况下提升分割边缘的准确性。以上这些还是针对检测目的的，所以分割精度上有时在意，有时也不在意。在精确分割方面仍然有值得探索的地方，除了目前很火的attention机制，其实我觉得依然得回头去关注下标注不那么精细的情况下如何去提升边缘的分割精度（当然这又可能是个ill问题，或者是个外插问题，不过从guided filter的角度看至少还有些图像结构信息可以作为先验知识利用起来） 参考： 1.https://blog.csdn.net/sanshibayuan/article/details/103642419 2.https://blog.csdn.net/sanshibayuan/article/details/104011910 3.https://zhuanlan.zhihu.com/p/102231853 4.https://zhuanlan.zhihu.com/p/84890413 5.https://zhuanlan.zhihu.com/p/98351269","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"实例分割","slug":"深度学习/实例分割","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"}],"tags":[]},{"title":"AutoCAD基础","slug":"AutoCAD基础","date":"2020-04-07T01:42:49.000Z","updated":"2021-02-19T02:26:05.825Z","comments":true,"path":"2020/04/07/AutoCAD基础/","link":"","permalink":"https://sjtu-xx.github.io/2020/04/07/AutoCAD%E5%9F%BA%E7%A1%80/","excerpt":"cad教程网站","text":"cad教程网站 总：https://zhuanlan.zhihu.com/p/34532045 一些建议 要打开关于正在运行的命令信息的“帮助”，只需按 F1 键。 要重复上一个命令，请按 Enter 键或空格键。 要查看各种选项，请选择一个对象，然后单击鼠标右键，或在用户界面元素上单击鼠标右键。 要取消正在运行的命令或者如果感觉运行不畅，请按 Esc 键。极轴追踪 默认情况下，极轴追踪处于打开状态并引导光标以水平或垂直方向（0 或 90 度）移动。 当然你也可以设置30°、45°等等锁定角度 如果直线的第二个点需要以 45 度角创建且长度为 8 个单位，则需要在“命令”窗口中输入 &lt;45，如图所示。对象捕捉 输入 OSNAP 命令以设置默认对象捕捉，也称为“运行”对象捕捉。特性选项板 “特性”选项板是基本工具，打开它的方式有这几种： 使用 PROPERTIES 命令（快捷键 PR） 快捷键按 CTRL+1 单击“常用”选项卡的“特性”面板中的小箭头对象选择 使用窗交选择（右到左选择），可选中绿色区域内的或接触该绿色区域的任何对象。 使用窗口选择（左向右选择），将选中完全包含在蓝色区域内的任何对象。 如果框选对象多了两个怎么办，例如，选择了 42 个对象，其中有两个不应选择，可以按住 Shift 键并选中这两个对象。拷贝 COPY 要制作大量副本，那就使用 “阵列”命令AR修建和延伸 一种常用技巧是将 OFFSET 命令与 TRIM 和 EXTEND 命令结合使用。在命令窗口中，修建快捷键 TR ，延伸快捷键 EX。 不论修建还是延伸，执行命令后不要选择边界直接再按Enter 键或空格键，此操作强制 CAD 将所有对象视作可能的边界！ 修建和延伸命令可以互通，例如修建时按住shift键，选择的对象就会变成延伸！镜像 MIRROR拉伸 使用 STRETCH 命令（或在命令窗口中输入快捷键 S）并使用窗交选择选择对象。圆角 FILLET 命令（在命令窗口中输入快捷键 F）通过创建与两个选定对象相切的圆弧来创建圆角。多段线编辑 PEDIT 在某些情况下，修改多段线的最简单方法是：分解它、进行修改，然后使用 PEDIT 命令的“合并”选项将这些对象转换回多段线。 注释和标注 可以使用代表多行文字的 MTEXT 命令（或在“命令”窗口中输入 MT）来创建通用说明。在“注释”面板中提供了多行文字工具。 在 AutoCAD 中，多重引线对象用于创建具有引线的文字，例如常规标签、参照标签、索引和标注。 我们可以使用 DIMLINEAR 命令（快捷键dli）来创建水平和垂直标注（所有标注命令都以 DIM 前缀开头）。 使用 DIMALIGNED 命令（快捷键DAL）来创建平行于对象的标注。 非常不建议或者不允许直接双击更改标注尺寸，这样只会让你的后续工作越来越多！ 可以使用 DIMSTYLE 命令（快捷键D）设定许多标注变量，以控制标注外观和行为的几乎每个微妙差异。 常用命令更改单位：DDUNITS缩放：ZOOM平移：PAN 新建文件：NEW打开文件：OPEN保存文件：SAVE撤销：UNDO","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"CAD","slug":"CAD","permalink":"https://sjtu-xx.github.io/tags/CAD/"}]},{"title":"fortran语法","slug":"fortran语法","date":"2020-04-04T12:30:05.000Z","updated":"2021-02-19T02:26:06.411Z","comments":true,"path":"2020/04/04/fortran语法/","link":"","permalink":"https://sjtu-xx.github.io/2020/04/04/fortran%E8%AF%AD%E6%B3%95/","excerpt":"把fortran的语法简单总结一下,方便以后查阅","text":"把fortran的语法简单总结一下,方便以后查阅 基本语法1234567program program_nameimplicit none ! type declaration statements ! executable statements end program program_name 加法fortran程序123456789101112131415program addNumbers! This simple program adds two numbers implicit none ! Type declarations real :: a, b, result ! Executable statements a = 12.0 b = 15.0 result = a + b print *, 'The total is ', result end program addNumbers 所有Fortran程序start关键字程序和end关键字结束程序，然后是该程序的名称。 隐无语句允许编译器检查所有的变量类型是正确声明。必须始终使用无隐在每个程序的开始。 在Fortran语言注释开始使用感叹号（！），因为在这之后的所有字符（除字符串）被编译器忽略。 print*命令在屏幕上显示数据。 代码行缩进，是保持一个程序读取一个很好的做法。 Fortran语言允许大写和小写字母。 Fortran语言是区分大小写的，除了字符串常量。 内置数据类型Fortran语言提供了五种内在数据类型：整型(integer),实型(real),复杂类型(complex，储存复数)，逻辑类型(logical)，字符类型(character)1234567891011121314program testingimplicit none !4bytes整数 integer(kind=4)::largeval !输出integer允许的最大值 print *,huge(largeval) real::p,q !如果不指定长度，默认为1 character(len=40)::name name = \"zara ali\" !name(1:4)得到zaraend program testing 变量变量声明type-specifier :: variable_name12345integer :: total real :: average complex :: cx logical :: done character(len=80) :: message ! a string of 80 characters 变量赋值12345total = 20000 average = 1666.67 done = .true. message = “A big Hello from Tutorials Point” cx = (3.0, 5.0) ! cx = 3.0 + 5.0i 常量12!parameter 表示常量real, parameter :: pi = 3.1415927 运算符1234567891011121314151617!算术运算符+,-,*,/,**!关系运算符== !等于/= !不等&gt;&lt;&gt;=&lt;=!逻辑运算符.and..or..not..eqv..neqv. fortran选择决策if语句普通if1234567891011121314151617181920if (logical expression) then statement end ifif (logical expression) then statement(s) else other_statement(s)end if[name:] if (logical expression 1) then ! block 1 else if (logical expression 2) then ! block 2 else if (logical expression 3) then ! block 3 else ! block 4 end if [name] 命名if例子：1234567891011program markGradeA implicit none real :: marks ! assign marks marks = 90.4 ! use an if statement to give grade gr: if (marks &gt; 90.0) then print *, \" Grade A\" end if grend program markGradeA select case结构12345678910[name:] select case (expression) case (selector1) ! some statements ... case (selector2) ! other statements ... case default ! more statements ... end select [name] 也可以指定为一个范围123456789101112131415161718192021222324252627282930313233program selectCaseProgimplicit none ! local variable declaration integer :: marks = 78 select case (marks) case (91:100) print*, \"Excellent!\" case (81:90) print*, \"Very good!\" case (71:80) print*, \"Well done!\" case (61:70) print*, \"Not bad!\" case (41:60) print*, \"You passed!\" case (:40) print*, \"Better try again!\" case default print*, \"Invalid marks\" end select print*, \"Your marks is \", marks end program selectCaseProg 循环12345678910!do循环do var = start, stop [,step] ! statement(s) …end do!do whiledo while (logical expr) statementsend do exit语句终止循环或select case语句。 cycle语句相当于python中的continue stop终止program fortran字符字符串接1234567891011121314151617181920212223program helloimplicit none character(len=15) :: surname, firstname character(len=6) :: title character(len=40):: name character(len=25)::greetings title = 'Mr. ' firstname = 'Rowan ' surname = 'Atkinson' name = title//firstname//surname greetings = 'A big hello from Mr. Beans' print *, 'Here is ', name print *, greetings end program hello! 输出! Here is Mr.Rowan Atkinson ! A big hello from Mr.Bean fortran数组123456789101112!声明!创建一个5×5的二维矩阵命名的整数数组integer,dimension(5,5)::matrix!声明某些明确的下限real, dimension(2:6) :: numbersinteger, dimension (-3:2,0:4) :: matrix!赋值numbers = (/1.5, 3.2,4.5,0.9,7.2 /)!索引array ([lower]:[upper][:stride], ...) 向量和矩阵乘法12dot_product(vector_a,vector_b)matmul(matrix_a,matrix_b) 动态数组动态数组是一种数组，其尺寸在编译时不知道，而是在执行时才已知/确定的。动态数组的属性使用 allocatable 声明。 real, dimension (:,:), allocatable :: darray 示例1234567891011121314151617181920212223program dynamic_array implicit none !rank is 2, but size not known real, dimension (:,:), allocatable :: darray integer :: s1, s2 integer :: i, j print*, \"Enter the size of the array:\" read*, s1, s2 ! allocate memory allocate ( darray(s1,s2) ) do i = 1, s1 do j = 1, s2 darray(i,j) = i*j print*, \"darray(\",i,\",\",j,\") = \", darray(i,j) end do end do deallocate (darray) end program dynamic_array data语句data 语句可用于初始化多个阵列，或用于阵列部分的初始化。1data variable / list / ... 示例12345678910111213141516171819202122232425262728program dataStatementimplicit none integer :: a(5), b(3,3), c(10),i, j data a /7,8,9,10,11/ data b(1,:) /1,1,1/ data b(2,:)/2,2,2/ data b(3,:)/3,3,3/ data (c(i),i=1,10,2) /4,5,6,7,8/ data (c(i),i=2,10,2)/5*2/ Print *, 'The A array:' do j = 1, 5 print*, a(j) end do Print *, 'The B array:' do i = lbound(b,1), ubound(b,1) write(*,*) (b(i,j), j = lbound(b,2), ubound(b,2)) end do Print *, 'The C array:' do j = 1, 10 print*, c(j) end do end program dataStatement where语句where与numpy.where类似1234567891011121314151617181920212223242526272829program whereStatementimplicit none integer :: a(3,5), i , j do i = 1,3 do j = 1, 5 a(i,j) = j-i end do end do Print *, 'The A array:' do i = lbound(a,1), ubound(a,1) write(*,*) (a(i,j), j = lbound(a,2), ubound(a,2)) end do where( a&lt;0 ) a = 1 elsewhere a = 5 end where Print *, 'The A array:' do i = lbound(a,1), ubound(a,1) write(*,*) (a(i,j), j = lbound(a,2), ubound(a,2)) end do end program whereStatement 导出数据类型(结构)定义声明格式123type type_name declarationsend type示例123456type Books character(len=50) :: title character(len=50) :: author character(len=150) :: subject integer :: book_idend type Books 访问结构成员type(Books) :: book11234book1%title = \"C Programming\"book1%author = \"Nuha Ali\"book1%subject = \"C Programming Tutorial\"book1%book_id = 6495407 结构数组type(Books), dimension(2) :: list 指针声明123integer, pointer :: p1 ! pointer to integer real, pointer, dimension (:) :: pra ! pointer to 1-dim real array real, pointer, dimension (:,:) :: pra2 ! pointer to 2-dim real array 分配指针空间12345678910111213program pointerExampleimplicit none integer, pointer :: p1 allocate(p1) p1 = 1 Print *, p1 p1 = p1 + 4 Print *, p1 end program pointerExample 目标是另一个正态变量，空间预留给它。目标变量必须与目标属性进行声明。一个指针变量使用的关联操作符使目标变量相关联(=&gt;)。1234567891011121314151617181920212223program pointerExampleimplicit none integer, pointer :: p1 integer, target :: t1 p1=&gt;t1 p1 = 1 Print *, p1 Print *, t1 p1 = p1 + 4 Print *, p1 Print *, t1 t1 = 8 Print *, p1 Print *, t1 end program pointerExample 基本输入输出我们可以使用打印print语句，以及读取键盘使用read语句，并显示数据输出到屏幕上。这种形式的输入输出是自由格式的I/O，它被称为列表控制的输入输出。 123read(*,*) item1, item2, item3...print *, item1, item2, item3write(*,*) item1, item2, item3... 格式化123read fmt, variable_list print fmt, variable_list write fmt, variable_list 文件输入输出OPEN, WRITE, READ 和 CLOSE语句可以实现这一目标。 open (list-of-specifiers) close ([UNIT=]u[,IOSTAT=ios,ERR=err,STATUS=sta]) read ([UNIT=]u, [FMT=]fmt, IOSTAT=ios, ERR=err, END=s) write([UNIT=]u, [FMT=]fmt, IOSTAT=ios, ERR=err, END=s) 修辞符 描述 [UNIT=] u 单元数u可以是任何数量范围内9-99，它表明该文件，可以选择任何号码，但在程序中每一个打开的文件必须有一个唯一的数字 IOSTAT= ios 它是在I/O状态标识符和应为整数的变量。如果打开的语句是成功，则返回IOS值为零，否则为一个非零值。 ERR = err 它是一个标签到该控制跳以防有错误。 FILE = fname 文件名，一个字符串。 STATUS = sta 它示出了该文件的先前状态。一个字符串，可以有三个值NEW, OLD 或 SCRATCH。一个临时文件被创建和删除，当关闭或程序结束。 ACCESS = acc 它是该文件的访问模式。可以有两个值SEQUENTIAL 或 DIRECT。默认值是SEQUENTIAL。 FORM= frm 它给该文件的格式的状态。可以有FORMATTED 或UNFORMATTED两个值。默认值是UNFORMATTED RECL = rl 它指定的每个记录中的一个直接访问文件的长度。 fortran过程包括函数和子程序 函数函数是返回一个数量的过程。函数不修改其参数。返回数值被称为函数值，并将其表示为函数名。 语法1234function name(arg1, arg2, ....) [declarations, including those for the arguments] [executable statements] end function [name] 示例12345678910111213141516171819202122232425262728program calling_func real :: a a = area_of_circle(2.0) Print *, \"The area of a circle with radius 2.0 is\" Print *, a end program calling_func! this function computes the area of a circle with radius r function area_of_circle (r) ! function result implicit none ! dummy arguments real :: area_of_circle ! local variables real :: r real :: pi pi = 4 * atan (1.0) area_of_circle = pi * r**2 end function area_of_circle 子程序子程序没有返回值，可以修改其参数 语法1234subroutine name(arg1, arg2, ....) [declarations, including those for the arguments] [executable statements] end subroutine [name] 调用子程序使用call来调用子程序123456789101112131415161718192021222324252627282930program calling_funcimplicit none real :: a, b a = 2.0 b = 3.0 Print *, \"Before calling swap\" Print *, \"a = \", a Print *, \"b = \", b call swap(a, b) Print *, \"After calling swap\" Print *, \"a = \", a Print *, \"b = \", b end program calling_funcsubroutine swap(x, y) implicit none real :: x, y, temp temp = x x = y y = temp end subroutine swap 指定参数意图intent(in) 用作输入intent(out) 用作输出，他们将被覆盖intent(inout) 参数都使用和覆盖1234567891011121314151617181920212223242526272829program calling_funcimplicit none real :: x, y, z, disc x= 1.0 y = 5.0 z = 2.0 call intent_example(x, y, z, disc) Print *, \"The value of the discriminant is\" Print *, disc end program calling_funcsubroutine intent_example (a, b, c, d) implicit none ! dummy arguments real, intent (in) :: a real, intent (in) :: b real, intent (in) :: c real, intent (out) :: d d = b * b - 4.0 * a * c end subroutine intent_example 递归当一个函数被递归使用，则 result 选项要被使用。1234567891011121314151617181920212223242526272829program calling_funcimplicit none integer :: i, f i = 15 Print *, \"The value of factorial 15 is\" f = myfactorial(15) Print *, f end program calling_func! computes the factorial of n (n!) recursive function myfactorial (n) result (fac) ! function result implicit none ! dummy arguments integer :: fac integer, intent (in) :: n select case (n) case (0:1) fac = 1 case default fac = n * myfactorial (n-1) end select end function myfactorial 内部过程当一个过程被包含在程序中，它被称为程序的内部程序。1234567891011121314151617181920212223242526program mainprog implicit none real :: a, b a &#x3D; 2.0 b &#x3D; 3.0 Print *, &quot;Before calling swap&quot; Print *, &quot;a &#x3D; &quot;, a Print *, &quot;b &#x3D; &quot;, b call swap(a, b) Print *, &quot;After calling swap&quot; Print *, &quot;a &#x3D; &quot;, a Print *, &quot;b &#x3D; &quot;, b contains subroutine swap(x, y) real :: x, y, temp temp &#x3D; x x &#x3D; y y &#x3D; temp end subroutine swap end program mainprog 模块模块用于： 包装子程序，数据和接口块。 定义，可以使用多于一个常规全局数据。 声明可以选择的任何程序内提供的变量。 导入整个模块，可使用在另一个程序或子程序。 使用模块use name 12345678910111213141516171819202122232425262728293031module constants implicit none real, parameter :: pi = 3.1415926536 real, parameter :: e = 2.7182818285 contains subroutine show_consts() print*, \"Pi = \", pi print*, \"e = \", e end subroutine show_consts end module constants program module_example use constants implicit none real :: x, ePowerx, area, radius x = 2.0 radius = 7.0 ePowerx = e ** x area = pi * radius**2 call show_consts() print*, \"e raised to the power of 2.0 = \", ePowerx print*, \"Area of a circle with radius 7.0 = \", area end program module_example 缺省情况下，在一个模块中的所有的变量和子程序被提供给正在使用的模块代码，通过 use 语句声明。 但是，可以控制模块代码中使用的private 和 public 属性的访问性。当声明一些变量或子程序为私有，这是不可以用在模块之外使用。 common，module共享数据common在新书写的代码里，避免使用 COMMON 语句，而使用 Module 语句代替它。1234COMMON /a/b, /c/d, e, f!表示在公用区a中有变量（或者数组）b，在公用区c中有d, e, f 。integer b,d,e,f!在使用公用区变量前，必须再次说明类型，非常容易发生错误 modulesave 属性表明这些变量会被保存起来，以便在不同的程序单元间保持同样的值。（虽然语法未明确指出，但所有的编译器都默许 Module 中的变量具有 save 属性，因此，很多时候 save 也可以忽略不写）123456789101112131415161718192021Module modname Implicit None !// 明确变量类型，顺序无关 Integer , save :: a = 1 , b = 2 End Module modnameprogram www_fcode_cn use modname !// 无需，也不能再定义 a b Implicit None write(*,*) b , a !// 输出 2，1 正确 a = 3 b = 4 !// 按变量名对应，因此倒序输出，其值也倒序 call Sub()End Program www_fcode_cnSubroutine Sub() use modname !// 无需，也不能再定义 a b Implicit None write(*,*) a , b !// 输出 3，4 正确End Subroutine Sub","categories":[{"name":"Fortran","slug":"Fortran","permalink":"https://sjtu-xx.github.io/categories/Fortran/"}],"tags":[]},{"title":"OmniGraffle公式的插入","slug":"OmniGraffle公式的插入","date":"2020-04-03T08:34:49.000Z","updated":"2021-02-19T02:26:06.291Z","comments":true,"path":"2020/04/03/OmniGraffle公式的插入/","link":"","permalink":"https://sjtu-xx.github.io/2020/04/03/OmniGraffle%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8F%92%E5%85%A5/","excerpt":"Windows上的visio在mac上用不了，omnigraffle是一个比较好的替代工具，但是，最近使用过程中发现omnigraffle中无法进行latex公式的编辑。","text":"Windows上的visio在mac上用不了，omnigraffle是一个比较好的替代工具，但是，最近使用过程中发现omnigraffle中无法进行latex公式的编辑。在网上翻找了各种工具解决，但是都无法避免在mac上安装新的软件。最后，在一个角落里发现了一种新的解决办法，利用mac自带的grapher。使用了之后发现简直是神器。 进入grapher后，任意选择一项，随便输入公式，右键便可保存（保存为pdf格式防止失真）。","categories":[{"name":"其他工具","slug":"其他工具","permalink":"https://sjtu-xx.github.io/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"MaskRCNN细节详解","slug":"MaskRCNN细节详解","date":"2020-03-24T14:40:33.000Z","updated":"2021-02-19T02:26:06.277Z","comments":true,"path":"2020/03/24/MaskRCNN细节详解/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/24/MaskRCNN%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3/","excerpt":"参考链接：https://zhuanlan.zhihu.com/p/37998710 简介","text":"参考链接：https://zhuanlan.zhihu.com/p/37998710 简介 mask rcnn是ICCV2017的best paper。Mask RCNN沿用了Faster RCNN的思想，特征提取采用ResNet-FPN的架构，另外多加了一个Mask预测分支。ResNet-FPN+Fast RCNN+Mask，实际上就是Mask RCNN。 回顾ResNet-FPN（Feature Pyramid Networks）多尺度检测在目标检测中变得越来越重要，对小目标的检测尤其如此。现在主流的目标检测方法很多都用到了多尺度的方法，包括最新的yolo v3。Feature Pyramid Network (FPN)则是一种精心设计的多尺度检测方法，下面就开始简要介绍FPN。 FPN结构中包括自下而上，自上而下和横向连接三个部分，如下图所示。这种结构可以将各个层级的特征进行融合，使其同时具有强语义信息和强空间信息，在特征学习中算是一把利器了。FPN实际上是一种通用架构，可以结合各种骨架网络使用，比如VGG，ResNet等。Mask RCNN文章中使用了ResNNet-FPN网络结构。如下图：自下而上从下到上路径。可以明显看出，其实就是简单的特征提取过程，和传统的没有区别。具体就是将ResNet作为骨架网络，根据feature map的大小分为5个stage。stage2，stage3，stage4和stage5各自最后一层输出conv2，conv3，conv4和conv5分别定义为C2，C3，C4，C5，他们相对于原始图片的stride是{4,8,16,32}。需要注意的是，考虑到内存原因，stage1的conv1并没有使用。自上而下和横向连接自上而下是从最高层开始进行上采样，这里的上采样直接使用的是最近邻上采样，而不是使用反卷积操作，一方面简单，另外一方面可以减少训练参数。横向连接则是将上采样的结果和自底向上生成的相同大小的feature map进行融合。具体就是对C2，C3，C4，C5中的每一层经过一个conv 1x1操作（1x1卷积用于降低通道数），无激活函数操作，输出通道全部设置为相同的256通道，然后和上采样的feature map进行加和操作。在融合之后还会再采用3*3的卷积核对已经融合的特征进行处理，目的是消除上采样的混叠效应（aliasing effect）。 实际上，上图少绘制了一个分支：M5经过步长为2的max pooling下采样得到 P6，作者指出使用P6是想得到更大的anchor尺度512×512。但P6是只用在 RPN中用来得到region proposal的，并不会作为后续Fast RCNN的输入。 总结一下，ResNet-FPN作为RPN输入的feature map是 [公式] ，而作为后续Fast RCNN的输入则是 [公式] 。 ResNet-FPN+Fast RCNN将ResNet-FPN和Fast RCNN进行结合，实际上就是Faster RCNN的了，但与最初的Faster RCNN不同的是，FPN产生了特征金字塔[P2,P3,P4,P5,P6]，而不只是一个featrue map。金字塔经过RPN之后会产生很多region proposal。这些region proposal是分别由[P2,P3,P4,P5,P6]经过RPN产生的，但用于输入到Fast RCNN中的是 [P2,P3,P4,P5]，也就是说要在[P2,P3,P4,P5]中根据region proposal切出ROI进行后续的分类和回归预测。问题来了，我们要选择哪个feature map来切出这些ROI区域呢？实际上，我们会选择最合适的尺度的feature map来切ROI。具体来说，我们通过一个公式来决定宽w和高h的ROI到底要从哪个Pk来切： k=\\left\\lfloor{k_0+log_2(\\sqrt{wh}/224)}\\right\\rfloor这里224表示用于预训练的ImageNet图片的大小。$k_0$表示面积为$w\\times h=224\\times 224$的ROI所应该在的层级。作者将$k_0$设置为4，也就是说$w\\times h=224\\times 224$的ROI应该从P4中切出来。假设ROI的scale小于224（比如说是112 * 112），$k=k_0-1=4-1=3$，就意味着要从更高分辨率的P3中产生。另外，k值会做取整处理，防止结果不是整数。 这种做法很合理，大尺度的ROI要从低分辨率的feature map上切，有利于检测大目标，小尺度的ROI要从高分辨率的feature map上切，有利于检测小目标。 ResNet-FPN+Fast RCNN+mask将ResNet-FPN+Fast RCNN+mask，则得到了最终的Mask RCNN ROI AlignFaster R-CNN存在的问题是：特征图与原始图像是不对准的（mis-alignment），所以会影响检测精度。而Mask R-CNN提出了RoIAlign的方法来取代ROI pooling，RoIAlign可以保留大致的空间位置。 在Faster RCNN中，有两次整数化的过程： region proposal的xywh通常是小数，但是为了方便操作会把它整数化。 将整数化后的边界区域平均分割成 k x k 个单元，对每一个单元的边界进行整数化。 事实上，经过上述两次整数化，此时的候选框已经和最开始回归出来的位置有一定的偏差，这个偏差会影响检测或者分割的准确度。在论文里，作者把它总结为“不匹配问题”（misalignment）。 为了解决这个问题，ROI Align方法取消整数化操作，保留了小数，使用双线性插值的方法获得坐标为浮点数的像素点上的图像数值。但在实际操作中，ROI Align并不是简单地补充出候选区域边界上的坐标点，然后进行池化，而是重新进行设计。 下面通过一个例子来讲解ROI Align操作。如下图所示，虚线部分表示feature map，实线表示ROI，这里将ROI切分成2x2的单元格。如果采样点数是4，那我们首先将每个单元格子均分成四个小方格（如红色线所示），每个小方格中心就是采样点。这些采样点的坐标通常是浮点数，所以需要对采样点像素进行双线性插值（如四个箭头所示），就可以得到该像素点的值了。然后对每个单元格内的四个采样点进行maxpooling，就可以得到最终的ROIAlign的结果。 损失Mask RCNN定义多任务损失： L=L_{cls}+L_{box}+L_{mask}$L{cls}$和$L{box}$与faster rcnn的定义没有区别。需要具体说明的是，假设一共有K个类别，则mask分割分支的输出维度是$Kmm$, 对于$m*m$中的每个点，都会输出K个二值Mask（每个类别使用sigmoid输出）。需要注意的是，计算loss的时候，并不是每个类别的sigmoid输出都计算二值交叉熵损失，而是该像素属于哪个类，哪个类的sigmoid输出才要计算损失(如图红色方形所示)。并且在测试的时候，我们是通过分类分支预测的类别来选择相应的mask预测。这样，mask预测和分类预测就彻底解耦了。(nll) 这与FCN方法是不同，FCN是对每个像素进行多类别softmax分类，然后计算交叉熵损失，很明显，这种做法是会造成类间竞争的，而每个类别使用sigmoid输出并计算二值损失，可以避免类间竞争。实验表明，通过这种方法，可以较好地提升性能。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[]},{"title":"Faster-RCNN细节详解","slug":"Faster-RCNN细节详解","date":"2020-03-24T13:19:03.000Z","updated":"2021-02-19T02:26:06.055Z","comments":true,"path":"2020/03/24/Faster-RCNN细节详解/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/24/Faster-RCNN%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3/","excerpt":"参考链接：https://zhuanlan.zhihu.com/p/31426458","text":"参考链接：https://zhuanlan.zhihu.com/p/31426458 简介Faster RCNN是Ross B. Girshick在2016年提出的。Faster RCNN(Region CNN)可以分为4个主要内容： Conv layers。作为一种CNN网络目标检测方法，Faster RCNN首先使用一组基础的conv+relu+pooling层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。 Region Proposal Networks。RPN网络用于生成region proposals。该层通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals。 Roi Pooling。该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。 Classification。利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。 下图为python版本中的VGG16模型中的faster_rcnn_test.pt的网络结构，可以清晰的看到该网络对于一副任意大小PxQ的图像，首先缩放至固定大小MxN，然后将MxN图像送入网络；而Conv layers中包含了13个conv层+13个relu层+4个pooling层；RPN网络首先经过3x3卷积，再分别生成positive anchors和对应bounding box regression偏移量，然后计算出proposals；而Roi Pooling层则利用proposals从feature maps中提取proposal feature送入后续全连接和softmax网络作classification（即分类proposal到底是什么object）。 1. Conv LayersConv layers包含了conv，pooling，relu三种层。以python版本中的VGG16模型中的faster_rcnn_test.pt的网络结构为例，如图2，Conv layers部分共有13个conv层，13个relu层，4个pooling层。这里有一个非常容易被忽略但是又无比重要的信息，在Conv layers中： 所有的conv层都是：kernel_size=3，pad=1，stride=1 所有的pooling层都是：kernel_size=3，pad=2，stride=2这意味着conv层的输入和输出都是M*N的大小。pooling层将输出长宽变为输入的1/2.那么，一个MxN大小的矩阵经过Conv layers固定变为(M/16)x(N/16)！这样Conv layers生成的feature map中都可以和原图对应起来。 2. Region Proposal Networks(RPN)Faster RCNN则抛弃了传统的滑动窗口和SS方法，直接使用RPN生成检测框，这也是Faster R-CNN的巨大优势，能极大提升检测框的生成速度。RPN网络实际分为2条线，上面一条通过softmax分类anchors获得positive和negative分类，下面一条用于计算对于anchors的bounding box regression偏移量，以获得精确的proposal。而最后的Proposal层则负责综合positive anchors和对应bounding box regression偏移量获取proposals，同时剔除太小和超出边界的proposals。其实整个网络到了Proposal Layer这里，就完成了相当于目标定位的功能。 2.1 anchors所谓anchors，实际上就是一组由rpn/generate_anchors.py生成的矩形。9个矩形共有3种形状，长宽比为大约为{1:2,1:1,2:1}三种。实际上通过anchors就引入了检测中常用到的多尺度方法。如下图，遍历Conv layers计算获得的feature maps，为每一个点都配备这9种anchors作为初始的检测框。这样做获得检测框很不准确，不用担心，后面还有2次bounding box regression可以修正检测框位置。 上图中的各个数字 在原文中使用的是ZF model中，其Conv Layers中最后的conv5层num_output=256，对应生成256张特征图，所以相当于feature map每个点都是256-dimensions 在conv5之后，做了rpn_conv/3x3卷积且num_output=256，相当于每个点又融合了周围3x3的空间信息（猜测这样做也许更鲁棒？反正我没测试），同时256-d不变（如图4和图7中的红框） 假设在conv5 feature map中每个点上有k个anchor（默认k=9），而每个anhcor要分positive和negative，所以每个点由256d feature转化为cls=2k scores；而每个anchor都有(x, y, w, h)对应4个偏移量，所以reg=4k coordinates 补充一点，全部anchors拿去训练太多了，训练程序会在合适的anchors中随机选取128个postive anchors+128个negative anchors进行训练（什么是合适的anchors下文5.1有解释） 其实RPN最终就是在原图尺度上，设置了密密麻麻的候选Anchor。然后用cnn去判断哪些Anchor是里面有目标的positive anchor，哪些是没目标的negative anchor。所以，仅仅是个二分类而已！ Anchor一共有多少个？原图800x600，VGG下采样16倍，feature map每个点设置9个Anchor，所以：$ceil(800/16)\\times ceil(600/16)\\times 9=50\\times 38 \\times 9 = 17100$ 2.2 bounding box regression原理对于窗口一般使用四维向量$(x,y,w,h)$表示，分别表示窗口的中心点坐标和宽高。对于图 11，红色的框A代表原始的positive Anchors，绿色的框G代表目标的GT，我们的目标是寻找一种关系，使得输入原始的anchor A经过映射得到一个跟真实窗口G更接近的回归窗口G’.即： 给定anchor $A=(A_x,A_y,A_w,A_h)$和$GT=[G_x,G_y,G_w,G_h]$ 寻找一种变换F使得:$F(A_x,A_y,A_w,A_h)=(G_x^{‘},G_y^{‘},G_w{‘},G_h^{‘})$ 一种简单的思路就是平移后缩放：平移：$G_x^{‘}=A_w·d_x(A)+A_x$$G_y^{‘}=A_w·d_y(A)+A_y$缩放：$G_w^{‘}=A_w·exp(d_w(A))$$G_h^{‘}=A_h·exp(d_h(A))$ A_x等为系数，需要学习的参数有$d_x(A),d_y{A},d_w(A),d_h(A)$。 对于训练bouding box regression网络回归分支，输入是cnn feature Φ，监督信号是Anchor与GT的差距，即训练目标是：输入 Φ的情况下使网络输出与监督信号尽可能接近。 2.3 proposal layerProposal Layer负责综合所有anchors的变换量和positive anchors，计算出精准的proposal，送入后续RoI Pooling Layer。 Proposal Layer有3个输入：positive vs negative anchors分类器结果rpn_cls_prob_reshape，对应的bbox reg的变换量rpn_bbox_pred，以及im_info；另外还有参数feat_stride=16，这和图4是对应的。 im_info 对于一副任意大小PxQ图像，传入Faster RCNN前首先reshape到固定MxN，im_info=[M, N, scale_factor]则保存了此次缩放的所有信息。然后经过Conv Layers，经过4次pooling变为WxH=(M/16)x(N/16)大小，其中feature_stride=16则保存了该信息，用于计算anchor偏移量。 这里的输出是[x1,y1,x2,y2]是对应M*N输入图像尺度的。 3. ROI poolingRol pooling层有2个输入： 原始的feature maps RPN输出的proposal boxes（大小各不相同） RoI Pooling layer forward过程： 由于proposal是对应MXN尺度的，所以首先使用spatial_scale参数将其映射回(M/16)X(N/16)大小的feature map尺度； 再将每个proposal对应的feature map区域水平分为pooled_w * pooled_h的网格； 对网格的每一份都进行max pooling处理。这样处理后，即使大小不同的proposal输出结果都是固定大小，实现了固定长度输出。 4. Faster RCNN的训练6个步骤 在已经训练好的model上，训练RPN网络，对应stage1_rpn_train.pt 利用步骤1中训练好的RPN网络，收集proposals，对应rpn_test.pt 第一次训练Fast RCNN网络，对应stage1_fast_rcnn_train.pt 第二训练RPN网络，对应stage2_rpn_train.pt 再次利用步骤4中训练好的RPN网络，收集proposals，对应rpn_test.pt 第二次训练Fast RCNN网络，对应stage2_fast_rcnn_train.pt 5 QA为何有ROI Pooling还要把输入图片resize到固定大小的MxN由于引入ROI Pooling，从原理上说Faster R-CNN确实能够检测任意大小的图片。但是由于在训练的时候需要使用大batch训练网络，而不同大小输入拼batch在实现的时候代码较为复杂，而且当时以Caffe为代表的第一代深度学习框架也不如Tensorflow和PyTorch灵活，所以作者选择了把输入图片resize到固定大小的800x600。这应该算是历史遗留问题。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[]},{"title":"交叉熵和负对数损失","slug":"交叉熵和KL散度","date":"2020-03-17T02:27:38.000Z","updated":"2021-02-19T02:26:06.724Z","comments":true,"path":"2020/03/17/交叉熵和KL散度/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/17/%E4%BA%A4%E5%8F%89%E7%86%B5%E5%92%8CKL%E6%95%A3%E5%BA%A6/","excerpt":"最近学的有点迷糊。复习一下各种常用的损失函数的公式。","text":"最近学的有点迷糊。复习一下各种常用的损失函数的公式。 交叉熵交叉熵主要用于分类问题。用于比较两组数据的分布差异。交叉熵避免了使用二次代价函数带来的梯度消失问题（消除了sigmoid的导数项）。 单分类问题的loss一个样本只能有一个类别一个样本的loss loss=-\\sum_{i=1}^{n}{y_i\\log(\\hat{y_i})}batch的loss(m为batch size) loss=-\\frac{1}{m}\\sum_{j=1}^{m}\\sum_{i=1}^{n}{y_{ji}\\log(\\hat{y_{ji}})}多标签问题的loss一个样本可以有多个类别。n-hotPred采用的是sigmoid函数计算。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。一个样本的loss： loss=-ylog(\\hat{y})-(1-y)log(1-\\hat{y})batch的loss loss=\\sum_{j=1}^{m}\\sum_{i=1}^{m}{-y_{ji}log{\\hat{y_{ji}}}-(1-y_{ji})log(1-\\hat{y_{ji}})}KL散度KL散度是\b信息论中的重要概念，用来描述两个概率分布的差异。 如果对于同一个随机变量x有两个单独的概率分布P(x)和Q(x)，则可以使用KL散度(Kullback-Leiber(KL) divergence)来衡量这两个分布的差异： D_{KL}(P||Q) = E_{x\\sim P}[log\\frac{P(x)}{Q(x)}] = E_{x\\sim P}[log{P(x)}-log{Q(x)}]KL散度有很多有用的性质： 最重要的是，它是非负的。 当x是离散型变量时，KL散度为0当且仅当P(x)与Q(x)具有相同的分布。 KL散度表征了某种距离，但不是真正的距离，因为KL散度不对称：$D{KL}(P||Q)\\not=D{KL}(Q||P)$ 交叉熵和KL散度 KL散度可以被用于计算代价，而在特定情况下最小化KL散度等价于最小化交叉熵。而交叉熵的运算更简单，所以用交叉熵来当做代价。 交叉熵与KL散度密切相关： H(P,Q) = H(P) + D_{KL}(P||Q)其中H(P,Q)是交叉熵(cross-entropy)，H(P)是概率分布P的香农熵。在深度学习中，针对Q最小化交叉熵等价于最小化KL散度，因为Q与P独立，Q与P的香农熵无关。 交叉熵和负对数损失（negative log likelihood，NLL)参考链接具有交叉熵的S形(sigmoid激活，每一个输出具有独立分布)输出层与具有对数似然的softmax（输出和为1）输出层非常相似。 考虑使用以下分类任务(K类)。让我们分别看一下网络的输出层和成本函数。就我们的目的而言，输出层是S形或softmax，成本函数是交叉熵或对数似然。输出层如果是S型，输出层将具有𝐾每个Sigmoid的值在0到1之间。至关重要的是，这些输出的总和可能不等于1，因此不能将它们解释为概率分布。这两个语句的唯一例外是以下情况𝐾=2即二分类，此时只有一个S形就足够了。在这种情况下，第二类的预测值可以由1减去输出的预测值得到。如果输出层是softmax，则它还具有𝐾输出。但是在这种情况下，输出之和为1。由于这一限制，具有softmax输出层的网络比具有多个S型网络的网络具有更低的灵活性。为了说明该约束，请考虑用于对数字进行分类的网络。它有十个输出节点。如果它们是S形，则它们中的两个（例如8和9或0和6）都可以输出（例如0.9）。对于softmax，这是不可能的。输出仍然可以相等（例如均为0.45），但是由于受到限制，当调整权重以增加一位数字的输出时，它必然会降低其他位数的输出。该文本在同一章中有一个滑块演示来说明这种效果。那预测呢？好吧，一种简单的方法是简单地分配具有最大输出的类。对于两种类型的输出层都是如此。至于代价函数，可以对任何一个网络使用交叉熵或对数似然（或其他成本函数，例如均方误差）代价函数K分类问题的交叉熵损失为： C_\\text{CE} = -\\frac{1}{n} \\sum\\limits_x \\sum\\limits_{k=1}^K (y_k \\ln a_k^L + (1 - y_k) \\ln (1 - a_k^L))这里x是输入(对于每个x，只有$y_k$为1，其余为0（即one-hot编码）)， n是input sizeK分类的NLL损失为： C_\\text{LL} = -\\frac{1}{n} \\sum\\limits_x y^T \\ln(a^L) = -\\frac{1}{n} \\sum\\limits_x \\sum\\limits_{k=1}^K y_k \\ln(a_k^L)这里，y是one-hot编码的输出，并且$a^L$是模型的输出这是两个成本函数之间的关键区别：对数似然仅考虑相应类别的输出，而交叉熵函数也考虑其他输出。您可以在上面的表达式中看到这一点-总而言之CE和CLL有相同的项，但是CE还有一个附加项。这意味着CE和LL都以正确类别的输出量奖励网络。但是，CE还对网络中其他类别的输出量进行了惩罚。如果混乱很严重，那么惩罚也很严重。 总而言之，如果要考虑其他类别输出量的影响就使用CE，如果不考虑就使用CLL","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"pytorch教程（七月在线笔记）","slug":"pytorch教程（七月在线笔记）","date":"2020-03-15T02:09:39.000Z","updated":"2021-02-19T02:26:06.603Z","comments":true,"path":"2020/03/15/pytorch教程（七月在线笔记）/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/15/pytorch%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%83%E6%9C%88%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AE%B0%EF%BC%89/","excerpt":"Pytorch基础","text":"Pytorch基础 原位修改函数后加下划线“_”表示原位修改:y.add_(x)。 numpy和tensor的转化numpy转换为tensor-》torch.from_array(a)tensor转换为numpy-》a.numpy() cuda向量a.cuda()a.to(&quot;cuda&quot;)a.to(torch.device(&quot;cuda&quot;))torch.ones_like(device=torch.device(&quot;cuda&quot;)) 简单的双层神经网络案例1234567891011121314151617181920212223242526272829303132import torchimport torch.nn as nn# N is batch size; D_in is input dimension;# H is hidden dimension; D_out is output dimension.N, D_in, H, D_out = 64, 1000, 100, 10x = torch.randn(N,D_in)y = torch.randn(N,D_out)model = nn.Sequential( nn.Linear(D_in,H), nn.ReLU(), nn.Linear(H,D_out))loss_fn = nn.MSELoss(reduction=\"sum\")learning_rate = 1e-4optimizer = torch.optim.Adam(model.parameters(),lr=learning_rate)for i in range(500): # forward：构建模型 y_pred = model(x) # loss loss = loss_fn(y_pred,y) # 默认情况下grad是叠加，zero_grad用来重置参数列表 optimizer.zero_grad() # backward：计算梯度 loss.backward() optimizer.step() print(i,\":\",loss.item()) 123# 注意：验证时要no_gradwith torch.no_grad(): testY = model(testX) FizzBuzz游戏简单案例游戏规则如下：从1开始往上数数，当遇到3的倍数的时候，说fizz，当遇到5的倍数，说buzz，当遇到15的倍数，就说fizzbuzz，其他情况下则正常数数。 Pytorch模型的建立模型的建立包括几个步骤： 处理数据 搭建模型 forward pass optimizer backward pass 词向量和语言模型词向量github资料地址 链接: https://pan.baidu.com/s/1QEFLWKRkMh-wh2nE5kD4Xw 提取码: x8iw分布式表示：用一个词附近的其他词来表示该词。Word2Vec：Skip-Gram DataLoader实现Dataloader一个dataloader需要以下内容： 把所有text编码成数字，然后用subsampling预处理这些文字。 保存vocabulary，单词count，normalized word frequency 每个iteration sample一个中心词 根据当前的中心词返回context单词 根据中心词sample一些negative单词 返回单词的counts这里有一个好的tutorial介绍如何使用PyTorch dataloader. 为了使用dataloader，我们需要定义以下两个function: len function需要返回整个数据集中有多少个itemgetitem 根据给定的index返回一个item有了dataloader之后，我们可以轻松随机打乱整个数据集，拿到一个batch的数据等等。 123456789101112131415161718192021class WordEmbeddingDataset(tud.Dataset): def __init__(self,text,word_to_idx,idx_to_word,word_freqs): super(WordEmbeddingDataset,self).__init__() self.word_to_idx = word_to_idx self.idx_to_word = idx_to_word self.word_freqs = torch.Tensor(word_freqs) self.text_encoded = torch.Tensor([self.word_to_idx.get(w,self.word_to_idx[\"&lt;unk&gt;\"]) for w in text]) def __len__(self): return len(self.text_encoded) def __getitem__(self,idx): center_word = self.text_encoded[idx] pos_indices = list(range(idx-C,idx))+list(range(idx+1,idx+C+1)) pos_indices = [i%len(self.word_to_idx) for i in pos_indices] pos_words = torch.Tensor([self.text_encoded[i] for i in pos_indices]) neg_words = torch.multinomial(self.word_freqs,K*pos_words.shape[0],True) return center_word,pos_words,neg_wordsdataset = WordEmbeddingDataset(text,word_to_idx,idx_to_word,word_freqs)dataloader = tud.DataLoader(dataset,batch_size=BATCH_SIZE,shuffle=True) model1234567891011121314151617181920212223242526272829class EmbeddingModel(nn.Module): def __init__(self,vocab_size,embed_size): super(EmbeddingModel,self).__init__() self.vocab_size = vocab_size self.embed_size = embed_size self.in_embed = nn.Embedding(self.vocab_size,self.embed_size) self.out_embed = nn.Embedding(self.vocab_size,self.embed_size) def forward(self,input_label,pos_labels,neg_labels): # input_label : [batch_size] # pos_label : [batch_size,window_size*2] # neg_label : [batch_size,window_size*2*K] input_embed = self.in_embed(input_label) # [batch_size,embed_size] pos_embed = self.out_embed(pos_labels) # [batch_size,window_size*2,embed_size] neg_embed = self.out_embed(neg_labels) # [batch_size,window_size*2*K,embed_size] input_embed = input_embed.unsqueeze(2) pos_dot = torch.bmm(pos_embed,input_embed).squeeze(2) # [batch_size,window_size*2] neg_dot = torch.bmm(neg_embed,-input_embed).squeeze(2) # [batch_size,window_size*2*K] pos_loss = F.logsigmoid(pos_dot).sum(1) #.sum(1) neg_loss = F.logsigmoid(neg_dot).sum(1) loss = pos_loss+neg_loss return -loss def input_embeddings(self): return self.in_embed.weight.data.cpu().numpy() training1234567891011121314151617model = EmbeddingModel(VOCAB_SIZE,EMBEDDING_SIZE)if USE_CUDA: model = model.cuda()optimizer = torch.optim.SGD(model.parameters(),lr=LEARNING_RATE)for e in range(NUM_EPOCHS): for i,(input_label,pos_labels,neg_labels) in enumerate(dataloader): if USE_CUDA: input_label = input_label.long().cuda() pos_labels = pos_labels.long().cuda() neg_labels = neg_labels.long().cuda() optimizer.zero_grad() loss = model(input_label,pos_labels,neg_labels).mean() loss.backward() optimizer.step() if i % 100 == 0: print(\"epoch: &#123;&#125;, iter: &#123;&#125;, loss: &#123;&#125;\".format(e, i, loss.item())) 评估123456789101112131415161718192021222324def evaluate(filename, embedding_weights): if filename.endswith(\".csv\"): data = pd.read_csv(filename, sep=\",\") else: data = pd.read_csv(filename, sep=\"\\t\") human_similarity = [] model_similarity = [] for i in data.iloc[:, 0:2].index: word1, word2 = data.iloc[i, 0], data.iloc[i, 1] if word1 not in word_to_idx or word2 not in word_to_idx: continue else: word1_idx, word2_idx = word_to_idx[word1], word_to_idx[word2] word1_embed, word2_embed = embedding_weights[[word1_idx]], embedding_weights[[word2_idx]] model_similarity.append(float(sklearn.metrics.pairwise.cosine_similarity(word1_embed, word2_embed))) human_similarity.append(float(data.iloc[i, 2])) return scipy.stats.spearmanr(human_similarity, model_similarity)# , model_similaritydef find_nearest(word): index = word_to_idx[word] embedding = embedding_weights[index] cos_dis = np.array([scipy.spatial.distance.cosine(e, embedding) for e in embedding_weights]) return [idx_to_word[i] for i in cos_dis.argsort()[:10]] 语言模型常见的语言模型RNN（Recurrent neural network）Long short-term memory(LSTM)：几个门来控制输入输出：忘记门、输入门、更新门、输出门原始的LSTM：优化的LSTM（Pytorch中的LSTM）： 训练时训练CrossEntropy Gated Recurrent unit 模型建立这些循环神经网络都可能出现梯度爆炸的问题。因此最好做一个gradient clippinggithub 文本处理1234567891011TEXT = torchtext.data.Field(lower=True)train, val, test = torchtext.datasets.LanguageModelingDataset.splits(path=\".\", train=\"word2vec/text8.train.txt\", validation=\"word2vec/text8.dev.txt\", test=\"word2vec/text8.test.txt\", text_field=TEXT)TEXT.build_vocab(train, max_size=MAX_VOCAB_SIZE)print(\"vocabulary size: &#123;&#125;\".format(len(TEXT.vocab)))VOCAB_SIZE = len(TEXT.vocab)TEXT.vocab.itos # index to string. type:list 包含两个特殊字符&lt;unk&gt; &lt;pad&gt;TEXT.vocab.stoi # string to index. type:dict 包含两个特殊字符&lt;unk&gt; &lt;pad&gt;train_iter, val_iter, test_iter = torchtext.data.BPTTIterator.splits( (train, val, test), batch_size=BATCH_SIZE, device=-1, bptt_len=32, repeat=False, shuffle=True) 模型保存123456789val_loss = evaluate(model, val_iter)if len(val_losses) == 0 or val_loss &lt; min(val_losses): print(\"best model, val loss: \", val_loss) torch.save(model.state_dict(), \"lm-best.th\")else: scheduler.step() optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)val_losses.append(val_loss) # scheduler = torch.optim.lr_scheduler.ExponentialLR(optimizer, 0.5) 模型加载1234best_model = RNNModel(\"LSTM\", VOCAB_SIZE, EMBEDDING_SIZE, EMBEDDING_SIZE, 2, dropout=0.5)if USE_CUDA: best_model = best_model.cuda()best_model.load_state_dict(torch.load(\"lm-best.th\")) 文本分类模型 logits : 任何数字sigmoid处理后： probability BCEWithLogitsLoss() binary cross entropy: 二分类问题文本分类模型中，dropout很重要，特别是数据量比较少的时候。（可以dropout，或把部分单词的word调成&lt;unk&gt;）WordAVG 很强。 卷积网络local feature detect Batchnormalization 常见的卷积网络 迁移学习我们常用以下两种方法做迁移学习。 fine tuning: 从一个预训练模型开始，我们改变一些模型的架构，然后继续训练整个模型的参数。 feature extraction: 我们不再改变预训练模型的参数，而是只更新我们改变过的部分模型参数。我们之所以叫它feature extraction是因为我们把预训练的CNN模型当做一个特征提取模型，利用提取出来的特征做来完成我们的训练任务。通过requires_grad = False 来冻结层以下是构建和训练迁移学习模型的基本步骤： 初始化预训练模型 把最后一层的输出层改变成我们想要分的类别总数 定义一个optimizer来更新参数 模型训练 图片风格迁移和GAN风格迁移content lossstyleGram Matrix可以被拿来表示两张图片的texture相似度style loss GAN(Generative Adversarial Networks)Generator: 生成器，目标是让生成的数据接近真实数据Discriminator: 判别器，目标是能够鉴别真实数据和生成的假数据 论文：style transfer from non-parallel text by cross-alignment DCGAN使用deconv层作为图片生成器Deconvolutional Layer https://datascience.stackexchange.com/questions/6107/what-are-deconvolutional-layers介绍deconvhttps://arxiv.org/pdf/1603.07285.pdf Seq2Seq和Attention 大规模预训练语言模型https://zhuanlan.zhihu.com/p/46652512BERT、ELMO、OpenAI GPT ELMO一个预训练两层双向LSTM语言模型：-》得到的是词向量-&gt;用来替代embedding层，通常能提高很多https://www.aclweb.org/anthology/N18-1202https://github.com/allenai/allennlpAllenNLP一个很好的构建NLP模型的package，基于PyTorchAllenAI在2018 EMNLP上的一个tutorialhttps://github.com/allenai/writing-code-for-nlp-research-emnlp2018/blob/master/writing_code_for_nlp_research.pdf elmo的训练代码：bilm-tfelmo使用tensorflow训练再导出到pytorch中 BERT不是一个语言模型，目标是预测masked word OpenAI GPT-2一种Transformer模型","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"tensorflow和pytorch环境部署（windows下）","slug":"tensorflow和pytorch环境部署（windows下）","date":"2020-03-14T10:31:25.000Z","updated":"2021-02-19T02:26:06.721Z","comments":true,"path":"2020/03/14/tensorflow和pytorch环境部署（windows下）/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/14/tensorflow%E5%92%8Cpytorch%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%88windows%E4%B8%8B%EF%BC%89/","excerpt":"由于现在tensorflow和pytorch更新都依赖cuda，更新比较麻烦，最近正好闲着，想着把电脑里面的环境更新一下。","text":"由于现在tensorflow和pytorch更新都依赖cuda，更新比较麻烦，最近正好闲着，想着把电脑里面的环境更新一下。 cuda和cudnn的安装cuda的安装直接从官网下载cuda。cuda直接运行安装。 cudnn的安装cudnn下载完成后，解压到cuda的安装目录即可。 tensorflow的安装安装conda install tensorflow-gpu==2.1.0 测试代码123456789import tensorflow as tfimport osos.environ['TF_CPP_MIN_LOG_LEVEL'] = '2' # 不显示等级2以下的提示信息print('GPU', tf.test.is_gpu_available())a = tf.constant(2.0)b = tf.constant(4.0)print(a + b) pytorch的安装安装conda install pytorch torchvision cudatoolkit=10.1 -c pytorch 测试12import torchprint(torch.cuda.is_available()) 其他软件包的安装conda install jupyter notebook scikit-learn opencv pillow lxml","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"TimeDistributed层（keras）","slug":"TimeDistributed层（keras）","date":"2020-03-11T02:28:36.000Z","updated":"2021-02-19T02:26:06.343Z","comments":true,"path":"2020/03/11/TimeDistributed层（keras）/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/11/TimeDistributed%E5%B1%82%EF%BC%88keras%EF%BC%89/","excerpt":"tf.keras.layers.TimeDistributed","text":"tf.keras.layers.TimeDistributed This wrapper allows to apply a layer to every temporal slice of an input.输入至少应当有3个维度，第一个维度被函数默认为是一个临时的维度。考虑一个具有32个样本的样本集合，每个样品都是由10个16维的向量组成。这个batch的输入shape就应当是(32,10,16),不包括样本个数维度的输入shape是(10,16)。 这个时候就可以使用TimeDistributed来对10个向量每个向量添加一个Dense层。此时输出是（32,10,8）维度的。123model = Sequential()model.add(TimeDistributed(Dense(8), input_shape=(10, 16)))# now model.output_shape == (None, 10, 8)对于一个子序列层，不需要输入input_shape参数12model.add(TimeDistributed(Dense(32)))# now model.output_shape == (None, 10, 32)输出尺寸为(32, 10, 32). 同样TimeDistributed可以用于任何层,比如Conv2D layer:123model = Sequential()model.add(TimeDistributed(Conv2D(64, (3, 3)), input_shape=(10, 299, 299, 3)))","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"常见的目标检测算法(RCNN,SSD,YOLO)","slug":"常见的目标检测算法","date":"2020-03-10T04:15:28.000Z","updated":"2021-02-19T02:26:06.915Z","comments":true,"path":"2020/03/10/常见的目标检测算法/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/10/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/","excerpt":"参考链接","text":"参考链接 常见的目标检测算法object detection，就是在给定的图片中精确找到物体所在位置，并标注出物体的类别。所以，object detection要解决的问题就是物体在哪里以及是什么的整个流程问题。然而，这个问题可不是那么容易解决的，物体的尺寸变化范围很大，摆放物体的角度，姿态不定，而且可以出现在图片的任何地方，更何况物体还可以是多个类别。 目前学术和工业界出现的目标检测算法分成3类： 传统的目标检测算法：Cascade + HOG/DPM + Haar/SVM以及上述方法的诸多改进、优化； 候选区域/窗 + 深度学习分类：通过提取候选区域，并对相应区域进行以深度学习方法为主的分类的方案，如：R-CNN（Selective Search + CNN + SVM）SPP-net（ROI Pooling）Fast R-CNN（Selective Search + CNN + ROI）Faster R-CNN（RPN + CNN + ROI）R-FCN等系列方法； 基于深度学习的回归方法：YOLO/SSD/DenseBox 等方法；以及最近出现的结合RNN算法的RRC detection；结合DPM的Deformable CNN等传统目标检测流程：1）区域选择（穷举策略：采用滑动窗口，且设置不同的大小，不同的长宽比对图像进行遍历，时间复杂度高）2）特征提取（SIFT、HOG等；形态多样性、光照变化多样性、背景多样性使得特征鲁棒性差）3）分类器分类（主要有SVM、Adaboost等） 传统目标检测的主要问题是：1）基于滑动窗口的区域选择策略没有针对性，时间复杂度高，窗口冗余2）手工设计的特征对于多样性的变化没有很好的鲁棒性 候选区域/窗 + 深度学习分类R-CNN横空出世预先找出图中目标可能出现的位置，即候选区域（Region Proposal）。利用图像中的纹理、边缘、颜色等信息，可以保证在选取较少窗口(几千甚至几百）的情况下保持较高的召回率（Recall）。所以，问题就转变成找出可能含有物体的区域/框（也就是候选区域/框，比如选2000个候选框），这些框之间是可以互相重叠互相包含的，这样我们就可以避免暴力枚举的所有框了。大牛们发明好多选定候选框Region Proposal的方法，比如Selective Search和EdgeBoxes。那提取候选框用到的算法“选择性搜索”到底怎么选出这些候选框的呢？具体可以看一下PAMI2015的“What makes for effective detection proposals？”2014年，RBG（Ross B. Girshick）使用Region Proposal + CNN代替传统目标检测使用的滑动窗口+手工设计特征，设计了R-CNN框架，使得目标检测取得巨大突破，并开启了基于深度学习目标检测的热潮。 RCNN算法分为4个步骤R-CNN的简要步骤如下(1) 输入测试图像(2) 利用选择性搜索Selective Search算法在图像中从下到上提取2000个左右的可能包含物体的候选区域Region Proposal(3) 因为取出的区域大小各自不同，所以需要将每个Region Proposal缩放（warp）成统一的227x227的大小并输入到CNN，将CNN的fc7层的输出作为特征(4) 将每个Region Proposal提取到的CNN特征输入到SVM进行分类(5) 使用回归器精细修正候选框位置：对于每一个类，训练一个线性回归模型去判定这个框是否框得完美。 Selective Search 主要思想:使用一种过分割手段，将图像分割成小区域 (1k~2k 个),查看现有小区域，按照合并规则合并可能性最高的相邻两个区域。重复直到整张图像合并成一个区域位置,输出所有曾经存在过的区域，所谓候选区域其中合并规则如下： 优先合并以下四种区域： 颜色（颜色直方图）相近的 纹理（梯度直方图）相近的 合并后总面积小的： 保证合并操作的尺度较为均匀，避免一个大区域陆续“吃掉”其他小区域 （例：设有区域a-b-c-d-e-f-g-h。较好的合并方式是：ab-cd-ef-gh -&gt; abcd-efgh -&gt; abcdefgh。 不好的合并方法是：ab-c-d-e-f-g-h -&gt;abcd-e-f-g-h -&gt;abcdef-gh -&gt; abcdefgh） 合并后，总面积在其BBOX中所占比例大的： 保证合并后形状规则。 SPP NetSPP：Spatial Pyramid Pooling（空间金字塔池化）SPP-Net是出自2015年发表在IEEE上的论文-《Spatial Pyramid Pooling in Deep ConvolutionalNetworks for Visual Recognition》。众所周知，CNN一般都含有卷积部分和全连接部分，其中，卷积层不需要固定尺寸的图像，而全连接层是需要固定大小的输入。所以当全连接层面对各种尺寸的输入数据时，就需要对输入数据进行crop（crop就是从一个大图扣出网络输入大小的patch，比如227×227），或warp（把一个边界框bounding box的内容resize成227×227）等一系列操作以统一图片的尺寸大小，比如224224（ImageNet）、3232(LenNet)、9696等。但warp/crop这种预处理，导致的问题要么被拉伸变形、要么物体不全，限制了识别精确度。SPP Net的作者Kaiming He等人逆向思考，既然由于全连接FC层的存在，普通的CNN需要通过固定输入图片的大小来使得全连接层的输入固定。那借鉴卷积层可以适应任何尺寸，为何不能在卷积层的最后加入某种结构，使得后面全连接层得到的输入变成固定的呢？这个“化腐朽为神奇”的结构就是spatial pyramid pooling layer。下图便是R-CNN和SPP Net检测流程的比较：它的特点有两个:1.结合空间金字塔方法实现CNNs的多尺度输入。SPP Net的第一个贡献就是在最后一个卷积层后，接入了金字塔池化层，保证传到下一层全连接层的输入固定。换句话说，在普通的CNN机构中，输入图像的尺寸往往是固定的（比如224224像素），输出则是一个固定维数的向量。SPP Net在普通的CNN结构中加入了ROI池化层（ROI Pooling），使得网络的输入图像可以是任意尺寸的，输出则不变，同样是一个固定维数的向量。简言之，CNN原本只能固定输入、固定输出，CNN加上SSP之后，便能任意输入、固定输出。神奇吧？ROI池化层一般跟在卷积层后面，此时网络的输入可以是任意尺度的，在SPP layer中每一个pooling的filter会根据输入调整大小，而SPP的输出则是固定维数的向量，然后给到全连接FC层。2.只对原图提取一次卷积特征在R-CNN中，每个候选框先resize到统一大小，然后分别作为CNN的输入，这样是很低效的。而SPP Net根据这个缺点做了优化：只对原图进行一次卷积计算，便得到整张图的卷积特征feature map，然后找到每个候选框在feature map上的映射patch，将此patch作为每个候选框的卷积特征输入到SPP layer和之后的层，完成特征提取工作。如此这般，R-CNN要对每个区域计算卷积，而SPPNet只需要计算一次卷积，从而节省了大量的计算时间，比R-CNN有一百倍左右的提速。 Fast R-CNNSPP Net真是个好方法，R-CNN的进阶版Fast R-CNN就是在R-CNN的基础上采纳了SPP Net方法，对R-CNN作了改进，使得性能进一步提高。R-CNN与Fast R-CNN的区别有哪些呢？先说R-CNN的缺点：即使使用了Selective Search等预处理步骤来提取潜在的bounding box作为输入，但是R-CNN仍会有严重的速度瓶颈，原因也很明显，就是计算机对所有region进行特征提取时会有重复计算，Fast-RCNN正是为了解决这个问题诞生的。与R-CNN框架图对比，可以发现主要有两处不同：一是最后一个卷积层后加了一个ROI pooling layer，二是损失函数使用了多任务损失函数(multi-task loss)，将边框回归Bounding Box Regression(先验框尺寸和位置的调整)直接加入到CNN网络中训练(1) ROI pooling layer实际上是SPP-NET的一个精简版，SPP-NET对每个proposal使用了不同大小的金字塔映射，而ROI pooling layer只需要下采样到一个7x7的特征图。对于VGG16网络conv5_3有512个特征图，这样所有region proposal对应了一个77512维度的特征向量作为全连接层的输入。换言之，这个网络层可以把不同大小的输入映射到一个固定尺度的特征向量，而我们知道，conv、pooling、relu等操作都不需要固定size的输入，因此，在原始图片上执行这些操作后，虽然输入图片size不同导致得到的feature map尺寸也不同，不能直接接到一个全连接层进行分类，但是可以加入这个神奇的ROI Pooling层，对每个region都提取一个固定维度的特征表示，再通过正常的softmax进行类型识别。(2) R-CNN训练过程分为了三个阶段，而Fast R-CNN直接使用softmax替代SVM分类，同时利用多任务损失函数边框回归也加入到了网络中，这样整个的训练过程是端到端的(除去Region Proposal提取阶段)。也就是说，之前R-CNN的处理流程是先提proposal，然后CNN提取特征，之后用SVM分类器，最后再做bbox regression，而在Fast R-CNN中，作者巧妙的把bbox regression放进了神经网络内部，与region分类和并成为了一个multi-task模型，实际实验也证明，这两个任务能够共享卷积特征，并相互促进。 所以，Fast-RCNN很重要的一个贡献是成功的让人们看到了Region Proposal + CNN这一框架实时检测的希望，原来多类检测真的可以在保证准确率的同时提升处理速度，也为后来的Faster R-CNN做下了铺垫。 画一画重点：R-CNN有一些相当大的缺点（把这些缺点都改掉了，就成了Fast R-CNN）。大缺点：由于每一个候选框都要独自经过CNN，这使得花费的时间非常多。解决：共享卷积层，现在不是每一个候选框都当做输入进入CNN了，而是输入一张完整的图片，在第五个卷积层再得到每个候选框的特征 原来的方法：许多候选框（比如两千个）—&gt;CNN—&gt;得到每个候选框的特征—&gt;分类+回归现在的方法：一张完整图片—&gt;CNN—&gt;得到每张候选框的特征—&gt;分类+回归 所以容易看见，Fast R-CNN相对于R-CNN的提速原因就在于：不过不像R-CNN把每个候选区域给深度网络提特征，而是整张图提一次特征，再把候选框映射到conv5上，而SPP只需要计算一次特征，剩下的只需要在conv5层上操作就可以了。 Faster R-CNNFast R-CNN存在的问题：存在瓶颈：选择性搜索，找出所有的候选框，这个也非常耗时。那我们能不能找出一个更加高效的方法来求出这些候选框呢？解决：加入一个提取边缘的神经网络，也就说找到候选框的工作也交给神经网络来做了。所以，rgbd在Fast R-CNN中引入Region Proposal Network(RPN)替代Selective Search，同时引入anchor box应对目标形状的变化问题（anchor就是位置和大小固定的box，可以理解成事先设置好的固定的proposal）。具体做法： • 将RPN放在最后一个卷积层的后面 • RPN直接训练得到候选区域 一种网络，四个损失函数; • RPN calssification(anchor good.bad) • RPN regression(anchor-&gt;propoasal) • Fast R-CNN classification(over classes) • Fast R-CNN regression(proposal -&gt;box) Faster R-CNN的主要贡献就是设计了提取候选区域的网络RPN，代替了费时的选择性搜索selective search，使得检测速度大幅提高。 最后总结一下各大算法的步骤：RCNN1.在图像中确定约1000-2000个候选框 (使用选择性搜索Selective Search)2.每个候选框内图像块缩放至相同大小，并输入到CNN内进行特征提取3.对候选框中提取出的特征，使用分类器判别是否属于一个特定类4.对于属于某一类别的候选框，用回归器进一步调整其位置 Fast R-CNN1.在图像中确定约1000-2000个候选框 (使用选择性搜索Selective Search)2.对整张图片输进CNN，得到feature map3.找到每个候选框在feature map上的映射patch，将此patch作为每个候选框的卷积特征输入到SPP layer和之后的层4.对候选框中提取出的特征，使用分类器判别是否属于一个特定类5.对于属于某一类别的候选框，用回归器进一步调整其位置 Faster R-CNN1.对整张图片输进CNN，得到feature map2.卷积特征输入到RPN，得到候选框的特征信息3.对候选框中提取出的特征，使用分类器判别是否属于一个特定类4.对于属于某一类别的候选框，用回归器进一步调整其位置 基于深度学习的回归算法TOLO和SSD算法可以参看我的其他博文 YOLO (CVPR2016, oral)(You Only Look Once: Unified, Real-Time Object Detection)Faster R-CNN的方法目前是主流的目标检测方法，但是速度上并不能满足实时的要求。YOLO一类的方法慢慢显现出其重要性，这类方法使用了回归的思想，利用整张图作为网络的输入，直接在图像的多个位置上回归出这个位置的目标边框，以及目标所属的类别。 SSD首先SSD获取目标位置和类别的方法跟YOLO一样，都是使用回归，但是YOLO预测某个位置使用的是全图的特征，SSD预测某个位置使用的是这个位置周围的特征（感觉更合理一些）。 那么如何建立某个位置和其特征的对应关系呢？可能你已经想到了，使用Faster R-CNN的anchor机制。如SSD的框架图所示，假如某一层特征图(图b)大小是88，那么就使用33的滑窗提取每个位置的特征，然后这个特征回归得到目标的坐标信息和类别信息(图c)。 不同于Faster R-CNN，这个anchor是在多个feature map上，这样可以利用多层的特征并且自然的达到多尺度（不同层的feature map 3*3滑窗感受野不同）。 小结：SSD结合了YOLO中的回归思想和Faster R-CNN中的anchor机制，使用全图各个位置的多尺度区域特征进行回归，既保持了YOLO速度快的特性，也保证了窗口预测的跟Faster R-CNN一样比较精准。SSD在VOC2007上mAP可以达到72.1%，速度在GPU上达到58帧每秒。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[]},{"title":"卷积操作动画","slug":"卷积操作动画","date":"2020-03-10T03:49:01.000Z","updated":"2021-02-19T02:26:06.907Z","comments":true,"path":"2020/03/10/卷积操作动画/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/10/%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C%E5%8A%A8%E7%94%BB/","excerpt":"最近在看实例分割的相关算法，始终无法很好的理解反卷积的相关内容，在github上找到了大佬制作的卷积和反卷积动图，放在博客保存一波。github：https://github.com/vdumoulin/conv_arithmetic","text":"最近在看实例分割的相关算法，始终无法很好的理解反卷积的相关内容，在github上找到了大佬制作的卷积和反卷积动图，放在博客保存一波。github：https://github.com/vdumoulin/conv_arithmetic Convolution animationsN.B.: Blue maps are inputs, and cyan maps are outputs. No padding, no strides Arbitrary padding, no strides Half padding, no strides Full padding, no strides No padding, strides Padding, strides Padding, strides (odd) Transposed convolution animationsN.B.: Blue maps are inputs, and cyan maps are outputs. No padding, no strides, transposed Arbitrary padding, no strides, transposed Half padding, no strides, transposed Full padding, no strides, transposed No padding, strides, transposed Padding, strides, transposed Padding, strides, transposed (odd) Dilated convolution animationsN.B.: Blue maps are inputs, and cyan maps are outputs. No padding, no stride, dilation","categories":[],"tags":[]},{"title":"利用mAP(mean Average Precision)计算目标检测精确度","slug":"利用mAP计算目标检测精确度","date":"2020-03-09T04:17:38.000Z","updated":"2021-02-19T02:26:06.748Z","comments":true,"path":"2020/03/09/利用mAP计算目标检测精确度/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/09/%E5%88%A9%E7%94%A8mAP%E8%AE%A1%E7%AE%97%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%B2%BE%E7%A1%AE%E5%BA%A6/","excerpt":"CSDN: https://blog.csdn.net/weixin_44791964/article/details/104695264","text":"CSDN: https://blog.csdn.net/weixin_44791964/article/details/104695264 知识储备1、IOU的概念IOU的概念应该比较简单，就是衡量预测框和真实框的重合程度。下图是一个示例：图中绿色框为实际框（好像不是很绿……），红色框为预测框，当我们需要判断两个框之间的关系时，主要就是判断两个框的重合程度 计算IOU的公式为： IOU=\\frac{S_交}{S_并}2、TP TN FP FN的概念TP TN FP FN里面一共出现了4个字母，分别是T F P N。T是True；F是False；P是Positive；N是Negative。 T或者F代表的是该样本 是否被正确分类。P或者N代表的是该样本 原本是正样本还是负样本。 TP（True Positives）意思就是被分为了正样本，而且分对了。TN（True Negatives）意思就是被分为了负样本，而且分对了，FP（False Positives）意思就是被分为了正样本，但是分错了（事实上这个样本是负样本）。FN（False Negatives）意思就是被分为了负样本，但是分错了（事实上这个样本是这样本）。 在mAP计算的过程中主要用到了，TP、FP、FN这三个概念。 3、precision（精确度）和recall（召回率）精确度：模型预测为真的样本中，实际为真的比例 Precision=\\frac{TP}{TP+FP}召回率：模型预测为真且实际为真的样本占实际为真的样本的比例 Recall=\\frac{TP}{TP+FN}4、概念举例如图所示，蓝色的框是 真实框。绿色和红色的框是 预测框，绿色的框是正样本，红色的框是负样本。一般来讲，当预测框和真实框IOU&gt;=0.5时，被认为是正样本。因此对于这幅图来讲。真实框一共有3个，正样本一共有2个，负样本一共有2个。此时 Precision= \\frac{2}{2+2}=\\frac{1}{2}Recall=\\frac{2}{2+1} = \\frac{2}{3}单个指标的局限性在目标检测算法里面有一个非常重要的概念是置信度，如果置信度设置的高的话，预测的结果和实际情况就很符合，如果置信度低的话，就会有很多误检测。 假设一幅图里面总共有3个正样本，目标检测对这幅图的预测结果有10个，其中3个实际上是正样本，7个实际上是负样本。对应置信度如下。 如果我们将可以接受的置信度设置为0.95的话，那么目标检测算法就会将序号为1的样本作为正样本，其它的都是负样本。此时TP = 1，FP = 0，FN = 2。 Precision=\\frac{1}{1+0}=1Recall= \\frac{1}{1+2} = \\frac{1}{3}此时Precision非常高，但是事实上我们只检测出一个正样本，还有两个没有检测出来，因此只用Precision就不合适。 这个时候如果我们将可以接受的置信度设置为0.35的话，那么目标检测算法就会将序号为1的样本作为正样本，其它的都是负样本。此时TP = 3，FP = 3，FN = 0。 Precision=\\frac{3}{3+3}=\\frac{1}{2}Recall= \\frac{3}{3+0} = \\frac{1}{2}此时Recall非常高，但是事实上目标检测算法认为是正样本的样本里面，有3个样本确实是正样本，但有三个是负样本，存在非常严重的误检测，因此只用Recall就不合适。 二者进行结合才是评价的正确方法。 什么是APAP事实上指的是，利用不同的Precision和Recall的点的组合，画出来的曲线下面的面积。如下面这幅图所示。当我们取不同的置信度，可以获得不同的Precision和不同的Recall，当我们取得置信度够密集的时候，就可以获得非常多的Precision和Recall。 此时Precision和Recall可以在图片上画出一条线，这条线下部分的面积就是某个类的AP值。mAP就是所有的类的AP值求平均。 github: https://github.com/Cartucho/mAP","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"一些常用的tensorflow操作","slug":"常用tensorflow操作","date":"2020-03-07T13:43:52.000Z","updated":"2021-02-19T02:26:06.914Z","comments":true,"path":"2020/03/07/常用tensorflow操作/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/07/%E5%B8%B8%E7%94%A8tensorflow%E6%93%8D%E4%BD%9C/","excerpt":"特征层or图像处理","text":"特征层or图像处理 （1）tf.image.crop_and_resize对特征层或图像进行裁剪，裁剪后再进行resize123456789tf.image.crop_and_resize( image, boxes, box_ind, crop_size, method='bilinear', extrapolation_value=0, name=None)参数： image：一个Tensor,必须是下列类型之一：uint8, uint16, int8, int16, int32, int64, half, float32, float64, 一个形状为[batch, image_height, image_width, depth]的四维张量,image_height和image_width需要为正值. boxes：一个类型为float32的Tensor，是形状为[num_boxes, 4]的二维张量。张量的第i行指定box_ind[i]图像中框的坐标，并且在标准化坐标中指定[y1, x1, y2, x2]，四个坐标均是标准归一化后的结果；标准化的坐标值y被映射到图像坐标y * (image_height - 1)处，从而标准化图像高度的[0, 1]间隔被映射到[0, image_height - 1]的图像高度坐标中。我们允许y1&gt;y2,在这种情况下,采样的裁剪是原始图像的上下翻转版本，宽度维度的处理方式类似。[0,1]范围之外的标准化坐标是允许的,在这种情况下，我们使用extrapolation_value外推输入图像值。 box_ind：一个int32类型的Tensor；形状为[num_boxes]的1维张量,在[0, batch)中具有int32值，该box_ind[i]值指定第i个方框要引用的图像。 crop_size：一个int32类型的Tensor；一个2个元素的一维张量,size = [crop_height, crop_width]。所有裁剪的图像修补程序都调整为此大小.图像内容的宽高比不被保留；crop_height和crop_width需要为正值。 method：可选的string,其来自：“bilinear”；默认为”bilinear”；指定插值方法的字符串.现在只支持“双线性(bilinear)”. extrapolation_value：可选的float,默认为0,用于推断的值(如果适用). name：操作的名称(可选).返回值：tf.image.crop_and_resize函数返回一个类型为float32的Tensor. 形状为[num_boxes, ,crop_height, crop_width, depth]测试代码：12345678910import tensorflow as tffrom PIL import Imageimport numpy as npimg = np.array(Image.open(\"img/street.jpg\"))shape = img.shapeimg = img.reshape([1,shape[0], shape[1], shape[2]])a = tf.image.crop_and_resize(img,[[0.5,0.6,0.9,0.8],[0.2,0.6,1.3,0.9]],box_ind=[0,0],crop_size=(100,100))sess = tf.Session()b = a.eval(session = sess)Image.fromarray(np.uint8(b[0])).show() （2）tf.image.crop_and_resize这是在对图像、特征层处理经常用到的函数，可以对特征层或者图像resize。123456tf.image.resize_images( images, size, method=ResizeMethod.BILINEAR, align_corners=False)使用指定的method调整images为size。调整大小的图像将失真，如果他们的原始纵横比与size不一样。 images：形状为[batch, height, width, channels]的4-D张量或形状为[height, width, channels]的3-D张量。 size：2个元素(new_height, new_width)的1维int32张量,表示图像的新大小。 method：ResizeMethod,默认为ResizeMethod.BILINEAR。 align_corners：布尔型,如果为True,则输入和输出张量的4个拐角像素的中心对齐,并且保留角落像素处的值；默认为False。如果images是四维,则返回一个形状为[batch, new_height, new_width, channels]的四维浮动张量；如果images是三维,则返回一个形状为[new_height, new_width, channels]的三维浮动张量. （3）tf.transpose可以对输入进行转置。123456tf.transpose( a, perm=None, name='transpose', conjugate=False) a：一个 Tensor。 perm：a 的维数的排列。 name：操作的名称(可选)。 获得特定位置的内容(1) tf.gather1234567tf.gather( params, indices, validate_indices=None, name=None, axis=0) params：一个张量，这个张量是用来收集数值的.该张量的秩必须至少是 axis + 1。 indices：一个张量.必须是以下类型之一：int32,int64.索引张量必须在 [0, params.shape[axis]) 范围内。 axis：一个张量.必须是以下类型之一：int32，int64。在参数轴从中收集索引。默认为第一个维度.支持负索引。 name：操作的名称(可选)。 测试代码:12345678910111213import tensorflow as tf a = tf.Variable([[1,2,3,4,5], [6,7,8,9,10], [11,12,13,14,15]])index_a = tf.Variable([0,1,2,3]) b = tf.Variable([1,2,3,4,5,6,7,8,9,10])index_b = tf.Variable([2,4,6,8]) with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print(sess.run(tf.gather(a, index_a))) print(sess.run(tf.gather(a, index_a,axis = 1))) print(sess.run(tf.gather(b, index_b)))输出：12345678[[ 1 2 3 4 5] [ 6 7 8 9 10] [11 12 13 14 15] [ 0 0 0 0 0]][[ 1 2 3 4] [ 6 7 8 9] [11 12 13 14]][3 5 7 9] (2) tf.gather_nd获得特定位置的内容。12345tf.gather_nd( params, indices, name=None) params：张量，这个张量是用来收集数值的。 indices：张量，必须是以下类型之一：int32，int64；索引张量。 name：操作的名称(可选)。 测试代码:1234567891011121314import tensorflow as tf a = tf.Variable([[1,2,3,4,5], [6,7,8,9,10], [11,12,13,14,15]])index_a = tf.Variable([[0,1],[0,0],[1,3],[2,4]])b = tf.Variable([[[1,2,3],[4,5,6]], [[6,7,8],[9,10,11]], [[11,12,13],[14,15,16]]])index_b = tf.Variable([[0,1],[0,0],[1,1],[2,2]])index_c = tf.Variable([[0,1,1],[0,0,0],[1,1,1],[2,2,2]]) with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print(sess.run(tf.gather_nd(a, index_a))) print(sess.run(tf.gather_nd(b, index_b))) print(sess.run(tf.gather_nd(b, index_c)))输出：123456[ 2 1 9 15][[ 4 5 6] [ 1 2 3] [ 9 10 11] [ 0 0 0]][ 5 1 10 0] (3) tf.where判断哪些位置符合这个表达式。123456tf.where( condition, x=None, y=None, name=None) 根据condition返回x或y中的元素。 如果x和y都为None,则该操作将返回condition中true元素的坐标，坐标以二维张量返回，其中第一维(行)表示真实元素的数量，第二维(列)表示真实元素的坐标。 如果两者都不是None。则x和y必须具有相同的形状。如果x和y是标量，则condition张量必须是标量，如果x和y是更高级别的矢量，则condition必须是大小与x的第一维度相匹配的矢量，或者必须具有与x相同的形状。 condition张量作为一个可以选择的掩码(mask)，它根据每个元素的值来判断输出中的相应元素/行是否应从 x (如果为 true) 或 y (如果为 false)中选择。 如果condition是向量，则x和y是更高级别的矩阵，那么它选择从x和y复制哪个行(外部维度)。如果condition与x和y具有相同的形状，那么它将选择从x和y复制哪个元素。 测试代码:123456789101112131415161718192021222324import tensorflow as tfimport numpy as npsess=tf.Session()#-------------------## 用法1：# x，y没值的时候#-------------------#a=[[[True, False], [True, False]], [[False, True], [False, True]], [[False, False], [False, True]]]print(sess.run(tf.where(a)))#-------------------## 用法2：# x，y有值的时候#-------------------#a=np.array([[1,0,0],[0,1,1]])a1=np.array([[3,2,3],[4,5,6]])print(sess.run(tf.equal(a,1)))print(sess.run(tf.where(tf.equal(a,1),a,a1)))输出：123456789[[0 0 0] [0 1 0] [1 0 1] [1 1 1] [2 1 1]][[ True False False] [False True True]][[1 2 3] [4 1 1]] 矩阵操作（1）tf.cast12345tf.cast( x, dtype, name=None) tf.cast()函数的作用是执行 tensorflow 中张量数据类型转换，比如读入的图片如果是int8类型的，一般在要在训练前把图像的数据格式转换为float32。 x：待转换的数据（张量） dtype：目标数据类型 name：可选参数，定义操作的名称 测试代码:123456789101112import tensorflow as tfimport numpy as npt1 = tf.Variable([1,2,3,4,5])t2 = tf.cast(t1,dtype=tf.float32)with tf.Session() as sess: print('t1: &#123;&#125;'.format(t1)) print('t2: &#123;&#125;'.format(t2)) sess.run(tf.global_variables_initializer()) sess.run(t2) print(t2.eval())输出：1[1. 2. 3. 4. 5.] （2）tf.stack12345tf.stack( values, axis=0, name='stack') 将秩为 R 的张量列表堆叠成一个秩为 (R+1) 的张量. values：具有相同形状和类型的 Tensor 对象列表. axis：一个 int，要一起堆叠的轴，默认为第一维，负值环绕，所以有效范围是[-(R+1), R+1) name：此操作的名称(可选)。 测试代码:12345678910111213import tensorflow as tfimport numpy as npx = tf.constant([1, 4])y = tf.constant([2, 5])z = tf.constant([3, 6])s0 = tf.stack([x, y, z]) # [[1, 4], [2, 5], [3, 6]] (Pack along first dim.)s1 = tf.stack([x, y, z], axis=1) # [[1, 2, 3], [4, 5, 6]]with tf.Session() as sess: print(sess.run(s0)) print(sess.run(s1))输出：12345[[1 4] [2 5] [3 6]][[1 2 3] [4 5 6]] （3）tf.concat用于对张量进行拼接：1234tf.concat( [tensor1, tensor2, tensor3,...], axis) 测试代码:123456789101112131415161718192021222324import tensorflow as tfimport numpy as npx = tf.constant([1, 4])y = tf.constant([2, 5])z = tf.constant([3, 6])s0 = tf.concat([x, y, z], axis=0) # [[1, 4], [2, 5], [3, 6]] (Pack along first dim.)x = tf.constant([[1], [4]])y = tf.constant([[2], [5]])z = tf.constant([[3], [6]])s1 = tf.concat([x, y, z], axis=0) s2 = tf.concat([x, y, z], axis=1) with tf.Session() as sess: print(sess.run(s0)) print(sess.run(s1)) print(sess.run(s2))输出：123456789[1 4 2 5 3 6][[1] [4] [2] [5] [3] [6]][[1 2 3] [4 5 6]] （3）tf.reduce_max用于求取某个维度最大值：1234567tf.reduce_max( input_tensor, axis=None, keep_dims=False, name=None, reduction_indices=None)计算一个张量的各个维度上元素的最大值.按照axis给定的维度减少input_tensor。除非 keep_dims 是true，否则张量的秩将在axis的每个条目中减少1。如果keep_dims为true，则减小的维度将保留为长度1。 input_tensor：要使用的张量。。 axis：要减小的尺寸。如果为，None(默认),则减少所有维度.必须在[-rank(input_tensor), rank(input_tensor))范围内。 keep_dims：如果为true,则保留长度为1的减少维度。 name：操作的名称(可选)。 reduction_indices：axis的废弃的名称。 测试代码:1234567891011121314import tensorflow as tfimport numpy as npa=np.array([[1, 2], [5, 3], [2, 6]])b = tf.Variable(a)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print(sess.run(tf.reduce_max(b))) print(sess.run(tf.reduce_max(b, axis=1, keepdims=False))) print(sess.run(tf.reduce_max(b, axis=1, keepdims=True))) print(sess.run(tf.reduce_max(b, axis=0, keepdims=True)))输出：1234566[2 5 6][[2] [5] [6]][[5 6]]","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"Mask R-CNN实例分割算法","slug":"Mask-R-CNN算法","date":"2020-03-07T13:01:18.000Z","updated":"2021-02-19T02:26:06.267Z","comments":true,"path":"2020/03/07/Mask-R-CNN算法/","link":"","permalink":"https://sjtu-xx.github.io/2020/03/07/Mask-R-CNN%E7%AE%97%E6%B3%95/","excerpt":"基于Fast RCNN的实例分割算法CSDN：https://blog.csdn.net/weixin_44791964/article/details/104629135","text":"基于Fast RCNN的实例分割算法CSDN：https://blog.csdn.net/weixin_44791964/article/details/104629135 Mask R-CNN实现思路一、预测部分1、主干网络介绍Mask-RCNN使用Resnet101作为主干特征提取网络，对应着图像中的CNN部分，其对输入进来的图片有尺寸要求，需要可以整除2的6次方。在进行特征提取后，利用长宽压缩了两次、三次、四次、五次的特征层来进行特征金字塔结构的构造。 ResNet101有两个基本的块，分别名为Conv Block和Identity Block，其中Conv Block输入和输出的维度是不一样的，所以不能连续串联，它的作用是改变网络的维度；Identity Block输入维度和输出维度相同，可以串联，用于加深网络的。Conv Block的结构如下：Identity Block的结构如下：这两个都是残差网络结构。 以官方使用的coco数据集输入的shape为例，输入的shape为1024x1024，shape变化如下：我们取出长宽压缩了两次、三次、四次、五次的结果来进行特征金字塔结构的构造。 2、特征金字塔的构建特征金字塔FPN的构建是为了实现特征多尺度的融合，在Mask R-CNN当中，我们取出在主干特征提取网络中长宽压缩了两次C2、三次C3、四次C4、五次C5的结果来进行特征金字塔结构的构造。提取到的P2、P3、P4、P5、P6可以作为RPN网络的有效特征层，利用RPN建议框网络对有效特征层进行下一步的操作，对先验框进行解码获得建议框。 提取到的P2、P3、P4、P5可以作为Classifier和Mask网络的有效特征层，利用Classifier预测框网络对有效特征层进行下一步的操作，对建议框解码获得最终预测框；利用Mask语义分割网络对有效特征层进行下一步的操作，获得每一个预测框内部的语义分割结果。 3、获得proposal建议框由上一步获得的有效特征层在图像中就是Feature Map，其有两个应用，一个是和ROIAsign结合使用、另一个是进入到Region Proposal Network进行建议框的获取。 在进行建议框获取的时候，我们使用的有效特征层是P2、P3、P4、P5、P6，它们使用同一个RPN建议框网络获取先验框调整参数，还有先验框内部是否包含物体。 在Mask R-cnn中，RPN建议框网络的结构和Faster RCNN中的RPN建议框网络类似。 首先进行一次3x3的通道数为512的卷积。 然后再分别进行一次anchors_per_location x 4的卷积 和一次anchors_per_location x 2的卷积。 anchors_per_location x 4的卷积 用于预测 公用特征层上 每一个网格点上 每一个先验框的变化情况。（为什么说是变化情况呢，这是因为Faster-RCNN的预测结果需要结合先验框获得预测框，预测结果就是先验框的变化情况。） anchors_per_location x 2的卷积 用于预测 公用特征层上 每一个网格点上 每一个预测框内部是否包含了物体。 当我们输入的图片的shape是1024x1024x3的时候，公用特征层的shape就是256x256x256、128x128x256、64x64x256、32x32x256、16x16x256，相当于把输入进来的图像分割成不同大小的网格，然后每个网格默认存在3（anchors_per_location ）个先验框，这些先验框有不同的大小，在图像上密密麻麻。 anchors_per_location x 4的卷积的结果会对这些先验框进行调整，获得一个新的框。anchors_per_location x 2的卷积会判断上述获得的新框是否包含物体。 到这里我们可以获得了一些有用的框，这些框会利用anchors_per_location x 2的卷积判断是否存在物体。 到此位置还只是粗略的一个框的获取，也就是一个建议框。然后我们会在建议框里面继续找东西。 4、Proposal建议框的解码通过第二步我们获得了许多个先验框的预测结果。预测结果包含两部分。 anchors_per_location x 4的卷积 用于预测 有效特征层上 每一个网格点上 每一个先验框的变化情况。 anchors_per_location x 1的卷积 用于预测 有效特征层上 每一个网格点上 每一个预测框内部是否包含了物体。 相当于就是将整个图像分成若干个网格；然后从每个网格中心建立3个先验框，当输入的图像是1024,1024,3的时候，总共先验框数量为196608+49152+12288+3072+768 = 261,888‬ 当输入图像shape不同时，先验框的数量也会发生改变。 5、对Proposal建议框加以利用（Roi Align）让我们对建议框有一个整体的理解：事实上建议框就是对图片哪一个区域有物体存在进行初步筛选。 实际上，Mask R-CNN到这里的操作是，通过主干特征提取网络，我们可以获得多个公用特征层，然后建议框会对这些公用特征层进行截取。 其实公用特征层里的每一个点相当于原图片上某个区域内部所有特征的浓缩。 建议框会对其对应的公用特征层进行截取，然后将截取的结果进行resize，在classifier模型里，截取后的内容会resize到7x7x256的大小。在mask模型里，截取后的内容会resize到14x14x256的大小。在利用建议框对公用特征层进行截取的时候要注意，要找到建议框属于那个特征层，这个要从建议框的大小进行判断。 在classifier模型里，其会利用一次通道数为1024的7x7的卷积和一次通道数为1024的1x1的卷积对ROIAlign获得的7x7x256的区域进行卷积，两次通道数为1024卷积用于模拟两次1024的全连接，然后再分别全连接到num_classes和num_classes * 4上，分别代表这个建议框内的物体，以及这个建议框的调整参数。 在mask模型里，其首先会对resize后的局部特征层进行四次3x3的256通道的卷积，再进行一次反卷积，再进行一次通道数为num_classes的卷积，最终结果代表每一个像素点分的类。最终的shape为28x28xnum_classes，代表每个像素点的类别。 6、预测框的解码在第四部分获得的建议框也代表了图片上的某一些区域，它在后面的在classifier模型里也起到了先验框的作用。 也就是classifier模型的预测结果，代表了建议框内部物体的种类和调整参数。 建议框调整后的结果，也就是最终的预测结果，这个预测结果就可以在图片上进行绘制了。 预测框的解码过程包括了如下几个步骤：1、取出不属于背景，并且得分大于config.DETECTION_MIN_CONFIDENCE的建议框。2、然后利用建议框和classifier模型的预测结果进行解码，获得最终预测框的位置。3、利用得分和最终预测框的位置进行非极大抑制，防止重复检测。 7、mask语义分割信息的获取在第六步中，我们获得了最终的预测框，这个预测框相比于之前获得的建议框更加准确，因此我们把这个预测框作为mask模型的区域截取部分，利用这个预测框对mask模型中用到的公用特征层进行截取。 截取后，利用mask模型再对像素点进行分类，获得语义分割结果。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"实例分割","slug":"深度学习/实例分割","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"}],"tags":[{"name":"实例分割","slug":"实例分割","permalink":"https://sjtu-xx.github.io/tags/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"}]},{"title":"调参建议","slug":"调参建议","date":"2020-02-26T10:29:03.000Z","updated":"2021-02-19T02:26:07.209Z","comments":true,"path":"2020/02/26/调参建议/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/26/%E8%B0%83%E5%8F%82%E5%BB%BA%E8%AE%AE/","excerpt":"caffe及其他算法中常见参数调整建议，参数包括学习速率，正则化参数，批处理样本数量","text":"caffe及其他算法中常见参数调整建议，参数包括学习速率，正则化参数，批处理样本数量 学习速率 运用梯度下降算法进行优化时，权重的更新规则中，在梯度项前会乘以一个系数，这个系数就叫学习速率η； 可以先把学习速率设置为0.01，然后观察training cost的走向，如果cost在减小，那可以逐步地调大学习速率；如果cost在增大，那就得减小学习速率，反复几次大概确定学习速率的合适值。3.为什么是training cost而不是validation accuracy？《Neural networks and deep learning》一书中有这样一段说明，大致意思是，（1）学习速率只影响寻求最优解的过程，而不像正则化参数和批处理的样本数量那样对最后的分类准确率造成影响，而这可以通过training cost来观察逼近局部最优解的过程中，step是不是大了；（2）训练前期，如果validation accuracy上升，那么training cost会一直减小，所以使用哪种标准判断是否要调整学习速率是没有关系的，这只是作者个人喜好； 正则化系数正则项系数初始值也没有一个比较好的准则。建议一开始将正则项系数λ设置为0，先确定一个比较好的learning rate。然后固定该learning rate，给λ一个值（比如1.0），然后根据validation accuracy，将λ增大或者减小。 批处理样本数量https://www.zhihu.com/question/61607442当采用mini-batch时，一个batch里的所有样本被放在一个矩阵里，利用线性代数库来加速梯度的计算，这是工程实现中的一个优化方法。batch越大，可以充分利用矩阵、线性代数库来进行计算的加速，batch越小，则加速效果可能越不明显。而batch越大，权重的更新就会不那么频繁，导致优化过程太漫长。所以mini-batch size需要根据数据集规模和设备计算能力去选。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"实例分割","slug":"实例分割","date":"2020-02-26T10:13:46.000Z","updated":"2021-02-19T02:26:06.910Z","comments":true,"path":"2020/02/26/实例分割/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/26/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/","excerpt":"基本概念","text":"基本概念 物体检测：Fast/Faster R−CNNFast/Faster R−CNN通常包含两个问题，一是判断属于某个特定类的物体是否出现在图中；二是对该物体进行定位（常用表征就是物体的边界框）可实现输入测试图片，输出检测到的物体类别和位置。语义分割 Fully Convolutional Network (FCN)Fully Convolutional Network (FCN)简单而言就是给定一张图片，对图片上的每一个像素点分类实例分割物体检测和语义分割的综合体。相对物体检测的边界框，实例分割可精确到物体的边缘；相对语义分割，实例分割可以标注出图上同一物体的不同个体","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"实例分割","slug":"深度学习/实例分割","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"}],"tags":[]},{"title":"FasterRCNN目标检测","slug":"FasterRCNN目标检测","date":"2020-02-25T13:37:48.000Z","updated":"2021-02-19T02:26:06.059Z","comments":true,"path":"2020/02/25/FasterRCNN目标检测/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/25/FasterRCNN%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/","excerpt":"CSDN FasterRCNN","text":"CSDN FasterRCNN Faster-RCNN是一个非常有效的目标检测算法，虽然是一个比较早的论文， 但它至今仍是许多目标检测算法的基础。 Faster-RCNN作为一种two-stage的算法，与one-stage的算法相比，two-stage的算法更加复杂且速度较慢，但是检测精度会更高。 事实上也确实是这样，Faster-RCNN的检测效果非常不错，但是检测速度与训练速度有待提高。Feature map通过主干提取网络获得9通道是9个先验框，36是9个先验框的调整参数（cx,cy,dw,dh）。proposal中的先验框在Feature map中进行截取。ROIPooling将截取到的信息resize到一个相同的大小Faster-RCNN可以采用多种的主干特征提取网络，常用的有VGG，Resnet，Xception等等.Faster-RCNN的主干特征提取网络部分只包含了长宽压缩了四次的内容，第五次压缩后的内容在ROI中使用。即Faster-RCNN在主干特征提取网络所用的网络层如图所示。 一些理解如果采用resnet网络，resnet网络的输出为（x//16，y//16，1024）在实际应用中： 分类损失=正负样本的binary_crossentropy之和（正样本为检测出来的目标，副样本为背景） 回归损失=正样本的smooth_l1_loss之和 RPN网络的输出为anchor的置信度和尺寸修正参数。这些参数的结果通过decode后就是预测框。这些预测框类似于fastRCNN中的预测框的信息。最终结果的输出为每个class的置信度和框的尺寸修正参数。 ROI pooling layer 感兴趣区域池（也称为RoI pooling）是使用卷积神经网络在对象检测任务中广泛使用的操作。例如，在单个图像中检测多个汽车和行人。其目的是对非均匀尺寸的输入执行最大池化以获得固定尺寸的特征图（例如7×7）。 ROI pooling作用有两点：（1）根据输入image，将ROI映射到feature map对应位置，映射是根据image缩小的尺寸来的；（2）将得到的RoI映射在feature map上得到的RoI feature region输出统一大小的特征区域（由于区域提议得到的RoI大小和尺度比例不尽相同，无法输入FC层进行一维化操作） ROI pooling layer的具体操作 1. 根据输入image，将ROI映射到feature map对应位置 2. 将映射后的区域划分为相同大小的sections（sections数量与输出的维度相同） 具体过程：假设我们输入的RoI的尺寸大小为H x W，而我们经过RoI pooling layer操作后需要得到的统一尺寸大小为h x w，则有以下几步过程： 1） 输入的H x W需要被划分成h x w个网格块，然后对每个块进行max pooling操作； 2） 那么重要的是每个块需要被划分为多大的像素呢？采用平均分块得到每个块的像素尺寸大小为，但此时又存在问题，如果除不整呢？解决方法是除不整舍去小数保留整数，而最后一个行块或列块包含剩余没有包括在内的元素值。具体看下面的例子。 3. 对每个sections进行max pooling操作 这样我们就可以从不同大小的方框得到固定大小的feature maps 案例考虑一个88大小的feature map，一个ROI，以及输出大小为22.（1）输入的固定大小的feature map（2）region proposal 投影之后位置（左上角，右下角坐标）：（0，3），（7，8）。（3）将其划分为（22）个sections（因为输出大小为22），我们可以得到：（4）对每个section做max pooling，可以得到：","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[]},{"title":"图像预处理操作","slug":"图像预处理操作","date":"2020-02-25T13:01:52.000Z","updated":"2021-02-19T02:26:06.908Z","comments":true,"path":"2020/02/25/图像预处理操作/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/25/%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/","excerpt":"在将图片输入到模型中进行训练之前，往往需要对图片数据集进行增强处理等一系列操作。本文对这些预处理操作进行一些总结。","text":"在将图片输入到模型中进行训练之前，往往需要对图片数据集进行增强处理等一系列操作。本文对这些预处理操作进行一些总结。 PIL和opencv格式的转换123456789101112131415161718192021# OpenCV转换成PIL.Image格式import cv2 from PIL import Image import numpy img = cv2.imread(\"plane.jpg\") cv2.imshow(\"OpenCV\",img) image = Image.fromarray(cv2.cvtColor(img,cv2.COLOR_BGR2RGB)) image.show() cv2.waitKey() # PIL.Image转换成OpenCV格式import cv2 from PIL import Image import numpy image = Image.open(\"plane.jpg\") image.show() img = cv2.cvtColor(numpy.asarray(image),cv2.COLOR_RGB2BGR) cv2.imshow(\"OpenCV\",img) cv2.waitKey() letter_box的添加为了防止将图片resize到固定大小的时候的失真，往往需要在对图片进行缩放后添加白边。如下图所示。图像添加letter box的代码如下：1234567891011121314151617181920212223242526from PIL import Imagedef letterbox_image(image, size): # image为Image.open读入的图像 # size为目标尺寸 iw, ih = image.size w, h = size scale = min(w/iw, h/ih) nw = int(iw*scale) nh = int(ih*scale) image = image.resize((nw,nh), Image.BICUBIC) # BICUBIC:双三次插值 new_image = Image.new('RGB', size, (128,128,128)) new_image.paste(image, ((w-nw)//2, (h-nh)//2)) return new_imageif __name__ == \"__main__\": import cv2 import numpy as np pil_img = letterbox_image(Image.open(\"1.png\"),(100,200)) cv2_img = cv2.cvtColor(np.array(pil_img),cv2.COLOR_RGB2BGR) cv2.imshow(\"xx\",cv2_img) cv2.waitKey() # import numpy as np # plt.imshow(letterbox_image(Image.open(\"1.png\"),(100,200))) # plt.show()","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"python中的absl库","slug":"python中的absl库","date":"2020-02-25T07:16:27.000Z","updated":"2021-02-19T02:26:06.552Z","comments":true,"path":"2020/02/25/python中的absl库/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/25/python%E4%B8%AD%E7%9A%84absl%E5%BA%93/","excerpt":"absl库用来进行命令行命令解析","text":"absl库用来进行命令行命令解析absl 库全称是 Abseil Python Common Libraries。它原本是个C++库，后来被迁移到了Python上。 它是创建Python应用的代码集合。这些代码从谷歌自己的Python代码基地中搜集而来，已经过全面的测试并广泛用于生产中。 特点： 简单的应用创建分布式的命令行标志系统用户自定义的记录模块，并拥有额外的功能。拥有测试工具下面是它的 hello world 样例。我们输入参数：name 代表名字，num_times 代表语句重复次数。name是必填参数，num_times是可选参数，默认值为1.12345678910111213141516171819from absl import appfrom absl import flags FLAGS = flags.FLAGS # 用法和TensorFlow的FLAGS类似，具有谷歌独特的风格。flags.DEFINE_string(\"name\", None, \"Your name.\")flags.DEFINE_integer(\"num_times\", 1, \"Number of times to print greeting.\") # 指定必须输入的参数flags.mark_flag_as_required(\"name\") def main(argv): del argv # 无用 for i in range(0, FLAGS.num_times): print('Hello, %s!' % FLAGS.name) if __name__ == '__main__': app.run(main) # 和tf.app.run()类似","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"}]},{"title":"Davinci教程","slug":"Davinci教程","date":"2020-02-25T03:22:30.000Z","updated":"2021-02-19T02:26:06.038Z","comments":true,"path":"2020/02/25/Davinci教程/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/25/Davinci%E6%95%99%E7%A8%8B/","excerpt":"在家闲的无聊，随便学学，B站链接B站影视剧风达芬奇教程","text":"在家闲的无聊，随便学学，B站链接B站影视剧风达芬奇教程 软件初始设置偏好设置 -&gt; 用户 -&gt; 项目加载与保存 -&gt; 打开实时保存与项目备份 软件使用素材导入在媒体中将素材分类导入到各个媒体文件夹中。 快编和剪辑剪辑将视频拖拽到浏览窗口后，通过I和O键设置入口和出口，之后将截取的视频拖拽到时间线即可。 添加特效在特效库中将效果拖拽到时间线对应的视频进行添加。添加之后通过效果检查器面板设置参数 快编快编适合粗剪 Fusion不推荐使用其制作特效。特效推荐使用AE等。 剪辑项目设置设置缓存的目录：文件 -&gt; 项目设置 -&gt; 主设置 -&gt; 工作文件夹设置帧率：文件 -&gt; 项目设置 -&gt; 主设置 -&gt; 时间线格式 -&gt; 时间线帧率/播放帧率(25)(因为国内交流电频率50Hz) 资源导入先导入所有素材，然后文件夹分类 视频剪辑设置出入点I和O键拖入时间线时可以在浮动的框口中选择只导入画面或音频创建时间线：建议创建时间线然后再进行拖拽时间线操作： 时间线缩放：alt+鼠标中键 或 ctrl+加号/减号 图标功能：修剪编辑模式：前后素材一起移动动态修剪模式：不常用切刀：快捷键B（command+B）插入片段：在片段之间插入覆盖片段：覆盖重合的部分替换片段：替换对应的片段磁力链接：链接视频和音频锁定：锁定时间线的位置 如果只导入视频，可以按下F来匹配帧，从而可以从素材显示窗口再导入音频。 效果添加在特效库中将效果拖拽到时间线对应的视频进行添加。添加之后通过效果检查器面板设置参数 调整效果检查器面板参数 直接输入 鼠标拖动数字 alt+鼠标拖动（精细操作） 实时面板左下角可以进行裁切或变换等。 涉及到时间的特效 关键帧通过效果检查及面板参数后面的菱形添加关键帧在两个关键帧之间可以进行调整在时间线上点击菱形 批处理ctrl+c复制右键片段粘贴属性不同比例的素材统一，防止出现黑边：项目-&gt;图像缩放调整-&gt;输入缩放调整 插件redgiant红巨星宇宙 代理生成为了使视频流畅播放，就需要对素材进行优化。几种方法： 菜单栏-&gt; 播放 -&gt; 代理模式 -&gt; 选择更低的分辨率 优化媒体文件（将媒体文件优化到一个更优的文件） 选择媒体文件，右键-&gt; 生成优化的媒体文件（编码设置：文件-&gt;项目设置-&gt;主设置-&gt;优化的媒体和渲染缓存，工作文件夹-&gt;…） 复杂操作后仍然会卡顿：播放-&gt;渲染缓存 智能媒体文件夹与双时间线剪辑通常剪辑视频分为Aroll和Broll，Aroll代表内容的核心框架，Broll为帮助描述主内容的画面等。通常流程为Aroll-&gt;Broll-&gt;特效。智能媒体文件夹：通过各种信息将素材文件进行分类。双时间线剪辑：时间线右上角 一个时间线放素材和裁剪 将有用的片段拉到第二个时间线，防止对视频的破坏（编辑-》删除空隙） 快编界面一次性快速浏览大量素材选中素材按下c键可以快速进行自动调色","categories":[{"name":"其他工具","slug":"其他工具","permalink":"https://sjtu-xx.github.io/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"达芬奇","slug":"达芬奇","permalink":"https://sjtu-xx.github.io/tags/%E8%BE%BE%E8%8A%AC%E5%A5%87/"},{"name":"剪辑","slug":"剪辑","permalink":"https://sjtu-xx.github.io/tags/%E5%89%AA%E8%BE%91/"}]},{"title":"生成tensorflow的docset","slug":"生成tensorflow的docset","date":"2020-02-23T13:41:51.000Z","updated":"2021-02-19T02:26:07.165Z","comments":true,"path":"2020/02/23/生成tensorflow的docset/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/23/%E7%94%9F%E6%88%90tensorflow%E7%9A%84docset/","excerpt":"","text":"为dash.app生成tensorflow的docset来查找apigithub；https://github.com/m3hrdadfi/dash-tf-docset","categories":[{"name":"其他工具","slug":"其他工具","permalink":"https://sjtu-xx.github.io/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"几种对抗生成网络","slug":"几种对抗生成网络","date":"2020-02-23T12:54:48.000Z","updated":"2021-02-19T02:26:06.729Z","comments":true,"path":"2020/02/23/几种对抗生成网络/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/23/%E5%87%A0%E7%A7%8D%E5%AF%B9%E6%8A%97%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/","excerpt":"DCGAN深度卷积对抗生成网络","text":"DCGAN深度卷积对抗生成网络 CSDN：https://blog.csdn.net/weixin_44791964/article/details/103743038DCGAN的全称是Deep Convolutional Generative Adversarial Networks ,意即深度卷积对抗生成网络。 它是由Alec Radford在论文Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks中提出的。 实际上它是在GAN的基础上增加深度卷积网络结构。 CGAN待条件约束的GANCSDN：https://blog.csdn.net/weixin_44791964/article/details/103744620 CGAN一种带条件约束的GAN，在生成模型（D）和判别模型（G）的建模中均引入条件变量y（conditional variable y）。 使用额外信息y对模型增加条件，可以指导数据生成过程。这些条件变量y可以基于多种信息，例如类别标签，用于图像修复的部分数据，来自不同模态（modality）的数据。 如果条件变量y是类别标签，可以看做CGAN是把纯无监督的 GAN 变成有监督的模型的一种改进。 这个简单直接的改进被证明非常有效。 简单来讲，普通的GAN输入的是一个N维的正态分布随机数，而CGAN会为这个随机数添上标签，其利用Embedding层将正整数（索引值）转换为固定尺寸的稠密向量，并将这个稠密向量与N维的正态分布随机数相乘，从而获得一个有标签的随机数。此时，模型的LOSS将包括标签的损失和准确率的损失。 ACGANCSDN: https://blog.csdn.net/weixin_44791964/article/details/103746380ACGAN一种带条件约束的DCGAN，在生成模型（D）和判别模型（G）的建模中均引入条件变量y（conditional variable y）。 ACGAN相当于是DCGAN和CGAN的结合，将深度卷积网络和标签带入到GAN当中。 使用额外信息y对模型增加条件，可以指导数据生成过程。这些条件变量y可以基于多种信息，例如类别标签，用于图像修复的部分数据，来自不同模态（modality）的数据。 在存在类别标签的情况下，将深度卷积网络带入到GAN当中，提高图片的生成质量。 这个简单直接的改进被证明非常有效。 简单来讲，普通的GAN输入的是一个N维的正态分布随机数，而ACGAN会为这个随机数添上标签，其利用Embedding层将正整数（索引值）转换为固定尺寸的稠密向量，并将这个稠密向量与N维的正态分布随机数相乘，从而获得一个有标签的随机数。 与此同时，ACGAN将深度卷积网络带入到存在标签的GAN中，可以生成更加高质量的图片 COGANCOGAN是一种耦合生成式对抗网络，其内部具有一定的耦合，可以对同一个输入有不同的输出。 其具体实现方式就是：1、建立两个生成模型，两个判别模型。2、两个生成模型的特征提取部分有一定的重合，在最后生成图片的部分分开，以生成不同类型的图片。3、两个判别模型的特征提取部分有一定的重合，在最后判别真伪的部分分开，以判别不同类型的图片。 LSGANCSDN:https://blog.csdn.net/weixin_44791964/article/details/103758751LSGAN是一种最小二乘GAN。 其主要特点为将loss函数的计算方式由交叉熵更改为均方差。无论是判别模型的训练，还是生成模型的训练，都需要将交叉熵更改为均方差。 CycleGANCSDN:https://blog.csdn.net/weixin_44791964/article/details/103780922CycleGAN是一种完成图像到图像的转换的一种GAN。 图像到图像的转换是一类视觉和图形问题，其目标是获得输入图像和输出图像之间的映射。 但是，对于许多任务，配对的训练数据将不可用。 CycleGAN提出了一种在没有成对例子的情况下学习将图像从源域X转换到目标域Y的方法。 SRGANCSDN:https://blog.csdn.net/weixin_44791964/article/details/103825427 SRGAN出自论文Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Network。其主要的功能就是输入一张低分辨率图片，生成高分辨率图片。文章提到，普通的超分辨率模型训练网络时只用到了均方差作为损失函数，虽然能够获得很高的峰值信噪比，但是恢复出来的图像通常会丢失高频细节。SRGAN利用感知损失(perceptual loss)和对抗损失(adversarial loss)来提升恢复出的图片的真实感。其中感知损失是利用卷积神经网络提取出的特征，通过比较生成图片经过卷积神经网络后的特征和目标图片经过卷积神经网络后的特征的差别，使生成图片和目标图片在语义和风格上更相似对抗损失由GAN提供，根据图像是否可以欺骗过判别网络进行训练。 生成网络此图从左至右来看，我们可以知道：SRGAN的生成网络由三个部分组成。1、低分辨率图像进入后会经过一个卷积+RELU函数2、然后经过B个残差网络结构，每个残差网络内部包含两个卷积+标准化+RELU，还有一个残差边。3、然后进入上采样部分，将长宽进行放大，两次上采样后，变为原来的4倍，实现提高分辨率。 判别网络此图从左至右来看，我们可以知道：SRGAN的判别网络由不断重复的 卷积+LeakyRELU和标准化 组成。 训练思路1、对判别模型进行训练将真实的高分辨率图像和虚假的高分辨率图像传入判别模型中。将真实的高分辨率图像的判别结果与1对比得到loss。将虚假的高分辨率图像的判别结果与0对比得到loss。利用得到的loss进行训练。 2、对生成模型进行训练将低分辨率图像传入生成模型，得到高分辨率图像，利用该高分辨率图像获得判别结果与1进行对比得到loss。将真实的高分辨率图像和虚假的高分辨率图像传入VGG网络，获得两个图像的特征，通过这两个图像的特征进行比较获得loss。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"GAN","slug":"GAN","permalink":"https://sjtu-xx.github.io/tags/GAN/"}]},{"title":"GAN生成式对抗网络","slug":"GAN生成式对抗网络","date":"2020-02-23T12:48:50.000Z","updated":"2021-02-19T02:26:06.125Z","comments":true,"path":"2020/02/23/GAN生成式对抗网络/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/23/GAN%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/","excerpt":"什么是GANCSDN: https://blog.csdn.net/weixin_44791964/article/details/103729797","text":"什么是GANCSDN: https://blog.csdn.net/weixin_44791964/article/details/103729797生成式对抗网络（GAN, Generative Adversarial Networks ）是一种深度学习模型，是近年来复杂分布上无监督学习最具前景的方法之一。模型通过框架中（至少）两个模块：生成模型（Generative Model）和判别模型（Discriminative Model）的互相博弈学习产生相当好的输出。原始 GAN 理论中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。一个优秀的GAN应用需要有良好的训练方法，否则可能由于神经网络模型的自由性而导致输出不理想。 其实简单来讲，一般情况下，GAN就是创建两个神经网络，一个是生成模型，一个是判别模型。 生成模型输入一行正态分布随机数生成相应的输出。判别模型对生成模型的输出进行判别，判断它是不是真的。 生成模型的目的是生成让判别模型无法判断真伪的输出。判别模型的目的是判断出真伪。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"GAN","slug":"GAN","permalink":"https://sjtu-xx.github.io/tags/GAN/"}]},{"title":"Retinanet目标检测算法","slug":"Retinanet目标检测算法","date":"2020-02-23T03:04:16.000Z","updated":"2021-02-19T02:26:06.333Z","comments":true,"path":"2020/02/23/Retinanet目标检测算法/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/23/Retinanet%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/","excerpt":"Retinanet目标检测算法","text":"Retinanet目标检测算法 Retinanet是在何凯明大神提出Focal loss同时提出的一种新的目标检测方案，来验证Focal Loss的有效性。 One-Stage目标检测方法常常使用先验框提高预测性能，一张图像可能生成成千上万的候选框，但是其中只有很少一部分是包含目标的的，有目标的就是正样本，没有目标的就是负样本。这种情况造成了One-Stage目标检测方法的正负样本不平衡，也使得One-Stage目标检测方法的检测效果比不上Two-Stage目标检测方法。 Focal Loss是一种新的用于平衡One-Stage目标检测方法正负样本的Loss方案。 Retinane的结构非常简单，但是其存在非常多的先验框，以输入600x600x3的图片为例，就存在着67995个先验框，这些先验框里面大多包含的是背景，存在非常多的负样本。以Focal Loss训练的Retinanet可以有效的平衡正负样本，实现有效的训练。 ResNet50有两个基本的块，分别名为Conv Block和Identity Block，其中Conv Block输入和输出的维度是不一样的，所以不能连续串联，它的作用是改变网络的维度；Identity Block输入维度和输出维度相同，可以串联，用于加深网络的。Conv Block的结构如下：Identity Block的结构如下：通过图像金字塔我们可以获得五个有效的特征层，分别是P3、P4、P5、P6、P7，为了和普通特征层区分，我们称之为有效特征层，将这五个有效的特征层传输过class+box subnets就可以获得预测结果了。 class subnet采用4次256通道的卷积和1次num_priors x num_classes通道的卷积，num_priors指的是该特征层所拥有的先验框数量，num_classes指的是网络一共对多少类的目标进行检测。 box subnet采用4次256通道的卷积和1次num_priors x 4通道的卷积，num_priors指的是该特征层所拥有的先验框数量，4指的是先验框的调整情况。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"目标检测","slug":"目标检测","permalink":"https://sjtu-xx.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"SSD目标检测","slug":"SSD目标检测","date":"2020-02-22T13:44:03.000Z","updated":"2021-02-19T02:26:06.339Z","comments":true,"path":"2020/02/22/SSD目标检测/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/22/SSD%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/","excerpt":"CSDN：https://blog.csdn.net/weixin_44791964/article/details/104107271 SSD目标检测算法","text":"CSDN：https://blog.csdn.net/weixin_44791964/article/details/104107271 SSD目标检测算法 SSD是一种非常优秀的one-stage目标检测方法，one-stage算法就是目标检测和分类是同时完成的，其主要思路是利用CNN提取特征后，均匀地在图片的不同位置进行密集抽样，抽样时可以采用不同尺度和长宽比，物体分类与预测框的回归同时进行，整个过程只需要一步，所以其优势是速度快。但是均匀的密集采样的一个重要缺点是训练比较困难，这主要是因为正样本与负样本（背景）极其不均衡（参见Focal Loss），导致模型准确度稍低。SSD的英文全名是Single Shot MultiBox Detector，Single shot说明SSD算法属于one-stage方法，MultiBox说明SSD算法基于多框预测。 SSD目标检测原理SSD采用的主干网络是VGG网络，VGG网络相比普通的VGG网络有一定的修改，主要修改的地方就是：1、将VGG16的FC6和FC7层转化为卷积层。2、去掉所有的Dropout层和FC8层；3、新增了Conv6、Conv7、Conv8、Conv9。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[]},{"title":"Focal loss原理与实现","slug":"Focal-loss原理与实现","date":"2020-02-22T06:29:39.000Z","updated":"2021-02-19T02:26:06.118Z","comments":true,"path":"2020/02/22/Focal-loss原理与实现/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/22/Focal-loss%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/","excerpt":"什么是Focal loss","text":"什么是Focal loss Focal loss是何恺明大神提出的一种新的loss计算方案。其具有两个重要的特点。 1、控制正负样本的权重2、控制容易分类和难分类样本的权重 正负样本的概念如下：一张图像可能生成成千上万的候选框，但是其中只有很少一部分是包含目标的的，有目标的就是正样本，没有目标的就是负样本。 容易分类和难分类样本的概念如下：假设存在一个二分类，样本1属于类别1的pt=0.9，样本2属于类别1的pt=0.6，显然前者更可能是类别1，其就是容易分类的样本；后者有可能是类别1，所以其为难分类样本。 如何实现权重控制呢，请往下看： 控制正负样本的权重如下是常用的交叉熵loss，以二分类为例：我们可以利用如下Pt简化交叉熵loss。此时：想要降低负样本的影响，可以在常规的损失函数前增加一个系数αt。与Pt类似，当label=1的时候，αt=α；当label=otherwise的时候，αt=1 - α，a的范围也是0到1。此时我们便可以通过设置α实现控制正负样本对loss的贡献。其中：分解开就是： 控制容易分类和难分类样本的权重按照刚才的思路，一个二分类，样本1属于类别1的pt=0.9，样本2属于类别1的pt=0.6，也就是 是某个类的概率越大，其越容易分类 所以利用1-Pt就可以计算出其属于容易分类或者难分类。具体实现方式如下。其中(1-p_t)^{\\gamma}称为调制系数1、当pt趋于0的时候，调制系数趋于1，对于总的loss的贡献很大。当pt趋于1的时候，调制系数趋于0，也就是对于总的loss的贡献很小。2、当γ=0的时候，focal loss就是传统的交叉熵损失，可以通过调整γ实现调制系数的改变。 两种权重控制方法合并通过如下公式就可以实现控制正负样本的权重和控制容易分类和难分类样本的权重。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"注意力机制概念详解与其在LSTM中的使用","slug":"注意力机制","date":"2020-02-21T15:20:12.000Z","updated":"2021-02-19T02:26:07.158Z","comments":true,"path":"2020/02/21/注意力机制/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/21/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/","excerpt":"csdn: https://blog.csdn.net/weixin_44791964/article/details/104000722 什么是注意力机制","text":"csdn: https://blog.csdn.net/weixin_44791964/article/details/104000722 什么是注意力机制 利用神经网络找到输入进来的特征，哪一部分更有用。 假设我们要翻译一句话：打电脑游戏。也就是play computer game。如果不引入注意力机制，那么我们从Encoder获得语义编码c之后，这个语义编码在Decoder中传递，其内容就和Encoder无关了。 但是事实上我们希望在翻译打电脑游戏中的打的时候，我们更注意打-&gt;play的转换，此时我们希望Decoder更加注意Encoder从打中提取出来的特征。 这就是注意力机制的概念，它的本意是让神经网络模型在做特定的事的时候可以注意到它需要注意的地方。 由于神经网络是一堆数字的传递，每个事物的特征也是由一堆数字组成的，比如打字的特征也是一堆数字，电脑的特征也是一堆数字，游戏的特征也是一堆数字，语义编码c就是这么多特征的组合。 那么如何使得神经网络模型对某个内容进行注意呢？其实就是将改变不同内容的权重，当我们需要神经网络注意到打的时候，我们只需要提高打字的特征的权重就可以了。假设函数 f 可以用于提取特征，函数 g 可以实现解码。那么如果我们要神经网络注意到打，可以通过如下方式进行。 C_{play}=g(0.8∗f(打),0.1∗f(电脑),0.1∗f(游戏))注意力机制的通俗解释在mobelnet中注意力机制的应用如上，将图片通过全局均匀池化层变成一个长条，变成短条，恢复长条，恢复大小。长条变短条再变长条的过程就是重要特征提取的过程。短条中给了重要特征更高的权重。 总的来说类似自编码器，中间的全连接层用来将重要的特征进行提取（重要的特征给高的权重）。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"注意力机制","slug":"注意力机制","permalink":"https://sjtu-xx.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"}]},{"title":"人脸识别(mtcnn+facenet)","slug":"人脸识别-mtcnn-facenet","date":"2020-02-21T10:43:56.000Z","updated":"2021-02-19T02:26:06.725Z","comments":true,"path":"2020/02/21/人脸识别-mtcnn-facenet/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/21/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-mtcnn-facenet/","excerpt":"csdn链接：https://blog.csdn.net/weixin_44791964/article/details/103697409","text":"csdn链接：https://blog.csdn.net/weixin_44791964/article/details/103697409 什么是mtcnn和facenet1、mtcnnMTCNN，英文全称是Multi-task convolutional neural network，中文全称是多任务卷积神经网络，该神经网络将人脸区域检测与人脸关键点检测放在了一起。总体可分为P-Net、R-Net、和O-Net三层网络结构。 2、facenet谷歌人脸检测算法，发表于 CVPR 2015，利用相同人脸在不同角度等姿态的照片下有高内聚性，不同人脸有低耦合性，提出使用 cnn + triplet mining 方法，在 LFW 数据集上准确度达到 99.63%。 通过 CNN 将人脸映射到欧式空间的特征向量上，实质上：不同图片人脸特征的距离较大；通过相同个体的人脸的距离，总是小于不同个体的人脸这一先验知识训练网络。 测试时只需要计算人脸特征EMBEDDING，然后计算距离使用阈值即可判定两张人脸照片是否属于相同的个体。 简单来讲，在使用阶段，facenet即是：1、输入一张人脸图片2、通过深度学习网络提取特征3、L2标准化4、得到128维特征向量。 人脸对齐常见的对齐方法有1、通过双眼坐标进行旋正2、通过矩阵运算求解仿射矩阵进行旋正","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"https://sjtu-xx.github.io/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"}]},{"title":"语义分割","slug":"语义分割","date":"2020-02-20T15:03:20.000Z","updated":"2021-02-19T02:26:07.206Z","comments":true,"path":"2020/02/20/语义分割/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/20/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/","excerpt":"语义分割","text":"语义分割 就是先对图片进行特征提取，然后进行decoder或者说是上采样后对每个像素点进行分类，判断每个像素点属于哪一个类别。 Segnet模型Segnet模型是一个比较基础的语义分割模型，其结构比较简单，在说其结构之前，我们先讲一下convolutional Encoder-Decoder的结构。其主要结构与自编码（Autoencoder）类似，通过编码解码复原图片上每一个点所属的类别。下图主要是说明利用卷积层编码与解码的过程。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"语义分割","slug":"语义分割","permalink":"https://sjtu-xx.github.io/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"}]},{"title":"经典的卷积神经网络","slug":"经典的卷积神经网络","date":"2020-02-20T09:02:56.000Z","updated":"2021-02-19T02:26:07.166Z","comments":true,"path":"2020/02/20/经典的卷积神经网络/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/20/%E7%BB%8F%E5%85%B8%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"csdn链接：https://blog.csdn.net/weixin_44791964/article/details/102824592","text":"csdn链接：https://blog.csdn.net/weixin_44791964/article/details/102824592 经典神经网络的改进点 名称 改进点 VGG16 1、使用非常多的3*3卷积串联，利用小卷积代替大卷积，该操作使得其拥有更少的参数量，同时会比单独一个卷积层拥有更多的非线性变换。2、探索了卷积神经网络的深度与其性能之间的关系，成功构建16层网络（还有VGG19的19层网络）。 ResNet50 1、使用残差网络，其可以解决由于网络深度加深而产生的学习效率变低与准确率无法有效提升的问题。2、采用bottleneck design结构，在3x3网络结构前利用1x1卷积降维，在3x3网络结构后，利用1x1卷积升维，相比直接使用3x3网络卷积效果更好，参数更少。 InceptionV3 1、Inception系列通用的改进点是使用不同大小的卷积核，使得存在不同大小的感受野，最后实现拼接达到不同尺度特征的融合。2、利用1x7的卷积和7x1的卷积代替7x7的卷积，这样可以只使用约（1x7 + 7x1) / (7x7) = 28.6%的计算开销；利用1x3的卷积和3x1的卷积代替3x3的卷积，这样可以只使用约（1x3 + 3x1) / (3x3) = 67%的计算开销。 Xception 1、开始采用残差网络，其可以解决由于网络深度加深而产生的学习效率变低与准确率无法有效提升的问题。2、采用SeparableConv2D层，先进行1x1操作然后再进行滑动3x3操作，中间为了保证数据不被破坏，没有添加relu层。 MobileNet 1、是一种轻量级的深层神经网络，为一定设备设计。 2、采用depthwise separable convolution结构，3x3卷积核厚度只有一层，然后在输入张量上一层一层地滑动，所以一个卷积核就对应了一个输出通道，当卷积完成后，在利用1x1的卷积调整厚度，实现参数减少。 1、VGG16 1、一张原始图片被resize到(224,224,3)。2、conv1两次[3,3]卷积网络，输出的特征层为64，输出为(224,224,64)，再2X2最大池化，输出net为(112,112,64)。3、conv2两次[3,3]卷积网络，输出的特征层为128，输出net为(112,112,128)，再2X2最大池化，输出net为(56,56,128)。4、conv3三次[3,3]卷积网络，输出的特征层为256，输出net为(56,56,256)，再2X2最大池化，输出net为(28,28,256)。5、conv3三次[3,3]卷积网络，输出的特征层为256，输出net为(28,28,512)，再2X2最大池化，输出net为(14,14,512)。6、conv3三次[3,3]卷积网络，输出的特征层为256，输出net为(14,14,512)，再2X2最大池化，输出net为(7,7,512)。7、利用卷积的方式模拟全连接层，效果等同，输出net为(1,1,4096)。共进行两次。8、利用卷积的方式模拟全连接层，效果等同，输出net为(1,1,1000)。最后输出的就是每个类的预测。 具体实现代码可以看我的博文神经网络学习小记录16——VGG16模型的复现及其详解（包含如何预测） 2、ResNet50ResNet50最大的特点是使用了残差网络。残差网络的特点是将靠前若干层的某一层数据输出直接跳过多层引入到后面数据层的输入部分。意味着后面的特征层的内容会有一部分由其前面的某一层线性贡献。其结构如下： ResNet50有两个基本的块，分别名为Conv Block和Identity Block，其中Conv Block输入和输出的维度是不一样的，所以不能连续串联，它的作用是改变网络的维度；Identity Block输入维度和输出维度相同，可以串联，用于加深网络的。Conv Block的结构如下： Identity Block的结构如下： 这两个都是残差网络结构。总的网络结构如下： conv中存在瓶颈结构，(1,1)的卷积降维，（3，3）卷积，（1，1）升维 具体实现代码可以看我的博文神经网络学习小记录20——ResNet50模型的复现详解 3、InceptionV3Inception系列的网络的特点是采用不同大小的卷积核，使得存在不同大小的感受野，最后实现拼接达到不同尺度特征的融合。 对于InceptionV3而言，其网络中存在着如下的结构。 这个结构使用不同大小的卷积核对输入进行卷积（这个结构主要在代码中的block1使用）。 还存在着这样的结构，利用1x7的卷积和7x1的卷积代替7x7的卷积，这样可以只使用约（1x7 + 7x1) / (7x7) = 28.6%的计算开销；利用1x3的卷积和3x1的卷积代替3x3的卷积，这样可以只使用约（1x3 + 3x1) / (3x3) = 67%的计算开销。 下图利用1x7的卷积和7x1的卷积代替7x7的卷积（这个结构主要在代码中的block2使用）。 下图利用1x3的卷积和3x1的卷积代替3x3的卷积（这个结构主要在代码中的block3使用）。 具体实现代码可以看我的博文神经网络学习小记录21——InceptionV3模型的复现详解 4、Xception其可以被叫做极致的Inception。其特点是采用了残差网络和depthwise separable convolution。 depthwise separable convolution就是对于一个卷积点而言：假设有一个3×3大小的卷积层，其输入通道为16、输出通道为32。具体为，32个3×3大小的卷积核会遍历16个通道中的每个数据，最后可得到所需的32个输出通道，所需参数为16×32×3×3=4608个。 应用深度可分离卷积，用16个3×3大小的卷积核分别遍历16通道的数据，得到了16个特征图谱。在融合操作之前，接着用32个1×1大小的卷积核遍历这16个特征图谱，所需参数为16×3×3+16×32×1×1=656个。可以看出来depthwise separable convolution可以减少模型的参数。 通俗地理解就是卷积核厚度只有一层，然后在输入张量上一层一层地滑动，所以一个卷积核就对应了一个输出通道，当卷积完成后，在利用1x1的卷积调整厚度。 不过Xception模型中的depthwise separable convolution和普通的不太一样，普通的depthwise separable convolution是先进行3x3操作再进行1x1操作（就好像mobileNet中的一样），而Xception模型中则是先进行1x1操作然后再进行3x3操作，中间为了保证数据不被破坏，没有添加relu层，而mobileNet添加了relu层。在建立模型的时候，可以使用Keras中的SeparableConv2D层建立相应的功能。 对于Xception模型而言，其一共可以分为3个flow，分别是Entry flow、Middle flow、Exit flow；分为14个block，其中Entry flow中有4个、Middle flow中有8个、Exit flow中有2个。具体结构如下： 其内部主要结构就是残差卷积网络搭配SeparableConv2D层实现一个个block，在Xception模型中，常见的两个block的结构如下。这个主要在Entry flow和Exit flow中： 这个主要在Middle flow中： 具体实现代码可以看我的博文神经网络学习小记录22——Xception模型的复现详解 5、MobileNetMobileNet模型是Google针对手机等嵌入式设备提出的一种轻量级的深层神经网络，其使用的核心思想便是depthwise separable convolution。 对于一个卷积点而言：假设有一个3×3大小的卷积层，其输入通道为16、输出通道为32。具体为，32个3×3大小的卷积核会遍历16个通道中的每个数据，最后可得到所需的32个输出通道，所需参数为16×32×3×3=4608个。 应用深度可分离卷积，用16个3×3大小的卷积核分别遍历16通道的数据，得到了16个特征图谱。在融合操作之前，接着用32个1×1大小的卷积核遍历这16个特征图谱，所需参数为16×3×3+16×32×1×1=656个。可以看出来depthwise separable convolution可以减少模型的参数。 如下这张图就是depthwise separable convolution的结构 在建立模型的时候，可以使用Keras中的DepthwiseConv2D层实现深度可分离卷积，然后再利用1x1卷积调整channels数。 通俗地理解就是3x3的卷积核厚度只有一层，然后在输入张量上一层一层地滑动，每一次卷积完生成一个输出通道，当卷积完成后，在利用1x1的卷积调整厚度。 如下就是MobileNet的结构，其中Conv dw就是分层卷积，在其之后都会接一个1x1的卷积进行通道处理， 具体实现代码可以看我的博文神经网络学习小记录23——MobileNet模型的复现详解","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"卷积神经网络","slug":"卷积神经网络","permalink":"https://sjtu-xx.github.io/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"mtcnn人脸检测","slug":"mtcnn人脸检测","date":"2020-02-20T06:53:50.000Z","updated":"2021-02-19T02:26:06.534Z","comments":true,"path":"2020/02/20/mtcnn人脸检测/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/20/mtcnn%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/","excerpt":"cdsn：https://blog.csdn.net/weixin_44791964/article/details/103530206","text":"cdsn：https://blog.csdn.net/weixin_44791964/article/details/103530206 什么是mtcnnMTCNN，英文全称是Multi-task convolutional neural network，中文全称是多任务卷积神经网络，该神经网络将人脸区域检测与人脸关键点检测放在了一起。总体可分为P-Net、R-Net、和O-Net三层网络结构。 实现流程1.构建图像金字塔首先将图像进行不同尺度的变换，构建图像金字塔，以适应不同大小的人脸的进行检测。构建方式是通过不同的缩放系数factor对图片进行缩放，每次缩小为原来的factor大小。实现示意图如下：当一个图片输入的时候，会缩放为不同大小的图片，但是缩小后的长宽最小不可以小于12 2.PnetPnet的全称为Proposal Network，其基本的构造是一个全卷积网络。对上一步构建完成的图像金字塔，通过一个FCN进行初步特征提取与标定边框。实现图片示意图如下：在完成初步提取后，还需要进行Bounding-Box Regression调整窗口与NMS(非极大抑制)进行大部分窗口的过滤。Pnet有两个输出，classifier用于判断这个网格点上的框的可信度，bbox_regress表示框的位置。bbox_regress并不代表这个框在图片上的真实位置，如果需要将bbox_regress映射到真实图像上，还需要进行一次解码过程。 3.RnetRnet全称为Refine Network，其基本的构造是一个卷积神经网络，相对于第一层的P-Net来说，增加了一个全连接层，因此对于输入数据的筛选会更加严格。在图片经过P-Net后，会留下许多预测窗口，我们将所有的预测窗口送入R-Net，这个网络会滤除大量效果比较差的候选框。实现图片示意图如下： 4.OnetOnet与Rnet工作流程类似。输出框的可信度，调整框的位置大小，五个标记点。全称为Output Network，基本结构是一个较为复杂的卷积神经网络，相对于R-Net来说多了一个卷积层。O-Net的效果与R-Net的区别在于这一层结构会通过更多的监督来识别面部的区域，而且会对人的面部特征点进行回归，最终输出五个人脸面部特征点。实现图片示意图如下： CODE以Rnet为例，其他见cdsn中的github链接 Rnet1234567891011121314151617181920212223242526272829def create_Rnet(weight_path): input = Input(shape=[24, 24, 3]) # 24,24,3 -&gt; 11,11,28 # 卷积层 28通道，卷积核大小（3*3），stride步长为1，padding（valid：无填充；same为0填充）。输出为28通道，22*22 x = Conv2D(28, (3, 3), strides=1, padding='valid', name='conv1')(input) x = PReLU(shared_axes=[1, 2], name='prelu1')(x) # 池化层大小(3*3),步长为2，输出通道数不变，大小变为11*11 x = MaxPool2D(pool_size=3,strides=2, padding='same')(x) # 11,11,28 -&gt; 4,4,48 x = Conv2D(48, (3, 3), strides=1, padding='valid', name='conv2')(x) x = PReLU(shared_axes=[1, 2], name='prelu2')(x) x = MaxPool2D(pool_size=3, strides=2)(x) # 4,4,48 -&gt; 3,3,64 x = Conv2D(64, (2, 2), strides=1, padding='valid', name='conv3')(x) x = PReLU(shared_axes=[1, 2], name='prelu3')(x) # 3,3,64 -&gt; 64,3,3 x = Permute((3, 2, 1))(x) x = Flatten()(x) # 576 -&gt; 128 x = Dense(128, name='conv4')(x) x = PReLU( name='prelu4')(x) # 128 -&gt; 2 128 -&gt; 4 classifier = Dense(2, activation='softmax', name='conv5-1')(x) bbox_regress = Dense(4, name='conv5-2')(x) model = Model([input], [classifier, bbox_regress]) model.load_weights(weight_path, by_name=True) return model","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"mtcnn","slug":"mtcnn","permalink":"https://sjtu-xx.github.io/tags/mtcnn/"}]},{"title":"keras搭建yolo3目标检测平台","slug":"keras搭建yolo3目标检测平台","date":"2020-02-18T13:29:54.000Z","updated":"2021-02-19T02:26:06.488Z","comments":true,"path":"2020/02/18/keras搭建yolo3目标检测平台/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/18/keras%E6%90%AD%E5%BB%BAyolo3%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B9%B3%E5%8F%B0/","excerpt":"github：https://github.com/qqwweee/keras-yolo3csdn: https://blog.csdn.net/weixin_44791964/article/details/103276106 yolo3检测基本原理","text":"github：https://github.com/qqwweee/keras-yolo3csdn: https://blog.csdn.net/weixin_44791964/article/details/103276106 yolo3检测基本原理 现将图片转换为416*416的网格（加灰条防止失真），再将其转换为13*13或其他大小，如果检测大物体，选择13*13,检测小物体选择52*52的网格。每个网格负责一个区域的检测，只要物体的中心点落在这个区域，这个物体就是这个网格点来确定的。 yolo3的网络结构Darknet-53为特征提取网络，后面为利用特征进行目标检测。Darknet-53中的最后三个特征层，对应不同尺度的目标检测。 最后一个特征层 ：5次卷积后3*3卷积,1*1卷积进行通道调整，最后13*13的网络中的输出13*13*75大小，这13*13代表13*13个格点，3为每个点生成3个先验框，25为（4+1+20，4:x_offset,y_offset,h和w，1:置信度，分类结果：20）。 倒数第二个特征层：对13*13进行上采样，结合后进行5次卷积，然后3*3卷积，1*1进行通道调整 Darknet53主干网络残差结构块使得前一个特征层中的其中一部分特征可以不经过卷积直接映射到下一个特征层，利于特征提取。残差结构块：33的卷积将通道数压缩为原来的一半(得x)，之后对x进行11卷积将通道数复原，同时对x进行残差操作，将这两部分结合。 解码过程由第二步我们可以获得三个特征层的预测结果，shape分别为(N,13,13,255)，(N,26,26,255)，(N,52,52,255)的数据，对应每个图分为13x13、26x26、52x52的网格上3个预测框的位置。 但是这个预测结果并不对应着最终的预测框在图片上的位置，还需要解码才可以完成。 此处要讲一下yolo3的预测原理，yolo3的3个特征层分别将整幅图分为13x13、26x26、52x52的网格，每个网络点负责一个区域的检测。 我们知道特征层的预测结果对应着三个预测框的位置，我们先将其reshape一下，其结果为(N,13,13,3,85)，(N,26,26,3,85)，(N,52,52,3,85)。 最后一个维度中的85包含了4+1+80，分别代表x_offset、y_offset、h和w、置信度、分类结果。 yolo3的解码过程就是将每个网格点加上它对应的x_offset和y_offset，加完后的结果就是预测框的中心，然后再利用 先验框和h、w结合 计算出预测框的长和宽。这样就能得到整个预测框的位置了。 YOLOv3相比于之前的yolo1和yolo2，改进较大，主要改进方向有： 1、主干网络修改为darknet53，其重要特点是使用了残差网络Residual，darknet53中的残差卷积就是进行一次3X3、步长为2的卷积，然后保存该卷积layer，再进行一次1X1的卷积和一次3X3的卷积，并把这个结果加上layer作为最后的结果， 残差网络的特点是容易优化，并且能够通过增加相当的深度来提高准确率。其内部的残差块使用了跳跃连接，缓解了在深度神经网络中增加深度带来的梯度消失问题。 2、darknet53的每一个卷积部分使用了特有的DarknetConv2D结构，每一次卷积的时候进行l2正则化，完成卷积后进行BatchNormalization标准化与LeakyReLU。普通的ReLU是将所有的负值都设为零，Leaky ReLU则是给所有负值赋予一个非零斜率。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"keras","slug":"keras","permalink":"https://sjtu-xx.github.io/tags/keras/"},{"name":"yolo3","slug":"yolo3","permalink":"https://sjtu-xx.github.io/tags/yolo3/"}]},{"title":"口罩检测","slug":"口罩检测","date":"2020-02-18T13:25:49.000Z","updated":"2021-02-19T02:26:06.908Z","comments":true,"path":"2020/02/18/口罩检测/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/18/%E5%8F%A3%E7%BD%A9%E6%A3%80%E6%B5%8B/","excerpt":"口罩检测数据集来源：https://www.bilibili.com/video/av88696686?t=115口罩检测模型：https://github.com/zzh8829/yolov3-tf2","text":"口罩检测数据集来源：https://www.bilibili.com/video/av88696686?t=115口罩检测模型：https://github.com/zzh8829/yolov3-tf2模型使用： 数据集更改将所有图片放到一个文件夹，重命名文件，修改xml文件中filename修改./data/voc2012.names中的名称为have_mask和no_mask 模型修改由于磁盘空间有限，在train.py中的modelcheckpoint中添加参数，save_best_only=True 数据集生成分别生成train和val123456789python tools/voc2012.py \\ --data_dir './data/voc2012_raw/VOCdevkit/VOC2012' \\ --split train \\ --output_file ./data/voc2012_train.tfrecordpython tools/voc2012.py \\ --data_dir './data/voc2012_raw/VOCdevkit/VOC2012' \\ --split val \\ --output_file ./data/voc2012_val.tfrecord 模型训练迁移学习1234567891011121314wget https://pjreddie.com/media/files/yolov3.weights -O data/yolov3.weightspython convert.pypython detect.py --image ./data/meme.jpg # Sanity checkpython train.py \\ --dataset ./data/voc2012_train.tfrecord \\ --val_dataset ./data/voc2012_val.tfrecord \\ --classes ./data/voc2012.names \\ --num_classes 2 \\ --mode fit --transfer darknet \\ --batch_size 16 \\ --epochs 10 \\ --weights ./checkpoints/yolov3.tf \\ --weights_num_classes 80 随机初始化12345678python train.py \\ --dataset .&#x2F;data&#x2F;voc2012_train.tfrecord \\ --val_dataset .&#x2F;data&#x2F;voc2012_val.tfrecord \\ --classes .&#x2F;data&#x2F;voc2012.names \\ --num_classes 2 \\ --mode fit --transfer none \\ --batch_size 16 \\ --epochs 10 \\ 可以在迁移学习冻结darknet主题部分之后，不冻结再次训练batch_size要尽量小，不然会爆显存 预测 1python detect.py --classes ./data/voc2012.names --num_classes 2 --weights ./checkpoints/yolov3_train_2.tf --image ./data/street.jpg 实时检测","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"实践案例","slug":"深度学习/实践案例","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"口罩检测","slug":"口罩检测","permalink":"https://sjtu-xx.github.io/tags/%E5%8F%A3%E7%BD%A9%E6%A3%80%E6%B5%8B/"}]},{"title":"Embedding层","slug":"Embedding层","date":"2020-02-17T14:45:55.000Z","updated":"2021-02-19T02:26:06.046Z","comments":true,"path":"2020/02/17/Embedding层/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/17/Embedding%E5%B1%82/","excerpt":"word2vec到item2vec： 链接","text":"word2vec到item2vec： 链接 Embedding层 近年来，从计算机视觉到自然语言处理再到时间序列预测，神经网络、深度学习的应用越来越广泛。在深度学习的应用过程中，Embedding 这样一种将离散变量转变为连续向量的方式为神经网络在各方面的应用带来了极大的扩展。该技术目前主要有两种应用，NLP 中常用的 word embedding 以及用于类别数据的 entity embedding。 此篇文章内容主要源自于 Neural Network Embeddings Explained ，起初未在文章开头标明，谢谢 @Michael Tan 的提醒 。 本篇文章主要介绍以下内容： 什么是 neural network embedding ？ 我们为什么需要使用 neural network embedding？ 以及 embedding 是如何自学习的？ 本文中，将谈到这样一个例子，使用 neural network embedding 来表示所有维基百科上的书籍，可以通过这里访问到原作者的推荐系统项目。 Figure 1: Neural Network Embedding of all books on Wikipedia. Embedding 和 One Hot 编码上面说了，Embedding 是一个将离散变量转为连续向量表示的一个方式。在神经网络中，embedding 是非常有用的，因为它不光可以减少离散变量的空间维数，同时还可以有意义的表示该变量。 我们可以总结一下，embedding 有以下 3 个主要目的： 在 embedding 空间中查找最近邻，这可以很好的用于根据用户的兴趣来进行推荐。 作为监督性学习任务的输入。 用于可视化不同离散变量之间的关系。 这也就意味对于上面我们所说的维基百科书籍表示而言，使用 Neural Network Embedding，我们可以在维基百科上获取到的所有 37,000 本书，对于每一篇，仅仅用一个包含 50 个数字的向量即可表示。此外，因为 embedding 是可学习的，因此在不断的训练过程中，更相似的书籍的表示在 embedding space 中将彼此更接近。 要了解 embedding 的优点，我们可以对应 One-hot 编码来观察。One-hot 编码是一种最普通常见的表示离散数据的表示，首先我们计算出需要表示的离散或类别变量的总个数 N，然后对于每个变量，我们就可以用 N-1 个 0 和单个 1 组成的 vector 来表示每个类别。这样做有两个很明显的缺点： 对于具有非常多类型的类别变量，变换后的向量维数过于巨大，且过于稀疏。 映射之间完全独立，并不能表示出不同类别之间的关系。 123456789# One Hot Encoding Categoricalsbooks &#x3D; [&quot;War and Peace&quot;, &quot;Anna Karenina&quot;, &quot;The Hitchhiker&#39;s Guide to the Galaxy&quot;]books_encoded &#x3D; [[1, 0, 0], [0, 1, 0], [0, 0, 1]]Similarity (dot product) between First and Second &#x3D; 0Similarity (dot product) between Second and Third &#x3D; 0Similarity (dot product) between First and Third &#x3D; 0 因此，考虑到这两个问题，表示类别变量的理想解决方案则是我们是否可以通过较少的维度表示出每个类别，并且还可以一定的表现出不同类别变量之间的关系，这也就是 embedding 出现的目的。 123456789# Idealized Representation of Embeddingbooks &#x3D; [&quot;War and Peace&quot;, &quot;Anna Karenina&quot;, &quot;The Hitchhiker&#39;s Guide to the Galaxy&quot;]books_encoded_ideal &#x3D; [[0.53, 0.85], [0.60, 0.80], [-0.78, -0.62]]Similarity (dot product) between First and Second &#x3D; 0.99Similarity (dot product) between Second and Third &#x3D; -0.94Similarity (dot product) between First and Third &#x3D; -0.97 而为了更好的表示类别实体，我们还可以是用一个 embedding neural network 和 supervised 任务来进行学习训练，以找到最适合的表示以及挖掘其内在联系。 One-hot 编码的最大问题在于其转换不依赖于任何的内在关系，而通过一个监督性学习任务的网络，我们可以通过优化网络的参数和权重来减少 loss 以改善我们的 embedding 表示，loss 越小，则表示最终的向量表示中，越相关的类别，它们的表示越相近。 上面给出维基百科的例子中，可能有这样的一个 supervised 任务，“预测这本书是否是 Leo Tolstoy 写的”，而我们最终产生的 embedding 则会让 Tolstory 写的书之间的表示更接近。因此弄清楚如何创建监督学习任务和产生相关表示是 embedding 表示的关键。 Embedding 可视化Embedding 最酷的一个地方在于它们可以用来可视化出表示的数据的相关性，当然要我们能够观察，需要通过降维技术来达到 2 维或 3 维。最流行的降维技术是：t-Distributed Stochastic Neighbor Embedding (TSNE)。 我们可以定义维基百科上所有书籍为原始 37,000 维，使用 neural network embedding 将它们映射到 50 维，然后使用 TSNE 将它们映射到 2 维，其结果如下： Figure 2: Embedding of all 37,000 books on Wikipedia 这样看好像并不能看出什么，但是如果我们根据不同书籍的特征着色，我们将可以很明显的看出结果。 Figure 3: Embeddings Colored by Genre 我们可以清楚地看到属于同一类型的书籍的分组。虽然它并不完美，但惊奇的是，我们只用 2 个数字就代表维基百科上的所有书籍，而在这些数字中仍能捕捉到不同类型之间的差异。这代表着 embedding 的价值。 静态图的问题在于我们无法真正探索数据并调查变量之间的分组或关系。 为了解决这个问题，TensorFlow开发了 projector，这是一个在线应用程序，可以让我们可视化并与 embedding 交互。 结果如下： Figure 4: Interactive Exploration of Book Embeddings using projector 总结Embedding 的基本内容如前面介绍所示，然而我想说的是它的价值并不仅仅在于 word embedding 或者 entity embedding，这种将类别数据用低维表示且可自学习的思想更存在价值。通过这种方式，我们可以将神经网络，深度学习用于更广泛的领域，Embedding 可以表示更多的东西，而这其中的关键在于要想清楚我们需要解决的问题和应用 Embedding 表示我们得到的是什么。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"长短记忆神经网络","slug":"长短记忆神经网络","date":"2020-02-17T13:47:12.000Z","updated":"2021-02-19T02:26:07.210Z","comments":true,"path":"2020/02/17/长短记忆神经网络/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/17/%E9%95%BF%E7%9F%AD%E8%AE%B0%E5%BF%86%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"理解LSTM：原文链接 中文链接","text":"理解LSTM：原文链接 中文链接 循环神经网络（RNN）循环神经网络通过将信息循环操作，保证信息持续存在。 长依赖存在的问题存在两个问题： 预测”the cloud in the sky”中的sky，只需要短距离的信息。 预测”I grew up in France… I speak fluent French.”中的french就需要长距离的信息。 理论上RNNs是能够处理这种“长依赖”问题的。通过调参来解决这种问题。但是在实践过程中RNNs无法学习到这种特征。Hochreiter (1991) [German] 和Bengio, et al. (1994)深入研究过为什么RNNs没法学习到这种特征。 LSTM网络在标准的RNN中，该重复模块将具有非常简单的结构，例如单个tanh层。标准的RNN网络如下图所示LSTMs也具有这种链式结构，但是它的重复单元不同于标准RNN网络里的单元只有一个网络层，它的内部有四个网络层。LSTMs的结构如下图所示。图中黄色类似于CNN里的激活函数操作，粉色圆圈表示点操作，单箭头表示数据流向，箭头合并表示向量的合并（concat）操作，箭头分叉表示向量的拷贝操作. LSTMs核心思想LSTMs的核心是细胞状态，用贯穿细胞的水平线表示。细胞状态像传送带一样。它贯穿整个细胞却只有很少的分支，这样能保证信息不变的流过整个RNNs。LSTM网络能通过一种被称为门的结构对细胞状态进行删除或者添加信息。门能够有选择性的决定让哪些信息通过。其实门的结构很简单，就是一个sigmoid层和一个点乘操作的组合。 keras将LSTM层的数据整形为(number_of_sequences, number_of_steps,features)。即：（样本个数，时间步，特征个数）对每一个样本，需要有number_of_steps个时间步的样本，每个时间步都要满足特征个数。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"RNN","slug":"RNN","permalink":"https://sjtu-xx.github.io/tags/RNN/"},{"name":"LSTM","slug":"LSTM","permalink":"https://sjtu-xx.github.io/tags/LSTM/"},{"name":"神经网络","slug":"神经网络","permalink":"https://sjtu-xx.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"numpy中的axis和广播","slug":"numpy中的axis和广播","date":"2020-02-17T10:23:26.000Z","updated":"2021-02-19T02:26:06.547Z","comments":true,"path":"2020/02/17/numpy中的axis和广播/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/17/numpy%E4%B8%AD%E7%9A%84axis%E5%92%8C%E5%B9%BF%E6%92%AD/","excerpt":"通俗易懂的解释numpy中的广播","text":"通俗易懂的解释numpy中的广播 原连接： https://blog.csdn.net/xiang_freedom/article/details/77968164 广播是numpy对不同shape的array进行数值计算的方式，符合一定规则的前提下，将较小的array“广播”成更大的、可以计算的array。广播意味着一种向量化操作，从而在类似C语言中产生大量循环，这会导致内存和计算效率的低效。在Python中，广播不会做大量的数据复制并且通常使计算更加高效。 标准的数组计算形式为两个shape形状一样： 12345&gt;&gt;&gt; a &#x3D; np.array([1.0, 2.0, 3.0])&gt;&gt;&gt; b &#x3D; np.array([2.0, 2.0, 2.0])&gt;&gt;&gt; a * barray([ 2., 4., 6.])1234 如果shape不一致，需要满足一定规则，可以使用广播。 广播规则网上很多文章的写法都是： 让所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐 输出数组的shape是输入数组shape的各个轴上的最大值 如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为1时，这个数组能够用来计算，否则出错 当输入数组的某个轴的长度为1时，沿着此轴运算时都用此轴上的第一组值 我看的时候看了很久都没有看懂。其实可以更简单的描述：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足： 当前维度的值相等 当前维度的值有一个是1 若条件不满足，抛出“ValueError: frames are not aligned”异常。输出数组的维度是每一个维度的最大值，广播将值为1的维度进行“复制”、“拉伸”，如图所示 需要注意的是这里的“复制”只是一个抽象概念，Python并不会对数据进行真实复制。 举例： 1234Image (3d array): 256 x 256 x 3Scale (1d array): 3Result (3d array): 256 x 256 x 3123 在第三个维度相等 1234A (4d array): 8 x 1 x 6 x 1B (3d array): 7 x 1 x 5Result (4d array): 8 x 7 x 6 x 5123 在第2、3、4维度满足第2个条件 123A (2d array): 2 x 1B (3d array): 8 x 4 x 312 错误的情况，在第二个维度不满足条件。 参考资料numpy文档 ：https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html图形化描述：http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc Python之NumPy（axis=0 与axis=1）区分2018年06月23日 15:42:06 hlang8160 阅读数 237 转自：http://blog.csdn.net/wangying19911991/article/details/73928172 https://www.zhihu.com/question/58993137https://www.cnblogs.com/rrttp/p/8028421.html python中的axis究竟是如何定义的呢？他们究竟代表是DataFrame的行还是列？考虑以下代码： df = pd.DataFrame([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], \\columns=[“col1”, “col2”, “col3”, “col4”])dfcol1 col2 col3 col40 1 1 1 11 2 2 2 22 3 3 3 3如果我们调用df.mean(axis=1),我们将得到按行计算的均值 df.mean(axis=1)0 11 22 3然而，如果我们调用 df.drop((name, axis=1),我们实际上删掉了一列，而不是一行： df.drop(“col4”, axis=1)col1 col2 col30 1 1 11 2 2 22 3 3 3 Can someone help me understand what is meant by an “axis” in pandas/numpy/scipy?有人能帮我理解一下，在pandas、numpy、scipy三都当中axis参数的真实含义吗？ 投票最高的答案揭示了问题的本质： 其实问题理解axis有问题，df.mean其实是在每一行上取所有列的均值，而不是保留每一列的均值。也许简单的来记就是axis=0代表往跨行（down)，而axis=1代表跨列（across)，作为方法动作的副词（译者注） 换句话说: 使用0值表示沿着每一列或行标签\\索引值向下执行方法使用1值表示沿着每一行或者列标签模向执行对应的方法下图代表在DataFrame当中axis为0和1时分别代表的含义: axis参数作用方向图示 另外，记住，Pandas保持了Numpy对关键字axis的用法，用法在Numpy库的词汇表当中有过解释： 轴用来为超过一维的数组定义的属性，二维数据拥有两个轴：第0轴沿着行的垂直往下，第1轴沿着列的方向水平延伸。 所以问题当中第一个列子 df.mean(axis=1)代表沿着列水平方向计算均值，而第二个列子df.drop(name, axis=1) 代表将name对应的列标签（们）沿着水平的方向依次删掉。","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://sjtu-xx.github.io/tags/numpy/"}]},{"title":"利用python进行数据分析4（pandas数据处理进阶）","slug":"利用python进行数据分析4（pandas数据处理进阶）","date":"2020-02-17T10:19:09.000Z","updated":"2021-02-19T02:26:06.774Z","comments":true,"path":"2020/02/17/利用python进行数据分析4（pandas数据处理进阶）/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/17/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%904%EF%BC%88pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6%EF%BC%89/","excerpt":"七、数据聚合和分组操作","text":"七、数据聚合和分组操作 1.GroupBy机制groupby的结果会自动过滤掉非数值列 12345678910####以自身的列作为键grouped &#x3D; df[&#39;data1&#39;].groupby(df[key1])grouped 是一个GroupBy对象grouped.mean() 返回对应键的均值grouped &#x3D; df[&#39;data1&#39;].groupby([df[&#39;key1&#39;],df[&#39;key2&#39;]]).mean() #多层# 还可以直接使用列名进行分组df[&#39;data1&#39;].groupby(&#39;key1&#39;).mean()df[&#39;data1&#39;].groupby([&#39;key1&#39;,&#39;key2&#39;]).mean() 分组的键还可以是正确长度的任何数组： grouped.size()返回一个包含组大小信息的Series。 （1）遍历各分组1. 2. 3. 4. ​ axis=1 表示将每一列分给不同的组 ​ 默认axis=1表示将每一行分给不同的组 （2）使用字典/Series分组1.使用字典作为索引 2.使用Series作为索引 （3）使用函数分组将行索引作为调用函数的参数，以返回值作为分组依据 df.groupby(len).sum() （4）以索引层级进行分组 2.数据聚合apply方法传入的是整个dataframe，而agg方法传入的是每一列数据 常用的聚合方法 函数名 描述 count 非NA值的数量 sum 非NA值的和 mean 非NA值的均值 median 非NA值的中位数 std，var 无偏的（分母n-1）标准差和方差 min，max 非NA值的最值 prod 非NA值的乘积 first，last 非NA值的第一个，最后一个 Series的方法生来就可以用于聚合 自定义聚合方法： 同时使用多个聚合函数：传入函数名列表 ​ grouped.agg([&#39;sum&#39;,&#39;std&#39;,peak_to_peak]) 使用多个聚合函数时的列名难以辨认：可以通过传入元组列表（name，function） ​ grouped.agg([(&#39;mean&#39;,&#39;foo&#39;)]) 对不同的列使用不同的聚合函数：传入字典列表{列名：函数名} ​ grouped.agg({&#39;tip&#39;:np.max}) ​ grouped.agg({&#39;tip&#39;:[np.max,&#39;sum&#39;]}) 返回不含行索引的聚合数据： ​ df.groupby(&#39;key1&#39;,as_index=False) 也可以将结果进行reset_index()获得，但as_index方法可以避免不必要的计算 3.应用（split-apply-combine）对分组后的df采用apply（）方法，函数必须返回标量值或pandas对象 apply方法可以传入关键字参数： （1）压缩分组键不显示分组的键： df.groupby(&#39;key1&#39;,group_keys=False) （2）分位数与桶分析cut后的对象可直接传入groupby方法。 4.数据透视表与交叉表df.pivot_table(index=[&#39;day&#39;,&#39;smoker&#39;]) 如果只想在tip_pct和size上聚合，并根据time分组。把day放入行，smoker放入列。 df.pivot_table([&#39;tip_pct&#39;,&#39;size&#39;],index=[&#39;time&#39;,&#39;day&#39;],columns=&#39;smoker&#39;) 添加margins=True会添加All行和列表标签，这会返回单层中所有数据的分组统计值。All为均值 可以添加aggfunc参数： 参数： （1）交叉表计算的是分组中的数据出现的次数。 pd.crosstab([df.time,df.dat],tips.smoker,margins=True) 参数依次为：index，columms， 八、时间序列pd.read_csv(filename,parse_dates=True,index_col=0) 1.日期和时间数据的类型及工具常用的python库：time,datetime,calendar (1)字符串与datetime的转化str方法和strftime方法 datetime格式 使用相同的方法可以将str转换为datetime格式 dateutil库能够自动解析日期并转换为datetime格式（日期在月份前可以使用dayfirst=True参数）： pandas中的日期： 2.时间序列基础不同索引的时间序列之间的算术运算在日期上自动对齐 （1）索引、选择、子集索引： 1）基于标签索引 2）使用能解释为日期的字符串 3）使用切片：通过传递年份或年份加月份（可以使用不在索引中的时间戳进行切片） ​ 使用truncate切片： 3.日期范围、频率和移位（1）生成日期范围12345pd.date_range(&#39;2012-04-01&#39;,&#39;2012-06-01&#39;) #默认以天为间隔pd.date_range(start&#x3D;&#39;2012-04-01&#39;,periods&#x3D;20) #生成20个时间pd.date_range(end&#x3D;&#39;2012-04-01&#39;,periods&#x3D;20) #生成20个时间pd.date_range(&#39;2000-01-01&#39;,&#39;2000-12-01&#39;,freq&#x3D;&#39;BM&#39;) #在区间内按照频率生成pd.date_range(&#39;2012-05-06 12:56:31&#39;,periods&#x3D;5,normalize&#x3D;True) #生成的列表中不包含时刻，只有日期 （2）频率和日期offsetpandas.tseries.offsets中有Hour，Minute等对象，大多数情况下不需要主动创建 可以传递的freq参数：‘4h‘，’1h30min‘ offset可以通过加法结合： (3)移位将时间戳对应的数据前移或后移。 指定freq后，将会改变时间戳，而不会改变数据 使用offset： rowback和rollforward： offset与groupby结合 4.时区处理（1）时区的本地化和转换123456789df.index.tz 查看当前的index的时区属性生成时直接设定rng &#x3D; pd.data_range(&#39;2012-01-01 12:01&#39;,period&#x3D;10,tz&#x3D;&#39;UTC&#39;)ts &#x3D; pd.Series(np.random.randn(len(rng)),index&#x3D;rng)将时区转化为本地化时区ts.tz_localize(&#39;UTC&#39;)ts_shanghai &#x3D; ts.tz_localize(&#39;Asia&#x2F;Shanghai&#39;)ts_shanghai.tz_convert(&#39;UTC&#39;) (2)时区感知时间戳对象的操作时间戳对象也可直接进行时区操作 （3）不同时区间的操作两个时区不同的时间序列联合时，结果为UTC时间 5.时间区间和区间算数12345678910111213141516171819202122pandas区间：p &#x3D; pd.Period(2007,freq&#x3D;&#39;A-DEC&#39;)p+2p-5p - pd.Period(2005,freq&#x3D;&#39;A-DEC&#39;) # 2pandas区间序列：pd.period_range(&#39;2000-01-01&#39;,&#39;2000-06-30&#39;,freq&#x3D;&#39;M&#39;)使用数组生成区间序列：pd.PeriodIndex([&#39;200103&#39;,&#39;200104&#39;],freq&#x3D;&#39;Q-DEC&#39;)pd.PeriodIndex(year&#x3D;yearlist,quarter&#x3D;quaterlist,freq&#x3D;&#39;Q-DEC&#39;)区间频率的转换p.asfreq(&#39;M&#39;,how&#x3D;&#39;start&#39;) # 低频率向高频率转换# 高频率向低频率转换时，直接根据自区间所属决定父区间# 时间戳转化为区间pts &#x3D; ts.to_period(&#39;M&#39;) #转换的频率可以不指定# 区间转换为时间戳ts &#x3D; pts.to_timestamp(how&#x3D;&#39;end&#39;)# 从数组生成PeriodIndex 6.重采样从低频率转换到高频率：向上采样 从高频率转换到低频率：向下采样 resample方法的参数： （1）下采样 （2）开高低收ts.resample(&#39;5min&#39;).ohlc() (3)向上采样与差值使用asfreq()在不聚合的情况下转到高频率 df.resample(&#39;D&#39;).asfreq() 差值或向前填充 df.resample(&#39;D&#39;).ffill() (4)使用时间区间进行重采样由于区间涉及时间范围： 在向下采样中，目标频率必须是原频率的子区间 在向上采样中，目标频率必须是原频率的父区间 7.移动窗口函数123456789df.COL1.rolling(250,min_periods&#x3D;10).mean()df.COL1.expanding().mean()df.COL1.ewm(span&#x3D;30).mean() #指数加权函数，给近期的观测值更高的权重,span为跨度二元移动窗口pd.COL2.rolling(125,min_period&#x3D;10).corr(pd.COL1)pd.rolling(125,min_period&#x3D;10).corr(pd.COL1)自定义窗口函数只要输入为一个序列返回一个单值即可 九、高阶Pandas1.分类数据（1）Categorical对象 Series转换为category类型的数据 category.value对象有两个属性：codes和categories。 可以通过python序列直接创建pandas.Categorical对象 通过codes和categories构建 访问category对象的分类方法(通过cat)： 123df1.cat.codesdf1.cat.categoriesdf2.cat.set_categories([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) Categories方法 1pd.Categorical(df['thal']).cat.codes #Categorial对应的index值 2.GroupBy高阶应用（1）分组转换和展开Groupby12345df &#x3D; pd.DataFrame(&#123;&#39;key&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]*4,&#39;value&#39;:np.arange(12)&#125;)gdf &#x3D; df.groupby(&#39;key&#39;).value #返回的是Series对象gdf.mean() # 每一组的平均值gdf.transform(&#39;mean&#39;) #将每一组的平均值赋值给该组每一个元素，然后返回gdf.transform(lambda x:x.mean()) （2）方法链技术方法链可以减少中间变量 两种等价的赋值方式 （3）pipe方法两种等价形式 十、Python建模库将pandas的DataFrame对象转换为numpy数组：df1.value Patsy库 Statsmodels库 scikit-learn库","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://sjtu-xx.github.io/tags/pandas/"},{"name":"数据分析","slug":"数据分析","permalink":"https://sjtu-xx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"利用python进行数据分析3（绘图与可视化）","slug":"利用python进行数据分析3（绘图与可视化）","date":"2020-02-17T10:16:27.000Z","updated":"2021-02-19T02:26:06.766Z","comments":true,"path":"2020/02/17/利用python进行数据分析3（绘图与可视化）/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/17/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%903%EF%BC%88%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%EF%BC%89/","excerpt":"六、绘图与可视化","text":"六、绘图与可视化 1.matplotlib入门（1）图片与子图12plt.plot(np.arange(10))plt.show() plt绘制的图位于Figure对象中 12345fig &#x3D; plt.figure()ax1 &#x3D; fig.add_subplot(2,2,1) 两行两列，第一个位置ax2 &#x3D; fig.add_subplot(2,2,2)ax3 &#x3D; fig.add_subplot(2,2,3)此时调用plt.plot()会在最后一张图进行绘制 fig.add_subplot返回的是Axes Subplot对象 图形类型： hist，scatter 子图： 1234567fig,axes &#x3D; plt.subplots(2,3)axes为Axes Subplot对象列表索引方法：axes[0,1]subplots方法参数：sharex：所有子图使用相同的x刻度subplot_kw：传入add_subplot的关键字参数字典，用于生成子图 调整子图间距plt.subplot_adjust(left=None,bottom=None,right=None,top=None,wspace=None,hspace=None) wspace和hspace分别控制的是图片的宽度和高度百分比，用作子图间距。 颜色，标记和线型1）字符串参数指定： plt.plot(x,y,&#39;g--&#39;)绿色，虚线 plt.plot(x,y,&#39;go--&#39;)绿色，虚线,标记为点 2）参数指定 plt.plot(x,y,color=&#39;g&#39;,linestyle=&#39;--&#39;) plt.plot(x,y,color=&#39;g&#39;,linestyle=&#39;dashed&#39;，marker=&#39;o&#39;) 3）折线图的线性插值 plt.plot(x,y,&#39;k--&#39;,drawstyle=&#39;step-post&#39;) drawstyle默认为线性插值 （2）刻度、标签和图例xlim,xticks,xticklabels 使用方法： 1）不带参数 plt.xlim() 返回当前的x轴绘图范围 2)带参数 plt.xlim([0,10]) 设置范围 这些方法对应子图中的get_xlim()和set_xlim()方法 2.1设置标题、轴标签、刻度和刻度标签12345678910ax.set_title(&#39;Title&#39;)ax.set_xlable(&#39;Stages&#39;)ax.set_xticks([0,200,500,750])ax.set_xticklabels([&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;],rotation&#x3D;30,fontsize&#x3D;&#39;small&#39;)prop&#x3D;&#123; &#39;title&#39;:&quot;Title&quot;, &#39;xlabel&#39;:&quot;Stages&quot;&#125;ax.set(**prop) 2.2 图例要使用图例，在绘制时要穿入 label参数， 不使用图例，绘制时不要穿入label或传入label=&#39;_nolegend_&#39; (3)注释与子图加工文本，箭头：text，arrow，annotate方法 文本： ax.text(x,y,&#39;hello world&#39;,family=&#39;monospace&#39;,fontsize=10) 添加箭头： 1234567891011ax.annotate(label, xy&#x3D;(x, data.asof(x)+75), xytext&#x3D;(x, data.asof(x)+275), arrowprops&#x3D;&#123; facecolor:&#39;black&#39;, headwidth:4, width:2, headlength:4 &#125;, horizontalalignment&#x3D;&#39;left&#39;, verticalalignment&#x3D;&#39;top&#39;) 其他图形： matplotlib.pyplot中提供了常见图形的引用，完整的引用在matplotlib.patches中 使用时，先生成patch对象shp，然后调用ax.add_patch将图形添加到子图中 12rect &#x3D; plt.Rectangle((0.2,0.75),0.4,0.15,color&#x3D;&#39;k&#39;,alpha&#x3D;0.3)ax.add_patches(rect) (4)将图像保存到文件1234567plt.savefig(filename)plt.savefig(filename,dpi&#x3D;400,bbox_inches&#x3D;&#39;tight&#39;) bbox_inches修建图片的空白参数：facecolor,edgecolor. 子图之外背景的颜色；&#39;w&#39;默认format 导出图片的格式bbox_inches. 导出图片中figure所占的百分比 （5）修改配置12345678910plt.rc()rc的第一个参数时想要自定义的组件，如figure，axes，xtick等使用：font_options &#x3D; &#123; &#39;family&#39;:&#39;monospace&#39;, &#39;size&#39;:&#39;small&#39;, &#39;weigth&#39;:bold&#125;plt.rc(&#39;font&#39;,**font_options) 2.使用pandas和seaborn绘图（1）折线图默认情况下pandas对象调用plot函数会绘制折线图 12345678910111213141516171819202122s.plot()df.plot() 等价df.plot.line()Series方法参数：lable:标签ax：绘图所用的matplotlib子图对象；如果没有传值，使用当前活动的matplotlib子图style：&#39;g--&#39;等kind：可以是area,bar,barh,density,hist,kde,line,pielogy:在y轴上对数缩放use_index：使用对象索引刻度标签rot：刻度标签的旋转xticks：用于x轴刻度的值xlim：x轴范围grid：展示轴的网格Dataframe方法参数：subplots：将每一列绘制在单独的子图sharex：共享x轴的参数figsize：title：标题legend：添加子图图例（默认为True）sort_columns:按字母顺序绘制各列，默认情况使用已有的列顺序 （2）柱状图bar(),barh() :垂直/水平柱状图 使用： data.plot.bar(ax=axes[0],color=&#39;k&#39;,alpha=0.7) 堆积柱状图： data.plot.bar(stacked=True) 使用seaborn绘制： 12345import seaborn as snssns.barplot(x&#x3D;&#39;tip_pct&#39;,y&#x3D;&#39;day&#39;,data&#x3D;tips,orient&#x3D;&#39;h&#39;)sns.barplot(x&#x3D;&#39;tip_pct&#39;,y&#x3D;&#39;day&#39;,hue&#x3D;&#39;time&#39;,data&#x3D;tips,orient&#x3D;&#39;h&#39;) hue参数：将数据按照time进行分类样式：sns.set(style&#x3D;&#39;whitegrid&#39;) （4）直方图和密度图直方图：data.plot.hist(bins=50)分成50列 内核密度估计图：data.plot.density() 同时绘制两者：sns.distplot(data,bins=100,color=&#39;k&#39;) (5)散点图和点图12345散点图sns.regplot(&#39;col1&#39;,&#39;col2&#39;,data&#x3D;trans_data)散点图组sns.pairplot(trans_data,kind&#x3D;&#39;scatter&#39;,diag_kind&#x3D;&#39;kde&#39;,plot_kws&#x3D;&#123;&#39;alpha&#39;:0.2&#125;) （6）特征网格和分类数据 sns.factorplot(x=&#39;day&#39;,y=&#39;tip&#39;,row=&#39;time&#39;,col=&#39;smoker&#39;,data=tips,kind=&#39;bar&#39;) 通用的特征网格 sns.FacetGrid","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://sjtu-xx.github.io/tags/pandas/"},{"name":"seaborn","slug":"seaborn","permalink":"https://sjtu-xx.github.io/tags/seaborn/"},{"name":"数据分析","slug":"数据分析","permalink":"https://sjtu-xx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"利用python进行数据分析2（pandas数据处理基础）","slug":"利用python进行数据分析2（pandas数据处理基础）","date":"2020-02-17T10:13:05.000Z","updated":"2021-02-19T02:26:06.765Z","comments":true,"path":"2020/02/17/利用python进行数据分析2（pandas数据处理基础）/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/17/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%902%EF%BC%88pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%89/","excerpt":"pandas中的字符串方法","text":"pandas中的字符串方法df[“col1”].str.startswith() 三、数据载入，存储及文件格式1。文本格式数据的读写方法 函数 描述 read_csv 从文件对象读取分隔好的数据，默认分隔符为逗号 read_table 从文件对象读取分隔好的数据，默认分隔符为制表符（‘\\t’） read_fwf 从特定宽度的文件中读取数据，无分隔符 read_clipboard read_table的剪贴板版本 read_excel 从xls或xlsx中读取数据 read_hdf 读取用pandas存储的HDF5文件 read_json 从json字符串读取表格数据 read_html 从html文件读取表格数据 read_msgpack 读取MessagePack二进制格式的Pandas数据 read_pickle read_sas 读取储存在SAS系统中定制储存格式的SAS数据集 read_sql 将SQL查询结果（使用SQLAlchemy）读取为DataFrame read_stata 读取Stata格式的数据集 read_feather 读取Feather二进制格式 参数： 1234567891011121314151617pd.read_table(tablename,sep&#x3D;&#39;,&#39;)pd.read_csv(csv_file,names&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]，index_col&#x3D;&#39;c&#39;) #names列名，index_col将指定列作为索引列分层索引:pd.read_csv(csv_file,names&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]，index_col&#x3D;[&#39;a&#39;,&#39;b&#39;])可以使用正则表达式pd.read_csv(csv_file,sep&#x3D;&#39;\\s+&#39;) 以多个空格分开跳过行pd.read_csv(csv_file,skiprows&#x3D;[1，2，3])处理缺省值(na_values需要用NA替换的对象)pd.read_csv(file,na_values&#x3D;[&quot;NULL&quot;])指定缺省值标识(将message列中的foo和NA认为是缺省值，赋值np.nan)sentinels &#x3D; &#123;&#39;message&#39;:[&#39;foo&#39;,&#39;NA&#39;]&#125;pd.read_csv(file,na_values&#x3D;sentinels) 参数（P170） 参数 描述 path 文件路径 sep/delimiter 分隔符 header 用作索引的行号，默认为0，如果没有，应为None index_col 应作行索引的列名或列号 names 结果的列名列表，和header=None连用 skiprows 跳过的行数或行号列表 na_values 需要用NA替换的值序列 comment 在行结尾处分隔注释的字符 parse_dates 尝试将数据解析为datetime，默认时False。如果为True，将尝试解析所有的列。也可以指定列名。如果列表的元素是元组或列表，将会组合起来进行解析 keep_date_col 如果连接列到parse_dates，保留被连接的列，默认False converters 包含列名称映射到函数的字典（） dayfirst 解析非明确日期，按照国际标准格式处理 date_parser 用于解析日期的函数 nrows 从文件开头处读入的行数 iterator 返回一个TextParser，用于零散的读文件 chunksize 用于迭代的块大小 skip_footer 忽略文件尾部的行数 verbose 打印各种解释器输出的信息，如缺失值的数量 encoding 文本编码 squeeze 如果解析数据只包含一列，返回一个 Series thousands 千位分隔符 （1）分块读取文件123456pd.options.display.maxrow = 10 显示设置 分块读取 chunk = pd.read_csv(file,chunksize=1000) for item in chunk: pass (2)将数据写入文本格式12345678data.to_csv(file)data.to_csv(file,sep&#x3D;&#39;|&#39;)data.to_csv(sys.stdout,na_rep&#x3D;&#39;NULL&#39;) 缺省值的表示data.to_csv(sys.stdout,index&#x3D;False) 不输出行的标签data.to_csv(sys.stdout,header&#x3D;False) 不输出列的标签data.to_csv(sys.stdout,columns&#x3D;[&#39;a&#39;,&#39;b&#39;]) 写入列的子集Series也有to_csv方法 （3）使用分隔CSV格式python自带了csv库 123456import csvwith open(&#39;file&#39;,&#39;r&#39;) as f: read &#x3D; csv.reader(f) for i in read(): pass逐行读取 reader可选参数 参数 描述 delimiter 分隔符 lineterminator 平台默认的行终止符 quotechar 用在含有特殊字符字段中的引号，默认是“ quoting 引用惯例。csv.QUOTE_ALL：引用所有字段，csv.QUOTE_MINIMAL:只使用特殊字符，。。。 skipinitialsqace 忽略分隔分隔符后的空白，默认False doublequote 如何处理字段内部的引号。 escapechar 默认禁用。 写入 123with open(file,'w') as f: writer = csv.writer(f,dialect = my_dialect) writer.writerow(('a','b','c')) (4) JSON123456import jsonjson.dumps(obj)json.load(pbj)pandas.read_json(&#39;json file path&#39;) 默认每个对象是表里的一行data.to_json(orient&#x3D;&#39;record&#39;) 按照每一行数据一个&#123;&#125;记录 (5) XML和HTML网络抓取html 12table &#x3D; pd.read_html(&#39;filename&#39;) 会搜并尝试解析所有包含在&lt;table&gt;标签中的表格型数据类型。table[0] xml 1234from lxml import objectifyparsed &#x3D; objectify.parse(open(path))root &#x3D; parsed.getroot() 2.二进制格式123pickle仅作为临时储存格式，由于库的更新，pickle化的对象未来可能无法被反序列化pd.read_pickle()pd.to_pickle() (1)使用HDF5格式HDF代表分层数据格式 每个HDF5文件可以储存多个数据集并且支持元数据 HDF5适用于处理不适合在内存中存储的超大型数据 12345store &#x3D; pd.HDFStore(&#39;file&#39;)store[&#39;obj1&#39;] &#x3D; framestore[&#39;obj2&#39;] &#x3D; frame[&#39;a&#39;]store.put(&#39;obj2&#39;,frame,format&#x3D;&#39;table&#39;) 两种格式：table和fixed，TABLe格式支持特殊语法的查询操作store.select(&#39;obj2&#39;,where&#x3D;[&#39;index&gt;&#x3D;10 and index&lt;&#x3D;15&#39;]) 高阶方法 12frame.to_hdf(&#39;file&#39;,&#39;obj3&#39;,format&#x3D;&#39;table&#39;)pd.read_hdf(&#39;mydata.h5&#39;,&#39;obj3&#39;,where&#x3D;[&#39;index&lt;5&#39;]) (2)读取Microsoft Excel文件12345读取(推荐):xlsx &#x3D; pd.ExcelFile(&#39;exp.xlsx&#39;)df &#x3D; pd.read_excel(xlsx,&#39;sheet1&#39;)读取简化df &#x3D; pd.read_excel(&#39;exp.xlsx&#39;,&#39;sheet1&#39;) （3）与Web API交互12request.get()request.post() (4) 与数据库交互123import sqlalchemy as sqladb &#x3D; sqlalchemy.create_engine(&#39;sqlite:&#x2F;&#x2F;mydata.sqlite&#39;)pd.read_sql(&#39;select * from test&#39;,db) 四、数据的清洗与准备1.处理缺失值对于数据值型的数据，pandas使用NaN(Not a number)表示缺失值。我们称NaN为容易检测到的标识值。 方法 方法 描述 dropna 根据每个标签的值是否是缺失值来筛选轴标签，并根据允许丢失的数据量来确定阈值 fillna 用某些值填充缺失的数据或使用差值方法 isnull 返回表明哪些值是缺失值的布尔值 notnull （1）过滤缺失值1234567891011121314from numpy import nan as NA# 删除缺失值# 处理Series对象data &#x3D; pd.Series([1,NA,2,3423,4,NA])data.dropna()data[data.notnull()]#处理dataframe对象df.dropna() #默认删除包含缺失值的行df.dropna(how&#x3D;&#39;all&#39;) #删除所有值均为NA的行df.dropna(axis&#x3D;1，how&#x3D;&#39;all&#39;) #删除所有值均为NA的列df.dropna(thresh&#x3D;2) #保留至少有两个非NA数据的行 （2）补全缺失值123456# 所有的缺失值用相同的值补全df.fillna(0)# 不同列使用不同的值进行补全df.fillna(&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;)修改已经存在的对象df.fillna(0,inplace&#x3D;True) fillna函数参数 参数 描述 value 标量值或字典型对象用于填充缺失值 method 差值方法，如果没有其他参数，默认是ffill axis 需要填充的轴 inplace 修改对象，而不是生成一个视图 limit 用于前向或后向填充时最大的填充范围 2.数据转换（1）删除重复值1234567df.duplicated() 返回布尔值的Series，表示每一行是否存在重复data.drop_duplicates() #删除相同的行data.drop_duplicates([&#39;k1&#39;]) #删除k1列相同的行data.drop_duplicates([&#39;k1&#39;,&#39;k2&#39;],keep&#x3D;&#39;last&#39;) #保留重复的最后一行 （2）使用函数或映射进行数据转换1234lowercased &#x3D; data[&#39;food&#39;].str.lower()lowercased.map(&#123;&#39;meat&#39;:&#39;pig&#39;&#125;)data[food].map(lambda x:meat_to_animal[x]) (3) 替代值123456789替换某些值data.replace(999,np.nan)data.replace([999,1000],np.nan)不同的值用不同的替换data.replace([999,1000],[np.nan,0])data.replace(&#123;999:np.nan,1000:0&#125;)data.str.replace是对字符串按照元素替代的 （4）重命名轴索引12345678map索引并赋值data.index &#x3D; data.index.map(lambda x:x[:4].upper())使用rename函数data.rename(index&#x3D;str.title,columns&#x3D;str.upper)data.rename(index&#x3D;&#123;&#39;ohio&#39;:&#39;OHIO&#39;&#125;)inplace:替换原有数据集 （5）离散化和分箱(分段)将数据分段 123456789101112131415161718192021cut按照数据值进行切分cats &#x3D; pd.cut(ages,bins) ages是想要划分的数据，bins是区间的断点返回一个Categorical对象。cats.codes 返回每个数据属于那个箱的Seriescats.categories 返回每个箱的区间pd.value_count(cats) 返回cats的值改变区间的开闭cats &#x3D; pd.cut(ages,bins，right&#x3D;false) 默认是右封闭自定义箱名cats &#x3D; pd.cut(ages,bins,lables&#x3D;[&#39;Youth&#39;,&quot;YoungAdult&quot;])根据最大值和最小值，创建等长的箱pd.cut(data,4,precision&#x3D;2) 将数据切成4份,每个区间长度相同qcut按照数据分位数进行切分pd.qcut(data,4) 将数据切成4份，每个区间的数据数量相同pd.qcut(data,[0,0.1,0.5,1])labels&#x3D;False可以使得分组名返回数值 (6) 检测和过滤异常值12345输出每列的信息data.describe()找出存在绝对值大于3的行data[(np.abs(data)&gt;3).any(axis&#x3D;1)] (7)置换和随机抽样123456789随机抽样：先生成一个随机序列，然后取样df.take(np.random.permutation(5))df &#x3D; pd.DataFrame(np.arange(20).reshape(5,4))生成一个不含重复值的随机序列df.sample(n&#x3D;3) #随机三个列生成一个含重复值的随机序列(有放回的抽取)df.sample(n&#x3D;10,replace&#x3D;True) （8）计算指标/虚拟变量pd.get_dummies将某一列变量转换为机器学习或统计建模可用的矩阵 给变量添加前缀 将get_dummies和cut等离散化函数连用 3.字符串操作（1）Python中的字符串方法（2）正则表达式（3） pandas中的字符串函数123456pattern &#x3D; re.compile(&#39;\\s+&#39;)data.str.findall(pattern,flags&#x3D;re.IGNORECASE)data.str.match(pattern)返回索引处的元素data.str.get(1)data.str[0] 五、数据规整：连接、联合和重塑1、分层索引多级index 将多层索引重塑 unstack() 恢复 stack() 多层索引对象 （1）重排序和层级排序12df.swaplevel(&#39;key1&#39;,&#39;key2&#39;)df.sort_index(level&#x3D;0) 按照第0级的索引重新排序 （2）按层级进行汇总统计12df.sum(level&#x3D;&#39;key1&#39;)df.sum(level&#x3D;&#39;color&#39;,axis&#x3D;1) (3)使用DataFrame的列进行索引123df.set_index([&#39;c&#39;,&#39;d&#39;])恢复df.reset_index() 2.联合与合并数据集123pd.merge:根据一个或多个键的值进行连接，类似于数据库中的join操作pd.concat:在axis的方向堆叠combine_first:允许将重叠数据拼接，来使用一个对象中的值填充到另一个对象中的缺失值。 （1）数据库风格的DataFrame join操作12345678910111213141516171819pd.merge(df1,df2,on&#x3D;&#39;key&#39;) 内连接pd.merge(df1,df2,left_on&#x3D;&#39;key1&#39;,right_on&#x3D;&#39;key2&#39;) 当inner join的两个df的间不相同时，可以使用这种方法，等效inner join.pd.merge(df1,df2,how&#x3D;&#39;outer&#39;) 外连接pd.merge(df1,df2,on&#x3D;&#39;key&#39;,how&#x3D;&#39;left&#39;) 左连接多个键pd.merge(df1,df2,on&#x3D;[&#39;key1&#39;,&#39;key2&#39;])当两组数据中存在重叠的列名时，需要使用suffixes参数添加后缀pd.merge(df1,df2,on&#x3D;&#39;key1&#39;,suffixes&#x3D;[&#39;_left&#39;,&#39;_right&#39;])每一行数据的来源indicator参数，添加一个列返回数据来源使用行索引进行连接left_index&#x3D;Truepd.merge(df1,df2,left_on&#x3D;&#39;key1&#39;,right_index&#x3D;&#39;True&#39;,how&#x3D;&#39;outer&#39;)简单的写法df1.join([df2,df3],how&#x3D;&#39;outer&#39;) 将直接根据索引进行连接 (2)沿轴向连接12345678pd.concat([s1,s2,s3]) 默认沿着axis&#x3D;0的轴向生效，默认外连接pd.concat([s1,s2],axis&#x3D;1,join&#x3D;&#39;inner&#39;,join_axes&#x3D;[[&#39;a&#39;,&#39;b&#39;,&#39;e&#39;]])连接轴上创建多层索引pd.concat([s1,s2],keys&#x3D;[&#39;one&#39;,&#39;two&#39;]) 每一个连接对象对应一个索引pd.concat(&#123;&#39;one&#39;:s1,&#39;two&#39;:s2&#125;)pd.concat([s1,s2],ignor_index&#x3D;True) 忽略默认的index （3）联合重叠数据使用传入的对象修补缺失值 123df1.combine_first(df2)与下面的等价np.where(np.isnull(df1),df2,df1) 3.重塑和透视stack：“旋转”或将列中的数据透视到行 unstack:将行中的数据透视到列 12df1.unstack(0)df1.unstack(&#39;state&#39;) （1）将long的数据转换为wide的格式123df.pivot(&#39;data&#39;,&#39;item&#39;,&#39;value&#39;) 第一个参数作为行索引，第二个参数为列索引，第三个参数是填充df的值。pivot方法等价于按照set_index方法建立分层索引，然后unstack。 （2）将width的数据转换为long的格式pivot的相反的操作是melt：将多列合并为一列 1234pd.melt(df,[&#39;key&#39;]) [&#39;key&#39;]为分组指标指定列作为值列pd.melt(df,id_vars&#x3D;[&#39;key&#39;],value_vars&#x3D;[&#39;A&#39;,&#39;B&#39;]) pandas1.0.0新特性markdown导出12345678In [1]: df = pd.DataFrame(&#123;\"A\": [1, 2, 3], \"B\": [1, 2, 3]&#125;, index=['a', 'a', 'b'])In [2]: print(df.to_markdown())| | A | B ||:---|----:|----:|| a | 1 | 1 || a | 2 | 2 || b | 3 | 3 | 实验特性NA1234567891011In [3]: s = pd.Series([1, 2, None], dtype=\"Int64\")In [4]: sOut[4]: 0 11 22 &lt;NA&gt;Length: 3, dtype: Int64In [5]: s[2]Out[5]: &lt;NA&gt; string和bool类型之前的时间和字符串都为object类型，现在可以更改为string和bool类型 select_dtypesdf.select_dtypes(&quot;string&quot;)可以选择所有类型为string的列","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://sjtu-xx.github.io/tags/pandas/"},{"name":"数据分析","slug":"数据分析","permalink":"https://sjtu-xx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"数据处理","slug":"数据处理","permalink":"https://sjtu-xx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}]},{"title":"利用python进行数据分析1（numpy和pandas基础）","slug":"利用python进行数据分析1（numpy和pandas基础）","date":"2020-02-17T10:09:40.000Z","updated":"2021-02-19T02:26:06.752Z","comments":true,"path":"2020/02/17/利用python进行数据分析1（numpy和pandas基础）/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/17/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%901%EF%BC%88numpy%E5%92%8Cpandas%E5%9F%BA%E7%A1%80%EF%BC%89/","excerpt":"ipynb案例：推荐使用https://github.com/sjtu-xx/scientific-packages-for-python/ 一、numpy","text":"ipynb案例：推荐使用https://github.com/sjtu-xx/scientific-packages-for-python/ 一、numpy 1.ndarray（1）生成ndarray12345678910111213np.array （将输入转换为ndarray，自动复制）np.asarray (输入转换为ndarray，已经为ndarray不再复制)np.arange np.arange(32).reshape((8,4)np.onesnp.ones_likenp.zerosnp.zeros_likenp.emptynp.empty_likenp.fullnp.full_likenp.eye,np.identity (单位矩阵)np.random.randn(6,3) 生成正态分布的6*3的数组 （2）数据类型和大小1234567891011设定a&#x3D; np.array([1,2,3],dtype&#x3D;np.int32)查看a.dtype更改a.astype()a.shape 数组的尺寸a.ndim 数组的维度&gt; means ‘big-endian’ 删除：np.delete(a,[0,3]) 删除索引处的值 插入：np.append(ndarray, elements, axis)\\np.insert(ndarray, index, elements, axis) （3）数组算数1.相同尺寸的数组操作：对应元素操作 123arr + arrarr - arrarr * arr 2.带有标量计算的操作：将参数传递给每个元素 121/arrarr**2 3.同尺寸数组比较：产生同尺寸布尔数组 1arr2 &gt; arr1 （4）索引和切片索引返回的是对象的视图（自己认为是返回对象的引用） 1234567891011121314151617181920212223242526272829303132333435索引与赋值：arr[5:8] = 12arr[::2] 从0开始，步长为2索引数组的变化会体现在原数组上arr_slice = arr[5:8]arr_slice[1] = 2复制：arr_copy = arr[5:8].copy()二维索引(两种方法等价)：arr[2][1]arr[2,1]arr[:2] 前两行arr[1,:2] 第一行前两列布尔索引data == 1 返回与data同尺寸的布尔数组data[data==1] 类似的有 取反操作： ~(data==1) data!=1 或操作： (data==1)|(data==2)与操作： (data==1)&amp;(data==2)比较： data&lt;0data[name == 'Bob'] 若name是一维数组，且大小与data数组轴索引长度一致，则返回True对应的行神奇索引arr[[4,3,1,2]] 将依次返回对应的行arr[[4,2,3],[1,2,3]] 将返回(4，1)，(2，2)，(3，3)对应的值查找：arr.searchsorted(0.5) 在已经排序的数组中查找0.5 （5）数组的转置和换轴123arr.T 转置arr.transpose(1,0,2) （0，1，2）轴替换为（1，0，2）轴arr.swapaxes(1,2) 交换1，2轴，返回数组的视图，没有对原数组进行复制 2.通用函数：快速的逐元素数组函数（1）一元ufunc abs、fabs计算整数、浮点数或复数的绝对值。对于非复数值，可以使用更快的fabs。 log10，log2，log1p，其底数分别为，10,2；以及log（1+ P) singn 计算个元素正负号，1（正数），0（零），-1（负数） ceil返回大于等于该值的最小整数。 floor 返回小于等于该值的最大整数。 rint四舍五入，保留dtype。 modf将数组的小数和整数部分一两个独立数组的形式返回。 isnan返回布尔型数组，表示哪些值是NaN（非数字）。 isfinite/isinf返回布尔型数组，表示哪些元素是有穷的（非inf，非NaN）或那些是无穷的。 cos,cosh,sin,sinh,tan,tanh普通型和双曲型三角函数。 arccos,arccosh,arcsin,arcsinh,asrtan,arctanh反三角函数。 logical_not计算个元素的not x的真值，相当于-arr。 （2）二元ufunc add 元素对应相加。 subtract 第一个数组元素减去第二个的元素。 multiply 数组元素相乘。 divide,floor_divide 除法，或向下整除（丢弃余数）。 power第一个数组中的元素A，第二个数组中的元素B，返回A的B次方。 maximum,fmax返回两个数组中较大值组成的数组。fmax忽略NaN。 minimum,fmin同上。 mod求模，即求余数。 copysign第二个数组的符号，复制给第一个数组。 greater,greater_equal,less,less_equal,equal,not_euqal元素级比较运算，最终产生布尔型数组，相当于&gt;,&gt;=,&lt;,&lt;=,==,!=。 logical_and,logical_or,logical_xor元素级真值运算，相当于&amp;，|，^。 3.使用数组进行面向数组编程（1）将条件逻辑作为数组操作12np.where(cond,xarr,yarr) 等价于 x if condition else y, cond布尔数组，xarr，yarr同大小数组np.where(a&gt;0,2,-2) 大于0填2，否则-2 （2）数学和统计方法123456789101112均值np.mean(arr)arr.mean()arr.mean(axis=1) 指定轴的操作sum 求和mean 平均std，var 标准差和方差min，max 最值argmin，argmax 最值的位置cumsum 累加和，可以对指定的轴进行累加cumprod 累乘，可以对指定的轴进行累乘 （3）布尔数组的方法1234a = np.array([True,False])a.sum() 计算True的个数a.any() True，any可以接受axis参数a.all() False （4）排序12arr.sort()arr.sort(1) 对维度1的数据进行排序 （5）唯一值与其他集合逻辑123456np.unique(arr) 计算唯一值，并排序intersect1d(x,y) 计算交集并排序union1d(x,y) 计算并集并排序in1d(x,y) 计算在x中元素是否在y中，返回布尔数组setdiff1d(x,y) 计算在x但不在y中的元素setxor1d(x,y) 在x,y但不在交集中的元素 4.使用数组进行文件的输入和输出123np.save('test.npy',arr)np.load('test.npy')np.savez('test.npz',a=arr1,b=arr2) 5. 线性代数1234点乘：np.dot(x,y)x.dot(y)x @ y np.linalg中的函数 函数 描述 diag 将对角元素作为一维数组返回 dot 点乘 trace 对角元素和 det 行列式 eig 特征值和特征向量 inv 逆矩阵 pinv Moore-Penrose伪逆 qr QR分解 svd 计算奇异值分解（SVD） solve 求解Ax=b，其中A是方阵 lstsq 计算Ax=b的最小二乘解 6.伪随机数的生成np.random的数据生成函数公用了一个随机数种子 即，np.random.seed(1234) 可以生成一个自定义种子的随机数生成器，rng = np.random.RandomState(1234) rng.randn(10) np.random下的部分函数 函数 描述 seed 随机数种子 permutation 返回一个序列的随机排列 shuffle 随机排列一个序列 rand 从均匀分布中抽取样本 randint 随机整数 randn 从均值0方差1的正态分布中抽取样本 binomial 从二项分布中抽取样本 normal 从正态分布中抽取样本 beta 从beta分布中抽取样本 chisquare 从卡方分布中抽取样本 gamma 从伽马分布中。。。。 uniform 从（0，1）中抽取样本 二、pandas1.pandas中的数据结构（1）Series1234567891011121314151617181920212223obj = pd.Series([1,2,3,4])obj.values 返回值obj.index 返回索引obj.add(item,fill_value=0)obj = pd.Series([1,2,3,4],index=['a','b','x','e'])obj['a'] 可以使用标签索引obj = pd.Series(&#123;'a':12,'b':1&#125;)字典参数时，obj将按照value从大到小进行排列obj = pd.Series(&#123;'a':12,'b':1&#125;，index=[\"a\",\"b\"])这样可以按照index中的键进行排序Series可以使用numpy中的函数obj.isnull() 返回布尔Seriesobj.notnull()Series对象和其索引都有name属性obj.nameobj.index.name obj.index = ['b','a'] 可以改变元素顺序 （2）DataFrame1234567891011121314151617181920212223242526272829构造：data = &#123;'a':[1,312,3,4],'n':[23,123,4,32]&#125;frame = pd.DataFrame(data)指定列顺序frame = pd.DataFrame(data,columns=['n','a'])指定indexframe = pd.DataFrame(data,columns=['n','a'],index=['asd','asdf','asdfasdf'])frame.head() 前五行frame.tail()返回名为a的列:frame.a frame['a'] 行的选取：frame.loc['asd']返回所有的列名frame.column删除列del frame['a']转置frame.T返回数据frame.values 以二维数组ndarray的方式返回 注意：选取列/行返回的是列的索引。 （3）索引对象12obj.index 索引对象不可变，用户不可修改pd.Index(['a','b']) 创建索引对象 索引对象的方法 方法 描述 append difference 差集 intersection 交集 union 并集 isin 表示每一个值是否在传值容器中的布尔数组 Delete 将位置i处的元素删除 delete insert 在位置i处插入元素 is_monotonic 如果索引递增返回True is_unique 如果索引序列唯一返回True unique 计算索引的唯一值序列 2.基本功能（1）重建索引123456行重建索引obj.reindex(['a','b','x']) 不存在的索引会引入缺省值列重建索引obj.reindex(column=['a','b','c'])查看obj.loc[['a','b','c'],['aw','qwer']] 行，列 （2）轴向上删除数据123data.drop('a')data.drop('a',axis=1)data.drop(['a','b'],axis='column') 注意：凡是会对原数组作出修改并返回一个新数组的，往往都有一个 inplace可选参数。如果手动设定为True（默认为False），那么原数组直接就被替换。也就是说，采用inplace=True之后，原数组名（如2和3情况所示）对应的内存值直接改变； 而采用inplace=False之后，原数组名对应的内存值并不改变，需要将新的结果赋给一个新的数组或者覆盖原数组的内存位置（如1情况所示）。 （3）索引，选择，过滤注意：标签索引包含尾部，整数索引不包含尾部 索引 12345678910Seriesobj = pd.Series([0,1,12,34]，index=['a','b','c'])obj[2:3] 不包含尾部obj['b':'c']包含尾部DataFramedata['a'] 使用单个值或序列索引列data[['a','b']]data[:2] 选择前两行data[data['three']&gt;5]选择three大于5的行 选择 123456789轴标签loc,整数标签ilocdata.loc[['a','b','c'],['as','ear','ear']]支持切片选择单个标签df.at['a','b']df.iat[1,2]get_value,set_value 根据标签设置单个值 （4）算数和数据对齐两个Series或DataFrame运算时，不重叠的部分会产生缺省值NaN r开头的方法有fill_value关键字参数 df1.radd(df2,fill_value=0) （5）DataFrame和Series数据之间的操作默认情况下，DataFrame和Series的数学操作会将Series的索引和DataFrame的列进行匹配并广播到各行。 如果要在列上广播，使用df.sub(series,axis=”index”) （6）函数应用和映射将函数应用到某一行或某一列的数组上。 123456f = lambda x:x.max()-x.min()frame.apply(f) 对每一列调用一次，有axis参数也可以返回序列def f(series): return pd.Series([series.max(),series.min()],index=['max','min']) （7）排序和排名1234obj.sort_index(axis=0,ascending=False) 将对应的数据也进行排序，默认是升序obj.sort_values(by=['a','b'],axis=0) 按照a,b,两列进行排序obj.rank() 返回排名值，对并列的取平均obj.rank(method='first') 返回排名，当时对并列的不取平均 rank的方法 方法 描述 average 默认，平均值 min 最小值 max 最大值 first 按照在数据中出现的次序进行排序 dense 类似于method=‘min’，但组间排名总是加一，而不是一个组中的相等元素的数量。 （8）含有重复标签的轴索引1obj.index.is_unique 判断是否存在重复 3.描述性统计的概述与计算skipna参数默认为True， 描述性统计和汇总统计 方法 描述 count 非NA值的个数 describe 计算Series或DataFrame各列的汇总统计集合 min，max 计算最小值，最大值 argmin，argmax 计算最大值，最小值的索引位置 idxmin，idxmax 计算最大值，最小值的索引 quantile 计算样本从0-1之间的分位数 sum mean median mad 平均值的平均绝对偏差 prod 所有值的积 var 方差 std 标准差 skew 样本偏度值（第三时刻） kurt 样本峰度值（第四时刻） cumsum 累加 cummin，cummax 累计的最小，最大 cumprod 累乘 diff 计算第一个算数差值将数据作某种移动后与原数据的差值 pct_change 计算百分比改变，相比前一项 （1）相关性和协方差123456789df['col1'].corr(df1['col2']) 计算两个Series中重叠的，非NA的，按照索引对齐的值的相关性。df['col1'].cov(df1['col2'])返回所有列之间相互的相关性df1.corr()df1.cov()返回所有列和IBM列的相关性df1.corrwith(df1.IBM) （2）唯一值，计数和成员属性检查1234567Series方法obj.unique() 返回唯一值obj.value_count() 数据计数pd.value_count(obj.values,sort=False)obj.isin(['a','b']) 成员属性检查 4.索引1df.reindex(columns&#x3D;&#39;xx&#39;,level&#x3D;&#39;ess&#39;) 5.map1df[&#39;name&#39;].map(func) 对name列的对象执行func操作","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://sjtu-xx.github.io/tags/numpy/"},{"name":"pandas","slug":"pandas","permalink":"https://sjtu-xx.github.io/tags/pandas/"},{"name":"数据分析","slug":"数据分析","permalink":"https://sjtu-xx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"OpenCV人脸检测","slug":"OpenCV人脸识别","date":"2020-02-16T03:01:36.000Z","updated":"2021-02-19T02:26:06.301Z","comments":true,"path":"2020/02/16/OpenCV人脸识别/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/16/OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/","excerpt":"转载链接","text":"转载链接本教程将介绍如何使用 OpenCV 和 Dlib 在 Python 中创建和运行人脸检测算法。同时还将添加一些功能，以同时检测多个面部的眼睛和嘴巴。本文介绍了人脸检测的最基本实现，包括级联分类器、HOG 窗口和深度学习 CNN。 我们将通过以下方法实现人脸检测： 使用 OpenCV 的 Haar 级联分类器 使用 Dlib 的方向梯度直方图 使用 Dlib 的卷积神经网络 本文代码的 Github 库（以及作者其他博客的代码）链接： https://github.com/maelfabien/Machine_Learning_Tutorials 我们将使用用于计算机视觉的开源库 OpenCV，它用 C/C++编写，有 C++、Python 和 Java 接口。同时支持 Windows、Linux、MacOS、iOS 和 Android 系统。同时我们还需要工具包 Dlib，它是一个包含机器学习算法和创建复杂软件的 C++工具包。 步骤 第一步是安装 OpenCV 和 Dlib。运行以下命令： 12pip install opencv-pythonpip install dlib 文件生成的路径如下（版本不同，路径会稍有差别）： 1&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2 如果在使用 Dlib 时出现问题，请参见文章：https://www.pyimagesearch.com/2018/01/22/install-dlib-easy-complete-guide/ 导入工具包和模型路径 创建一个新的 Jupyter notebook/Python 文件，从以下代码开始： 12345import cv2import matplotlib.pyplot as pltimport dlibfrom imutils import face_utilsfont &#x3D; cv2.FONT_HERSHEY_SIMPLEX 级联分类器 首先研究级联分类器。 理论 级联分类器，即使用类 Haar 特征工作的级联增强分类器，是集成学习的一种特殊情况，称为 boost。它通常依赖于 Adaboost 分类器（以及其他模型，如 Real Adaboost、Gentle Adaboost 或 Logitboost）。 级联分类器在包含检测目标的几百个样本图像以及不包含检测目标的其他图像上进行训练。 我们如何检测图上是否有人脸呢？有一种名为 Viola-Jones 的目标检测框架的算法，包括了实时人脸检测所需的所有步骤： 提取 Haar 特征，特征来自 Haar 小波 创建图像 Adaboost 训练 级联分类器 Haar 特征选择 人脸上最常见的一些共同特征如下： 与脸颊相比，眼部颜色较深 与眼睛相比，鼻梁区域较为明亮 眼睛、嘴巴、鼻子的位置较为固定…… 这些特征称为 Haar 特征。特征提取过程如下所示： Haar 特征 在上图中，第一个特征测量眼部和上脸颊之间的强度差异。特征值计算的方法很简单，对黑色区域中的像素求和再减去白色区域中的像素即可。 然后，将这个矩形作为卷积核作用到整个图像。为了不产生遗漏，我们需要用到每个卷积核的所有的维度和位置。简单的 24 * 24 的图像可能会产生超过 160000 个特征，每个特征由像素值的和/差组成。这样在计算上无法实现实时人脸检测。那么，该如何加快这个过程呢？ 一旦通过矩形框识别到有用区域，则在与之完全不同的区域上就无需再做计算了。这一点可以通过 Adaboost 实现。 使用积分图像原理计算矩形框特征的方法更快。我们将在下一节介绍这一点。 原始论文中提到几种可用于 Haar 特征提取的矩形框： 双矩形特征计算的是两个矩形区域内像素和的差，主要用于检测边缘 (a,b) 三矩形特征计算的是中心矩形和减去两个外部矩形和的差，主要用于检测线 (c,d) 四矩形特征计算的是矩形对角线对之间的差 (e) Haar 矩形 特征提取完成后，使用 Adaboost 分类器将它们应用于训练集，该分类器结合了一组弱分类器来创建准确的集成模型。只需 200 个特征（最初是 16 万个），实现了 95％的准确率。该论文的作者提取了 6000 个特征。 积分图像 以卷积核的形式计算特征需要花费很长时间。出于这个原因，作者 Viola 和 Jones 提出了图像的中间表示：积分图像。积分图像的作用是仅使用四个值简单地计算矩形和。我们来看看它是如何工作的！ 假设我们想要确定一个坐标为 (x,y) 的给定像素的矩形特征。然后，像素的积分图像是给定像素的上方和左侧的像素之和。 其中 ii(x,y) 是积分图像，i(x,y) 是原始图像。 当计算整个积分图像时，有一种只需要遍历一次原始图像的递归方法。实际上，我们可以定义以下一对递归形式： 其中 s(x,y) 是累积行和，而 s(x−1)=0, ii(−1,y)=0。 这是怎么实现的呢？假设我们想要估算区域 D 的像素总和。我们已经定义了 3 个其他区域：A，B 和 C。 点 1 处的积分图像的值是矩形 A 中的像素的总和。 点 2 处的值为 A + B。 点 3 处的值为 A + C。 点 4 处的值是 A + B + C + D。 因此，区域 D 中的像素之和可以简单地计算为： 4+1−(2+3)。 这样我们仅使用 4 个数组值就计算出了矩形 D 的值。 人们应该知道矩形在实际中是非常简单的特征，但对于人脸检测已经足够了。当涉及复杂问题时，可调滤波器往往更灵活多变。 可调滤波器 使用 Adaboost 学习分类函数 给定一组带标签的训练图像（正负样本均有），Adaboost 用于： 提取一小部分特征 训练分类器 由于 16 万个特征中的大多数特征与之极不相关，因此我们设计一个增强模型的弱学习算法，用来提取单个矩形特征，将最好的正负样本区分开。 级联分类器 虽然上述过程非常有效，但仍存在一个重大问题。在图像中，大部分图像为非面部区域。对图像的每个区域给予等同的注意力是没有意义的，因为我们应该主要关注最有可能包含人脸的区域。Viola 和 Jone 使用级联分类器在减少了计算时间的同时，实现了更高的检测率。 关键思想是在识别人脸区域时排除不含人脸的子窗口。由于任务是正确识别人脸，我们希望假阴率最小，即包含人脸却未被识别的子窗口最少。 每个子窗口都使用一系列分类器。这些分类器是简单的决策树： 如果第一个分类器检测为正样本，继续用第二个 如果第二个分类器检测是正样本，继续用第三个 以此类推 虽然有时可能包含人脸的图被认成负样本被子窗口漏检。但初级分类器以较低的计算成本筛除了大多数负样本，下图的分类器可额外消除更多的负样本，但需要更多的计算量。 使用 Adaboost 训练分类器，并调整阈值使错误率降到最低。在训练该模型时，变量如下： 每个阶段分类器数量 每个阶段的特征数量 每个阶段的阈值 幸运的是，在 OpenCV 中，整个模型已经经过预训练，可直接用于人脸检测。 如果想了解有关 Boosting 技术的更多信息，欢迎查看作者关于 Adaboost 的文章： https://maelfabien.github.io/machinelearning/adaboost 输入 下一步是找到预训练的权重。我们将使用默认的预训练模型来检测人脸、眼睛和嘴巴。文件应位于此路径（python 版本不同，路径略有不同）： 1&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data 确定路径后，以此方式声明级联分类器： 123456cascPath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_frontalface_default.xml&quot;eyePath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_eye.xml&quot;smilePath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_smile.xml&quot;faceCascade &#x3D; cv2.CascadeClassifier(cascPath)eyeCascade &#x3D; cv2.CascadeClassifier(eyePath)smileCascade &#x3D; cv2.CascadeClassifier(smilePath) 检测图像中的人脸 在实现实时人脸检测算法之前，让我们先尝试在图像上简单检测一下。从加载测试图像开始: 12345# Load the imagegray &#x3D; cv2.imread(&#39;face_detect_test.jpeg&#39;, 0)plt.figure(figsize&#x3D;(12,8))plt.imshow(gray, cmap&#x3D;&#39;gray&#39;)plt.show() 测试图像 然后开始检测人脸，并将检测到的人脸框起来。 1234567891011# Detect facesfaces &#x3D; faceCascade.detectMultiScale(gray,scaleFactor&#x3D;1.1,minNeighbors&#x3D;5,flags&#x3D;cv2.CASCADE_SCALE_IMAGE)# For each facefor (x, y, w, h) in faces: # Draw rectangle around the face cv2.rectangle(gray, (x, y), (x+w, y+h), (255, 255, 255), 3) 以下是 detectMultiScale 函数常见的参数列表： scaleFactor：确定每个图像缩放比例大小。 minNeighbors：确定每个候选矩形应保留多少个相邻框。 minSize：最小目标的大小。小于该值的目标将被忽略。 maxSize：最大目标的大小。大于该值的目标将被忽略。 最后，显示结果： 123plt.figure(figsize&#x3D;(12,8))plt.imshow(gray, cmap&#x3D;&#39;gray&#39;)plt.show() 在测试图像上成功检测到人脸。现在开始实时检测！ 实时人脸检测 下面继续进行实时人脸检测的 Python 实现。第一步是启动摄像头，并拍摄视频。然后，将图像转换为灰度图。这用于减小输入图像的维数。实际上，我们应用了一个简单的线性变换，而不是每个像素用三个点来描述红、绿、蓝。 这在 OpenCV 中是默认实现的。 12345video_capture &#x3D; cv2.VideoCapture(0)while True: # Capture frame-by-frame ret, frame &#x3D; video_capture.read() gray &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) 现在我们使用上述定义的 faceCascade 变量，它包含一个预训练算法，现在将其用于灰度图。 1234567faces &#x3D; faceCascade.detectMultiScale( gray, scaleFactor&#x3D;1.1, minNeighbors&#x3D;5, minSize&#x3D;(30, 30), flags&#x3D;cv2.CASCADE_SCALE_IMAGE ) 对于检测到的每个人脸，都加上一个矩形框： 12345for (x, y, w, h) in faces: if w &gt; 250 : cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 3) roi_gray &#x3D; gray[y:y+h, x:x+w] roi_color &#x3D; frame[y:y+h, x:x+w] 对于检测到的每张嘴，都加上一个矩形框： 12345678910smile &#x3D; smileCascade.detectMultiScale( roi_gray, scaleFactor&#x3D; 1.16, minNeighbors&#x3D;35, minSize&#x3D;(25, 25), flags&#x3D;cv2.CASCADE_SCALE_IMAGE ) for (sx, sy, sw, sh) in smile: cv2.rectangle(roi_color, (sh, sy), (sx+sw, sy+sh), (255, 0, 0), 2) cv2.putText(frame,&#39;Smile&#39;,(x + sx,y + sy), 1, 1, (0, 255, 0), 1) 对于检测到的每双眼睛，都加上一个矩形框： 1234eyes &#x3D; eyeCascade.detectMultiScale(roi_gray) for (ex,ey,ew,eh) in eyes: cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2) cv2.putText(frame,&#39;Eye&#39;,(x + ex,y + ey), 1, 1, (0, 255, 0), 1) 然后计算人脸总数，显示整体图像： 123cv2.putText(frame,&#39;Number of Faces : &#39; + str(len(faces)),(40, 40), font, 1,(255,0,0),2) # Display the resulting frame cv2.imshow(&#39;Video&#39;, frame) 当按下 q 键时，执行退出选项。 12if cv2.waitKey(1) &amp; 0xFF &#x3D;&#x3D; ord(&#39;q&#39;): break 最后当所有操作完成后，关闭所有窗口。在 Mac 上关闭窗口存在一些问题，可能需要通过活动管理器退出 Python。 12video_capture.release()cv2.destroyAllWindows() 封装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import cv2cascPath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_frontalface_default.xml&quot;eyePath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_eye.xml&quot;smilePath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_smile.xml&quot;faceCascade &#x3D; cv2.CascadeClassifier(cascPath)eyeCascade &#x3D; cv2.CascadeClassifier(eyePath)smileCascade &#x3D; cv2.CascadeClassifier(smilePath)font &#x3D; cv2.FONT_HERSHEY_SIMPLEXvideo_capture &#x3D; cv2.VideoCapture(0)while True: # Capture frame-by-frame ret, frame &#x3D; video_capture.read() gray &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) faces &#x3D; faceCascade.detectMultiScale( gray, scaleFactor&#x3D;1.1, minNeighbors&#x3D;5, minSize&#x3D;(200, 200), flags&#x3D;cv2.CASCADE_SCALE_IMAGE ) # Draw a rectangle around the faces for (x, y, w, h) in faces: cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 3) roi_gray &#x3D; gray[y:y+h, x:x+w] roi_color &#x3D; frame[y:y+h, x:x+w] cv2.putText(frame,&#39;Face&#39;,(x, y), font, 2,(255,0,0),5) smile &#x3D; smileCascade.detectMultiScale( roi_gray, scaleFactor&#x3D; 1.16, minNeighbors&#x3D;35, minSize&#x3D;(25, 25), flags&#x3D;cv2.CASCADE_SCALE_IMAGE ) for (sx, sy, sw, sh) in smile: cv2.rectangle(roi_color, (sh, sy), (sx+sw, sy+sh), (255, 0, 0), 2) cv2.putText(frame,&#39;Smile&#39;,(x + sx,y + sy), 1, 1, (0, 255, 0), 1) eyes &#x3D; eyeCascade.detectMultiScale(roi_gray) for (ex,ey,ew,eh) in eyes: cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2) cv2.putText(frame,&#39;Eye&#39;,(x + ex,y + ey), 1, 1, (0, 255, 0), 1) cv2.putText(frame,&#39;Number of Faces : &#39; + str(len(faces)),(40, 40), font, 1,(255,0,0),2) # Display the resulting frame cv2.imshow(&#39;Video&#39;, frame) if cv2.waitKey(1) &amp; 0xFF &#x3D;&#x3D; ord(&#39;q&#39;): break# When everything is done, release the capturevideo_capture.release()cv2.destroyAllWindows() 结果 我已经制作了人脸检测算法的 YouTube 视频演示： Dlib 的方向梯度直方图（HOG） 第二种常用的人脸检测工具由 Dlib 提供，它使用了方向梯度直方图（HOG）的概念。论文《Histograms of Oriented Gradients for Human Detection》实现这一方案。 理论 HOG 背后的想法是将特征提取到一个向量中，并将其输入到分类算法中，例如支持向量机，它将评估人脸（或实际想识别的任何对象）是否存在于某个区域中。 提取的特征是图像梯度（方向梯度）方向的分布（直方图）。梯度通常在边缘和角落周围较大，并允许我们检测这些区域。 在原始论文中，该算法用于人体检测，检测过程如下： 预处理 首先，输入图像必须尺寸相同（可通过裁剪和缩放）。图像长宽比要求为 1:2，因此输入图像的尺寸可能为 64x128 或 100x200。 计算梯度图像 第一步是通过以下卷积核计算图像的水平梯度和垂直梯度： 计算梯度的卷积核 图像的梯度通常会消除非必要信息。 上面图像的梯度可以通过下面的 python 语句找到： 123456gray &#x3D; cv2.imread(&#39;images&#x2F;face_detect_test.jpeg&#39;, 0)im &#x3D; np.float32(gray) &#x2F; 255.0# Calculate gradient gx &#x3D; cv2.Sobel(im, cv2.CV_32F, 1, 0, ksize&#x3D;1)gy &#x3D; cv2.Sobel(im, cv2.CV_32F, 0, 1, ksize&#x3D;1)mag, angle &#x3D; cv2.cartToPolar(gx, gy, angleInDegrees&#x3D;True) 绘制图片： 123plt.figure(figsize&#x3D;(12,8))plt.imshow(mag)plt.show() 我们之前没有预处理图像。 计算 HOG 首先将图像分成 8x8 个单元来提供紧凑表示，使 HOG 对噪声更鲁棒。然后，计算每个单元的 HOG。 为了估计区域内的梯度方向，我们只需在每个区域内的 64 个梯度方向值（8x8）及其大小（另外 64 个值）之间构建直方图。直方图的类别对应梯度的角度，从 0 到 180°。总共 9 类：0°，20°，40°…… 160°。 上面的代码给了我们 2 个信息： 梯度方向 梯度大小 当我们构建 HOG 时，有 3 种情况： 角度小于 160°，且不介于两类之间。在这种情况下，角度将添加到 HOG 的正确类中。 角度小于 160°，恰好在两类之间。在这种情况下，像素被均分到左右两侧类中。 角度大于 160°。在这种情况下，我们认为像素与 160°和 0°成比例。 每个 8x8 单元的 HOG 如下所示： HOG 模块归一化 最后，可以用 16×16 的模块对图像进行归一化，并使其对光照不变。这可以通过将大小为 8x8 的 HOG 的每个值除以包含它的 16x16 模块的 HOG 的 L2 范数来实现，这个模块实际上是长度为 9*4 = 36 的简单向量。 模块归一化 最后，将所有 36x1 向量连接成一个大向量。OK！现在有了特征向量，我们可以在上面训练一个软 SVM 分类器（C=0.01）。 检测图像上的人脸 实现非常简单： 123456789face_detect &#x3D; dlib.get_frontal_face_detector()rects &#x3D; face_detect(gray, 1)for (i, rect) in enumerate(rects):(x, y, w, h) &#x3D; face_utils.rect_to_bb(rect) cv2.rectangle(gray, (x, y), (x + w, y + h), (255, 255, 255), 3)plt.figure(figsize&#x3D;(12,8))plt.imshow(gray, cmap&#x3D;&#39;gray&#39;)plt.show() 实时人脸检测 如前所述，该算法非常容易实现。我们还实现了一个更轻量的版本，只用来识别人脸。Dlib 让人脸关键点的检测更加容易，但这是另一个话题。 1234567891011121314151617181920212223video_capture &#x3D; cv2.VideoCapture(0)flag &#x3D; 0while True: ret, frame &#x3D; video_capture.read() gray &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) rects &#x3D; face_detect(gray, 1) for (i, rect) in enumerate(rects): (x, y, w, h) &#x3D; face_utils.rect_to_bb(rect) cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2) cv2.imshow(&#39;Video&#39;, frame) if cv2.waitKey(1) &amp; 0xFF &#x3D;&#x3D; ord(&#39;q&#39;): breakvideo_capture.release()cv2.destroyAllWindows() Dlib 中的卷积神经网络 最后一种方法基于卷积神经网络。为了增强结果，它还实现了最大边缘目标检测（MMOD）。 理论 卷积神经网络是主要用于计算机视觉的前馈神经网络。它们提供自动图像预处理以及密集的神经网络部分。CNN 还是用来处理带有网格状拓扑的数据的特殊神经网络。它的架构灵感来自动物视觉皮层。 以前的方法中，很大一部分工作是选择滤波器来创建特征，以便尽从图像中可能多地提取信息。随着深度学习和计算能力的提高，这项工作现在可以实现自动化。CNN 的名称就来自我们用一组滤波器卷积初始图像输入的事实。需要选择的参数仍是需要应用的滤波器数量以及尺寸。滤波器的尺寸称为步幅。一般步幅设置在 2 到 5 之间。 在这种特定情况下，CNN 的输出是二分类，如果有人脸，则取值 1，否则取 0。 检测图像上的人脸 一些元素在实现中会发生变化。 第一步是下载预训练模型：https://github.com/davisking/dlib-models/blob/master/mmod_human_face_detector.dat.bz2 将下载后的权重放到文件夹中，并定义 dnnDaceDetector： 1dnnFaceDetector &#x3D; dlib.cnn_face_detection_model_v1（&quot;mmod_human_face_detector.dat&quot;） 然后，与之前做的相同： 1234567891011rects &#x3D; dnnFaceDetector(gray, 1)for (i, rect) in enumerate(rects): x1 &#x3D; rect.rect.left() y1 &#x3D; rect.rect.top() x2 &#x3D; rect.rect.right() y2 &#x3D; rect.rect.bottom() # Rectangle around the face cv2.rectangle(gray, (x1, y1), (x2, y2), (255, 255, 255), 3)plt.figure(figsize&#x3D;(12,8))plt.imshow(gray, cmap&#x3D;&#39;gray&#39;)plt.show() 实时人脸检测 最后，实现实时 CNN 人脸检测： 1234567891011121314151617181920212223242526272829video_capture &#x3D; cv2.VideoCapture(0)flag &#x3D; 0while True: # Capture frame-by-frame ret, frame &#x3D; video_capture.read() gray &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) rects &#x3D; dnnFaceDetector(gray, 1) for (i, rect) in enumerate(rects): x1 &#x3D; rect.rect.left() y1 &#x3D; rect.rect.top() x2 &#x3D; rect.rect.right() y2 &#x3D; rect.rect.bottom() # Rectangle around the face cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2) # Display the video output cv2.imshow(&#39;Video&#39;, frame) # Quit video by typing Q if cv2.waitKey(1) &amp; 0xFF &#x3D;&#x3D; ord(&#39;q&#39;): breakvideo_capture.release()cv2.destroyAllWindows() 如何选择模型 这是一个很难回答的问题，但我们只讨论两个重要指标： 计算时间 准确率 在速度方面，HOG 是最快的算法，其次是 Haar 级联分类器和 CNN。 但是，Dlib 中的 CNN 是准确率最高的算法。HOG 表现也很好，但在识别较小的人脸时会有一些问题。Haar 级联分类器的整体表现与 HOG 相似。 考虑到实时人脸检测的速度，我在个人项目中使用了 HOG。 希望这个关于 OpenCV 和 Dlib 的人脸检测的快速教程能对你有所帮助。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://sjtu-xx.github.io/tags/OpenCV/"},{"name":"人脸检测","slug":"人脸检测","permalink":"https://sjtu-xx.github.io/tags/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"}]},{"title":"vtk流水线","slug":"vtk可视化管线","date":"2020-02-13T06:39:13.000Z","updated":"2021-02-19T02:26:06.723Z","comments":true,"path":"2020/02/13/vtk可视化管线/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/13/vtk%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%BA%BF/","excerpt":"vtk中的流水线","text":"vtk中的流水线 在VTK中将原始数据转换为我们看到的屏幕上的一幅图像，要经过许多步骤的处理，这些步骤由众多的VTK的对象共同协调完成，就好象生产线上加工零件一样，每位工人都负责一部分的工作，整条生产线就能将原材料制作成产品。因此在VTK中，这种对象之间协调完成工作的过程被称作流水线(Pipeline)。 原始数据被转换为图像要经过两条流水线： 可视化流水线(Visualization Pipeline)：它的工作是将原始数据加工成图形数据。通常我们需要可视化的数据本身并不是图形数据，例如某个零件内部各个部分的温度，或者是流体在各个坐标点上的速度等等。 图形流水线(Graphics Pipeline)：它的工作是将将图形数据加工为我们所看到的图像。可视化流水线所产生的图形数据通常是三维空间的数据，如何在二维的屏幕上显示出来就需要图形流水线的加工了。 映射器(Mapper)则是可视化流水线的终点，图形流水线的起点，它将各种派生类能将众多的数据映射为图形数据以供图形流水线加工。 让我们对照一下前面的的圆锥的例子：ConeSource的对象通过程序内部计算输出一组描述圆锥的数据(PolyData)：然后，PolyData通过PolyDataMapper映射器将数据映射为图形数据。在这个例子中，可视化流水线由ConSource和PolyDataMapper组成。 图形数据依次通过Actor、Renderer最终在RenderWindow中显示出来，这一部分就是图形流水线。 Actor : 表示润色场景中的一个实体。它包括一个图形数据(mapper)，并且具有描述实体的位置、方向、大小的属性。 Renderer : 表示润色的场景。它包括多个需要润色的Actor。在圆锥的例子中，它只包括一个表示圆锥的Actor。 RenderWindow : 表示润色用的图形窗口，它包括一个或者多个Render。在圆锥的例子中，它只包括一个Renderer。 RenderWindowInteractor : 给图形窗口提供一些用户交互功能，例如平移、旋转、放大缩小。这些交互式操作并不改变Actor或者图形数据的属性，只是调整场景中的照相机(Camera)的一些设置而已。","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"vtk","slug":"vtk","permalink":"https://sjtu-xx.github.io/tags/vtk/"}]},{"title":"kaggle笔记-2（常见模型）","slug":"kaggle笔记-2","date":"2020-02-06T07:11:56.000Z","updated":"2021-02-19T02:26:06.488Z","comments":true,"path":"2020/02/06/kaggle笔记-2/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/06/kaggle%E7%AC%94%E8%AE%B0-2/","excerpt":"常见的模型","text":"常见的模型 监督模型线性回归文本分类中线性模型具有很好的准确性。对XOR问题线性模型难以区分对于非线性问题，支持向量机往往结果更好 支持向量机决策树回归和分类树 集成学习方法通过多个模型集成来获得最终结果 随机森林 Adaboost xgboost 无监督模型主成分分析 PCA有线性约束用法:123from sklearn import decompositionpca = decomposition.PCA(n_components=2)pca.fit(data_x) t-SNE没有线性约束123from sklean.manifold import TSNEtsne = TSNE(random_state=20)tsne.fit(data_x) 聚类算法 KMeans簇个数的选择,选择inertia下降慢的簇个数123from sklearn.cluster import KMeanskmeans = KMeans(n_cluster=3).fit(X)inertia = np.sqrt(kmeans.inertia_) Affinity Propagation（近邻传播聚类）不需要设置簇的个数，将每个数据视为一个节点，观察与其他节点的相似性。不断更新吸引度和归属度进行分析。 Spectral Clustering（谱聚类）首先定义相似矩阵（用来确定两个数据之间的距离），该矩阵描述了一个以观测值为顶点，以观测值对间的估计相似度值为边权的完整图。对于上面定义的度量和二维观测，这是非常直观的-如果两个观测之间的边较短，则两个观测是相似的。我们想把图分解成两个子图，这样每个子图中的每个观察都与该子图中的另一个观察相似。 Agglomerative clustering（层次聚类）将每个观测值赋给不同的簇，计算簇之间的距离，不断的合并最近邻的簇 123456789101112131415161718192021from scipy.cluster import hierarchyfrom scipy.spatial.distance import pdistX = np.zeros((150,2))np.random.seed(seed=42)X[:50, 0] = np.random.normal(loc=0.0, scale=.3, size=50)X[:50, 1] = np.random.normal(loc=0.0, scale=.3, size=50)X[50:100, 0] = np.random.normal(loc=2.0, scale=.5, size=50)X[50:100, 1] = np.random.normal(loc=-1.0, scale=.2, size=50)X[100:150, 0] = np.random.normal(loc=-1.0, scale=.2, size=50)X[100:150, 1] = np.random.normal(loc=2.0, scale=.5, size=50)# pdist will calculate the upper triangle of the pairwise distance matrixdistance_mat = pdist(X) # linkage — is an implementation if agglomerative algorithmZ = hierarchy.linkage(distance_mat, 'single')plt.figure(figsize=(10, 5))dn = hierarchy.dendrogram(Z, color_threshold=0.5) 聚类结果的判定 Adjusted Rand Index (ARI) Adjusted Mutual Information (AMI) Homogeneity, completeness, V-measure Silhouette 聚类算法的使用1234567891011121314151617181920212223242526272829303132333435from sklearn import metricsfrom sklearn import datasetsimport pandas as pdfrom sklearn.cluster import KMeans, AgglomerativeClustering, AffinityPropagation, SpectralClusteringdata = datasets.load_digits()X, y = data.data, data.targetalgorithms = []algorithms.append(KMeans(n_clusters=10, random_state=1))algorithms.append(AffinityPropagation())algorithms.append(SpectralClustering(n_clusters=10, random_state=1, affinity='nearest_neighbors'))algorithms.append(AgglomerativeClustering(n_clusters=10))data = []for algo in algorithms: algo.fit(X) data.append((&#123; 'ARI': metrics.adjusted_rand_score(y, algo.labels_), 'AMI': metrics.adjusted_mutual_info_score(y, algo.labels_, average_method='arithmetic'), 'Homogenity': metrics.homogeneity_score(y, algo.labels_), 'Completeness': metrics.completeness_score(y, algo.labels_), 'V-measure': metrics.v_measure_score(y, algo.labels_), 'Silhouette': metrics.silhouette_score(X, algo.labels_)&#125;))results = pd.DataFrame(data=data, columns=['ARI', 'AMI', 'Homogenity', 'Completeness', 'V-measure', 'Silhouette'], index=['K-means', 'Affinity', 'Spectral', 'Agglomerative'])results 图像分类普通卷积模型两个卷积层+一个池化层 图像分割U-NET：用于图像分割的卷积神经网路https://blog.csdn.net/Formlsl/article/details/80373200","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://sjtu-xx.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"kaggle","slug":"kaggle","permalink":"https://sjtu-xx.github.io/tags/kaggle/"},{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"训练深层神经网络","slug":"训练深层神经网络","date":"2020-02-04T15:39:38.000Z","updated":"2021-02-19T02:26:07.205Z","comments":true,"path":"2020/02/04/训练深层神经网络/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/04/%E8%AE%AD%E7%BB%83%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"梯度消失/爆炸问题","text":"梯度消失/爆炸问题 Sigmoid函数，当输入变大（负或正）时，函数饱和在 0 或 1，导数非常接近 0。因此，当反向传播开始时， 它几乎没有梯度通过网络传播回来，而且由于反向传播通过顶层向下传递，所以存在的小梯度不断地被稀释，因此较低层确实没有任何东西可用。Glorot 和 Bengio 在他们的论文中提出了一种显著缓解这个问题的方法。 我们需要信号在两个方向上正确地流动：在进行预测时是正向的，在反向传播梯度时是反向的。 我们不希望信号消失，也不希望它爆炸并饱和。 为了使信号正确流动，作者认为，我们需要每层输出的方差等于其输入的方差。Xavier初始化:默认情况下，dense()函数使用 Xavier 初始化（具有统一的分布）。可以variance_scaling_initializer()函数来将其更改为 He 初始化。 非饱和激活函数ELU &gt; leaky ReLU(及其变体) &gt; ReLU &gt; tanh &gt; sigmoid如果您关心运行时性能，那么您可能喜欢 leaky ReLU超过ELU。 如果你不想调整另一个超参数，你可以使用前面提到的默认的α值（leaky ReLU 为 0.01，ELU 为 1）。 如果您有充足的时间和计算能力，您可以使用交叉验证来评估其他激活函数，特别是如果您的神经网络过拟合，则为RReLU; 如果您拥有庞大的训练数据集，则为 PReLU。 批量标准化batch_norm()标准化：均值为0方差为1 优化器动量优化，Nesterov 加速梯度，AdaGrad，RMSProp，Adam 优化总是应该使用Adam_optimization 正则化避免过拟合数据增强配置 这个默认配置可能需要调整： 如果你找不到一个好的学习率（收敛速度太慢，所以你增加了训练速度，现在收敛速度很快，但是网络的准确性不是最理想的），那么你可以尝试添加一个学习率调整，如指数衰减。 如果你的训练集太小，你可以实现数据增强。 如果你需要一个稀疏的模型，你可以添加 l1 正则化混合（并可以选择在训练后将微小的权重归零）。 如果您需要更稀疏的模型，您可以尝试使用 FTRL 而不是 Adam 优化以及 l1 正则化。 如果在运行时需要快速模型，则可能需要删除批量标准化，并可能用 leakyReLU 替换 ELU 激活函数。 有一个稀疏的模型也将有所帮助。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"深度学习中的激活函数","slug":"深度学习中的激活函数","date":"2020-02-04T15:25:58.000Z","updated":"2021-02-19T02:26:07.164Z","comments":true,"path":"2020/02/04/深度学习中的激活函数/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/","excerpt":"","text":"常见的激活函数 激活函数对于提高模型鲁棒性，非线性表达能力，缓解梯度消失问题，将特征图映射到新的特征空间从何更有利于训练，加速模型收敛等问题都有很好的帮助 激活函数，一般情况下。我们会放在pooling 之后，但有时候pooling 以后会有batch normalization，激活函数又会放在batch normalization 以后","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"激活函数","slug":"激活函数","permalink":"https://sjtu-xx.github.io/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"}]},{"title":"深度学习中的优化方法","slug":"深度学习中的优化方法","date":"2020-02-04T15:23:10.000Z","updated":"2021-02-19T02:26:07.163Z","comments":true,"path":"2020/02/04/深度学习中的优化方法/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/","excerpt":"","text":"梯度下降优化方法","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"优化","slug":"优化","permalink":"https://sjtu-xx.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"深度学习中的损失函数","slug":"深度学习中的损失函数","date":"2020-02-04T15:06:37.000Z","updated":"2021-02-19T02:26:07.163Z","comments":true,"path":"2020/02/04/深度学习中的损失函数/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/","excerpt":"","text":"损失函数汇总：csdn博客","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"损失函数","slug":"损失函数","permalink":"https://sjtu-xx.github.io/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"}]},{"title":"Jupyter服务器搭建（windows）","slug":"Jupyter服务器搭建（windows）","date":"2020-02-04T07:29:04.000Z","updated":"2021-02-19T02:26:06.266Z","comments":true,"path":"2020/02/04/Jupyter服务器搭建（windows）/","link":"","permalink":"https://sjtu-xx.github.io/2020/02/04/Jupyter%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88windows%EF%BC%89/","excerpt":"创建配置文件：jupyter-notebook --generate-config","text":"创建配置文件：jupyter-notebook --generate-config 配置文件位于/User/当前用户/.jupyter/*.py 修改登陆访问密码jupyter-notebook password 修改远程访问配置修改可访问ip：在配置文件中添加c.NotebookApp.ip = &#39;*&#39;修改工作目录：在配置文件中添加c.NotebookApp.notebook_dir = &#39;workdir&#39; 在其他电脑上通过访问ip:port进行连接","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"},{"name":"jupyter","slug":"jupyter","permalink":"https://sjtu-xx.github.io/tags/jupyter/"}]},{"title":"kaggle笔记-1(数据处理)","slug":"kaggle笔记-1","date":"2020-01-30T02:37:45.000Z","updated":"2021-02-19T02:26:06.487Z","comments":true,"path":"2020/01/30/kaggle笔记-1/","link":"","permalink":"https://sjtu-xx.github.io/2020/01/30/kaggle%E7%AC%94%E8%AE%B0-1/","excerpt":"分类的分析","text":"分类的分析 获得数据 分析数据 类别数据 等级数据 分类数据 连续数据 字母/数字/混合数据 通过透视表pivot table分析数据 通过图表可视化分析数据 分析等级数据 分析普通分类数据 分析数据之间的关系 相关性 data.corr().nlargest(10,&quot;result&quot;)[&quot;result] 处理数据 选择特征 缺失数据少 具有代表性 处理缺失数据 随机数 使用其他相关的参数进行估计（均值、中位数等） 处理离群值 根据实际情况添加特征 删除特征 添加新特征 模型选择 监督学习 分类问题（逻辑回归，KNN，决策树，SVM，朴素贝叶斯，随机森林，感知机，人工神经网络，RVE(关联向量机)） 模型训练 模型结果分析 常用技术特征提取和分析https://www.kaggle.com/kashnitsky/topic-6-feature-engineering-and-feature-selection/notebook 文本from sklearn.feature_extraction.text import CountVectorizer 图像12345from PIL import Imagefrom io import BytesIOimport requestsresponse = requests.get(url)img = Image.open(BytesIO(response.content)) 地理位置数据 时间和日期 时间序列 特征转换 正则化和改变分布from sklearn.preprocessing import StandardScaler 规范化from sklearn.preprocessing import MinMaxScaler 将数据重新分布在min和max之间from scipy.stats import lognorm; data = lognorm(s=1).rvs(1000) 将对数正态分布转换为正态分布 特征选择 统计方法方差小的认为数据的变化小12from sklearn.feature_selection import VarianceThresholdVarianceThreshold(.7).fit_transform(x_data_generated) 其他统计学方法 通过模型选择 GridSearch xgboost Xgboost是Boosting算法的其中一种，Boosting算法的思想是将许多弱分类器集成在一起，形成一个强分类器。因为Xgboost是一种提升树模型，所以它是将许多树模型集成在一起，形成一个很强的分类器。而所用到的树模型则是CART回归树模型。 Xgboost是在GBDT的基础上进行改进，使之更强大，适用于更大范围。 Xgboost一般和sklearn一起使用，但是由于sklearn中没有集成Xgboost，所以才需要单独下载安装。 xgboost教程分类问题和回归问题 https://zhuanlan.zhihu.com/p/31182879 库pandas 选择特定dtype对应的列[x if data[c].dtype == np.dtype(&quot;O&quot;) else y for c in data]categorical_features = df.select_dtypes(include=&quot;object&quot;)numerical_features = df.select_dtypes(exclude=&quot;object&quot;) seaborn 分析相关性sns.heatmap(titanic.corr()) heatmap参数 cmap：matplotlib 颜色条名称或者对象，或者是颜色列表，可选参数。 center：浮点数，可选参数。 annot:布尔值或者矩形数据，可选参数。(如果为True，则在每个热力图单元格中写入数据值。) fmt：字符串，可选参数。 annot_kws：字典或者键值对，可选参数。 linewidths：浮点数，可选参数。 linecolor：颜色，可选参数 square：布尔值，可选参数。(如果为True，则将坐标轴方向设置为“equal”，以使每个单元格为方形。) xticklabels, yticklabels：“auto”，布尔值，类列表值，或者整形数值，可选参数。 mask：布尔数组或者DataFrame数据，可选参数。 检查正态和线性:```python histogram and normal probability plotsns.distplot(df_train[‘GrLivArea’], fit=norm);fig = plt.figure()res = stats.probplot(df_train[‘GrLivArea’], plot=plt) 12345678## sklearn1. 预处理 - 将字符串类别转换为数字 &#96;&#96;&#96; python from sklearn.preprocessing import LabelEncoder la &#x3D; LabelEncoder() result &#x3D; la.fit_transform(data) 自定义转换器 FeatureUnion将不同的转换器应用于整个输入数据，然后通过将它们合并来组合结果。另一方面，ColumnTransformer将不同的转换器应用于整个输入数据的不同子集，并再次将结果连接起来(比如说对每一列的数据进行处理)。 123456789101112131415161718192021222324252627282930313233343536373839404142 from sklearn.base import BaseEstimator, TransformerMixin class TitleSelector(BaseEstimator, TransformerMixin): def __init__( self): self.dict_title = &#123; \"Capt\": 0, \"Col\": 0, \"Major\": 0, \"Jonkheer\": 1, \"Don\": 1, \"Sir\" : 1, \"Dr\": 0, \"Rev\": 0, \"the Countess\":1, \"Dona\": 1, \"Mme\": 2, \"Mlle\": 3, \"Ms\": 2, \"Mr\" : 4, \"Mrs\" : 2, \"Miss\" : 3, \"Master\" : 5, \"Lady\" : 1 &#125; def fit(self, X, y=None): return self def transform( self, X, y=None): for i, name in enumerate(X[\"Name\"]): for title in self.dict_title.keys(): if title in name: X[\"Name\"][i] = self.dict_title[title] break assert X[\"Name\"][i] in self.dict_title.values() return X name_transformer = Pipeline(steps=[ ('name', TitleSelector()), ('onehot', OneHotEncoder(handle_unknown='ignore'))]) 使用ColumnTransformer 12345678910111213num_cols = [\"Age\", \"Fare\", ]cat_cols = [\"Pclass\", \"Sex\", \"SibSp\", \"Parch\", \"Ticket\", \"Cabin\", \"Embarked\"]cols = num_cols + cat_cols + [\"Name\"]preprocessor = ColumnTransformer(transformers=[ ('num', numerical_transformer, num_cols), ('name', name_transformer, [\"Name\"]), ('cat', categorical_transformer, cat_cols),])X_train = preprocessor.fit_transform(df_train[cols])y_train = df_train[\"Survived\"].values 标准化、正则化123456789# 标准化：均值为0，方差为1from sklearn.preprocessing import scale,StandardScalerscaler = preprocessing.StandardScaler().fit(X)scaler = preprocessing.StandardScaler().fit_transform(X)# 限制范围from sklearn.preprocessing import MinMaxScalerpreprocessing.MinMaxScaler().fit_transform(X)# 正则化:范数为1preprocessing.normalize(X, norm='l2') 模型训练 pipeline 超参数搜索12345678910111213141516171819202122 from sklearn.pipeline import Pipeline from sklearn.model_selection import GridSearchCV from sklearn.tree import DecisionTreeClassifier clf = Pipeline([(\"cls\",AdaBoostClassifier(DecisionTreeClassifier(),algorithm=\"SAMME\",n_estimators=600, learning_rate=0.7))]) params = [&#123;\"cls__learning_rate\":np.linspace(0.1,1,10)&#125;] grid_search = GridSearchCV(clf,params,cv=3) grid_search.fit(X_train,Y_train) grid_search.best_score_ ``` 3. 模型结果 ```python model.predict(x_test) model.score(X_train,y_train) ``` 4. 结果分析 ```python from sklearn.model_selection import learning_curve N_train, val_train, val_test = learning_curve(pipeline, X, y, train_sizes=train_sizes, cv=5, scoring='roc_auc') tensorflow 层 Dense：全连接层 Dropout：dropout层 BatchNormalization：批标准化层 conv2D：卷积层 Embedding：类似onehot编码处理，但是会避免稀疏性 模型 12345678910111213from tensorflow.keras.layers import Dense, Dropout, BatchNormalizationfrom tensorflow.keras.models import Sequentialmodel = Sequential()model.add(Dense(32, input_dim=858, activation='relu'))model.add(Dropout(0.9))model.add(Dense(32, activation='relu'))model.add(BatchNormalization())model.add(Dropout(0.9))model.add(Dense(1, activation='sigmoid'))model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])model.fit(X_train, y_train, epochs=1000, batch_size=8)X_test = preprocessor.transform(df_test[cols])y_pred = model.predict_classes(X_test) print(model.summary())显示模型的详细信息 案例 泰坦尼克号1","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://sjtu-xx.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"kaggle","slug":"kaggle","permalink":"https://sjtu-xx.github.io/tags/kaggle/"}]},{"title":"mac（catalina）下miniconda的安装配置","slug":"mac（catalina）下miniconda的安装配置","date":"2020-01-26T05:50:41.000Z","updated":"2021-02-19T02:26:06.533Z","comments":true,"path":"2020/01/26/mac（catalina）下miniconda的安装配置/","link":"","permalink":"https://sjtu-xx.github.io/2020/01/26/mac%EF%BC%88catalina%EF%BC%89%E4%B8%8Bminiconda%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"","text":"mac(catalina)下的miniconda环境配置 brew install miniconda conda init zsh 或 conda init shell conda create env -f *.yml //yml文件通过conda env export --file result.yml进行备份","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"应用","slug":"Python/应用","permalink":"https://sjtu-xx.github.io/categories/Python/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"},{"name":"anaconda","slug":"anaconda","permalink":"https://sjtu-xx.github.io/tags/anaconda/"},{"name":"miniconda","slug":"miniconda","permalink":"https://sjtu-xx.github.io/tags/miniconda/"}]},{"title":"QT学习笔记（C++）","slug":"QT学习笔记（C-）","date":"2020-01-12T12:34:33.000Z","updated":"2021-02-19T02:26:06.331Z","comments":true,"path":"2020/01/12/QT学习笔记（C-）/","link":"","permalink":"https://sjtu-xx.github.io/2020/01/12/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/","excerpt":"开始","text":"开始 makefile 的编写1234567891011121314151617181920212223# Makefile for building: hellorectCC = gccCXX = g++LINKER = g++LFLAGS = -lm -staticOBJECTS = rect.o hellorect.oDSTTARGET = hellorect# Default ruleall: $(DSTTARGET)$(DSTTARGET): $(OBJECTS) $(LINKER) $(LFLAGS) -o $@ $(OBJECTS)hellorect.o: hellorect.cpp $(CXX) -c -o $@ $&lt; rect.o: rect.cpp $(CXX) -c -o $@ $&lt; clean: rm $(OBJECTS) hellorect.exe 这里解释一下上面脚本意思（# 打头的是注释，忽略掉）：中间带有等于号的都是定义变量，引用变量的方式就是 $(变量名) , 脚本里 CC 是 C 语言编译器，CXX 是 C++ 编译器，LINKER 是链接器， LFLAGS 是链接器的参数。OBJECTS 是编译得到的目标文件，DSTTARGET 是可执行的目标程序。接下来是 Makefile 的生成规则，Makefile 的基本规则是： 生成目标: 依赖文件[tab字符] 系统命令 示例的 Makefile 中 all: $(DSTTARGET) 是默认生成规则，依赖文件 $(DSTTARGET) ，它的下一行没有命令。 而如何生成 $(DSTTARGET) 呢，继续往下找 $(DSTTARGET): $(OBJECTS) 生成 $(DSTTARGET) 需要 $(OBJECTS)，有了目标文件之后执行命令 1$(LINKER) $(LFLAGS) -o $@ $(OBJECTS) 即调用链接器 $(LINKER)，根据链接器参数 $(LFLAGS) 和 $(OBJECTS)，生成 $@ 。 $@ 就是上一行冒号左边的要生成的目标。注意系统命令 $(LINKER) 之前一定要有制表符 tab 字符， 不能用 4 个空格代替，否则 make 时会出现没有分隔符（separator）的错误。接下来的四句： 12345hellorect.o: hellorect.cpp $(CXX) -c -o $@ $&lt; rect.o: rect.cpp $(CXX) -c -o $@ $&lt; 是使用编译器生成目标文件 hellorect.o 和 rect.o ，$@ 是上一行冒号左边的目标，$&lt; 是上一行冒号右边第一个依赖文件。 hellorect.o 和 rect.o就是链接器需要的 $(OBJECTS) 。最后的两句是清除规则： 12clean: rm $(OBJECTS) hellorect.exe rm 是删除命令，如果 Windows 系统里没有 rm 命令，请安装一个 msysgit 工具（ http://msysgit.github.io/）， 然后系统环境变量里面会有 msysgit 工具路径，里面有 rm 工具。 clean 做的事情就是删除项目生成的 .o 和 .exe 文件。（注：Linux 系统里可执行程序没有 .exe 后缀，需要去掉 .exe 后缀。） 自定义QWidget在自定义的类继承QWidget的同时，要包含Q_OBJECT宏。但是，第一次使用会报错 https://stackoverflow.com/questions/23595961/qt-a-missing-vtable-usually-means-the-first-non-inline-virtual-member-functionQ_OBJECT是必要的Q_OBJECT是信号，插槽，可调用项,qobject_cast翻译，属性，枚举和方法自省等的前提。 12345678910111213141516171819202122232425262728293031323334cmake_minimum_required(VERSION 3.0)project(test)# 指定c++标准的版本set(CMAKE_CXX_STANDARD 17)# 自动调用moc，uic，rcc处理qt的扩展部分set(CMAKE_AUTOMOC ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTORCC ON)# 设置Qt5的cmake模块所在目录，如果不设置将使用系统提供的版本# QT_DIR和QT_VERSION是指定了qt安装目录和版本的环境变量# 如果你使用了系统的cmake，那么会优先使用系统提供模块，因为cmake会优先搜索CMAKE_SYSTEM_PREFIX_PATH# 如果你不想让cmake优先搜索系统目录（会导致编译使用系统安装的qt而不是我们配置的），需要提示find_package命令set(CMAKE_PREFIX_PATH $&#123;CMAKE_PREFIX_PATH&#125; $ENV&#123;QT_DIR&#125;/$ENV&#123;QT_VERSION&#125;/gcc_64/lib/cmake)# 找到对应的qt模块，名字为qmake中QT += &lt;name&gt;中的name首字母大写后加上Qt5前缀# 例如core为QtCore，你也可以去$&#123;CMAKE_PREFIX_PATH&#125;的目录中找到正确的模块名# 如果不想使用系统qt，这样写（注意NO_DEFAULT_PATH参数，它会让find_package跳过系统目录的查找）：find_package(Qt5Widgets REQUIRED NO_DEFAULT_PATH)# 如果你想要使用系统自带的qt，这样写：# find_package(Qt5Widgets REQUIRED)# 将当前目录的所有源文件添加进变量aux_source_directory(. DIRS_SRCS)# 通常这样设置就可以，如果你的项目包含qrc文件，那么需要将它们单独添加进来# 例如add_executable(test $&#123;DIRS_SRCS&#125; resources.qrc)add_executable(test $&#123;DIRS_SRCS&#125;)# 把对应Qt模块的库链接进程序target_link_libraries(test Qt5::Widgets) 资源文件格式12345&lt;RCC&gt; &lt;qresource prefix=\"/icon\"&gt; &lt;file&gt;icon/icon_THP.png&lt;/file&gt; &lt;/qresource&gt;&lt;/RCC&gt; 注意事项信号与槽的连接①connect()绑定函数，如果放到主窗口的构造函数中，此时，子窗口的类还没新建对象，没有分配内存地址，如果new一个对象，程序不会报错（搜一下，有好新手跟我一样有这个疑问），但是新建的子窗口对象与通过主窗口的点击按钮后，新建的子窗口对象是两码事，在内存中是两个不同的地址，我们要绑定的应该是后者与主窗口的信号槽绑定，所以，connect函数应该放到主窗口点击子窗口按钮代码里面。②connect()绑定函数，如果放到子窗口的构造函数中，发送用this，接收用主窗口指针，原理一样，如果此处新建主窗口对象，然后建立连接，其实内存中有两个主窗口对象了，绑定的并不是我想显示日志信息的主窗口对象，此处可以直接调用出窗口已新建好对象的指针。③connect()，在子窗口和主窗口交互的过程中，其实放到哪里不重要，重要的是发送和接收的指针一定要是已新建好的主窗口/子窗口对象的指针，并且确保是新建好后再执行该connect()绑定函数。 复杂多窗口设计在多窗口设计过程中： 涉及到控件之间的信号连接，需要在控件被建立后再创建。 对于可能被重建（在deleterlater之后new对象）的控件，将其控件的相关连接单独写入一个函数。删除对象时，注意需要先删除对象相关的图标（Actions对应的toolbar和menubar中的item），然后通过deleterLater（）方法删除对象。 删除机制在qt中如果对象继承自一个QObject对象，则QT会自动对对象进行管理。 窗口布局窗口中添加分割线12345 QFrame *line; line = new QFrame(); line-&gt;setFrameShape(QFrame::VLine);// line-&gt;setFrameShadow(QFrame::Sunken); line-&gt;setLineWidth(3);","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"},{"name":"QT","slug":"QT","permalink":"https://sjtu-xx.github.io/tags/QT/"}]},{"title":"Effective_Modern_C++笔记","slug":"Effective-Modern-C-笔记","date":"2020-01-12T08:55:43.000Z","updated":"2021-02-19T02:26:06.045Z","comments":true,"path":"2020/01/12/Effective-Modern-C-笔记/","link":"","permalink":"https://sjtu-xx.github.io/2020/01/12/Effective-Modern-C-%E7%AC%94%E8%AE%B0/","excerpt":"型别推导","text":"型别推导 1234567auto x1 = 27; //型别是int，值是27auto x2(27); //型别是int，值是27auto x3 = &#123;27&#125;; //型别是std::initializer_list&lt;int&gt;,值是27auto x4&#123;27&#125;; //同上//错误auto x5 =&#123;1,2,3.0&#125;; 推导不出std::initializer_list&lt;T&gt;中的T 当用于auto声明变量的初始化表达式是用大括号扩起时，推导所得的型别就属于std::initializer_list. 带有auto返回值的函数若要返回一个大括号括起来的初始化表达式是通不过编译的。用auto来制定c++14中的lambda式的星灿类被是，也不能使用大括号括起来的初始化表达式。 123//C++11 返回值型别尾序语法：// 尾序返回值的好处在于，在指定返回值型别时，可以使用函数形参。auto authAndAccess(Container &amp;c, Index i)-&gt;decltype(c[i])&#123;return c[i]&#125; 1234Widget w;const Widget&amp; cw = w;auto myWidget1 = cw; //Widgetdecltype(auto) myWidget2 = cw; //const Widget &amp; 转向现代c++ 优先选用nullptr，而非0或NULL 优先选用using别名声明，而非typedef 优先选用限定作用域的枚举类别 限定作用域的枚举类别可以进行前置声明enum class Color; //正确enum Color; //错误 默认型别enum class Status: std::uint32_t; 优先选用删除函数，而非private未定义函数 为意在改写的函数添加override声明 优先选用const_iterator,而非iterator 只要函数不会发射异常，就为其加上noexcept声明 只要有可能使用constexpr，就使用他， 智能指针 使用unique_ptr管理具备专属所有权的资源 使用shared_ptr管理具备共享所有权的资源 对于类似shared_ptr但有可能空悬的指针使用weak_ptr 优先选用make_unique和make_shared，而非直接使用new 右值引用、移动语义和完美转发形参总是左值，即使其型别是右值引用12void f(Widget&amp;&amp; w);//w 是左值 std::move 和 std::forwardstd::move无条件的将实参强制转换成右值，而std::forward则仅在某个特定条件满足时才执行同一个强制转换。 如果想要取得某个对象执行移动操作的能力，不要将其声明为常量，因为针对常量对象执行的移动操作将一声不响的变换成复制操作；其次，std::move不仅不实际移动任何东西，甚至不保证经过其强制型别转换后的对象具备可移动能力。std::move的结果唯一可以确定的是，该结果是个右值。 std::forward是有条件的强制型别转换，仅当其实参是使用右值完成初始化时，他才会执行向右值型别的强制型别转换。 区分万能引用和右值引用如果看到了T&amp;&amp;，却没有其涉及的型别推导，则其为右值引用12345678void f(Widget&amp;&amp; param); //右值引用Widget&amp;&amp; var1 = Widget(); //右值引用template&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param); //右值引用auto&amp;&amp; var2 = var1; //万能引用template&lt;typername T&gt;void f(T&amp;&amp; param); //万能引用万能引用的初始化物会决定他代表的是一个左值还是右值引用：如果初始化物是右值，万能应用就会对应到一个右值引用；如果初始化物是一个左值，则万能引用就会对应到一个右值引用 针对右值引用实施std::move,针对万能指针实施std::forward避免依万能引用型别进行重载把重载和万能引用这两者结合起来几乎总是一个馊主意：一旦万能引用成为重载候选，他就会吸引走大批的实参型别，远比撰写重载代码的程序员期望的要多。 假定移动操作不存在，成本高，未使用std::array的复制和移动有相同的时间复杂度 lambda表达式c++14标准中，捕获成员变量的一种较好的方法是使用广义lambda捕获：12345void Widget::addFilter() const&#123; filter.emplace_back( [divisor = divisor](int value)&#123;return value % divisor == 0;&#125;) //将divisor复制入闭包，使用副本&#125; 优先使用lambda表达式而不是std::bind","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"}]},{"title":"Effective C++笔记","slug":"Effective-C-笔记","date":"2020-01-06T07:54:49.000Z","updated":"2021-02-19T02:26:06.044Z","comments":true,"path":"2020/01/06/Effective-C-笔记/","link":"","permalink":"https://sjtu-xx.github.io/2020/01/06/Effective-C-%E7%AC%94%E8%AE%B0/","excerpt":"让自己习惯C++","text":"让自己习惯C++ 尽量以const，enum，inline替换#define通常C++要求对使用的任何东西提供定义式，但如果他是class专属常量，又是static且为整数类型（integral type,例如int，char，bool），则无需特殊处理。只要不取他们的地址，可以声明并使用它们而无需使用定义式。但如果要取某个class专属常量的地址，就必须提供定义式。12345678//头文件class GamePlayer&#123;private: static const int NumTurns = 5; //常量声明式&#125;;//源文件中const int GamePlayer::NumTurns; //NumTurns的定义 对于单纯常量，最好以const对象或enum替换#defines 对于形似函数的宏，最好改用inline函数替换#defines 尽可能使用constconst关键字：如果const出现在*左侧，表示物体是常量；如果出现在右侧，表示指针是常量。123//两种表示方法一致void f1(const Widget* pw);void f1(Widget const* pw); 令函数返回一个常量值，往往可以降低因客户端而造成的意外 1const Rational operator*(const Rational &amp;lhs, const Rational &amp;rhs); 这样可以避免 1if ((a * b) = c)这样的错误。 对于即使在const对象中也可能被更改的对象，使用mutable关键字进行修饰const对象调用non-const对象是一种错误的行为 确定对象在使用前已先被初始化 对于内置类型，定义的时候一定要初始化，因为读取为初始化的值是未定义的 对于非内置类型，初始化责任落在构造函数上。确保每一个构造函数都讲对象的每一个成员初始化。 注意不要混淆赋值和初始化 12345678ABEntry::ABEntry(const std::string &amp;name, const std::string &amp;address, const std::list&lt;PhoneNumber&gt; &amp;phones)&#123; theName = name; //这些都是赋值 theAddress = address; //而非初始化 thePhones = phones; numTimesConsulted = 0;&#125; 这里，进行赋值之前，会调用成员的默认构造函数，然后才是赋值。这样性能不够好。可以换成如下： 12345678ABEntry::ABEntry(const std::string &amp;name, const std::string &amp;address, const std::list&lt;PhoneNumber&gt; &amp;phones) : theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0)&#123;&#125; 另外初始化列表中，成员话初始化的次序是类中定义的变量次序一样的。 对于不同编译单元的non local static对象的初始化顺序是未定义的 所谓编译单元是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含入得头文件。 static对象，其寿命从被构造出来知道程序结束为止。 non-local，指的是对象位于global或位于namespace作用于，抑或是class内或file作用于内被声明为static 123456class FileSystem&#123;public:std::size_t numDisks() const;&#125;extern FileSystem tfs; 另一个文件： 12345678910class Director&#123;public:Directory(params); ...&#125;Director::Director(params)&#123; std::size_t disks = tfs.numDisks(); //使用tfs对象&#125; 现在客户端决定创建一个Directory对象， 1Directory tempDir(params); 现在，初始化次序的重要性显现出来了：除非tfs在tempDir之前先被初始化，否则会用到尚未初始化的tfs。 解决方案： 把每个non-local static对象搬到自己的专属函数内，这些函数返回一个refrence指向它所含的对象。这个是单例模式一个常见的实现手法。 12345678910FileSystem &amp;tfs()&#123; static FileSystem fs; return fs;&#125;Director &amp;tempDir()&#123; static Director td; return td;&#125; 使用static对象可能会在多线程环境下造成race condition。 构造/析构/赋值运算了解C++默认编写并调用哪些函数 如果没有自己编写构造函数，C++会生成一个不带参数的默认构造函数。 在非特殊情况下，C++会自动生成拷贝构造函数、赋值运算符以及析构函数特殊情况指的是：如果类中有引用类型或者有const类型，此时由于引用类型和const类型不能重新赋值，所以编译器这个时候不会自动生成赋值运算符和拷贝构造函数。 若不想使用编译器自动生成的函数，就该明确拒绝如果一个类不希望被拷贝，那么其拷贝构造函数和赋值函数应该不生效。对于外部调用来讲，将拷贝构造函数和赋值函数声明为private就可以了。但是，如果类的成员函数和友元来调用，还是可以通过编译的，这个时候，可以只声明private类型的拷贝构造函数和赋值函数，而不去实现它们，这样友元或成员函数试图调用它们的时候，就会报链接错误。 如果希望在编译的时候就讲问题暴露出来，可以使用如下方法： 1234567891011class Uncopyable&#123;protected: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable &amp;); Uncopyable &amp;operator=(const Uncopyable);&#125;;class HomeForSale:private Uncopyable&#123;&#125;; 为求阻止HomeForSale对象被拷贝，我们唯一需要做的就是继承Uncopyable。 当成员函数或者友元函数，尝试拷贝HomeForSale对象，编译器变试着生成一个copy构造函数和一个copy assignment操作符，这样会去调用其base class的对应函数，这会被编译器拒绝，因为base class的拷贝函数是private。 为驳回编译器自动提供的机能，可将响应的成员函数声明为private并且不予实现。 为多态基类声明virtual构造函数任何class只要带有virtual函数，都几乎确定应该也有一个virtual析构函数。如果class不含virtual函数，通常表示他不愿意被用作一个base class。此时令析构函数为virtual往往是个馊主意。纯虚函数可以在类外提供定义。 别让异常逃离析构函数怎么样实现不让异常逃离析构函数呢？ 假设一个数据库连接的类，为了防止客户忘记关闭连接，往往会在析构的时候尝试关闭连接，例如 123456789101112131415class DBCONN&#123;~DBCONN()&#123; try &#123; db.close(); &#125;catch &#123; //记下错误，继续执行或者调用abort，终止程序 &#125;&#125;private: DB db;&#125;; 这种处理方式的缺点是，客户没有太多选择，要么是abort终止程序，要么是继续执行。 为了让客户有选择，可以单独提供一个close函数，让用户自己处理异常。如果用户决定自己不处理，那么析构函数的时候再采用一个默认的方式来处理。 不要在构造函数和析构函数中调用虚函数在构造函数中，调用构造函数的顺序是基类-&gt;子类，当基类在构造的时候，子类的部分还没有开始构造，这时候，如果调用虚函数，只会调用基类版本的，不符合虚函数的语义。 在析构函数中，调用析构函数的顺序是子类-&gt;基类，当基类在析构的时候，子类的部分已经析构完成，这时候，如果调用虚函数，同样只会调用基类版本的，不符合虚函数的语义。 令operator=返回自身的引用一般赋值操作，希望可以写成连续的形式 12int x, y, z;x = y = z = 15; 对于上述形式，则必须返回一个自身的引用。 类似的+=,*=等等都应该返回自身的引用。 在operator=中处理“自我赋值”改良版本 12345678910Widget &amp;Widget::operator=(const Widget &amp;w)&#123; if (this == &amp;w) &#123; return *this; &#125; delete p; p = new Test(*w.p); return *this;&#125;; 这个类虽然是能避免自我赋值问题，但是，如果new Test抛出了异常，那么Widget最终会持有一个指针指向一块被删除的Test，这样的指针是有害的。 1234567Widget &amp;Widget::operator=(const Widget &amp;rhs)&#123; Test *porg = p; p = new Test(*rhs.p); delete porg; return *this;&#125; 如果此时new Test发生异常，那么p可以保持原状.还有一个可以避免异常的方法 123456Widget &amp;Widget::operator=(const Widget &amp;rhs)&#123; Widget tmp(rhs); swap(tmp); return *this;&#125; 上面的代码确保异常安全，并且能够解决自我赋值问题。 复制对象时勿忘其每一个成分不要尝试以某个copying函数实现另一个copying函数(如拷贝函数实现赋值函数)，应该讲共同机能放入第三个函数中，并且由两个copying函数共同调用。 资源管理以对象管理资源比如使用shared_ptr对象代替传统指针 在资源管理类中小心copying行为对于资源管理类的copying行为，可能需要按照以下方面来决定： 禁止复制。有的RAII对象复制并不合理，如资源管理类中管理的锁 对底层资源祭出“引用计数法”。有时候，我们希望保持资源，直到它的最后一个使用者被销毁，例如shared_ptr。 复制底层资源。有时候，资源管理需要对某一份资源的任意数量的副本，而你需要资源管理类的唯一理由是，当你不在需要某个副本的时候，就释放它的空间。 转移底部资源的拥有权。确保RAII对象指向一个未加工的资源。即使复制，此时资源的拥有权从被复制物转移到目标物。（备注：这种情况应该比较少见吧）。 在资源管理类中提供对原始资源的访问对于mutex，我们可以用get_mutex来返回对原始mutex的引用。 有时候可能也会提供隐式转换的接口，例如： 1operator mutex() const; 这样就会在需要mutex的时候，自动转换。 成对使用new和delete时采取相同形式首先，来看new和delete操作符的语义 new会先创建对象的内存空间，然后调用其构造函数来初始化 delete会先调用析构函数，然后再释放类的空间 然后，new和delete需要采用相同的形式 12345std::string *str_ptr1 = new std::string;std::string *str_ptr2 = new std::string[100];...delete str_ptr1;delete[] str_ptr2; 如果用delete[]来删除str_ptr1，结果是未定义的，delete可能会先解析出数组大小，然后，析构这么多个元素，但是实际上只有一个元素需要释放。同样地，对str_ptr2调用delete，也会出现未定义的行为。 因此，new和delete形式必须要以相同的形式出现。 12new和deletenew[]和delete[] 以独立语句将newed对象置入智能指针考虑以下代码 123int priority();void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority);processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority()); 由于C++中，一条语句里面的函数调用的顺序是不确定的，上面的代码总共有三条语句： 123new Widgetpriority()std::tr1::shared_ptr&lt;Widget&gt;(); 如果最终编译器以上述顺序执行，并且priority函数中间发生了异常，那么new Widget创建的对象还没加入到shared_ptr中，会造成资源泄漏。 正确的做法 12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority()); 设计与声明让接口容易被正确使用，不易被误用 要设计不易被误用的接口 例如，要创建一个时间类型 1Date(int month, int year, int day); 上面的接口就是容易被误用的接口，因为可能把年月日的顺序给搞错了。 可以给年月日分别设计一个类型，构造函数中传入对应的类型才能正确编译。 限制类型内什么事可做，什么事不能做 比如opeator *的返回值类型为const 让你自己设计类型的表现与内置types一致 任何借口如果要求客户必须记得做某事，就容易出错，最好的方法就是给客户做好 例如 1Investment *createInvestment(); 该函数返回一个指针，需要客户在最后记得释放空间，当客户忘记这件事时，就会造成资源未释放。 比较好的方法，是返回一个shared_ptr智能指针。 shared_ptr支持定制型删除器，可以返回跨模块的new/delete问题，因为shared_ptr会自动调用本模块的delete函数。 设计class犹如设计type 新type的对象应该如何被创建和销毁 对象的初始化和对象的赋值该有什么样的差别 新type的对象如果被passed by value，意味着什么？即copy构造函数该如何实现 什么是新type的“合法值”？成员函数必须对菲合法值进行必要的错误检查 你的新type需要配合某个继承图系？ 你的新type需要什么样的转换？是否需要隐式或者显式转换成其他类型。 什么样的操作符和函数对此新type而言是合理的?该声明哪些函数，哪些应该是member函数，某些则不是。 什么样的标准含税应该驳回？例如，自动生成的拷贝构造函数，赋值函数和析构函数等等。 谁该取用新type的成员？哪些为public、哪些为protected、哪些为private。 什么是新type的“未声明接口”？这个不太懂 你的新type有多么一般化？或许你其实并非定义一个新type，而是定义一整个 types家族。 你真的需要一个新type吗？如果只是定义新的derived class以便为既有的class添加机能，那么说不定单纯定义一个或多个non-member函数或者template更能达到目标。 宁以pass-by-refrence-to-const替换pass-by-value对于自定义的类，往往通过pass by const refrence比较合适，因为这可以省去多次的构造函数的调用开销。对于内置对象，往往以pass-by-value比较合适，因为引用在编译器内部实现往往是指针，对于内置类型，用指针来传递往往会比pass-by-value变慢，多了一次读内存的过程（先读变量的地址，然后在真正读变量的值）。 对于STL迭代器和函数对象，往往习惯上也被设计为pass-by-value。 必须返回对象时，别妄想返回其refrence举个例子 1const Rational &amp;operator(const Rational &amp;lhs, const Rational &amp;rhs); 这个要返回refrence，所以，必须在heap上分配一个对象。因为，refrence指向一个函数内的local对象时，在函数退出时，已经被析构了，这时候，函数的返回值就是非法的了。 当你在必须“返回一个refrence和返回一个object”之间进行抉择时，你的工作就是挑出行为正确的那个。 绝不要返回pointer或refrence指向一个local stack对象，或返回refrence指向一个heap-allocated对象（这个需要外部调用delete，而且如果连续赋值可能导致内存空间无法释放），或返回pointer或refrence指向一个local static对象而有可能同时需要对个这样的对象。 将成员变量声明为private 如果将成员变量声明为public，那么，如果对成员变量进行改动，会影响到所有使用该成员变量的客户。 如果将成员变量声明为protected，那么，如果对成员变量进行改动，会影响到所有使用该成员变量的derived classes。 所以，为了封装性，把成员变量声明为private。 宁以non-member-non-friend替换member函数123456789101112131415161718class WebBrowser&#123;public: void clearCache(); void clearHistory(); void removeCookies();&#125;;class WebBrowser&#123;public: void clearEverything();&#125;;void clearBrowser(WebBrowser &amp;wb)&#123; wb.clearCache(); wb.clearHistory(); wb.removeCookies();&#125;; 从上面代码看出，以non-member-non-friend函数方式形式来实现clear操作会更有封装性，因为它不能访问类里面的数据，更加符合封装的思想。 若所有参数皆需类型转换，请为此采用non-member函数1234567891011121314class Rational&#123;public: Rational(int numerator = 0, int denominator = 1); int numberator() const; int denominator() const;private: ...&#125;;class Rational&#123;public: const Rational operator* (const Rational &amp;rhs) const;&#125;; 对于上面代码 1234Rational result = oneHalf * oneEighth;result = result * oneEighth;result = oneHalf * 2;result = 2 * oneHalf; //有错误 为了使得第四个赋值也能支持，可以把operator*实现成以下 1const Rational operator*(const Rational &amp;lhs, const Rational &amp;rhs); 考虑写出一个不抛异常的swap函数实现变量的定义最好要出现在其初值能确定的地方。这样可以避免定义了变量，未使用，却带来了构造函数和析构函数的开销。 对于循环： 1234567891011//方法A：定义循环外Widget w;for (int i = 0; i &lt; n; ++i)&#123; w = 取决于i的某个值;&#125;//方法B：定义循环内for (int i = 0; i &lt; n; ++i)&#123; Widget w(取决于i的某个值);&#125; 做法A：1个构造函数+1个析构函数+n个赋值函数 做法B：n个构造函数+n个析构函数 如果classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效。尤其当n比较大的时候。否则做法B或许比较好。 另外A带的是w的作用域变大，有时候会对程序的可理解性和易维护性造成冲突。 因此： 你知道赋值成本比“构造+析构”成本低 你正在处理代码中效率高度敏感的部分，否则你应该使用做法B 避免使用转型(cast) 如果可以，尽量避免转型，特别是在注重效率的代码中避免，如果有个设计需要转型动作，试着发展无需转型的替代设计。 如果转型是必要的，试着将它隐藏于某个函数背后，客户随后可以调用该函数，而不需将转型放进他们自己的代码内。 宁可使用C++风格转型，不要使用旧式转型前者很容易辨识出来，而且也比较有分别别类的职称。 避免返回handles指向对象内部 帮助const成员函数行为像个const 123456class Rectangle&#123;public: const Point &amp;upperLeft() const &#123;return pData-&gt;ulhc;&#125; const Point &amp;lowerRight() const &#123;return pData-&gt;lrhc;&#125;&#125;; 如果这里用非const返回值，会造成Rectangle中的ulhc货lrhc被外部的修改。 避免返回handles(包括refrence、指针、迭代器)指向对象内部。遵守这个条款可增加封装性。 因为有可能在某个临时对象上，操作这个内部对象，会造成问题： 例如： 12GUIObject *pgo;const Point *pUpperLeft = &amp;(boundingBox(*pgo).upperLeft()); 这个boundingBox会生成一个临时的Rectangle对象，造成upperLeft的返回的内部对象失效，造成程序不安全。 为“异常安全”而努力是值得的透彻了解inlining的内内外外 inline函数如果起作用了，会在每次调用的时候用实现的代码替换它，所以会造成程序体积变大。 inline只是向编译器的一个申请，可以明确用inline关键字，也可以在类体内部定义。 template的实例化和inline无关，如果需要template函数为inline，需要显式地声明它。 inline函数无法随着程序库的升级而升级。换句话说如果f是程序库内的一个inline函数，客户讲“f函数本体”编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序都必须重新编译。 将大多数inline限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 将文件间的编译依存关系降到最低 支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式，基于此构想的两个手段是Handle classes和Interface Classes。 继承和面向对象设计确定你的public继承函数塑膜处is-a关系“public”继承意味着is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base classes对象。 避免遮掩继承而来的名称看以下代码： 123456789101112131415161718192021222324252627class Base&#123;private: int x;public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); ...&#125;;class Derived : public Base&#123;public: virtual void mf1(); void mf3(); void mf4();&#125;；Derived d;int x;...d.mf1(); //没问题，调用Dervied::mf1d.mf1(x); //错误，因为Derived::mf1遮掩了Base::mf1d.mf2(); //没问题，调用Base::mf2d.mf3(); //没问题，调用Dervied::mf3d.mf3(x); //错误！因为Derived::mf3遮掩了Base::mf3 如果你正在使用public继承而又不继承那些重载函数，就是违反Base和derived classes之间的is-a关系，而is-a是public的基石。 为了被遮掩的名称再见天日，可使用using声明式 区分接口继承和实现继承我们可以为纯虚函数提供定义，但调用他的唯一途经是使用时明确指出其class名称。 考虑如下一段代码 12345678910class Shape&#123;public: virtual void draw() const = 0; virtual void error(const std::string &amp;msg); int objectID() const; ...&#125;;class Rectangle : public Shape &#123;...&#125;;class Ellipse : public Shape &#123;...&#125;; 对于一个pure virtual函数，且不带定义，目的是为了让derived classes只继承函数接口。然后，继承类必须实现它自身的行为。 声明impure virtual函数的目的是，让derived classes继承该函数的接口和缺省实现。也就是，如果某个集成类不想对该功能做特殊处理的时候，可以采用缺省的默认实现，否则，需要自己提供实现。这种方法可能会造成继承类忘记实现自己该实现的功能，这时候编译照样是过的。 声明pure virtual函数且带定义，也是让derived classes继承该函数的接口和缺省实现。这种方法跟上面的区别是，它可以防止集成类忘记实现自己功能的情况，因为是pure virual，采用默认实现也得显式地调用基类的函数。 声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现。 考虑virtual函数以外的其他选择场景：假如你打算为游戏内的人物设计一个继承体系。你的游戏属于暴力砍杀类型，剧中人物被伤害或因其他因素而降低健康状态的情况并不罕见。因此，你决定提供一个成员函数healthValue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能已不同的方式计算它们的健康指数，将healthValue声明为virtual似乎是再明白不过的做法。 方案1-虚函数方法123456class GameCharacter&#123;public: virtual int healthValue() const; //返回人物的健康指数 //derived classes可重新定义它&#125;; 方案2-借由Non-Virtual Interface手法实现Template Method模式这个方案的思路是保留healthValue为public成员函数，但让它成为non-virtual，表调用一个private virtual函数，进行实际工作： 12345678910111213141516class GameCharacter&#123;public: int healthValue() const &#123; ... //derived classes不重新定义它 int retVal = doHealthValue(); //做一些事情工作，详下 ... //做一些事后工作 return retVal; &#125;private: virtual int doHealthValue() const //derived classes可重新定义它 &#123; ... //缺省算法，计算健康指数 &#125; &#125;; 令客户通过public non-virtual成员函数间接调用private virtual函数，称为non-virtual interface手法(NVI)。它是所谓Template Method设计模式的一个独特表现形式。我把这个non-virtual函数称为virtual函数的wrapper。 优点：可以使得virtual函数在调用的时候，之前可以设定好适当场景，并在调用结束后清理场景。事前工作可以是锁定互斥器、制造运转日志记录项目、验证class约束条件。事后工作可以包括互斥器解除锁定，验证函数的时候条件、再次验证class约束条件等等。 方案3-借由Function Pointers实现Strategy模式12345678class GameCharacter&#123;public: explict GameCharacter(HealthCalcFunc hcf = defaultHealthCalc); void setHealthCalculator(HealthCalcFunc hcf);private: HealthCalcFunc healthFunc;&#125;; 优点：可以在运行时改变计算血量的方式，比如有的角色开始时计算血量是一种方式，过了某个血量范围后，又是另外一个方式。 缺点：如果计算血量，需要依赖non-public的信息，就无法进行下去。 方案4-借由tr1::function完成strategy模式tr1::function对象可以使用任何可调用无，也就是函数指针、函数对象或成员函数指针。 1234567class GameCharacter&#123;public: typedef std::tr1::function&lt;int (const GameCharacter &amp;)&gt; HealthCalcFunc;private: HealthCalcFunc healthCalcFunc;&#125;; 优点：灵活性，可以使用任何可调用的对象。 方案5-古典的strategy模式12345678910 --------------- ---------------- |GameCharacter|/\\-----------|HealthCalcFunc| ---------------\\/ --------------- /\\ /\\ || || -------||---------- ||------------ | || | || |------------ -------------- ----------- -----------|EvilBadGuy| |EyeCharacter| |SlowLoser| |FastLoser|------------ -------------- ----------- ----------- 绝不重新定义继承而来的non-virtual函数绝不重新定义继承而来的non-virtual函数 123456789101112131415class B&#123;public: void mf(); ...&#125;;class D : public B&#123;&#125;;D x;B *pb = &amp;x;pb-&gt;mf();//调用B::mfD *pd = &amp;x;pd-&gt;mf();//调用D::mf 在D中重载non-virtual的B类对象中的函数，其实已经违反了每个D都是一个B的约束。即对于non-virtual的接口，继承类应该和基类行为是一致的，否则就不应该设计成non-virtual接口。 绝不重新定义继承而来的缺省参数值virtual函数系动态绑定，而缺省参数值却是静态绑定。 举个例子 1234567891011class Shape&#123;public: enum ShapeColor&#123;Red, Green, Blue&#125;; virtual void draw(ShapeColor color=Red) const = 0;&#125;;class Rectangle : public Shape&#123;public: virtual void draw(ShapeColor color=Green) const = 0;&#125;; 有以下代码 123Shape *ps;Shape *pc = new Circle;Shape *pr = new Rectangle; 用pc-&gt;draw()的时候，采用的默认参数是Red，是Shape类的默认参数，而不是Derived的类的默认参数，因为默认参数是静态编译期间绑定的。 即使把Base class和Derived class设计成相同的默认参数，如果某一天要修改这个参数，得两个类都需要修改。 这个问题可以通过NVI方法来避免，把函数功能抽象成private的virtual函数，然后把缺省的默认参数移到non-virtual的public函数中。 通过复合塑模出has-a或“根据某物实现出”复合is-a有两种含义，一种has-a含义，另一种是is-implemented-in-terms-of，根据某物实现出。 例如，我们希望基于std::list来实现一个set，可以，在一个set类里面定义一个std::list作为内部成员，来实现set。 明智而审慎的使用private继承private继承意味着is-implemented-in-terms-of（根据某物实现出）。如果你让class D以private形式继承class B，你的用意是为了采用class B内已经备妥的某些特性，不是因为B对象和D对象存在有任何观念上的关系， 明智而审慎的使用多重继承","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"}]},{"title":"C-Primer读书笔记-第四部分：高级主题","slug":"C-Primer读书笔记-第四部分：高级主题","date":"2020-01-05T15:45:38.000Z","updated":"2021-02-19T02:26:05.938Z","comments":true,"path":"2020/01/05/C-Primer读书笔记-第四部分：高级主题/","link":"","permalink":"https://sjtu-xx.github.io/2020/01/05/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9A%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/","excerpt":"17.标准库特殊实施","text":"17.标准库特殊实施 tuple类型tuple支持的操作 操作 说明 tuple t; t是一个tuple，成员数为n，所有成员都进行值初始化 tuple t(v1,v2,…,vn); t是一个tuple，成员类型为T1…Tn。每个成员都用对应的vi进行初始化。此函数是explicit的。 make_tuple(v1,v2,…,vn); 返回一个用给定初始值初始化的tuple。tuple的类型从初始值的类型判断。 t1==t2 t1!=t2 get&lt;i&gt;(t) 返回t的第i个数据成员的引用；如果t是一个左值，结果返回一个左值引用；如果t是一个右值，结果返回一个右值引用。tuple所有成员都是public的。 tuple_size&lt;tupleType&gt;::value 一个类模板，可以通过一个tuple类型来初始化。她有一个名为value的public constexpr static数据成员，类型为size_t,表示给定tuple类型中成员的数量。 tuple_element::type 一个类模板，可以通过一个整型常量和一个tuple类型来初始化。她有一个名为type的public成员，表示给定tuple类型中指定成员的类型。 tuple的一个常见用途是从一个函数返回多个值。 正则表达式 类 类说明 regex 表示有一个正则表达式的类 regex_match 讲一个字符序列与一个正则表达式匹配 regex_search 寻找第一个与正则表达式匹配的子序列 regex_replace 是用给定格式替换一个正则表达式 sregex_iterator 迭代器适配器，调用regex_search来遍历一个string中所有匹配的字串 smatch 容器类，保存在string中搜索的结果 ssub_match string中匹配的表达式的结果 默认情况，regex使用的正则表达式语言是ECMAScript。在ECMAScript中，模式[[:alpha:]]匹配任意字母。 regex选项：定义在regex和regex_constants::syntax_option_type 标志 说明 icase 在匹配过程中忽略大小写 nosubs 不保存匹配的子表达式 optimize 执行速度优先与构造速度 ECMAScript 使用ECMA-262指定的语法 basic 使用POSIX基本的正则表达式语法 extended 使用POSIX扩展的正则表达式语法 awk 使用POSIX版本的awk语言的语法 grep 使用POSIX版本的grep的语法 egrep 使用POSIX版本的egrep的语法 使用regex r(&quot;[[:alnum:]]+\\\\.(cpp|cxx|xx)$&quot;,regex::icase) 一个正则表达式所表示的“程序”是在运行时而非编译时编译的。正则表达式的编译是一个非常慢的操作，特别是在你使用了扩展的正则表达式语法或是复杂的正则表达式时。应该努力避免创建很多不必要的regex。 迭代器 说明 sregex_iterator it(b,e,r) 一个sregex_iterator,遍历迭代器b和e表示的string。他调用sregex_search(b,e,r)将it定位到输入中第一个匹配的位置。 sregex_iterator end; sregex_iterator的尾后迭代器。 *it it-&gt; ++it it++ it1==it2 it1!=it2 随机数定义在头文件random中：随机数引擎类和随机数分布类 12default_random_engine e; //生成随机无符号数e(); 引擎操作 说明 Engine e 默认构造函数，使用默认种子 Engine e(s) 使用整数值s作为种子 e.seed(s) e.min() 该引擎可生成的最小值和最大值 e.max() Engine::result_type 该引擎生成的unsigned整型类型 e.discard(u) 将引擎推进u步，u的类型为unsigned long long 分布 说明 uniform_int_distribution u(0,9) 生成0到9之间均匀分布的随机数 uniform_real_distribution u(0,1) 生成0到1之间的随机实数 normal_distribution&lt;&gt; n(4,1.5) 均值4，标准差1.5 bernoulli_distribution(0.55) 是一个普通类，返回bool值 12345678910vector&lt;unsigned&gt; good_randVec()&#123; //由于我们希望引擎和分布对象保持状态，因此应该将他们定义为static的，从而每次调用都生成新的数 static default_random_engine e; static uniform_int_distribution&lt;unsigned&gt; u(0,9); vector&lt;unsigned&gt; ret; for (size_t i=0;i&lt;100;++i) ret.push_back(u(e)); return ret;&#125; IO库再探格式化输入输出 操作符 说明 boolalpha 将true和false输出为字符串 noboolalpha 将true和false输出为0，1 showbase 对整型值输出表示进制的前缀 noshowbase 不生成表示进制的前缀 showpoint 对浮点值总是显示小数点 noshowpoint 只有当浮点值包含小数部分时才显示小数点 showpos 对非负数显示+ noshowpos 对非负数不显示+ uppercase 在十六进制中打印0X，在科学计数法中打印E nouppercase 在十六进制中打印0x，在科学计数法中打印e dec 整数显示为十进制 hex 整数显示为十六进制 oct 整数显示为八进制 left 在值的右侧添加填充字符 right 在值的左侧添加填充字符 internal 在符号和值之间添加填充字符 fixed 浮点值显示为定点十进制 scientific 浮点值现实为科学计数法 hexfloat 浮点值显示为十六进制 defaultfloat 重置浮点数格式为十进制 unitbuf 每次输出操作后都刷新缓存区 nounitbuf 恢复正常的缓冲区刷新方式 skipws 输入运算符跳过空白符 noskipws 输入运算符不跳过空白符 flush 刷新ostream缓冲区 ends 插入空字符，然后刷新ostream缓冲区 endl 插入换行，然后刷新ostream缓冲区 iomanio中的操作符 函数 说明 setfill(ch) 用ch填充空白 setprecision(n) 将浮点精度设置为n setw(w) 读或写值的宽度为w个字符 setbase(b) 将整数输出为b进制 流随机访问seek和tell函数 g输入，p输出 函数 说明 tellg() 返回一个输入流中（tellg）或输出流中（tellp）标记当前位置 tellp() seekg(pos) seekp(pos) seekg(off,from) 定位到from之前或之后off个字符：from可以是(beg,cur,end) seekp(off,from) 18.用于大型程序的工具异常处理 一个异常如果没有被捕获，则它将终止当前的程序。程序将调用标准库函数terminate 通常情况下，如果catch接收的异常与某个继承体系有关，最好将该catch的参数定义成引用类型。 重新抛出仍然是一个throw语句，只不过不包含表达式throw;。 处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块。 一旦一个noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺。 命名空间 一个命名空间的定义包含两部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。 命名空间结束后无需分号。 命名空间可以是不连续的，命名空间可以定义在几个不同的部分。 命名空间中定义的成员可以直接使用名字，无须前缀；命名空间之外定义的成员必须使用含有前缀的名字 未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。 命名空间的别名：namespace primer=cplusplusprimer using namespace A; 把A中的名字 对于using声明，只是简单的令名字在局部作用域内有效。using指示是令整个命名空间的所有内容变得有效。通常情况下，命名空间中会有一些不能出现在局部作用域中的定义。因此，using指令一般被看做是出现在最近的外层作用域中。 特殊工具与技术控制内存分配重载new和delete new 执行new实际上执行了三步操作。 new表达式调用一个名为operator new（或者operator new[]）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间 以便存储特定类型的对象。 编译器运行响应的构造函数以构造这些对象，并为其传入初始值。 对象被分配了空间并构造完成，返回一个指向该对象的指针。 delete 两步操作。 对所指的对象或者数组中的元素执行对应的析构函数 编译器调用名为operator delete(或 operator delete[])的标准库函数释放内存空间。 malloc函数和free函数dynamic_cast123dynamic_cast&lt;type*&gt;(e); //e必须是指针，如果转换失败返回0dynamic_cast&lt;type&amp;&gt;(e); //e必须是左值，如果转换失败抛出bad_cast异常dynamic_cast&lt;type&amp;&amp;&gt;(e); //e不能是左值，如果转换失败抛出bad_cast异常 typeidtypeid运算符允许程序向表达式提问，你的对象是什么类型？ typeid(e)返回type_info类型的对象","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"}]},{"title":"C-Primer读书笔记-第三部分：类设计者的工具","slug":"C-Primer读书笔记-第三部分：类设计者的工具","date":"2020-01-02T15:45:38.000Z","updated":"2021-02-19T02:26:05.868Z","comments":true,"path":"2020/01/02/C-Primer读书笔记-第三部分：类设计者的工具/","link":"","permalink":"https://sjtu-xx.github.io/2020/01/02/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/","excerpt":"13.拷贝控制","text":"13.拷贝控制 拷贝、赋值与销毁五种特殊的成员函数：拷贝构造函数、拷贝赋值构造函数、移动构造函数、移动赋值构造函数、析构函数 拷贝构造函数 拷贝构造函数的第一个参数必须是引用类型。 12345class Foo&#123; public: Foo(); //默认构造函数 Foo(const Foo&amp;); //拷贝构造函数&#125; 拷贝初始化时依靠拷贝构造函数或移动构造函数来完成的。 12345string dots(10,'.'); //直接初始化string s(dots); //直接初始化string s2 = dots; //拷贝初始化string null_book = \"9-999-999\"; //拷贝初始化string nines = string(100,'9'); //拷贝初始化 赋值运算符通常应该返回一个指向其左侧运算对象的引用 拷贝赋值运算符1234class Foo&#123; public: Foo&amp; operator=(const Foo&amp;); //赋值运算符&#125; 如果一个类未定义拷贝赋值运算符，编译器会为他生成一个合成拷贝赋值运算符。 析构函数1234class Foo&#123; public: ~Foo(); //析构函数&#125; 析构函数没有返回值，也不接受参数。 与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，智能指针在析构阶段会自动销毁。 析构函数体本身并不直接销毁成员。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。 三/五原则三个基本操作：拷贝构造函数、拷贝赋值构造函数、析构函数 使用=default123456789class Sales_data&#123;public: //拷贝控制成员 Sales_data() = default; Sales_data(const Sales_data&amp;) = default; Sales_data&amp; operator=(const Sales_data &amp;); ~Sales_data() = default; &#125; 当我们在类内使用=default修饰成员的声明时，合成的函数将隐式地声明为内联的。 阻止拷贝可以通过将拷贝构造函数和拷贝复制构造函数定义为删除的函数来阻止拷贝。 123456struct NoCopy&#123; NoCopy() = default; NoCopy(const NoCopy&amp;) = delete; //阻止拷贝 NoCopy &amp;operator=(const NoCopy&amp;) = delete; //阻止赋值 ~NoCopy() = default; &#125; 析构函数不能是删除的成员。对于析构函数已删除的成员，不能定义该类型的变量或释放指向该类型动态分配对象的指针。 拷贝控制和资源管理行为像值的类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// value-like implementation of HasPtrclass HasPtr &#123; friend void swap(HasPtr&amp;, HasPtr&amp;);public: HasPtr(const std::string &amp;s = std::string()): ps(new std::string(s)), i(0) &#123; &#125; // each HasPtr has its own copy of the string to which ps points HasPtr(const HasPtr &amp;p): ps(new std::string(*p.ps)), i(p.i) &#123; &#125; HasPtr&amp; operator=(const HasPtr &amp;); ~HasPtr() &#123; delete ps; &#125;private: std::string *ps; int i;&#125;;inlinevoid swap(HasPtr &amp;lhs, HasPtr &amp;rhs)&#123; using std::swap; swap(lhs.ps, rhs.ps); // swap the pointers, not the string data swap(lhs.i, rhs.i); // swap the int members&#125;using std::string;HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs) &#123; string *newp = new string(*rhs.ps); // copy the underlying string delete ps; // free the old memory ps = newp; // copy data from rhs into this object i = rhs.i; return *this; // return this object&#125;HasPtr f(HasPtr hp) // HasPtr passed by value, so it is copied&#123; HasPtr ret = hp; // copies the given HasPtr // process ret return ret; // ret and hp are destroyed&#125;int main()&#123; HasPtr h(\"hi mom!\"); // allocates a new copy of \"hi mom!\" f(h); // copy constructor copies h in the call to f // that copy is destroyed when f exits&#125; // h is destroyed on exit, which destroys its allocated memory 行为像指针的类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// reference counted version of HasPtr#include &lt;string&gt;#include &lt;cstddef&gt;class HasPtr &#123;public: // constructor allocates a new string and a new counter, // which it sets to 1 HasPtr(const std::string &amp;s = std::string()): ps(new std::string(s)), i(0), use(new std::size_t(1)) &#123;&#125; // copy constructor copies all three data members // and increments the counter HasPtr(const HasPtr &amp;p): ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125; HasPtr&amp; operator=(const HasPtr&amp;); ~HasPtr();private: std::string *ps; int i; std::size_t *use; // member to track how many objects share *ps&#125;;HasPtr::~HasPtr()&#123; if (--*use == 0) &#123; // if the reference count goes to 0 delete ps; // delete the string delete use; // and the counter &#125;&#125;HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs) &#123; ++*rhs.use; // increment the use count of the right-hand operand if (--*use == 0) &#123; // then decrement this object's counter delete ps; // if no other users delete use; // free this object's allocated members &#125; ps = rhs.ps; // copy data from rhs into this object i = rhs.i; use = rhs.use; return *this; // return this object&#125;HasPtr f(HasPtr hp) // HasPtr passed by value, so it is copied&#123; HasPtr ret; ret = hp; // assignment copies the given HasPtr // proces ret return ret; // ret and hp are destroyed&#125;int main()&#123; HasPtr h(\"hi mom!\"); HasPtr h2 = h; // no new memory is allocated, // h and h2 share the same underlying string&#125; 交换操作1234//h是Foo中的一个HasPtr对象void swap(Foo &amp;lhs, Foo &amp;rhs)&#123; std::swap(lhs.h,rhs.h) //错误，使用了标准库版本的swap&#125; 12345//h是Foo中的一个HasPtr对象void swap(Foo &amp;lhs, Foo &amp;rhs)&#123; using std::swap; swap(lhs.h,rhs.h) //使用了HasPtr版本的swap&#125; 赋值运算符中使用swap 1234HasPtr&amp; HasPtr::operator=(HasPtr rhs)&#123; swap(*this,rhs); return *this;&#125; 对象移动 标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。 右值和左值 左值指的是可以取地址的变量，记住，左值与右值的根本区别在于能否获取内存地址，而能否赋值不是区分的依据。通常临时量均为右值。 临时变量（右值）生命周期a) 临时对象应该在完整表达式结束时销毁b) 常量左值引用会延长临时变量的生命 右值引用：通过&amp;&amp;而不是&amp;获得右值引用。 123456int i = 42;int &amp;r = i; //正确：r引用iint &amp;&amp;rr = i; //错误：不能将一个右值引用绑定到一个左值上int &amp;r2 = i*42; //错误：i*42是一个右值const int &amp;r3 = i*42; //正确：我们可以将一个const的引用绑定到一个右值上int &amp;&amp;rr2 = i*42; //正确：将rr2绑定到乘法结果上 左值持久，右值短暂左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。 右值引用： 所引用的对象即将被销毁 该对象没有其他用户 不能将一个右值引用绑定到一个右值引用类型的变量上： 123int &amp;&amp;rr1 = 42; //正确：字面值常量是一个右值int &amp;&amp;rr2 = rr1; //错误：表达式rr1是左值int &amp;&amp;rr2 = std::move(rr1); //正确（move位于头文件utility中） 移动构造函数和移动赋值运算符 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept 移动构造函数 1234StrVec::StrVec(StrVec &amp;&amp;s) noexcept //移动操作不应抛出任何异常 :elements(s.elements),first_free(s.first_free)&#123; s.elements=s.first_free = nullptr; &#125; 移动赋值运算符 12345678910111213StrVec &amp;StrVec::operator=(StrVec &amp;&amp;rhs) noexcept&#123; //直接检测自赋值 if (this != &amp;rhs)&#123; //释放已有的元素 free(); //从rhs接管资源 elements = rhs.elements; first_free = rhs.first_free; cap = rhs.cap; //将rhs置于可析构状态 rhs.elements = rhs.first_free = rhs.cap = nullptr; &#125;&#125; 移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝。 移动迭代器一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。 通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器。函数接受一个迭代器参数，返回一个移动迭代器。 不要随意使用移动操作。 在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用std::move。 右值引用和成员函数 区分移动和拷贝重载函数通常有一个版本接受一个const T&amp;，而另一个版本接受T&amp;&amp;。 一般来说，我们不需要为函数操作定义接受一个const X&amp;&amp;或是一个X&amp;参数的版本。当我们希望从实参窃取数据时，通常传递一个右值引用。为了达到这一目的，实参不能是const的。类似的，拷贝操作不应改变对象。 右值和左值引用成员函数强制运算对象是左值可以使用引用限定符（&amp;或&amp;&amp;）。引用限定符&amp;表示本对象（this）是一个左值，&amp;&amp;表示本对象是一个右值。const &amp;限定符表示本对象是一个const或左值。 12345678class Foo&#123; public: Foo &amp;operator=(const Foo&amp;) &amp;; //只能向可修改的左值赋值&#125;;Foo &amp;Foo::operator=(const Foo &amp;rhs) &amp;&#123; return *this&#125; 对于&amp;限定的函数，我们只能将他用于左值，对于&amp;&amp;限定的函数，只能用于右值： 1234567Foo &amp;retFoo(); //返回一个引用；（左值）Foo retVal(); //返回一个值；（右值）Foo i,j; //i和j是左值i = j; //i是左值retFoo() = j; //正确：retFoo()返回一个左值retVal() = j; //错误：retVal()返回一个右值i = retVal(); //正确：可以将一个右值作为赋值操作的右侧运算对象 const和&amp;限定符可同时使用，const在前。 14.重载运算符与类型转换基本概念 重载函数名由关键字operator和要定义的运算符号共同组成。 对二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。 如果一个运算符函数是成员函数，则他的第一个（左侧）运算对象绑定到隐式的this指针上。 只能重载已有的运算符，而无权发明新的运算符 通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。 选择作为成员还是非成员函数 赋值（=）、下标（[]）、调用（()）、成员访问箭头(-&gt;)运算符必须是成员。 复合赋值运算符（+=）一般来说应该是成员，但非必须。 改变运算对象的运算符或与给定类型密切相关的运算符，如递增、递减、解引用等，通常应该是成员。 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，他们通常应该是普通的非成员函数。 如果我们把运算符定义成成员函数时，他的左侧运算对象必须是运算符所属类别的一个对象： 123string s =\"world\";string t = s + \"!\"; //正确：我们能把一个const char*加到一个string对象中string u = \"hi\" + s; //如果+是string的成员，则产生错误 输入和输出运算符1ostream &amp;operator&gt;&gt;(ostream &amp;, const Sales_data &amp;); 令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节。 与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。 算术和关系运算符 如果一个类含有判断两个对象是否相等的操作，则他显然应该把函数定义成operator==而非一个普通的命名函数。 如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否有重复的数据。 下标运算符 下标运算符必须是成员函数。 如果一个类包含下标运算符，则他通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用。 12345class StrVec&#123;public: std::string&amp; operator[](std::size_t n)&#123;return element[n];&#125; const std::string&amp; operator[](std::size_t n) const &#123;return element[n];&#125;&#125; 递增和递减运算符12345class StrBlobPtr&#123;public: StrBlobPtr&amp; operator++(); //前置运算符 StrBlobPtr operator--(); //后置运算符&#125;; 重载、类型转换与运算符类型转换函数的一般类型如下：operator type() const 类型转换函数必须是类的成员函数；他不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是const。 显式的类型转换运算符： 1234567class SmallInt&#123;public: explicit operator int() const &#123;return val;&#125;;&#125;;SmallInt si = 3;static_cast&lt;int&gt;(si)+3; 如果表达式被用作条件，则编译器会将显示的类型转换自动应用于他。换句话说，当表达式出现在下列位置时，显式的类型转换被隐式的执行： if、while、do语句的条件部分 for语句头的条件表达式 逻辑非、或、与（！，||，&amp;&amp;）的运算对象 条件运算符（?:）的条件表达式 向bool的类型转换通常用在条件部分，因此operator bool一般定义为explicit的。 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。 除了显式地向bool类型转换外，尽量避免定义类型转换函数并尽可能的显示那些“显然正确”的非现实构造函数 在调用重载函数时，如果需要额外的标准类型转化，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。 表达式中运算符的候选函数集既包含成员函数，也应该包括非成员函数。 15.面向对象程序设计定义基类与派生类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;memory&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstddef&gt;// Item sold at an undiscounted price// derived classes will define various discount strategiesclass Quote &#123;friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, Quote&amp;);friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Quote&amp;);public: Quote(): price(0.0) &#123; &#125; Quote(const std::string &amp;book, double sales_price): bookNo(book), price(sales_price) &#123; &#125; // virtual destructor needed // if a base pointer pointing to a derived object is deleted virtual ~Quote() &#123; &#125; // dynamic binding for the destructor std::string isbn() const &#123; return bookNo; &#125; // returns the total sales price for the specified number of items // derived classes will override and apply different discount algorithms virtual double net_price(std::size_t n) const &#123; return n * price; &#125; // virtual function to return a dynamically allocated copy of itself virtual Quote* clone() const &#123;return new Quote(*this);&#125;private: std::string bookNo; // ISBN number of this itemprotected: double price; // normal, undiscounted price&#125;;// abstract base class to hold the discount rate and quantity// derived classes will implement pricing strategies using these dataclass Disc_quote : public Quote &#123;public: // other members as before Disc_quote(): quantity(0), discount(0.0) &#123; &#125; Disc_quote(const std::string&amp; book, double price, std::size_t qty, double disc): Quote(book, price), quantity(qty), discount(disc) &#123; &#125; double net_price(std::size_t) const = 0; std::pair&lt;size_t, double&gt; discount_policy() const &#123; return std::make_pair(quantity, discount); &#125;protected: std::size_t quantity; // purchase size for the discount to apply double discount; // fractional discount to apply&#125;; 基类通常应该定义一个虚析构函数。即使该函数不执行任何实际操作也是如此。 基类通过在其成员函数的声明语句之前添加关键字virtual使得该函数执行动态绑定。 如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。 继承自多个基类的类，基类以逗号分隔。 派生类的作用域嵌套在积累的作用域之内。 派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。 派生类的声明中包含类名，但不包含他的派生列表。 防止继承发生的办法，在类名后加一个关键字final。 我们可以把基类的指针或引用绑定到派生类的对象上。这意味着，当使用基类的引用（或指针）时，我们并不清楚该引用（或指针）所绑定对象的真是类型。 智能指针类也支持派生类向基类的类型转。 不存在基类向派生类的隐式转换 从基类向派生类的类型转换只对指针或引用类型有效。 派生类向基类的类型转换也可能会由于访问受限而变得不可行。 虚函数12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt; using namespace std; class A &#123; public: void foo() &#123; printf(\"1\\n\"); &#125; virtual void fun() &#123; printf(\"2\\n\"); &#125; &#125;; class B : public A &#123; public: void foo() //隐藏：派生类的函数屏蔽了与其同名的基类函数 &#123; printf(\"3\\n\"); &#125; void fun() //多态、覆盖 &#123; printf(\"4\\n\"); &#125; &#125;; int main(void) &#123; A a; B b; A *p = &amp;a; p-&gt;foo(); //输出1 p-&gt;fun(); //输出2 p = &amp;b; p-&gt;foo(); //取决于指针类型，输出1 p-&gt;fun(); //取决于对象类型，输出4，体现了多态 return 0; &#125; 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 。 引入纯虚函数的原因： （1）为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 （2）在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。 虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。 虚函数是C++中用于实现多态的机制。核心理念就是通过基类访问派生类定义的函数。如果父类或者祖先类中函数func()为虚函数，则子类及后代类中，函数func()是否加virtual关键字，都将是虚函数。为了提高程序的可读性，建议后代中虚函数都加上virtual关键字。 一个派生类的函数如果覆盖了某个继承而来的虚函数，则他的形参类型必须与被他覆盖的虚函数完全一致。 派生类中虚函数的返回类型也必须与基类中的完全一致。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。 final说明符说明该函数不能被覆盖。 override说明符说明该函数应该覆盖基类的函数。如果没有正确覆盖，则会报错。 虚函数与默认实参如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。 如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使试运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。 如果基函数使用默认实参， 则基类和派生类中定义的默认实参最好一致。 回避虚函数机制1double undiscounted = baseP-&gt;Quote::neet_price(42); 何时用？通常是当一个派生类的虚函数调用它覆盖的积累的虚函数版本时。 访问控制与继承 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问权。 派生类成员函数或友元对基类成员的访问权限只与基类中的访问说明符有关。 派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限。 123456789101112131415161718192021222324class Base&#123;public: void pub_mem();protected: int prot_mem;private: char priv_mem; //private成员&#125;;struct Pub_Derv:public Base&#123; //正确：派生类能访问protected成员 int f() &#123;return prot_mem;&#125; //错误：private成员对于派生类来说是不可访问的 char g() &#123;return priv_mem;&#125;&#125;struct Priv_Derv:private Base&#123; //private不影响对基类的访问权限 int f1() const &#123;return prot_mem;&#125;&#125;Pub_Derv d1;Priv_Derv d2;d1.pub_mem(); //正确d2.pub_mem(); //错误:pub_mem在派生类中是private的 派生类向基类转换的可访问性 只有当D共有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或私有的，则用户代码不能使用该转换。 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接积累的类型转换对于派生类的成员和友元来说永远是可访问的。 如果D继承B的方式是公有的或受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。 友元与继承 不能继承友元关系；每个类负责控制各自成员的访问权限。 改变个别成员的可访问性改变派生类继承的某个名字的访问级别，通过使用using声明： 1234567891011121314class Base&#123;public: std::size_t size() const &#123;return n;&#125;protected: std::size_t n;&#125;class Derived:private Base&#123;public: //保留对象尺寸相关的成员的访问级别 using Base::size;protected: using Base::n;&#125; 虚函数的作用域12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using std::cout; using std::endl;class Base &#123;public: virtual int fcn();&#125;;int Base::fcn() &#123; cout &lt;&lt; \"Base::fcn()\" &lt;&lt; endl; return 0; &#125;class D1 : public Base &#123;public: // hides fcn in the base; this fcn is not virtual // D1 inherits the definition of Base::fcn() int fcn(int); // parameter list differs from fcn in Base virtual void f2(); // new virtual function that does not exist in Base&#125;;int D1::fcn(int) &#123; cout &lt;&lt; \"D1::fcn(int)\" &lt;&lt; endl; return 0; &#125;void D1::f2() &#123; cout &lt;&lt; \"D1::f2()\" &lt;&lt; endl; &#125;class D2 : public D1 &#123;public: int fcn(int); // nonvirtual function hides D1::fcn(int) int fcn(); // overrides virtual fcn from Base void f2(); // overrides virtual f2 from D1&#125;;int D2::fcn(int) &#123; cout &lt;&lt; \"D2::fcn(int)\" &lt;&lt; endl; return 0; &#125;int D2::fcn() &#123; cout &lt;&lt; \"D2::fcn()\" &lt;&lt; endl; return 0; &#125;void D2::f2() &#123; cout &lt;&lt; \"D2::f2()\" &lt;&lt; endl; &#125;int main()&#123; D1 dobj, *dp = &amp;dobj; dp-&gt;fcn(42); // ok: static call to D1::fcn(int) Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj; bp1-&gt;fcn(); // virtual call, will call Base::fcn at run time bp2-&gt;fcn(); // virtual call, will call Base::fcn at run time bp3-&gt;fcn(); // virtual call, will call D2::fcn at run time D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj; d1p-&gt;f2(); // virtual call, will call D1::f2() at run time d2p-&gt;f2(); // virtual call, will call D2::f2() at run time Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj; p2-&gt;fcn(42); // statically bound, calls D1::fcn(int) p3-&gt;fcn(42); // statically bound, calls D2::fcn(int) Base* bp = &amp;d1obj; D1 *dp1 = &amp;d2obj; D2 *dp2 = &amp;d2obj; dp1-&gt;fcn(10); // static call to D1::fcn(int) dp2-&gt;fcn(10); // static call to D2::fcn(int)&#125; 虚析构函数通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。 虚析构函数将组织合成移动操作。 派生类的拷贝控制成员默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，必须在派生类的构造函数初始化列表中显式地使用基类的拷贝（或移动）构造函数。 12345678class Base&#123;&#125;;class D:public Base&#123;public: D (const D&amp; d):Base(d) //拷贝基类成员 /* D的成员的初始值 */&#123;&#125; D (D&amp;&amp; d):Base(std::move(d)) //移动基类成员 /* D的成员的初始值 */&#123;&#125;&#125;; 派生类的赋值运算符必须显式地为其基类部分赋值 派生类析构函数只负责销毁由派生类自己分配的资源 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。 继承的构造函数类不能继承默认、拷贝和移动构造函数。派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。 12345678class Bulk_quote:public Disc_quote&#123;public: using Disc_quote::Disc_quote; //继承Disc_quote的构造函数 /* 等价于 Bulk_quote(const std::string&amp; book,double price):Disc_quote(book,price)&#123;&#125; */&#125;; 由于using声明语句不能指定explicit或constexper。所以基类是explicit或constexper的，那么派生类具有相同的属性。 当一个基类构造函数含有默认实参，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。 如果基类有几个构造函数，大多数情况下派生类会继承所有这些构造函数。除了两个例外：1.如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数不会被继承。2.默认、拷贝和移动构造函数不会被继承。 容器与继承在容器中放置指针而非对象16.模板与泛型编程定义模板模板类型参数类型参数前必须使用关键字class或typename，两者含义相同。 12345template &lt;typename T&gt; T foo(T* p)&#123; T tmp = *p; //... return tmp;&#125; 非类型模板参数非类型模板参数表示一个值而非一个类型。通过特定的类型名指定。 12345template&lt;unsigned N,unsigned M&gt;int compare(const char (&amp;p1)[N],const char (&amp;p2)[M])&#123; return strcmp(p1,p2);&#125; 函数模板和类模板成员函数的定义通常放在头文件中 类模板123456template &lt;typename T&gt; class Blob&#123; //...&#125;//实例化类模板Blob&lt;int&gt; ia; 定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。 12template &lt;typename T&gt;ret-type Blob&lt;T&gt;::member-name(parm-list) 当我们使用一个类模板类型时，必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。 模板类型别名123456typedef Blob&lt;string&gt; StrBlob;//新标准template&lt;typename T&gt; using twin = pair&lt;T,T&gt;;twin&lt;string&gt; authors; //authors是一个pair&lt;string,string&gt; C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望通过一个模板类型参数的类型成员，就必须显式告诉编译器改名字是一个类型。通过使用关键字typename来实现： 12345678template &lt;typename T&gt;typename T::value_type top(const T&amp; c)&#123; if (!c.empty()) return c.back(); else return typename T::value_type();&#125; 默认模板实参无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参，就必须在模板名之后跟一个尖括号对： 123456789template&lt;class T=int&gt; class Number&#123; public: Numbers(T v=0):val(v)&#123;&#125; private: T val;&#125;Numbers&lt;long double&gt; lots_of_precision;Numbers&lt;&gt; average_precision; //空表示希望使用默认类型 成员模板一个类可以包含本身是模板的成员函数。这种成员被称为成员模板。成员模板不能是虚函数。 与类模板的普通函数成员不同，成员模板是函数模板。当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。 1234template &lt;typename T&gt;template &lt;typename It&gt; Blob&lt;T&gt;::Blob&lt;It b, It e: data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b,e))&#123;&#125; 控制实例化在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显式实例化避免这种开销： 123456extern template declaration; //实例化声明template declaration; //实例化定义//例子extern template class Blob&lt;string&gt;; //声明template int compare(const int &amp;, const int&amp;); //定义 对于一个给定的实例化版本，可能有多个声明，但只能有一个定义。","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"}]},{"title":"统计学习方法笔记","slug":"统计学习方法笔记","date":"2019-12-31T06:12:06.000Z","updated":"2021-02-19T02:26:07.185Z","comments":true,"path":"2019/12/31/统计学习方法笔记/","link":"","permalink":"https://sjtu-xx.github.io/2019/12/31/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"感知机算法（P40）","text":"感知机算法（P40） 算法的收敛性由Novikoff定理证明（P42） 1234567891011121314151617181920212223242526272829# 元素乘法：np.multiply(a,b)# 矩阵乘法：np.dot(a,b) 或 np.matmul(a,b) 或 a.dot(b)# 唯独注意：*，在 np.array 中重载为元素乘法，在 np.matrix 中重载为矩阵乘法!# 感知机（原始形式）import numpy as npX = [np.matrix([3,3,1]).T, np.matrix([4,3,1]).T, np.matrix([1,1,1]).T]Y = [1,1,-1]w = np.zeros(2)w = np.r_[w,0].reshape((3,1))l_r = 1def sign_result(ww,xx,yy): return np.sum(w.T*x)*yywhile True: flag = True for x,y in zip(X,Y): result = sign_result(w,x,y) if result&lt;=0: w = w + l_r * y * x flag = False continue if flag: breakprint(w) 朴素贝叶斯法先验概率：结果事件发生的概率通过学习先验概率和条件概率分布，预测后验概率。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://sjtu-xx.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://sjtu-xx.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"docker","slug":"docker","date":"2019-12-28T12:48:48.000Z","updated":"2021-02-19T02:26:06.404Z","comments":true,"path":"2019/12/28/docker/","link":"","permalink":"https://sjtu-xx.github.io/2019/12/28/docker/","excerpt":"思维导图 docker简介","text":"思维导图 docker简介 几个重要的概念，镜像（image），容器（container），仓库（repository） Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。image 文件生成的容器实例，本身也是一个文件，称为镜像文件。一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。 docker的安装mac下docker的安装直接在www.docker.com下载dmg安装包进行安装新版本需要账号（用户名xiaobais）速度过慢可以在下一节中的阿里云镜像加速器中获取 hello-world阿里云镜像加速 dev.aliyun.com进行登录 在服务中搜索-》容器镜像服务 镜像中心-》镜像加速器 按照对应的教程进行 docker为什么比虚拟机快(1)docker有着比虚拟机更少的抽象层。(2)docker利用的是宿主机的内核,而不需要Guest OS。 docker常用命令docker帮助命令123docker versiondocker infodocker --help docker镜像命令 docker images列出本地的镜像模板 Options-a 列出本地的所有镜像-q 只显示对象的ID—digests: 显示对象的摘要信息—no-trunc: 显示完整的信息 docker search Options-s 列出点赞数不小于指定值的镜像-no-trunc docker pull 《镜像名》 Optionsdocker pull 镜像名 等价于 docker pull 镜像名:lastestdocker pull 镜像名[:TAG] docker rmi Options删除单个镜像 docker rmi -f 镜像名删除多个镜像 docker rmi -f 镜像名:TAG 镜像名2:TAG删除全部 dockr rmi -f $(docker images -qa) docker容器命令 新建并启动容器docker run [OPTIONS] IMAGE [COMMAND][ARG...]docker run -it IMAGE 启用交互式容器 OPTIONS—name=”容器的新名字”：为容器制定一个名称 -i：以交互模式运行容器，通常与 -t 同时使用；-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；-d: 后台运行容器，并返回容器ID，也即启动守护式容器；-P: 随机端口映射；-p: 指定端口映射，有以下四种格式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort 列出所有正在运行的容器docker ps OPTIONS说明（常用）：-a :列出当前所有正在运行的容器+历史上运行过的-l :显示最近创建的容器。-n：显示最近n个创建的容器。-q :静默模式，只显示容器编号。—no-trunc :不截断输出。 启动容器docker start 重启容器docker restart 停止容器docker stop 强制停止容器docker kill 删除已停止容器docker rm删除多个容器 docker rm -f $(docker ps -a -q) docker ps -a -q |xargs docker rm 重要 启用守护式容器 docker run -d IMAGE 后台运行就会自动退出docker run -d mycentos /bin/sh -c &quot;while true;do echo hello xx;sleep 2;done&quot; 查看容器日志 docker logs -f -t --tail 容器id 查看容器内进程 docker top 查看容器内部细节 docker inspect 进入正在运行的容器并以命令行交互 进入容器 docker attach 容器id 在容器中执行命令docker exec -it 容器id COMMAND 在容器中执行命令并以命令行交互 docker exec -it 容器id /bin/bash 此时使用exit退出容器并不会关闭容器 将容器内数据拷贝到主机上 docker cp 容器id:地址 本地地址 提交容器副本，使之成为新的镜像docker commitdocker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 要创建的镜像的名称:[标签名] docker命令总结 attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像 build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像 commit Create a new image from a container changes # 提交当前容器为新的镜像 cp Copy files/folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中 create Create a new container # 创建一个新的容器，同 run，但不启动容器 diff Inspect changes on a container’s filesystem # 查看 docker 容器变化 events Get real time events from the server # 从 docker 服务获取容器实时事件 exec Run a command in an existing container # 在已存在的容器上运行命令 export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ] history Show the history of an image # 展示一个镜像形成历史 images List images # 列出系统当前镜像 import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export] info Display system-wide information # 显示系统相关信息 inspect Return low-level information on a container # 查看容器详细信息 kill Kill a running container # kill 指定 docker 容器 load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save] login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器 logout Log out from a Docker registry server # 从当前 Docker registry 退出 logs Fetch the logs of a container # 输出当前容器日志信息 port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口 pause Pause all processes within a container # 暂停容器 ps List containers # 列出容器列表 pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器 restart Restart a running container # 重启运行的容器 rm Remove one or more containers # 移除一个或者多个容器 rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] run Run a command in a new container # 创建一个新的容器并运行一个命令 save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load] search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像 start Start a stopped containers # 启动容器 stop Stop a running containers # 停止容器 tag Tag an image into a repository # 给源中镜像打标签 top Lookup the running processes of a container # 查看容器中运行的进程信息 unpause Unpause a paused container # 取消暂停容器 version Show the docker version information # 查看 docker 版本号 wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值 docker镜像镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。UnionFS(联合文件系统)UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。docker镜像加载 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 docker容器数据卷docker容器数据卷目的是将容器产生的数据进行持久化卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷 特点：1：数据卷可在容器之间共享或重用数据2：卷中的更改可以直接生效3：数据卷中的更改不会包含在镜像的更新中4：数据卷的生命周期一直持续到没有容器使用它为止 数据卷 容器内添加docker run -it -v /宿主机目录:/容器内目录 镜像名 /bin/bashdocker run -it -v /宿主机目录:/容器内目录:ro 镜像名 /bin/bash 容器内目录只读read only DockerFile添加VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]12345# volume testFROM centosVOLUME [&quot;&#x2F;dataVolumeContainer1&quot;,&quot;&#x2F;dataVolumeContainer2&quot;]CMD echo &quot;finished,--------success1&quot;CMD &#x2F;bin&#x2F;bash docker build -f dockerfile -t newcentos .对应的宿主机上的卷地址可以通过docker inspect newcentos Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied解决办法：在挂载目录后多加一个—privileged=true参数即可 数据卷容器命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器容器见传递共享--volumes-from docker run -it --name doc2 --volume-from doc1 centos容器之间配置信息传递，数据卷的生命周期一直持续到没有容器使用他为止。 DockerFile解析构建三步骤编写dockerfile - &gt; docker build - &gt; docker run 内容基础 每条保留字命令都必须为大写字母且后面要跟随至少一个参数 表示注释 每条指令都会创建一个新的镜像层进行提交 docker执行dockerfile的大致流程 docker从基础镜像运行一个容器 执行一条指令并对容器进行修改 执行类似commit的操作提交一个新的镜像层 docker再基于刚提交的镜像运行一个新容器 执行dockerfile中的下一条指令直到所有指令都执行完成 docker保留字指令 FROM: 基础镜像，当前的新镜像基于哪个镜像 MAINTAINER：镜像维护者姓名和邮箱 RUN：容器构建时需要运行的命令 EXPOSE：当前容器对外暴露出的端口 WORKDIR：指定在创建容器后，终端默认登陆进来的工作目录 ENV：用来在构建镜像过程中设置环境变量 ADD：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包 COPY：类似ADD,拷贝文件和目录到镜像中，将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置 VOLUME：容器数据卷，用于数据保存与持久化工作 CMD：指定一个容器启动时要执行的命令。dockerfile可以有多个CMD命令，但只有最后一个生效，CMD会被docker run后的参数替换 ENTRYPOINT：指定一个容器启动时要运行的命令。会追加参数 ONBUILD：当构建一个被继承的dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发 将镜像发布到阿里云dev.aliyun.com创建仓库在仓库中的管理按钮中查看帮助文档即可123sudo docker login --username&#x3D; registry.cn-xxx.aliyuncs.comsudo docker tag [Imageid] resgistry.cn-xxx.aliyuncs.com&#x2F;xasdf&#x2F;asdff:[镜像版本号]sudo docker push registry.cn-xxx.aliyuncs.com&#x2F;xasdf&#x2F;asdff:[镜像版本号]","categories":[{"name":"CODE工具","slug":"CODE工具","permalink":"https://sjtu-xx.github.io/categories/CODE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://sjtu-xx.github.io/tags/docker/"}]},{"title":"mac内置python环境","slug":"mac内置python环境","date":"2019-12-28T12:09:24.000Z","updated":"2021-02-19T02:26:06.532Z","comments":true,"path":"2019/12/28/mac内置python环境/","link":"","permalink":"https://sjtu-xx.github.io/2019/12/28/mac%E5%86%85%E7%BD%AEpython%E7%8E%AF%E5%A2%83/","excerpt":"","text":"防止与anaconda中的环境冲突设置alias在~/.bash_profile(如果使用zsh需要在~/.zshrc中)中添加alias python_mac=&quot;/usr/local/Cellar/python/3.7.5/bin/python3&quot;然后通过python_mac安装包python_mac -m pip install scikit-image","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"应用","slug":"Python/应用","permalink":"https://sjtu-xx.github.io/categories/Python/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"}]},{"title":"将vim配制成顺手的python轻量IDE","slug":"将vim配制成顺手的python轻量IDE","date":"2019-12-10T08:18:00.000Z","updated":"2021-02-19T02:26:06.913Z","comments":true,"path":"2019/12/10/将vim配制成顺手的python轻量IDE/","link":"","permalink":"https://sjtu-xx.github.io/2019/12/10/%E5%B0%86vim%E9%85%8D%E5%88%B6%E6%88%90%E9%A1%BA%E6%89%8B%E7%9A%84python%E8%BD%BB%E9%87%8FIDE/","excerpt":"原链接：https://www.jianshu.com/p/f0513d18742a","text":"原链接：https://www.jianshu.com/p/f0513d18742a 基础配置vim的配置在~/vimrc中完成一些常见的配置1234567891011121314151617181920212223242526272829303132333435363738&quot;去掉vi的一致性&quot;set nocompatible&quot;显示行号&quot;set number&quot; 隐藏滚动条&quot; set guioptions-&#x3D;r set guioptions-&#x3D;Lset guioptions-&#x3D;b&quot;隐藏顶部标签栏&quot;set showtabline&#x3D;0&quot;设置字体&quot;set guifont&#x3D;Monaco:h13 syntax on &quot;开启语法高亮&quot;let g:solarized_termcolors&#x3D;256 &quot;solarized主题设置在终端下的设置&quot;set background&#x3D;dark &quot;设置背景色&quot;colorscheme solarizedset nowrap &quot;设置不折行&quot;set fileformat&#x3D;unix &quot;设置以unix的格式保存文件&quot;set cindent &quot;设置C样式的缩进格式&quot;set tabstop&#x3D;4 &quot;设置table长度&quot;set shiftwidth&#x3D;4 &quot;同上&quot;set showmatch &quot;显示匹配的括号&quot;set scrolloff&#x3D;5 &quot;距离顶部和底部5行&quot;set laststatus&#x3D;2 &quot;命令行为两行&quot;set fenc&#x3D;utf-8 &quot;文件编码&quot;set backspace&#x3D;2set mouse&#x3D;a &quot;启用鼠标&quot;set selection&#x3D;exclusiveset selectmode&#x3D;mouse,keyset matchtime&#x3D;5set ignorecase &quot;忽略大小写&quot;set incsearchset hlsearch &quot;高亮搜索项&quot;set noexpandtab &quot;不允许扩展table&quot;set whichwrap+&#x3D;&lt;,&gt;,h,lset autoreadset cursorline &quot;突出显示当前行&quot;set cursorcolumn &quot;突出显示当前列&quot; 插件安装bundle 下载源码git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 在vim中添加配置1234567filetype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin '你的插件'call vundle#end()filetype plugin indent on 使用vundle安装插件方法。现在.vimrc中添加plugin命令：12“这是安装Github上的插件”Plugin &#39;Lokaltog&#x2F;vim-powerline&#39; YCM的安装和使用YCM的安装 brew install cmake cd ~/.vim/bundle git clone https://github.com/Valloric/YouCompleteMe.git cd ~/.vim/bundle/YouCompleteMe git submodule update --init --recursive /usr/local/Cellar/python/3.7.5/bin/python3.7 ./install.py --all 使得YCM支持第三方库由于vim不支持anaconda中的python，所以决定在系统python 环境中安装第三方库，并使得YCM支持安装的第三方库的自动补全。 YCM使用的python解释器路径在~/.vim/bundle/YouCompleteMe/third_party/ycmd/PYTHON_USED_DURING_BUILDING下，我这里的文件内容为/usr/local/opt/python/bin/python3.7 因为不确定系统的第三方库的安装位置，尝试进行安装：sudo /usr/local/opt/python/bin/python3.7 -m pip install numpy如果numpy已经安装则会出现提示：Requirement already satisfied: python-dateutil&gt;=2.6.1 in /usr/local/lib/python3.7/site-packages (from pandas) (2.8.1)所以我们就可以发现第三方库的安装路径为/usr/local/lib/python3.7/site-packages 为了支持第三方库，在vim ~/.vim/bundle/YouCompleteMe/.ycm_extra_conf.py添加： 1234def PythonSysPath( **kwargs ): ....... sys_path.insert(1,'/usr/local/lib/python3.7/site-packages') # 值为python安装第三方库的路径 return sys_path","categories":[{"name":"CODE工具","slug":"CODE工具","permalink":"https://sjtu-xx.github.io/categories/CODE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://sjtu-xx.github.io/tags/vim/"}]},{"title":"hexo博客备份","slug":"hexo博客备份","date":"2019-12-09T07:19:03.000Z","updated":"2021-02-19T02:26:06.416Z","comments":true,"path":"2019/12/09/hexo博客备份/","link":"","permalink":"https://sjtu-xx.github.io/2019/12/09/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/","excerpt":"备份步骤","text":"备份步骤 在博客仓库创建分支hexo（或其他） 设置hexo为默认分支 创建.gitignore文件文件内容：1234567.DS_StoreThumbs.dbdb.json*.lognode_modules&#x2F;public&#x2F;.deploy*&#x2F; 4.上传至github123git add .git commit -m \"blabla\"git push origin hexo hexo g -d 发布博客 恢复步骤 git clone https://github.com/sjtu-xx/sjtu-xx.github.io.gito 在克隆的文件夹下输入npm install hexo-cli,npm install,npm install hexo-deployer-git","categories":[{"name":"其他工具","slug":"其他工具","permalink":"https://sjtu-xx.github.io/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sjtu-xx.github.io/tags/hexo/"}]},{"title":"vim操作记录","slug":"vim操作记录","date":"2019-12-09T02:26:22.000Z","updated":"2021-02-19T02:26:06.722Z","comments":true,"path":"2019/12/09/vim操作记录/","link":"","permalink":"https://sjtu-xx.github.io/2019/12/09/vim%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/","excerpt":"通过命令行输入vimtutor打开教程","text":"通过命令行输入vimtutor打开教程 命令解释12345678910111213141516171819202122232425262728Many commands that change text are made from an operator and a motion.The format for a delete command with the d delete operator is as follows: d motionWhere: d - is the delete operator. motion - is what the operator will operate on (listed below).A short list of motions: w - until the start of the next word, EXCLUDING its first character. e - to the end of the current word, INCLUDING the last character. $ - to the end of the line, INCLUDING the last character.Thus typing de will delete from the cursor to the end of the word. Lesson 2.4: USING A COUNT FOR A MOTION ** Typing a number before a motion repeats it that many times. **1. Move the cursor to the start of the line marked ---&gt; below.2. Type 2w to move the cursor two words forward.3. Type 3e to move the cursor to the end of the third word forward.4. Type 0 (zero) to move to the start of the line. 光标移动 ^ k Hint: The h key is at the left and moves left. &lt; h l &gt; The l key is at the right and moves right. j The j key looks like a down arrow. v 退出123&lt;ESC&gt;:q # 退出:wq # 退出并保存 删除1234x # 删除单个字符dw # 删除从当前字母开始到结束的单词d$ # 删除从当前字母到行末的内容ndd # 删除n行 插入123a # 在后面添加i # 在前面插入p # 粘贴 撤销123u # 撤销一步U # 返回当前行的初始状态ctrl+R #撤销undo 光标位置1234nG # 移动到某一行G # 移动到末尾gg # 移动到开头Ctrl-G 显示当前位置 查找1234567891011121314&#x2F;word 查找word查找后按n可以继续查找下一个，N向相反的方向查找在相反方向查找使用？代替&#x2F;CTRL-o 返回到上一个位置CTRL-i 进入到下一个位置光标指向（，[,&#123;按下%可以跳转到),],&#125;位置替换:s&#x2F;old&#x2F;new &lt;ENTER&gt; # 替换第一个old出现的位置:s&#x2F;old&#x2F;new&#x2F;g # 替换当前行global出现的位置:#,#s&#x2F;old&#x2F;new&#x2F;g # 替换#行和#行之间的old:%s&#x2F;old&#x2F;new&#x2F;g #替换当前文件所有出现的old:%s&#x2F;old&#x2F;new&#x2F;gc #查找所有出现的位置，不确定是否替换c confirmation 执行外部命令1:! COMMAND 可以执行命令 选择行12按住v 进行选择选择行后，按下:, 然后 w &lt;FILENAME&gt; 保存选中的部分 插入文件12:r FILENAME 将文件内容插入到下方:r !ls 将ls执行结果插入到文件下方 插入123o 在当前行下方新建行，进入插入模式O 在当前行下方新建行，进入插入模式a 在后方插入 复制粘贴12y 复制yankp 粘贴paste 查找设置123:set ic # ignore case:set noic # 关闭:set hlsearch # 高亮 多行缩紧12方法1: v 进入视图模式后，选择多行，然后按&gt;方法2: 输入:21,324&gt; 将21到324行进行缩进 复制文件中的某些行1234:5,10 w&gt;&gt; filename 将本文件中的某些行复制到filename中:5,10 w! filename 将文件中的某些行复制到filename中，覆盖原来的内容&quot;+100yy 复制100行到系统的剪切板（+寄存器） 替换^M123vim下 :%s&#x2F;^M&#x2F;&#x2F;g 或者 :1,$s&#x2F;^M&#x2F;&#x2F;g 均可补充一点：^M是使用 &quot;CTRL-V CTRL-M&quot; 而不是字面上的 ^M 修改括号中的内容12ci&quot; 修改引号中的内容di&quot; 删除引号中的内容","categories":[{"name":"CODE工具","slug":"CODE工具","permalink":"https://sjtu-xx.github.io/categories/CODE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://sjtu-xx.github.io/tags/vim/"}]},{"title":"leetcode记录","slug":"leetcode记录","date":"2019-12-02T11:17:32.000Z","updated":"2021-02-19T02:26:06.493Z","comments":true,"path":"2019/12/02/leetcode记录/","link":"","permalink":"https://sjtu-xx.github.io/2019/12/02/leetcode%E8%AE%B0%E5%BD%95/","excerpt":"题目记录题51.八皇后问题","text":"题目记录题51.八皇后问题 解题思路：可以理解为一个坐标系，0，0是原点，N*N里面的每个点有两个函数，斜率分别是1，-1，（y=-x+b, y=-x+b）xy_sum中记录的是y=x+b里面的b xy_dif记录的是y=-x+b里面的b 如果之后的点里面有相同的元素在这两个列表里面就说明在这条线上已经有另一个皇后在了。 代码12345678910111213141516class Solution: def solveNQueens(self, n: int) -&gt; List[List[str]]: def DFS(queens:List[int],xy_dif:List[int],xy_sum:List[int]): q = len(queens) # 终止条件 if len(queens) == n: result.append(queens) return for p in range(n): if p not in queens and q-p not in xy_dif and q+p not in xy_sum: DFS(queens+[p],xy_dif+[q-p],xy_sum+[q+p]) result = [] DFS([],[],[]) return [[\".\"*i+\"Q\"+\".\"*(n-i-1) for i in sol] for sol in result] 题49.字母异位词分组 python中的集合操作符S | T 返回一个新的集合，包括在集合S和T的所有元素S - T 返回一个新集合，包括在集合S但不在T中的元素S &amp; T 返回一个新集合，包括同时在集合S和T中的元素S ^ T 返回一个新集合， 包括集合S和T中非相同元素S &lt;= T 或 S &lt; T 返回True/False， 判断S和T的子集关系S &gt;= T 或 S &gt; T 返回True/False， 判断S和T的包括关系 解法：12345678910111213141516171819202122232425#方法1class Solution(object): def groupAnagrams(self, strs): \"\"\" :type strs: List[str] :rtype: List[List[str]] \"\"\" dic = &#123;&#125; for s in strs: dic[tuple(sorted(s))] = dic.get(tuple(sorted(s)), []) + [s] return dic.values()# 方法2class Solution(object): def groupAnagrams(self, strs): \"\"\" :type strs: List[str] :rtype: List[List[str]] \"\"\" dic = &#123;&#125; for s in strs: count = [0] * 26 for c in s: count[ord(c) - ord('a')] += 1 dic[tuple(count)] = dic.get(tuple(count), []) + [s] return dic.values() 题891. 子序列宽度之和 知识点快慢指针快慢指针法判断循环：快指针每次前进2步，慢指针每次1步，如果快指针指向None表示不存在循环，如果慢指针追上快指针，表示存在循环。 异或操作按位进行异或操作的性质： 如果a、b两个值不相同，则异或结果为1(不同的位为1)。如果a、b两个值相同，异或结果为0（这里假设a、b 只能包含 1、0 两值，但别忘了，每个比特恰好是表示零和一的。也可以这么说：真 xor 假 = 真；真 xor 真 = 假；假 xor 假 = 假）。 满足交换律。 即：有a、b不等两值a xor a = 0b xor 0 = b所以：(a xor a) xor b = a xor b xor a = b xor 0 = b 二分查找 (1)传统二分法查找的问题mid = (left+right)//2如果left和right较大，可能会出现溢出问题为了避免溢出应当写为mid=left+(right-left)//2更好的写法是mid=(left+right)&gt;&gt;&gt;1 无符号右移，在python中不存在无符号右移(2)避免边界问题传统写法while(left&lt;=right)需要考虑退出循环时返回的是left还是right 注意事项 考虑左右边界，如果target不在目标数组的范围内，则会报错 当数组元素个数是偶数个时，存在左中位数和右中位数；当数组元素个数是奇数时，则只存在确定的中位数。 分治法在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 这个技巧是很多高效算法的基础，如排序算法、傅立叶变换。 贪心法贪心算法（英語：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。 比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。 回溯算法回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 python中的操作python中sort的实现算法timsorthttps://www.cnblogs.com/clement-jiao/p/9243066.html#_label1 python中哈希表的时间复杂符散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。 python中的位操作1234x &lt;&lt; yReturns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is the same as multiplying x by 2**y.x &gt;&gt; yReturns x with the bits shifted to the right by y places. This is the same as //'ing x by 2**y. python中的无穷大python中不存在直接的无穷大表示，但可以通过float(&#39;inf&#39;)来创建，可以使用isinf()来验证 python中生成器和迭代器的联合使用1234yield from generator#等价于for i in generator: yield i python中的字符编码12ord(\"A\") #将A转换为整数chr(123) #将整数转换为字符","categories":[{"name":"算法","slug":"算法","permalink":"https://sjtu-xx.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://sjtu-xx.github.io/tags/leetcode/"},{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://sjtu-xx.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"}]},{"title":"mac/linux常用命令","slug":"mac-linux常用命令","date":"2019-11-29T03:08:02.000Z","updated":"2021-02-19T02:26:06.523Z","comments":true,"path":"2019/11/29/mac-linux常用命令/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/29/mac-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"查看指定端口占用，并杀死对应进程","text":"查看指定端口占用，并杀死对应进程 12lsof: -i:80 #-i表示网络连接，80指明端口号，该命令会同时列出PIDkill -9 1863 # 杀掉pid=1863的进程","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sjtu-xx.github.io/categories/Linux/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://sjtu-xx.github.io/tags/mac/"},{"name":"linux","slug":"linux","permalink":"https://sjtu-xx.github.io/tags/linux/"},{"name":"命令","slug":"命令","permalink":"https://sjtu-xx.github.io/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"Abaqus后处理常用技术","slug":"Abaqus后处理常用技术","date":"2019-11-28T09:00:52.000Z","updated":"2021-02-19T02:26:05.798Z","comments":true,"path":"2019/11/28/Abaqus后处理常用技术/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/28/Abaqus%E5%90%8E%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/","excerpt":"后处理","text":"后处理 保存图片File -&gt; Print -&gt; 查看指定增量步的结果Result -&gt; Step/Frame 创建显示组Tools-&gt; Display Group -&gt; Create 显示窗口widget设置Viewport-&gt;Viewport Annotion options-&gt; 后处理不显示网格Options -&gt; Common -&gt; 设置透明背景 View-&gt;graphic options 设置超出设定范围的colorbar颜色Options-&gt; Contour -&gt;Spectrum-&gt;Greater than max; abaqus多图层绘制 打开odb后处理文件，将图层创建好之后设置好图片的各种参数，然后在View-&gt;Overlay Plot-&gt;create创建图层 点击右侧的plot overlay可以将图层混合。 如果需要进行对某个图层进行修改，在窗口勾选对应图层的Current。然后进行修改。 abaqus导出清晰的后处理图片abaqus在print-&gt;选择PS/EPS可以直接设定分辨率导出，但是导出的效率极低。使用PNG即使导出高像素，图片仍然模糊。TIFF格式设置像素最大值为2730px，则可以导出较为清晰的图片 导出的图片的字体，Arial较为合适，Times在缩放后较为模糊。 导出Mises和PEEQ记录 打开cae文件，设置只显示viewport中的legend,legend-&gt;setFont-&gt;arial(大小12) options -&gt; common -&gt; free edges Mises stress -&gt; 设置上下限(0-1e9)颜色 -&gt; spectrum min/max PEEQ -&gt; 上下限制(0-1.390) 选择增量步no gnd(21,34,77) ff20(14,18,25) print-&gt; tiff-&gt;关闭reduceto256的选项-&gt; width(2730) 导出expansion的记录选择0.2F和0.5F 打开cae文件，设置只显示viewport中的legend,legend-&gt; setFont-&gt; arial(大小12) options -&gt; common -&gt; free edges Tools -&gt; display group -&gt; create-&gt; ferrite mises limit (1.552e7-3.504e8) peeq limit(0-0.15) contour view -&gt; overlay plot -&gt; create -&gt; shape view -&gt; overlay plot -&gt; create","categories":[{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"}],"tags":[{"name":"Abaqus","slug":"Abaqus","permalink":"https://sjtu-xx.github.io/tags/Abaqus/"},{"name":"后处理","slug":"后处理","permalink":"https://sjtu-xx.github.io/tags/%E5%90%8E%E5%A4%84%E7%90%86/"}]},{"title":"leetcode(1-10)记录","slug":"leetcode-1-10-记录","date":"2019-11-27T13:50:55.000Z","updated":"2021-02-19T02:26:06.492Z","comments":true,"path":"2019/11/27/leetcode-1-10-记录/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/27/leetcode-1-10-%E8%AE%B0%E5%BD%95/","excerpt":"题目1-7为之前做过的题目，这里不再记录 8. 字符串转换整数 (atoi)","text":"题目1-7为之前做过的题目，这里不再记录 8. 字符串转换整数 (atoi) 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: “42”输出: 42示例 2: 输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3: 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。示例 4: 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。示例 5: 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解决思路由于python中不存在字符限制，可以使用正则表达式进行解决 解决方法123class Solution: def myAtoi(self, s: str) -&gt; int: return max(min(int(*re.findall('^[\\+\\-]?\\d+', s.lstrip())), 2**31 - 1), -2**31)","categories":[{"name":"算法","slug":"算法","permalink":"https://sjtu-xx.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://sjtu-xx.github.io/tags/leetcode/"}]},{"title":"Matplotlib绘图案例","slug":"Matplotlib绘图案例","date":"2019-11-27T09:01:00.000Z","updated":"2021-02-19T02:26:06.284Z","comments":true,"path":"2019/11/27/Matplotlib绘图案例/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/27/Matplotlib%E7%BB%98%E5%9B%BE%E6%A1%88%E4%BE%8B/","excerpt":"绘图数据处理绘图时对数据进行三次样条插值：","text":"绘图数据处理绘图时对数据进行三次样条插值： 123456789import matplotlib.pyplot as pltfrom scipy.interpolate import BSpline,make_interp_spline#....省略数据读取xnew = np.linspace(np.min(x_data), np.max(x_data), 300)spl = make_interp_spline(x_data, y_data, k=3) # type: BSplineynew = spl(xnew)plt.plot(xnew,ynew) 中文字体支持windows：1234import matplotlib.pyplot as plt# 设置新罗马字体plt.rcParams['font.sans-serif']=['SimHei'] #中文plt.rcParams['axes.unicode_minus']=False #负号mac:1234567891011121314151617181920### 使用mac自带的中文字体，不推荐import numpy as npimport matplotlib.pyplot as pltplt.rcParams['font.sans-serif'] = ['Arial Unicode MS']### 使用simhei# 1. 安装simhei https://www.fontpalace.com/font-details/SimHei/# 2. 执行rebuild from matplotlib.font_manager import _rebuild_rebuild() #reload一下# 3. 使用plt.rcParams['font.sans-serif']=['SimHei'] #中文plt.rcParams['axes.unicode_minus']=False #负号# 查看可用字体from matplotlib.font_manager import FontManagerfm = FontManager()mat_fonts = set(f.name for f in fm.ttflist)print mat_fonts 一般折线图的绘制123456789101112131415161718192021222324252627282930313233from pylab import mplmpl.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题import matplotlib.pyplot as plt# 设置新罗马字体plt.rc('font',family='Times New Roman')plt.rcParams['font.sans-serif']=['SimHei'] #中文plt.rcParams['axes.unicode_minus']=False #负号# 省略读取部分fig,ax = plt.subplots()ax.plot(x_data,y_data,label=\"线标签\") #添加标签ax.set_title(r\"$\\sigma-\\epsilon$\") #设置图表名称 latex设置在r‘’中ax.set_xlabel(r\"$\\varepsilon$/%\") #设置x轴标签ax.set_ylabel(r\"$\\sigma$/MPa\") #设置y轴标签ax.set_xlim(0,8) #设置x轴范围ax.set_xticks([]) #关闭x坐标tickax.tick_params(direction='in',colors='black') #设置tick的参数 plt.legend() #显示标签（绘图时的label）# plt.legend(frameon=False,fontsize=8) #取消边框，设置大小plt.xticks(x,labels,rotation=70) #tick显示# plt.xticks([]) #关闭tickplt.axis(\"off\") #关闭坐标轴plt.savefig(result_name,dpi=600,bbox_inches='tight',format=\"png\") #保存图片# 保存tiff时防止文件大小过大# plt.savefig在保存tiff文件时，调用的是pil中的函数，但是并没有提供对应的参数接口# 在mpl 3.1.0版本新加入了设置pil.image参数的功能plt.savefig(\"color_grain.tiff\", dpi=1200, bbox_inches='tight', format=\"tiff\", transparent=True,pil_kwargs=&#123;\"compression\": \"tiff_lzw\"&#125;) # 当参数错误时会被自动忽略 # 其他压缩算法 https://imageio.readthedocs.io/en/stable/format_tiff-pil.htmlplt.show() #显示图片plt.cla() # Clear axisplt.clf() # Clear figureplt.close() # Close a figure window 直方图的绘制123456789101112131415# 对于dataframe中的数据，直接使用下面的代码df[\"column_name\"].hist(bins=20) # 对于pyplot，使用时存在nan值可能会报错# 方法1,选择非nanimport numpy as npimport matplotlib.pyplot as pltdata = [1,23,4214,12,4,124,1,24,np.nan]plt.hist(data[data is not np.nan])# 方法2，删除nanimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltdata = pd.Series([1,23,4214,12,4,124,1,24,np.nan])plt.hist(data.dropna()) 双y轴图片的绘制1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import numpy as npimport matplotlib.pyplot as pltfrom matplotlib import rcrc('mathtext', default='regular')time = np.arange(10)temp = np.random.random(10)*30Swdown = np.random.random(10)*100-10Rn = np.random.random(10)*100-10fig = plt.figure()ax = fig.add_subplot(111)ax.plot(time, Swdown, '-', label = 'Swdown')ax.plot(time, Rn, '-', label = 'Rn')ax2 = ax.twinx()ax2.plot(time, temp, '-r', label = 'temp')ax.legend(loc=0)ax.grid()ax.set_xlabel(\"Time (h)\")ax.set_ylabel(r\"Radiation ($MJ\\,m^&#123;-2&#125;\\,d^&#123;-1&#125;$)\")ax2.set_ylabel(r\"Temperature ($^\\circ$C)\")ax2.set_ylim(0, 35)ax.set_ylim(-20,100)ax2.legend(loc=0)plt.savefig('0.png') 调整legend框的位置fig.legend(loc=1, bbox_to_anchor=(1,1), bbox_transform=ax.transAxes) # 调整legend框的位置多个axes中legend的添加1234plot1 = ax1.plot() # listplot2 = ax2.plot() # listlines = plot1+plot2ax1.legend(lines,[l.get_label() for l in lines]) 结果： 给两色图片添加legend123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import numpy as npimport matplotlib.pyplot as pltimport osimport pylab as plot# 设置legend的label大小以及handle宽度params = &#123;'legend.fontsize': 12, 'legend.handlelength': 2&#125;plot.rcParams.update(params)from matplotlib.patches import RectangleRESULT_DIR = \"./result\"if not os.path.exists(RESULT_DIR): os.makedirs(RESULT_DIR, exist_ok=True)for png_name in os.listdir(\"./data\"): # 建立两个subplot，第二个来绘制legend no_color_img = plt.imread(os.path.join(\"./data\", png_name)) unique_value = np.unique(no_color_img, return_counts=True)[0] print(\"total_color_count:\", len(unique_value)) value_list = sorted(unique_value.tolist()) new_color_img = np.zeros_like(no_color_img) for index, pvalue in enumerate(value_list): new_color_img[no_color_img == pvalue] = index print(value_list) fig, ax = plt.subplots(1, 2) img_ax = ax[0] imgs = img_ax.imshow(new_color_img, cmap=plt.get_cmap(\"winter\", len(value_list))) img_ax.axis(\"off\") # handle的rgb颜色可以通过mac取色器获得 legend_ax = ax[1] if len(value_list) == 2: legend_data = [[0, [16, 255, 127], \"Ferrite\"], [1, [0, 5, 255], \"Martensite\"]] elif len(value_list) == 3: legend_data = [[0, [16, 255, 127], \"Ferrite\"], [1, [0, 5, 255], \"Martensite\"],[2, [0, 5, 255], \"Martensite\"]] handles = [ Rectangle((0, 0), 1, 1, color=[v / 255 for v in c]) for k, c, n in legend_data ] legend_ax.legend(handles, [n for k, c, n in legend_data], mode=\"expand\", ncol=1, frameon=False, loc=\"center\") legend_ax.axis(\"off\") plt.subplots_adjust(hspace=0, wspace=0) # plt.tight_layout() plt.savefig(os.path.join(RESULT_DIR, \"&#123;&#125;-color.tiff\".format(png_name)), dpi=1200, bbox_inches='tight', format=\"tiff\", transparent=True, pil_kwargs=&#123;\"compression\": \"tiff_deflate\"&#125;) plt.show() 内置的colorbar官方网站内置颜色 绘制网格图12345678910111213141516171819import matplotlib.pyplot as pltimport numpy as npfrom matplotlib.colors import LinearSegmentedColormapimage_array = np.eye(4) fig = plt.figure()ax = fig.gca() # Get the current axes, creating one if necessary.# 自定义colorbarcmap = LinearSegmentedColormap.from_list('mycmap', ['red', 'blue', 'green']) # colorbar为过渡渐变im = ax.imshow(image_array, cmap=cmap, vmin=0, vmax=2)plt.setp(ax.spines.values(), linewidth=2) # 设置上下左右边框的宽度plt.grid(True, color='black', linestyle='-', linewidth=2, axis=\"both\") #设置网格的属性（颜色和宽度等）plt.tick_params(direction='in') # 将tick朝内，隐藏plt.xticks([i + 0.5 for i in range(3)], visible=False) #设置网格线的位置plt.yticks([i + 0.5 for i in range(3)], visible=False)plt.savefig(\"grid1.png\", bbox_inches=\"tight\", dpi=600, transparent=True, format=\"png\") #保存图片plt.show() 执行结果： 曲线间的填充1234567891011121314# 对函数和坐标轴之间的区域进行填充x = np.linspace(0,100,1000)y = np.sin(x)plt.fill(x,y,color=\"g\",alpha=0.5)# 对函数之间的区域进行填充x = np.linspace(0,100,1000)y1 = np.sin(x)y2 = np.cos(x)plt.fill_between(x,y1,y2,facecolor=\"g\")plt.fill_between(x,y1,y2,where= y2&gt;=y1,facecolor=\"g\",interpolate=True) #interpolate将可能的空白区域进行填充 核密度估计图12345678import seaborn as snsfrom scipy.stats import *sns.kdeplot(x) #只有1D核密度估计图sns.kedplot(x,y) #2D核密度估计图sns.distplot(x,y) #核密度估计图+直方图sns.distplot(x,y,kde=False)sns.distplot(x,y,hist=False)sns.distplot(x,y,fit=norm) #正态分布 表格123456789data = pd.read_csv(\"11.csv\",index_col=0)plt.clf()fig, ax = plt.subplots()fig.patch.set_visible(False)ax.axis('off')ax.axis('tight')ax.table(cellText=data.values, colLabels=data.columns,rowLabels=data.index, loc='center')fig.tight_layout()plt.savefig(\"1.png\",dpi=600,bbox_inches=\"tight\",pad_inches=1) #防止保存时超出图片边界","categories":[{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://sjtu-xx.github.io/tags/matplotlib/"},{"name":"latex","slug":"latex","permalink":"https://sjtu-xx.github.io/tags/latex/"},{"name":"绘图","slug":"绘图","permalink":"https://sjtu-xx.github.io/tags/%E7%BB%98%E5%9B%BE/"}]},{"title":"github中的快速查找","slug":"github中的快速查找","date":"2019-11-26T08:20:28.000Z","updated":"2021-02-19T02:26:06.413Z","comments":true,"path":"2019/11/26/github中的快速查找/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/26/github%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE/","excerpt":"","text":"根据CodeSheep的视频进行总结：123456789in:name example &#x2F;&#x2F;名字中有“example”in:readme example &#x2F;&#x2F;readme中有“example”in:description example &#x2F;&#x2F;描述中有“example”stars:&gt;1000 star&gt;1000forks:&gt;1000 fork&gt;1000pushed:&gt;2019-09-01 &#x2F;&#x2F;2019年9月1日后有更新的language:java &#x2F;&#x2F;用Java编写的项目","categories":[{"name":"CODE工具","slug":"CODE工具","permalink":"https://sjtu-xx.github.io/categories/CODE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"github","slug":"github","permalink":"https://sjtu-xx.github.io/tags/github/"}]},{"title":"cmake基础（搬运）","slug":"cmake基础（搬运）","date":"2019-11-26T03:30:12.000Z","updated":"2021-02-19T02:26:06.402Z","comments":true,"path":"2019/11/26/cmake基础（搬运）/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/26/cmake%E5%9F%BA%E7%A1%80%EF%BC%88%E6%90%AC%E8%BF%90%EF%BC%89/","excerpt":"原链接 ref 1. 编译单目录工程1.创建工程文件夹 1234mkdir hello #工程目录cd hellomkdir src # 存放源代码的目录mkdir build # 存放编译中间代码和目标代码的目录","text":"原链接 ref 1. 编译单目录工程1.创建工程文件夹 1234mkdir hello #工程目录cd hellomkdir src # 存放源代码的目录mkdir build # 存放编译中间代码和目标代码的目录 2.进入src目录，编写一个main.c文件 1234567#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; printf(\"hello world\\n\"); return 0;&#125; 3.编写工程顶层目录的CMakeLists.txt 1234567cmake_minumum_required(VERSION 2.6)#指定项目名project(hello)#指定子目录add_subdirectory(src) 4.编写子目录src的CMakeLists.txt 123aux_source_directory(. SRC_LIST)add_executable(hello $&#123;SRC_LIST&#125;) 5.编译工程 1.进入build 目录 2.执行命令cmake ..创建Makefile 3.执行命令make编译工程 4.在build的子目录src生成了执行文件 2. 编译多目录工程1.创建工程目录 1234567mkdir hello # 工程目录cd hellomkdir src # 存放源码目录mkdir build # 存放编译产生的中间文件cd src mkdir hello # 存放hello 模块mkdir world # 存放world 模块 2.编写hello模块 进入hello目录 编写hello.h文件 123456#ifndef HELLO_H#define HELLO_Hvoid Hello_Print(void);#endif 编写hello.c文件 12345678#include \"hello.h\"#include &lt;stdio.h&gt;void Hello_Print(void)&#123; printf(\"hello \");&#125; 编写CMakeLists.txt 文件 123aux_source_directory(. DIR_HELLO_SRC)add_library(hello_lib $&#123;DIR_HELLO_SRC&#125;) 3.编写world模块 进入world目录 编写world.h文件 123456#ifndef WORLD_H#define WORLD_Hvoid World_Print(void);#endif 编写world.c文件 12345678#include \"world.h\"#include &lt;stdio.h&gt;void World_Print(void)&#123; printf(\"world\");&#125; 编写CMakeLists.txt 文件 123aux_source_directory(. DIR_WORLD_SRC)add_library(world_lib $&#123;DIR_WORLD_SRC&#125;) 4.编写主模块 进入src目录 编写main.c 文件 12345678910#include \"hello/hello.h\"#include \"world/world.h\"int main(int argc, char **argv)&#123; Hello_Print(); World_Print(); return 0&#125; 编写CMakeLists.txt 文件 123456789add_source_directory(. DIR_SRC)# 添加子目录add_subdirectory(hello)add_subdirectory(world)# 执行文件add_executable(hello_prj $&#123;DIR_SRC&#125;)target_link_libraries(hello_prj ello_lib world_lib) 5.编写顶层目录的CMakeLists.txt文件 12345cmake_minumum_required(VERSION 2.6)project(hello_prj)add_subdirectory(src) 3. 动态库和静态库的构建和使用1.使用一个hello world工程来展开说明 项目结构 12345678910111213141516|-- CMakeLists.txt|-- build|-- include| |-- hello| | `-- hello.h| `-- world| `-- world.h|-- src| |-- CMakeLists.txt| |-- hello| | `-- hello.c| `-- world| `-- world.c`-- test |-- CMakeLists.txt `-- mytest.c 2.顶层目录CMakeLists.txt 123456789101112131415161718192021222324252627282930313233343536373839cmake_minimum_required(VERSION 2.6)project(helloworld)#设置库文件存放路径set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/build/lib)#设置执行文件存放路径set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/build/bin)#获取当前目录及子目录(递归获取),添加到头文件搜索路径function(include_sub_directories_recursively root_dir) if (IS_DIRECTORY $&#123;root_dir&#125;) # 当前路径是一个目录吗，是的话就加入到包含目录 message(\"include dir: \" $&#123;root_dir&#125;) include_directories($&#123;root_dir&#125;) endif() file(GLOB ALL_SUB RELATIVE $&#123;root_dir&#125; $&#123;root_dir&#125;/*) # 获得当前目录下的所有文件，让如ALL_SUB列表中 foreach(sub $&#123;ALL_SUB&#125;) if (IS_DIRECTORY $&#123;root_dir&#125;/$&#123;sub&#125;) include_sub_directories_recursively($&#123;root_dir&#125;/$&#123;sub&#125;) # 对子目录递归调用，包含 endif() endforeach()endfunction()#项目的所有目录都为头文件搜索路径include_sub_directories_recursively($&#123;PROJECT_SOURCE_DIR&#125;)#添加库文件搜索路径link_directories( $&#123;PROJECT_SOURCE_DIR&#125;/build/lib )#添加子目录add_subdirectory(src)add_subdirectory(test)#设置安装目录set(CMAKE_INSTALL_PREFIX $&#123;PROJECT_SOURCE_DIR&#125;/install) 3.helloworld库的源代码 hello.h文件 123456#ifndef HELLO_H#define HELLO_Hvoid Hello_Print(void);#endif hello.c文件 12345678#include \"hello/hello.h\"#include &lt;stdio.h&gt;void Hello_Print(void)&#123; printf(\"hello \");&#125; world.h文件 123456#ifndef WORLD_H#define WORLD_Hvoid World_Print(void);#endif world.c文件 12345678#include \"world/world.h\"#include &lt;stdio.h&gt;void World_Print(void)&#123; printf(\"world\");&#125; 4.子目录src下的CMakeLists.txt 123456789101112131415161718192021#递归获取当前目录及子目录下的所有c文件file(GLOB_RECURSE c_files \"*.c\")#生成动态库和静态库add_library(helloworld_lib_shared SHARED $&#123;c_files&#125;)add_library(helloworld_lib_static STATIC $&#123;c_files&#125;)#将动态库和静态库的名字设置为一致set_target_properties(helloworld_lib_shared PROPERTIES OUTPUT_NAME \"helloworld\")set_target_properties(helloworld_lib_static PROPERTIES OUTPUT_NAME \"helloworld\")#设置动态库版本set_target_properties(helloworld_lib_shared PROPERTIES VERSION 1.2 SOVERSION 1)#安装动态库和静态库INSTALL(TARGETS helloworld_lib_shared helloworld_lib_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)#安装头文件INSTALL(DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/include/ DESTINATION include) 5.mytest.c文件测试生成的库文件 mytest.c文件 12345678910111213#include \"hello/hello.h\"#include \"world/world.h\"#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; Hello_Print(); World_Print(); printf(\"\\n\"); return 0;&#125; CMakeLists.txt文件 12345678#递归获取所有当前目录及子目录下的C文件file(GLOB_RECURSE c_files ./*.c) #生成执行文件add_executable(mytest $&#123;c_files&#125;) #链接外部库target_link_libraries(mytest libhelloworld.so) 6.构建工程 12341.进入目录build2.执行命令: cmake ..3.执行命令: make4.执行命令: make install 4. 指定编译器和编译选项1.CMAKE_C_COMPILER: 指定C编译器 2.CMAKE_CXX_COMPILTER:指定C++编译器 3.CMAKE_C_FLAGS: 指定C编译选项 4.CMAKE_CXX_FLAGS:指定C++编译选项 5.EXECUTABLE_OUTPUT_PATH: 指定执行文件存放目录 6.LIBRARY_OUTPUT_PATH: 指定库文件存放目录 7.CMAKE_BUILD_TYPE:指定build类型[Debug|Release] 8.BUILD_SHARED_LIBS: 指定默认库编译方式[OFF|ON] 上述内部变量使用说明: 1.CMakeLists.txt文件上使用set命令 2.cmake 命令中指定，如: cmake -DCMAKE_C_COMPILER=gcc add_definitions:添加编译参数 5. 配置编译模块6. CMake 常用变量和语句1.include_directories:指定头文件搜索路径 2.link_directories:指定库文件搜索路径 3.add_subdirectory:添加子目录 4.target_link_libraries:指定文件链接库文件","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"},{"name":"c","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"},{"name":"cmake","slug":"cmake","permalink":"https://sjtu-xx.github.io/tags/cmake/"}]},{"title":"cmake官方教程（搬运）","slug":"cmake官方教程（搬运）","date":"2019-11-26T03:14:47.000Z","updated":"2021-02-19T02:26:06.403Z","comments":true,"path":"2019/11/26/cmake官方教程（搬运）/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/26/cmake%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%EF%BC%88%E6%90%AC%E8%BF%90%EF%BC%89/","excerpt":"原链接 ref 起点（Step 1）参看下面的CMakeLists.txt文件，最简单的一个工程需要有一个这样的cmake文件，一共就这么两行 123cmake_minimum_required (VERSION 2.6)project (Tutorial) add_executable (Tutorial tutorial.cxx)","text":"原链接 ref 起点（Step 1）参看下面的CMakeLists.txt文件，最简单的一个工程需要有一个这样的cmake文件，一共就这么两行 123cmake_minimum_required (VERSION 2.6)project (Tutorial) add_executable (Tutorial tutorial.cxx) 注意到这里都是用的小写的命令，在cmake文件里面大小写不严格区分，都可以用。 add_executable添加一个可编译的目标到工程里面 123add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...]) name: 工程所要构建的目标名称 WIN32/..: 目标app运行的平台 source1：构建目标App的源文件 tutorial.cxx的源代码计算一个数的平方根。第一版的代码很简单，参看如下： 123456789101112131415161718// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int main (int argc, char *argv[])&#123; if (argc &lt; 2) &#123; fprintf(stdout, \"Uage: %s number\\n\", argv[0]); return 1; &#125; double inputValue = atof(argv[1]); double outputValue = sqrt(inputValue); fprintf(stdout, \"The square root of %g is %g\\n\", inputValue, outputValue); return 0;&#125; 编写完上面两个文件以后，在根目录下新建一个build目录 . ├── build ├── CMakeLists.txt └── tutorial.cxx 然后运行如下命令 123$ cd buld$ CMake ..$ make CMake会自动加载上级目录里面的CMakeLists.txt文件，编译所需的文件都会生成在build目录下 make之后会生成可执行文件Tutorial 添加一个版本号和配置的头文件修改CMakeList.txt来添加version number： 1234567891011121314151617cmake_minimum_required (VERSION 2.6)project (Tutorial)# 版本号.set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0) # 配置一个头文件来传递一些CMake设置到源代码configure_file ( \"$&#123;PROJECT_SOURCE_DIR&#125;/TutorialConfig.h.in\" \"$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h\" ) # 添加TutorialConfig.h的路径到头文件的搜索路径include_directories(\"$&#123;PROJECT_BINARY_DIR&#125;\") # 添加目标可执行文件add_executable(Tutorial tutorial.cxx) configure_file会拷贝一个文件到另一个目录并修改文件内容: 123configure_file(&lt;input&gt; &lt;output&gt; [COPYONLY] [ESCAPE_QUOTES] [@ONLY] [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ]) cmake会自动定义两个变量 ${PROJECT_SOURCE_DIR}： 当前工程最上层的目录 ${PROJECT_BINARY_DIR}： 当前工程的构建目录（本例中新建的build目录） 在这个例子里，configure_file命令的源文件是TutorialConfig.h.in，手动创建这个文件： 123// Tutorial工程的配置选项和设置#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ 调用CMake的时候会在build目录下新的头文件，并且使用CMakeList.txt中定义的值来替换@Tutorial_VERSION_MAJOR@和@Tutorial_VERSION_MINOR@这两个变量。 下一步要在源文件tutorial.cxx中包含这个配置的头文件，就能使用这些版本信息了。 1234567891011121314151617181920212223// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include \"TutorialConfig.h\"int main (int argc, char *argv[])&#123; if (argc &lt; 2) &#123; fprintf(stdout, \"%s Version %d.%d\\n\", argv[0], Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR) fprintf(stdout, \"Uage: %s number\\n\", argv[0]); return 1; &#125; double inputValue = atof(argv[1]); double outputValue = sqrt(inputValue); fprintf(stdout, \"The square root of %g is %g\\n\", inputValue, outputValue); return 0;&#125; 运行如下命令查看结果 123$ cmake ..$ make$ ./Tutorial 这个时候控制台会打印出来版本号 12.&#x2F;Tutorial Version 1.0Uage: .&#x2F;Tutorial number 添加Library（Step 2）现在我们尝试添加一个library到我们的工程。这个lib提供一个自定义的计算平方根的函数，用来替换编译器提供的函数。 lib的源文件放到一个叫MathFunctions的子目录中，在目录下新建CMakeList.txt文件，添加如下的一行 1add_library(MathFunctions mysqrt.cxx) 源文件mysqrt.cxx包含一个函数mysqrt用于计算平方根。代码如下 1234567891011121314151617181920212223242526#include \"MathFunctions.h\"#include &lt;stdio.h&gt;// a hack square root calculation using simple operationsdouble mysqrt(double x)&#123; if (x &lt;= 0) &#123; return 0; &#125; double result; double delta; result = x; // do ten iterations int i; for (i = 0; i &lt; 10; ++i) &#123; if (result &lt;= 0) &#123; result = 0.1; &#125; delta = x - (result * result); result = result + 0.5 * delta / result; fprintf(stdout, \"Computing sqrt of %g to be %g\\n\", x, result); &#125; return result;&#125; 还需要添加一个头文件MathFunctions.h以提供接口给main函数调用 1double mysqrt(double x); 现在的目录结构 . ├── build ├── CMakeLists.txt ├── MathFunctions │ ├── CMakeLists.txt │ ├── MathFunctions.h │ └── mysqrt.cxx ├── TutorialConfig.h.in └── tutorial.cxx CMakeLists.txt文件需要相应做如下改动 添加一行add_subdirectory来保证新加的library在工程构建过程中被编译。 添加新的头文件搜索路径MathFunction/MathFunctions.h。 添加新的library到executable。 CMakeList.txt的最后几行变成了这样： 123456include_directories (\"$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions\")add_subdirectory (MathFunctions)# 添加executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Turorial MathFunctions) 最后要修改tutorial.cxx文件来调用自定义的mysqrt函数 最后编译一下试试 123$ cmake ..$ make$ ./Tutorial 看一下编译的log 12345678Scanning dependencies of target MathFunctions[ 50%] Building CXX object MathFunctions/CMakeFiles/MathFunctions.dir/mysqrt.cxx.oLinking CXX static library libMathFunctions.a[ 50%] Built target MathFunctionsScanning dependencies of target Tutorial[100%] Building CXX object CMakeFiles/Tutorial.dir/tutorial.cxx.oLinking CXX executable Tutorial[100%] Built target Tutorial 这里编译生成了新的库libMathFunctions.a 现在我们考虑把MathFunctions库配置成可选的首先在最顶层的CMakeList.txt文件添加一个option 123#需要用自定义的数学函数么？option (USE_MYMATH \"Use tutorial provided math implementation\" ON) 运行ccmake ..会跳出来配置的GUI，在GUi中会看到新添加的这个选项，用户可以根据需要进行修改。 下一个改变是依据配置来判断是否编译和链接MathFunctions库。按照如下所示的修改CMakeList.txt的末尾几行： 12345678910# add the MathFunctions library?if (USE_MYMATH) include_directories (\"$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions\") add_subdirectory (MathFunctions) SET (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)endif (USE_MYMATH)# add executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Turorial $&#123;EXTRA_LIBS&#125;) 这个例子里还是用了变量（EXTRA_LIBS）来收集后面link进可执行文件的时候任意可选的库。这是一个常用的方法，在工程非常大有很多optional的组件的时候，可以让这个编译文件保持干净。 代码的修改就更直接了(用宏定义隔离开)： 1234567891011121314151617181920212223242526272829303132// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include \"TutorialConfig.h\"#ifdef USE_MYMATH#include \"MathFunctions.h\"#endif int main (int argc, char *argv[])&#123; if (argc &lt; 2) &#123; fprintf(stdout,\"%s Version %d.%d\\n\", argv[0], Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR); fprintf(stdout,\"Usage: %s number\\n\",argv[0]); return 1; &#125; double inputValue = atof(argv[1]); #ifdef USE_MYMATH double outputValue = mysqrt(inputValue);#else double outputValue = sqrt(inputValue);#endif fprintf(stdout,\"The square root of %g is %g\\n\", inputValue, outputValue); return 0;&#125; 在源代码里面同样可以使用USE_MYMATH，只要在TutorialConfig.h.in里面添加一行 1#cmakedefine USE_MYMATH 安装测试 (Step 3)下一步我们会添加install规则和testing到工程。install规则非常直接。对于MathFunctions库，我们通过在MathFunctions的CMakeList文件中添加如下两行来安装库和头文件。 12install (TARGETS MathFunctions DESTINATION bin)install(FILES MathFunctions.h DESTINATION include) 对于应用程序，为了安装executable和配置头文件，需要在最上层的CMakeList.txt文件中添加下面几行 123# add the install targetsinstall (TARGETS Tutorial DESTINATION bin)install (FILES \"$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h\" DESTINATION include) 到了这里你就可以构建整个tutorial了，通过命令make install，系统会自动安装对应的头文件，库以及可执行文件。CMake变量CMAKE_INSTALL_PREFIX用来指定这些文件需要安装到哪个根目录。 添加测试用例也很直接，只要在最上层的CMakeList.txt文件添加一系列的基础测试来验证应用程序是否正常工作。 1234567891011121314151617181920include(CTest)# does the application runadd_test (TutorialRuns Tutorial 25)# does it sqrt of 25add_test (TutorialComp25 Tutorial 25)set_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION \"25 is 5\")# does it handle negative numbersadd_test (TutorialNegative Tutorial -25)set_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION \"-25 is 0\")# does it handle small numbersadd_test (TutorialSmall Tutorial 0.0001)set_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION \"0.0001 is 0.01\")# does the usage message work?add_test (TutorialUsage Tutorial)set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage:.*number\") 编译完成后可以通过在命令行运行ctest来执行这些测试用例。如果你希望添加很多测试用例来测试不同的输入值，这个时候推荐你创建一个宏，这样添加新的case会更轻松： 12345678910#define a macro to simplify adding tests, then use itmacro (do_test arg result) add_test (TutorialComp$&#123;arg&#125; Tutorial $&#123;arg&#125;) set_tests_properties (TutorialComp$&#123;arg&#125; PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125;)endmacro (do_test) # do a bunch of result based testsdo_test (25 \"25 is 5\")do_test (-25 \"-25 is 0\") 每次调用do_test，都会添加一个新的test case到工程。 添加系统回顾 (Step 4)下一步我们考虑在工程中添加一些代码，这些代码会依赖的某些特性在运行的目标平台上可能没有。比如说，我们添加了一些代码，这些代码需要用到log和exp函数，但某些目标平台上可能没有这些库函数。如果平台有log函数那么我们就是用log来计算平方根，我们首先通过CheckFunctionExists.cmake来测试一下是否有这些函数，在最上层的CMakeList文件中添加如下内容 1234# does this system provide the log and exp functions?include (CheckFunctionExists)check_function_exists (log HAVE_LOG)check_function_exists (exp HAVE_EXP) Next we modify the TutorialConfig.h.in to define those values if CMake found them on the platform as follows: 下一步，如果CMake发现平台有我们需要的这些函数，则需要修改TutorialConfig.h.in来定义这些值 123// does the platform provide exp and log functions?#cmakedefine HAVE_LOG#cmakedefine HAVE_EXP 有一点很重要，就是log和exp的测试工作需要在配置TutorialConfig.h前完成。最后在mysqrt函数中我们可以提供一个可选的实现方式： 12345// if we have both log and exp then use them#if defined (HAVE_LOG) &amp;&amp; defined (HAVE_EXP) result = exp(log(x)*0.5);#else // otherwise use an iterative approach . . . 添加生成文件和生成器 (Step 5)这一节中我们会演示一下怎么添加一个生成的源文件到引用程序的构建过程中。例如说，我们希望在构建过程中创建一个预先计算好的平方根表，然后把这个表格编译进我们的应用程序。首先我们需要一个能生成这张表的程序。在MathFunctions子目录中，定义一个新的源文件MakeTable.cxx: 123456789101112131415161718192021222324252627282930313233343536// A simple program that builds a sqrt table #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt; int main (int argc, char *argv[])&#123; int i; double result; // make sure we have enough arguments if (argc &lt; 2) &#123; return 1; &#125; // open the output file FILE *fout = fopen(argv[1],\"w\"); if (!fout) &#123; return 1; &#125; // create a source file with a table of square roots fprintf(fout,\"double sqrtTable[] = &#123;\\n\"); for (i = 0; i &lt; 10; ++i) &#123; result = sqrt(static_cast&lt;double&gt;(i)); fprintf(fout,\"%g,\\n\",result); &#125; // close the table with a zero fprintf(fout,\"0&#125;;\\n\"); fclose(fout); return 0;&#125; 注意到这里的需要传递正确的输出文件给app，然后才会生成table。下一步是在MathFunctions的CMakeList.txt添加相应的命令来编译生成可执行文件MakeTable，然后在编译过程中运行这个程序。如下所示的添加一些命令： 12345678910111213141516# first we add the executable that generates the tableadd_executable(MakeTable MakeTable.cxx) # add the command to generate the source codeadd_custom_command ( OUTPUT $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h COMMAND MakeTable $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h DEPENDS MakeTable ) # add the binary tree directory to the search path for # include filesinclude_directories( $&#123;CMAKE_CURRENT_BINARY_DIR&#125; ) # add the main libraryadd_library(MathFunctions mysqrt.cxx $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h ) 首先添加可执行的MakeTable。 然后我们添加一个用户命令指定怎么通过允许MakeTable来生成Table.h。 下一步需要让CMAKE知道mysqrt.cxx依赖生成的Table.h。把生成的Table.h添加到MathFunctions库的资源列表中。 还需要添加当前的bin的目录添加到include的list中，这样mysqrt.cxx编译时候可以找到Table.h。 最后编译包含Table.h的mysqrt.cxx来生成MathFunctions库 到这儿最上层的CMakeList.txt文件就如下面所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657cmake_minimum_required (VERSION 2.6)project (Tutorial)include(CTest) # The version number.set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0) # does this system provide the log and exp functions?include ($&#123;CMAKE_ROOT&#125;/Modules/CheckFunctionExists.cmake) check_function_exists (log HAVE_LOG)check_function_exists (exp HAVE_EXP) # should we use our own math functionsoption(USE_MYMATH \"Use tutorial provided math implementation\" ON) # configure a header file to pass some of the CMake settings# to the source codeconfigure_file ( \"$&#123;PROJECT_SOURCE_DIR&#125;/TutorialConfig.h.in\" \"$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h\" ) # add the binary tree to the search path for include files# so that we will find TutorialConfig.hinclude_directories (\"$&#123;PROJECT_BINARY_DIR&#125;\")# add the MathFunctions library?if (USE_MYMATH) include_directories (\"$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions\") add_subdirectory (MathFunctions) set (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)endif (USE_MYMATH) # add the executableadd_executable (Tutorial tutorial.cxx)target_link_libraries (Tutorial $&#123;EXTRA_LIBS&#125;) # add the install targetsinstall (TARGETS Tutorial DESTINATION bin)install (FILES \"$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h\" DESTINATION include) # does the application runadd_test (TutorialRuns Tutorial 25) # does the usage message work?add_test (TutorialUsage Tutorial)set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage:.*number\" ) #define a macro to simplify adding testsmacro (do_test arg result) add_test (TutorialComp$&#123;arg&#125; Tutorial $&#123;arg&#125;) set_tests_properties (TutorialComp$&#123;arg&#125; PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125; )endmacro (do_test) # do a bunch of result based testsdo_test (4 \"4 is 2\")do_test (9 \"9 is 3\")do_test (5 \"5 is 2.236\")do_test (7 \"7 is 2.645\")do_test (25 \"25 is 5\")do_test (-25 \"-25 is 0\")do_test (0.0001 \"0.0001 is 0.01\") TutorialConfig.h.in 文件如下: 1234567// the configured options and settings for Tutorial#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@#cmakedefine USE_MYMATH // does the platform provide exp and log functions?#cmakedefine HAVE_LOG#cmakedefine HAVE_EXP MathFunctions的文件CMakeLists.txt如下: 12345678910111213# first we add the executable that generates the tableadd_executable(MakeTable MakeTable.cxx)# add the command to generate the source codeadd_custom_command ( OUTPUT $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h DEPENDS MakeTable COMMAND MakeTable $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h )# add the binary tree directory to the search path # for include filesinclude_directories( $&#123;CMAKE_CURRENT_BINARY_DIR&#125; ) # add the main libraryadd_library(MathFunctions mysqrt.cxx $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h) install (TARGETS MathFunctions DESTINATION bin)install (FILES MathFunctions.h DESTINATION include)","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"},{"name":"c","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"},{"name":"cmake","slug":"cmake","permalink":"https://sjtu-xx.github.io/tags/cmake/"}]},{"title":"mac下的c++库安装","slug":"mac下的c-库安装","date":"2019-11-25T10:51:00.000Z","updated":"2021-02-19T02:26:06.524Z","comments":true,"path":"2019/11/25/mac下的c-库安装/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/25/mac%E4%B8%8B%E7%9A%84c-%E5%BA%93%E5%AE%89%E8%A3%85/","excerpt":"1.qt的安装安装步骤命令行执行1brew install qt","text":"1.qt的安装安装步骤命令行执行1brew install qt记录执行结果 提示无法找到QtWidgets等时在环境变量中添加export CMAKE_PREFIX_PATH=/usr/local/opt/qt5/,重启使得环境生效 qt assistant中帮助文档的安装qt assistant中的帮助文档发现不存在，所以进行安装qt assistant中的帮助文档不能单独安装，需要下载所有的源码进行安装 下载源码git clone git://code.qt.io/qt/qt5.gitgit checkout v5.14.0perl init-repository configure生成makefilecd qt5qt5 2.vtk的安装ref 安装步骤 命令行执行ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 命令行执行brew install vtk 3.oce（OpenCASCADE）的安装ref命令行执行brew tap brewsci/science &amp;&amp; brew install oce执行结果 4.opencv的安装命令行执行brew install opencv执行结果 Clion+QT+VTK环+OpenCV环境搭建 注意：在clion中编译时，不要使用gcc，将编译器设置为系统默认的clang。（由于brew install默认识别系统自带的编译器）Perferences-&gt;Toolchains-&gt;System(default) (如果之前修改过，新建一个设置为默认) clion中cmakelist配置123456789101112131415161718192021cmake_minimum_required(VERSION 3.15)project(test)set(CMAKE_CXX_STANDARD 14)set(Qt5_DIR /usr/local/opt/qt/lib/)#set(OCE_DIR /usr/local/Cellar/oce/0.18.2/OCE.framework)find_package(VTK REQUIRED)find_package(Qt5Widgets REQUIRED)find_package(Qt5Gui REQUIRED)find_package(Qt5Core REQUIRED)find_package(Qt5OpenGL REQUIRED)#find_package(OCE REQUIRED COMPONENTS TKPrim)#include_directories($&#123;OCE_INCLUDE_DIRS&#125;)find_package(OpenCV REQUIRED)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)include($&#123;VTK_USE_FILE&#125;)add_executable(test main.cpp)link_directories($&#123;OpenCV_LIBRARY_DIRS&#125;)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Widgets Qt5::Widgets Qt5::Core Qt5::Gui Qt5::OpenGL $&#123;VTK_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;) 由于vtk,opencv等会自动调用qt，不对qt进行单独测试测试文件:（opencv）：123456789101112131415161718192021222324252627282930#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main( int argc, char** argv )&#123; if( argc != 2) &#123; cout &lt;&lt;\" Usage: display_image ImageToLoadAndDisplay\" &lt;&lt; endl; return -1; &#125; Mat image; image = imread(argv[1], 1); // Read the file if(! image.data ) // Check for invalid input &#123; cout &lt;&lt; \"Could not open or find the image\" &lt;&lt; std::endl ; return -1; &#125; namedWindow( \"Display window\", WINDOW_AUTOSIZE );// Create a window for display. imshow( \"Display window\", image ); // Show our image inside it. waitKey(0); // Wait for a keystroke in the window return 0;&#125; 测试文件（vtk）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/*========================================================================= Program: Visualization Toolkit Module: Cube.cxx Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen All rights reserved. See Copyright.txt or http://www.kitware.com/Copyright.htm for details. This software is distributed WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the above copyright notice for more information.=========================================================================*/// This example shows how to manually create vtkPolyData.// For a python version, please see:// [Cube](https://lorensen.github.io/VTKExamples/site/Python/GeometricObjects/Cube/)#include &lt;vtkActor.h&gt;#include &lt;vtkCamera.h&gt;#include &lt;vtkCellArray.h&gt;#include &lt;vtkFloatArray.h&gt;#include &lt;vtkNamedColors.h&gt;#include &lt;vtkNew.h&gt;#include &lt;vtkPointData.h&gt;#include &lt;vtkPoints.h&gt;#include &lt;vtkPolyData.h&gt;#include &lt;vtkPolyDataMapper.h&gt;#include &lt;vtkRenderWindow.h&gt;#include &lt;vtkRenderWindowInteractor.h&gt;#include &lt;vtkRenderer.h&gt;#include &lt;array&gt;int main(int, char *[])&#123; vtkNew&lt;vtkNamedColors&gt; colors; std::array&lt;std::array&lt;double, 3&gt;, 8&gt; pts = &#123;&#123;&#123;&#123;0, 0, 0&#125;&#125;, &#123;&#123;1, 0, 0&#125;&#125;, &#123;&#123;1, 1, 0&#125;&#125;, &#123;&#123;0, 1, 0&#125;&#125;, &#123;&#123;0, 0, 1&#125;&#125;, &#123;&#123;1, 0, 1&#125;&#125;, &#123;&#123;1, 1, 1&#125;&#125;, &#123;&#123;0, 1, 1&#125;&#125;&#125;&#125;; // The ordering of the corner points on each face. std::array&lt;std::array&lt;vtkIdType, 4&gt;, 6&gt; ordering = &#123;&#123;&#123;&#123;0, 1, 2, 3&#125;&#125;, &#123;&#123;4, 5, 6, 7&#125;&#125;, &#123;&#123;0, 1, 5, 4&#125;&#125;, &#123;&#123;1, 2, 6, 5&#125;&#125;, &#123;&#123;2, 3, 7, 6&#125;&#125;, &#123;&#123;3, 0, 4, 7&#125;&#125;&#125;&#125;; // We'll create the building blocks of polydata including data attributes. vtkNew&lt;vtkPolyData&gt; cube; vtkNew&lt;vtkPoints&gt; points; vtkNew&lt;vtkCellArray&gt; polys; vtkNew&lt;vtkFloatArray&gt; scalars; // Load the point, cell, and data attributes. for (auto i = 0ul; i &lt; pts.size(); ++i) &#123; points-&gt;InsertPoint(i, pts[i].data()); scalars-&gt;InsertTuple1(i, i); &#125; for (auto&amp;&amp; i : ordering) &#123; polys-&gt;InsertNextCell(vtkIdType(i.size()), i.data()); &#125; // We now assign the pieces to the vtkPolyData. cube-&gt;SetPoints(points); cube-&gt;SetPolys(polys); cube-&gt;GetPointData()-&gt;SetScalars(scalars); // Now we'll look at it. vtkNew&lt;vtkPolyDataMapper&gt; cubeMapper; cubeMapper-&gt;SetInputData(cube); cubeMapper-&gt;SetScalarRange(cube-&gt;GetScalarRange()); vtkNew&lt;vtkActor&gt; cubeActor; cubeActor-&gt;SetMapper(cubeMapper); // The usual rendering stuff. vtkNew&lt;vtkCamera&gt; camera; camera-&gt;SetPosition(1, 1, 1); camera-&gt;SetFocalPoint(0, 0, 0); vtkNew&lt;vtkRenderer&gt; renderer; vtkNew&lt;vtkRenderWindow&gt; renWin; renWin-&gt;AddRenderer(renderer); vtkNew&lt;vtkRenderWindowInteractor&gt; iren; iren-&gt;SetRenderWindow(renWin); renderer-&gt;AddActor(cubeActor); renderer-&gt;SetActiveCamera(camera); renderer-&gt;ResetCamera(); renderer-&gt;SetBackground(colors-&gt;GetColor3d(\"Cornsilk\").GetData()); renWin-&gt;SetSize(600, 600); // interact with data renWin-&gt;Render(); iren-&gt;Start(); return EXIT_SUCCESS;&#125; 测试文件（oce/opencascade）12 卸载通过cmake安装的软件要通过如下方式进行卸载：cat install_manifest.txt | sudo xargs rm","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"},{"name":"qt","slug":"qt","permalink":"https://sjtu-xx.github.io/tags/qt/"}]},{"title":"C-Primer读书笔记-第二部分：标准库","slug":"C-Primer读书笔记-第二部分：标准库","date":"2019-11-25T09:00:37.000Z","updated":"2021-02-19T02:26:05.869Z","comments":true,"path":"2019/11/25/C-Primer读书笔记-第二部分：标准库/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/","excerpt":"8.IO库IO类IO库类型和头文件","text":"8.IO库IO类IO库类型和头文件 头文件 类型 iostream istream,wistream从流读取数据 &nbsp; ostream,wostream向流写入数据 &nbsp; iostream，wiostream读写流 fstream ifstream,wiftream从文件读取数据 &nbsp; ofstream,wofstream向文件写入数据 &nbsp; fstream，wfstream读写文件 sstream istringstream,wistringstream从string读取数据 &nbsp; ostringstream,wostringstream向string写入数据 &nbsp; stringstream，wstringstream读写流 我们不能拷贝或者对IO对象赋值。 1234567ofstream out1,out2;out1 = out2; //错误：不能赋值ofstream print(ofstream); //错误不能初始化ofstream参数out2 = print(out2); //错误：不能拷贝对象 //将流当作条件使用if (cin &gt;&gt; word); 流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。 带参数的clear接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。 12//复位failbit和badbit，保持其他标识位不变cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit) 在每个输出操作后，我们可以使用操作符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。 刷新输出缓冲区 操作符endl完成换行并刷新缓冲区的工作。 操作符ends向缓冲区插入一个空字符，然后刷新缓冲区。 操作符flush刷新缓冲区，不输出任何额外的字符。 如果想在每次输出操作后都刷新缓冲区，可以使用unitbuf操作符。他告诉流在接下来的每次写操作后都进行一次flush操作。而nounitbuf操作符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制： 12cout &lt;&lt; unitbuf; //所有输出操作后都会立即刷新缓冲区cout &lt;&lt; nounitbuff; //回到正常的缓冲方式 关联输入和输出流 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。 1cin.tie(&amp;cout); //将cin和cout关联在一起（默认情况下这两者是关联的） 每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream 文件输入输出 使用文件流对象 创建文件流对象时，可以提供文件名。如果提供文件名，则open会被自动调用； 12ifstream in(ifile); //构造ifstream并打开给定文件ofstream out; //输出文件流out 当一个fstream对象离开其作用域，与之关联的文件会自动关闭。（当一个fstream对象被销毁时，close会被自动调用） 文件模式 只可以对ofstream或fstream设定out模式。 只可以对ifstream或fstream设定in模式。 只有当out也被设定，才可以设定trunct模式 只要trunc没被设定，就可以设定app模式。 使用完流要及时close() string流 sstream特有的操作 例子 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include \"PersonInfo.h\"int main()&#123; std::vector&lt;PersonInfo&gt; personInfos; std::string line,data; std::ifstream inputFile; inputFile.open(\"/Users/xuexuan/Desktop/tmp/test/123\"); while(std::getline(inputFile,line))&#123; PersonInfo person; std::istringstream record(line); record &gt;&gt; person.name; while (record &gt;&gt; data)&#123; person.phones.push_back(data); &#125; personInfos.push_back(person); &#125; for (const auto &amp;item:personInfos)&#123; std::ostringstream formatted, badNums; for (const auto &amp;nums:item.phones)&#123; if(valid(nums))&#123; formatted &lt;&lt; \" \"&lt;&lt;nums; &#125; else&#123; badNums &lt;&lt; \" \"&lt;&lt;nums; &#125; &#125; if (badNums.str().empty())&#123; std::cout &lt;&lt; item.name &lt;&lt;\" \"&lt;&lt;formatted.str()&lt;&lt;std::endl; &#125; else&#123; std::cout &lt;&lt; item.name &lt;&lt;\" invalid:\"&lt;&lt; badNums.str() &lt;&lt;std::endl; &#125; &#125;&#125; 9.顺序容器顺序容器的类型 容器 特点 vector 可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快 list 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快 forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作都很快 array 固定大小数组。支持快速随机访问。不能添加或删除元素 string 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 vector\\deque\\list\\forward_list\\array\\stringarray是一种比内置数组更安全，更容易使用的数组类型。 array支持拷贝与赋值操作。forward_list没有没有size操作。 选择容器的基本原则 除非有很好的理由选择其他容器，否则选择vector 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list. 如果程序要求随机访问元素，应使用vector或deque 如果程序要求在容器中间插入或删除元素，应使用list或forward_list. 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素。则： 。。。 如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操作：迭代器，不使用下标操作，避免随机访问。这样，在必要时选择vector和list都很方便。 容器操作 新标准库中容器既提供成员版本的swap，也提供非成员版本的swap。统一使用非成员版本的swap是一个好习惯。 当不需要写访问时，应使用cbegin和cend 容器概述容器定义与初始化每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。 12345678C c;C c1(c2);C c1 = c2; // c1和c2必须是相同类型C c&#123;a,b,c&#125;; C c(b,e); //c初始化为迭代器b和e之间的元素的拷贝// 只有顺序容器才能接受大小参数C seq(n); //此函数是explicit的C seq(n,t); //n个t元素 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器与原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素即可。 虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array无此限制。 顺序容器操作添加元素 访问元素在解引用一个迭代器或调用front或back之前检查是否有元素 123if (!c.empty())&#123; auto val = *c.begin(), val2 = c.front();&#125; 顺序容器中访问元素的操作 删除元素 改变容器大小 改变容器大小 c .resize() 容器操作可能使迭代器失效 容器操作可能使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。 管理容量的成员函数 c.shrink_to_fit() 将capacity()减小为与size()相同大小 c.capacity() 不重新分配内存的话，c可以保存多少元素 c.reserve() 分配至少能容纳n个元素的内存空间 容器适配器 stack/queue/priority_queue 栈默认基于deque实现。 额外的string操作构造string的其他方法1234//n、len2和pos2都是无符号值string s(cp,n); //s是cp指向的数组中前n个字符的拷贝。此数组至少应该包含n个字符string s(s2,pos2); //s是string s2从下标pos2开始的字符的拷贝。若pos2&gt;S2.size(),构造函数未定义string s(s2,pos2,len2); //s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;S2.size(),构造函数行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符 子字符串操作 1s.substr(pos,n); //返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0.n的默认值为s.size()-pos,即拷贝从pos开始的所有字符 修改string的操作 string搜索操作 compare函数 数值转换 容器适配器除了顺序容器，标准库还定义了三个顺序容器适配器：stack，queue和priority_queue。 10.范型算法大多数算法定义在algorithm中。标准库还在numeric头文件中定义了一组数值范型算法。泛型算法本身不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作。算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。 只读算法累加算法 1int sum = accumulate(vec.cbegin(),vec.cend(),0) //accumulate中第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型 对于只读取而不改变元素的算法，通常最好使用cbegin()和cend() 判等算法 1equal(roster1.cbegin(),roster1.cend(),roster2.cbegin()) 那些只接收一个单一迭代器来表示第二个序列的算法都假定第二个序列至少和第一个序列一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。 写容器元素的算法12fill(vec.begin(),vec.end(),0); //将每个元素置0fill_n(dest,n,val); //将从dest开始的n个元素赋予val 向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素 back_inserter 插入迭代器 back_inserter定义在头文件iterator中的一个函数。接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。我们常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。 123456vector&lt;int&gt; vec; //空向量auto it = back_inserter(vec);*it = 42; //vec中现在有一个元素，值为42vector&lt;int&gt; vec;fill_n(back_inserter(vec),10,0); //添加10个元素到vec 拷贝算法12345678910111213//copy//返回目的位置迭代器（递增后）的值int a1[] = &#123;0,1,2,3,4,5,6&#125;int a2[sizeof(a1)/sizeof(*a1)]auto ret = copy(begin(a1),end(a1),a2); //把a1的内容拷贝给a2//replace//将ilst中的0替换为42replace(ilst.begin(),ilst.end(),0,42);//replace_copy//保留原序列不变，将调整后的序列保存在第三个参数所指的位置replace_copy(ilst.cbegin(),ilst.cend(),back_inserter(ivec),0,42); 重排元素的算法12345678910//sort//unique:将不重复的元素放在序列的开始部分void elimDups(vector&lt;string&gt; &amp;words)&#123; //按字典排序 sort(words.begin(),words.end()); //unique返回 指向不重复区域之后第一个位置的迭代器 auto end_unique = unique(words.begin(),words.end()); //使用vector的eraser删除重复元素 words.erase(end_unique,words.end());&#125; 定制操作向算法传递函数类似于sort之类的函数有第二个版本，接受第三个参数，此参数是一个谓词。 谓词是一个可调用的表达式。其返回结果是一个能用做条件的值。 123456789bool isShorter(const string &amp;s1, const string &amp;s2)&#123; return s1.size()&lt;s2.size();&#125;//按长度由短至长排列sort(words.begin(),words.end(),isShorter);//stable_sort//保持元素原有顺序sort(words.begin(),words.end(),isShorter); 12//find_if函数接受一个元素， lambda表达式 find_if 函数接受一对迭代器，查找范围内第一个满足特定条件的元素。 lambda表达式的形式[capture list](parameter list) -&gt; return type {function body} 一个lambda只有在其捕获列表中捕获一个他所在函数中的局部变量，才能在函数中使用该变量 如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void lambda捕获和返回 如果可能的话，应避免捕获指针或引用 隐式捕获：为了只是编译器推断捕获列表，应在捕获列表中写一个&amp;或=，&amp;告诉编译器采用引用捕获的方式，=告诉编译器采用值捕获的方式 1find_if(words.begin(),words.end(),[=](const string &amp;s)&#123;return s.size()&gt;sz&#125;) 如果希望改变被捕获的变量，就必须在参数列表开头加上关键字mutable。 123456void fcn3()&#123; size_t v1 = 42; auto f = [v1]() mutable &#123;return ++v1;&#125;; v1 = 0; auto j = f(); //j为43&#125; 指定lambda的返回类型 1234// transform// 接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。对输入序列中的每个元素调用可调用对象，并将结果写入到目的位置。// 返回绝对值transform(v1.begin(),v1.end(),[](const int &amp;v)-&gt;int&#123;if v&lt;0:return -v;else:return v;&#125;); 参数绑定bind函数位于头文件functional中，绑定格式auto newCallable = bind(callable, arglist)。arglist中的参数可能包含形如_n之类的名字，表示占位符。_1表示newCallable的第一个参数 使用placeholders名字 名字_n都定义在placeholders命名空间中。这个空间本身定义在std命名空间中 using namespace std::placeholders; 123456789bool check_size(const string &amp;s, string::size_type sz)&#123; return s.size() &gt;= sz;&#125;//下面的bind和lambda等价auto wc = find_if(words.begin(),words.end(), [sz](const string &amp;a)-&gt;bool&#123;return check_size(a, sz)&#125;);auto wc = find_if(words.begin(),words.end(), bind(check_size,_1,sz)); bind的哪些不是占位符的参数被拷贝到bind返回的可调用对象中。如果我们希望传递给bind一个对象而不拷贝它，就必须使用ref函数： 1for_each(words.begin(),words.end(),bind(print,ref(os),_1,' ')) 其他迭代器 插入迭代器 流迭代器 反向迭代器 移动迭代器 插入迭代器back_inserter、front_inserter、inserter 插入迭代器的工作方式 当调用inserter(c, iter) 时，得到一个迭代器，使用它时，会插入到iter原来所指的元素之前的位置 当调用front_inserter时，元素总是插入到第一个元素之前。 iostream迭代器123456//从标准输入中读取数据，存入一个vector中istream_iterator&lt;int&gt; in_iter(cin); //从cin读取intistream_iterator&lt;int&gt; eof; //istream尾后迭代器（空表示尾后迭代器）while (in_iter != eof)&#123; vec.push_back(*in_iter++); //将in_iter中的数据保存在in_iter中并读取下一条数据&#125; 可以通过copy打印vec中的元素，这比编写循环更简单。12copy(vec.begin(),vec.end(),out_iter);cout&lt;&lt;endl; 反向迭代器递增一个反向迭代器会移动到前一个位置，递减一个反向迭代器会移动到后一个位置。 泛型算法结构 ——- ——- 输入迭代器 只读、不写；单遍扫描，只能递增 输出迭代器 只写、不读；单遍扫描，只能递增 前向迭代器 可读写；多遍扫描，只能递增 双向迭代器 可读写；多遍扫描，可递增递减 随机访问迭代器 可读写，多遍扫描，支持全部迭代器运算 array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。 算法形参模式大多数算法具有如下四种形式之一：1234alg(beg,end,other args)alg(beg,end,dest,other args)alg(beg,end,beg2,other args)alg(beg,end,beg2,end2,other args) 接受单个目标迭代器的算法算法假定：按需要写入数据，不管写入多少元素都是安全的如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已经存在的元素内。更常见的情况是，dest被绑定到一个插入迭代器，或是一个ostream_iterator。 接受第二个输入序列的算法算法假定从beg2开始的范围与beg和end所表示的范围至少一样大。 算法命名规范一些算法使用重载形式传递一个谓词 (unique) _if版本的算法接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值。接受谓词的算法都有附加的_if前缀：12find(beg,end,val); //查找输入范围中val第一次出现的位置find_if(beg,end,pred); //查找第一个使pred为真的元素 区分拷贝元素的版本和不拷贝元素的版本写到额外空间的算法都在名字后面附加一个_copy:12reverse(beg,end);reverse_copy(beg,end,dest); //将元素按逆序拷贝到dest 特定容器算法list和forward_list成员函数版本的算法123456lst.merge(lst2); 将来自lst2的元素合并入lst，lst2变为空。lst和lst2都必须是有序的，使用&lt;运算符lst.merge(lst2,comp); 将来自lst2的元素合并入lst，lst2变为空。lst和lst2都必须是有序的，使用comparelst.remove(val); 调用erase删除掉与给定值相等的元素lst.reverse();lst.sort();lst.unique(); 11.关联容器关联容器支持高效的关键字查找和访问。两个主要的关联容器：set和map。|容器类型|描述||——————-|————-||按关键字有序保存元素|||map|关联数组：保存关键字-值对||set|关键字即值，即只保存关键字的容器||multimap|关键字可重复初夏你的map||multiset|关键字可重复出现的set||无序集合|||unordered_map|用哈希函数组织的map||unordered_set|用哈希函数组织的set||unordered_multimap|哈希组织的map：关键字可重复出现||unordered_multiset|哈希组织的set：关键字可重复出现| 使用关联容器使用map123456789//统计每个单词出现的次数map&lt;string, size_t&gt; word_count;string word;while (cin&gt;&gt;word)&#123; ++word_count[word];&#125;for (const auto &amp;w:word_count)&#123; cout &lt;&lt; w.first &lt;&lt; \" occurs \" &lt;&lt; w.second &lt;&lt; ((w.second&gt;1)?\"times\":\"time\")&lt;&lt;endl;&#125; 使用set123456789//统计每个单词出现的次数map&lt;string, size_t&gt; word_count;set&lt;string&gt; exclude = &#123;\"The\",\"But\",\"And\",\"the\",\"but\",\"and\"&#125;;string word;while (cin&gt;&gt;word)&#123; if (exclude.find(word)==exclude.end()) ++ word_count[word];&#125; 关联容器概述关联容器支持普通容器的所有操作。不支持顺序容器的位置相关操作（如push_back等）。 关联容器的定义1234567891011121314map&lt;string, size_t&gt; word_count; //空容器//列表初始化set&lt;string&gt; exclude = &#123;\"The\",\"But\",\"And\",\"the\",\"but\",\"and\"&#125;;map&lt;string,string&gt; authors = &#123;&#123;\"Joyce\",\"James\"&#125;, &#123;\"Austen\",\"Jane\"&#125;&#125;//vector&lt;int&gt; ivec;for (vector&lt;int&gt;::size_type i = 0; i!=0; ++i)&#123; ivec.push_back(i);&#125;set&lt;int&gt; iset(ivec.cbegin(),ivec.cend());multiset&lt;int&gt; miset(ivec.cbegin(),ivec.cend()); 关键字类型的要求关键字类型必须定义元素的比较方法使用关键字类型的比较函数12345//当使用decltype来获得一个函数的指针时，必须加上一个*来指出我们要使用一个给定函数类型的指针bool compareIsbn(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123;return lhs.isbn()&lt;rhs.isbn();&#125;multiset&lt;Sales_data, decltype(compareIsbn) *&gt; bookstore(compareIsbn); pair类型pair类型定义在头文件utility中。12345pair&lt;string,string&gt; anon;pair&lt;string,size_t&gt; word_count;pair&lt;string,vector&lt;int&gt;&gt; line;pair&lt;string,string&gt; author&#123;\"James\",\"Joyce\"&#125;;pair的数据成员是public的，两个成员分别命名为first和second。 关联容器的操作关联容器额外的类型别名 —————— —————— key_type mapped_type value_type 关联容器迭代器12345auto map_it = word_count.cbegin(); // *map_it是一个指向word_count中第一个元素的引用while (map_it != word_count.end())&#123; count&lt;&lt; map_it -&gt; first &lt;&lt; \" occurs \" &lt;&lt; map_it -&gt; second &lt;&lt; \"times\" &lt;&lt; endl; ++map_it;&#125; set类型中的元素是const的，map中的元素是pair，其第一个成员是const的。 由于关联容器中的元素不能通过他们的关键字进行快速查找，因此对其使用泛型算法是一个坏主意。使用关联容器定义的专用的find成员比泛型find快的多。 实际编程中，如果我们真要对一个关联容器使用算法，要么是将他作为一个源序列，要么是当作一个目的位置。 添加元素12345678//setset1.insert(ivec.begin(),ivec.end());set1.insert(&#123;1,23,4&#125;);//mapword_count.insert(&#123;word,1&#125;);word_count.insert(make_pair(word,1));word_count.insert(pair&lt;string,size_t&gt;(word,1));word_count.insert(map&lt;string,size_t&gt;::value_type(word,1)); insert具有返回值。对于不包含重复关键字的容器，添加单一元素的insert和emplace返回一个pair,pair的第一个元素为指向具有给定关键字的元素的迭代器，second是一个指示关键字插入成功还是已经存在在容器中的bool值。 删除元素123c.erase(k); //删除关键字为k的元素，返回size_t值，指出删除元素的数量c.erase(p); //删除迭代器指向的元素c.erase(b,e); //删除b和e之间的元素 map的下标操作不能对multimap和unordered_multimap进行下标操作。 与其他下标运算符不同的是，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。 12c[k]; //返回关键字为k的元素；如果k不在map中，则进行值初始化c.at(k); //如果k不在c中抛出out_of_range异常 访问元素1234c.find(k); //返回一个迭代器，指向第一个关键字为k的元素。如果不存在，指向尾后迭代器。c.count(k); //返回关键字等于k的元素的数量。c.lower_bound(k); //返回一个迭代器，指向第一个关键字不小于k的元素c.upper_bound(k); //返回一个迭代器，指向第一个关键字大于k的元素 无序容器无序关联容器使用哈希函数。 无序容器在储存上组织为一个桶，每个桶保存零个或多个元素。无序容器使用哈希函数将元素映射到桶。 无序容器的管理操作 123456789101112131415//桶接口c.bucket_count(); //正在使用的桶的数目c.max_bucket_count();c.bucket_size(n); //第n个桶中的元素个数c.bucket(k); //关键字为k的元素在哪个桶中//桶迭代local_iterator 用来访问桶中元素的迭代器类型const_local_iteratorc.begin(n),c.begin(n) 桶n的首元素迭代器和尾后迭代器c.cbegin(n),c.cbegin(n)//哈希策略c.load_factor(); // 每个桶的平均元素的数量c.max_load_factor();c.rehash(n); //重组存储，使得bucket_count&gt;n而且bucket_count&gt;size/max_load_facorc.reserve(n); //重组存储，是的c可以保存n个元素不必rehash 12.动态内存 静态内存保存局部static对象、类static成员以及定义在任何函数之外的变量。分配在静态内存中的对象由编译器自动创建和销毁。 栈内存用来保存函数内的非static对象。 除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来储存动态分配的对象。 动态内存与智能指针智能指针定义在头文件memory中 shared_ptr允许多个指针指向同一个对象 unique_ptr独占所指向的对象 weak_ptr，是一种弱引用，指向shared_ptr所管理的对象 shared_ptr类智能指针也是模板 123456789101112131415//shared_ptr和unique_ptr都支持的操作shared_ptr&lt;T&gt; sp 空智能指针，可以指向T类型的对象unique_ptr&lt;T&gt; upp 将p用作一个条件判断，如果p指向一个对象则为true*p 解引用pp-&gt;memp.get() 返回p中保存的指针。要小心使用，如果智能指针释放了对象，返回的指针指向的对象也就消失了swap(p,q) 交换p和q中的指针 //shared_ptr独有的操作make_shared&lt;T&gt; (args)shared_ptr&lt;T&gt;p(q) p是智能指针q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换成T*p=q 此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放。p.unique() 若p.use_count()为1返回true，否则falsep.use_count() 返回与p共享对象的智能指针的数量；可能很慢，主要用于调试 make_shared函数1234shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt; (42);shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10,'9'); //shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;(); //进行值初始化auto p6 = make_shared&lt;int&gt;(); 如果将shared_ptr保存在容器中，而后不再需要全部元素，而只要其中的一部分元素，要记得使用erase删除不再需要的那些元素。 程序使用动态内存的原因 程序不知道自己需要使用多少对象 程序不知道对象的准确类型 程序需要在多个对象间共享数据 直接管理内存使用new动态分配和初始化在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针. 1234567891011121314int *pr = new int(1024);string *ps = new string(10,'9');vector&lt;int&gt; *pv = new vector&lt;int&gt;&#123;0,1,2,3,4,5,6&#125;;string *ps = new string; //默认初始化为空stringstring *ps = new string(); //值初始化为空stringint *pi1 = new int; //默认初始化，*pi1的值未定义int *pi2 = new int(); //值初始化为0,*pi2为0//释放动态内存delete p;int *p2 = nullptr;delete p2; //释放空指针总是对的 new和delete内存管理常见的三个问题 1.忘记delete内存2.使用已经释放的对象3.同一块内存使用两次 shared_ptr和new结合使用12345678910111213shared_ptr&lt;int&gt; p1 = new int(42); //错误：必须直接初始化shared_ptr&lt;int&gt; p2(new int(42)); //正确：进行了值初始化//定义和改变shared_ptr的其他方法shared_ptr&lt;T&gt; p(q); //p管理内置指针q所指向的对象shared_ptr&lt;T&gt; p(u); //p从unique_ptr u处接管了对象的所有权；将u置空shared_ptr&lt;T&gt; p(q,d); //p接管了内置指针q所指对象的所有权。q将使用可调用对象d来代替deleteshared_ptr&lt;T&gt; p(p2,d); //p是shared_ptr p2的拷贝，唯一的区别是使用可调用对象d代替delete// 若p是唯一指向其对象的shared_ptr, reset会释放此对象。若传递了可选的参数内置指针q，会令q指向p，否则将p置空p.reset(); p.reset(q);p.reset(q,d); 不要混合使用普通指针和智能指针，也不要使用get初始化另一个智能指针或为另一个智能指针赋值 其他shared_ptr操作123p = new int(1024); //错误：不能将一个指针赋予shared_ptrp.reset(new int(1024)); //正确：p指向一个新对象//reset会更新引用计数 智能指针使用规范 不使用相同的内置指针初始化（或reset）多个智能指针 不delete get()返回的指针 不使用get()初始化或reset另一个之智能指针 如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，指针就变为无效了。 如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。 unique_ptr初始化unique_ptr也必须采用值初始化 1234567891011unique_ptr&lt;string&gt; p1(new string(\"Stearklwjer\"));unique_ptr&lt;string&gt; p1(p2); //错误：unique_ptr不支持拷贝//unique_ptr操作unique_ptr&lt;T&gt; u1; //空unique_ptr（使用delete释放指针）unique_ptr&lt;T,D&gt; u2; //空unique_ptr，使用D释放指针unique_ptr&lt;T,D&gt; u(d); //空unique_ptr,指向类型为T的对象，用类型为D的对象d来代替deleteu = nullptr; //释放u所指的对象，将u置空u.reset(); u.reset(q); //将u指向qu.reset(nullptr); 可以拷贝或赋值一个将要销毁的unique_ptr，比如函数返回值。 weak_ptrweak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会释放。 由于对象可能不存在，我们不能使用weak_ptr直接访问对象，必须调用lock()。 if (shared_ptr&lt;int&gt; np = wp.lock()){} 动态数组 当一个应用需要可变数量的对象时，使用vector。 new和数组1234567891011121314int *pia = new int[get_size()]; //pia指向第一个inttypedef int arrT[42];int *p = new arrT; //释放动态数组delete [] pia;//管理new分配的数组的unique_ptrunique_ptr&lt;int []&gt; up(new int [10]);up.release();//shared_ptr不直接管理动态数组，如果希望使用shared_ptr管理动态数组，必须提供自己定义的删除器shared_ptr&lt;int&gt; sp(new int[10], [](int *p)&#123;delete p;&#125;); 注意：动态数组类型并不是数组类型 allocator类allocator提供一种内存感知的内存分配方法。","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"}]},{"title":"c++头文件和源文件","slug":"c-头文件和源文件","date":"2019-11-19T06:15:35.000Z","updated":"2021-02-19T02:26:06.374Z","comments":true,"path":"2019/11/19/c-头文件和源文件/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/19/c-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6/","excerpt":"头文件(.h)：​ 写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。 .h文件中能包含：","text":"头文件(.h)：​ 写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。 .h文件中能包含： 类成员数据的声明，但不能赋值 类静态数据成员的定义和赋值，但不建议，只是个声明就好。 类的成员函数的声明 非类成员函数的声明 常数的定义：如：const int a=5; 静态函数的定义 类的内联函数的定义 不能包含： 1． 所有非静态变量（不是类的数据成员）的声明 2。 默认命名空间声明不要放在头文件，using namespace std;等应放在.cpp中，在 .h 文件中使用 std::string 特别注意 一，头文件中可以写 const 对象的定义。因为全局的 const 对象默认是没有 extern 的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个 .cpp 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同时，因为这些 .cpp 文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些 .cpp 文件中的这个 const 对象的值是相同的，可谓一举两得。同理，static 对象的定义也可以放进头文件。 二，头文件中可以写内联函数（inline）的定义。因为inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义；但是，如果我在其他的文件中还使用到了这个函数那怎么办呢？这几乎没什么太好的解决办法，因此 C++ 规定，内联函数可以在程序中定义多次，只要内联函数在一个 .cpp 文件中只出现一次，并且在所有的 .cpp 文件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。 三，头文件中可以写类（class）的定义。因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的。所以把类的定义放进头文件，在使用到这个类的 .cpp 文件中去包含这个头文件，是一个很好的做法。在这里，值得一提的是，类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。一般，我们的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个 .cpp 文件中。这是可以的，也是很好的办法。不过，还有另一种办法。那就是直接把函数成员的实现代码也写进类定义里面。在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被重定义了。 源文件（.cpp）：源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。那么当你需要用到自己写的头文件中的类时，只需要#include进来就行了。","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"}]},{"title":"c++内联函数","slug":"c-内联函数","date":"2019-11-19T06:14:18.000Z","updated":"2021-02-19T02:26:06.346Z","comments":true,"path":"2019/11/19/c-内联函数/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/19/c-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","excerpt":"参考链接：https://blog.csdn.net/BjarneCpp/article/details/76044493 1.内联函数在C++中我们通常定义以下函数来求两个整数的最大值：","text":"参考链接：https://blog.csdn.net/BjarneCpp/article/details/76044493 1.内联函数在C++中我们通常定义以下函数来求两个整数的最大值：1234int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;1234 为这么一个小的操作定义一个函数的好处有： ① 阅读和理解函数 max 的调用，要比读一条等价的条件表达式并解释它的含义要容易得多 ② 如果需要做任何修改，修改函数要比找出并修改每一处等价表达式容易得多 ③ 使用函数可以确保统一的行为，每个测试都保证以相同的方式实现 ④ 函数可以重用，不必为其他应用程序重写代码 虽然有这么多好处，但是写成函数有一个潜在的缺点：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行 C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数： 1234inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;1234 则调用：cout &lt;&lt; max(a, b) &lt;&lt; endl; 在编译时展开为：cout &lt;&lt; (a &gt; b ? a : b) &lt;&lt; endl; 从而消除了把 max写成函数的额外执行开销。 2. 内联函数和宏无论是《Effective C++》中的 “Prefer consts，enums，and inlines to #defines” 条款，还是《高质量程序设计指南——C++/C语言》中的“用函数内联取代宏”，宏在C++中基本是被废了，在书《高质量程序设计指南——C++/c语言》中这样解释到： 3. 将内联函数放入头文件关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。 如下风格的函数 Foo 不能成为内联函数： 12345inline void Foo(int x, int y); // inline 仅与函数声明放在一起 void Foo(int x, int y)&#123; //...&#125; 12345 而如下风格的函数 Foo 则成为内联函数： 12345void Foo(int x, int y); inline void Foo(int x, int y) // inline 与函数定义体放在一起&#123; //...&#125; 12345 所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但我认为 inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。 定义在类声明之中的成员函数将自动地成为内联函数，例如： 12345class A&#123; public: void Foo(int x, int y) &#123; ... &#125; // 自动地成为内联函数 &#125; 12345 但是编译器是否将它真正内联则要看 Foo函数如何定义 内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。 当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。 但是你会很奇怪，重复定义那么多次，不会产生链接错误？ 我们来看一个例子： 1234567891011121314151617181920212223242526272829303132333435// 文件A.h 代码如下:class A&#123;public: A(int a, int b) : a(a),b(b)&#123;&#125; int max();private: int a; int b;&#125;;1234567891011// 文件A.cpp 代码如下:#include \"A.h\"inline int A::max()&#123; return a &gt; b ? a : b;&#125;12345678// 文件Main.cpp 代码如下:#include &lt;iostream&gt;#include \"A.h\"using namespace std;inline int A::max()&#123; return a &gt; b ? a : b;&#125;int main()&#123; A a(3, 5); cout &lt;&lt; a.max() &lt;&lt; endl; return 0;&#125;12345678910111213141516 一切正常编译，输出结果：5 倘若你在Main.cpp中没有定义max内联函数，那么会出现链接错误：error LNK2001: unresolved external symbol &quot;public: int __thiscall A::max(void)&quot; (?max@A@@QAEHXZ)main.obj找不到函数的定义，所以内联函数可以在程序中定义不止一次，只要 inline 函数的定义在某个源文件中只出现一次，而且在所有源文件中，其定义必须是完全相同的就可以。 在头文件中加入或修改 inline 函数时，使用了该头文件的所有源文件都必须重新编译。 4. 慎用内联内联虽有它的好处，但是也要慎用，以下摘自《高质量程序设计指南——C++/C语言》： 而在Google C++编码规范中则规定得更加明确和详细： 内联函数：Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数. -inl.h文件： Tip： 复杂的内联函数的定义, 应放在后缀名为 -inl.h 的头文件中.内联函数的定义必须放在头文件中, 编译器才能在调用点内联展开定义. 然而, 实现代码理论上应该放在 .cc 文件中, 我们不希望 .h 文件中有太多实现代码, 除非在可读性和性能上有明显优势. 如果内联函数的定义比较短小, 逻辑比较简单, 实现代码放在 .h 文件里没有任何问题. 比如, 存取函数的实现理所当然都应该放在类定义内. 出于编写者和调用者的方便, 较复杂的内联函数也可以放到 .h 文件中, 如果你觉得这样会使头文件显得笨重, 也可以把它萃取到单独的 -inl.h 中. 这样把实现和类定义分离开来, 当需要时包含对应的 -inl.h 即可。","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"}]},{"title":"C++ Primer读书笔记(第一部分：C++基础)","slug":"C-Primer读书笔记-第一部分：C-基础","date":"2019-11-19T05:58:54.000Z","updated":"2021-02-19T02:26:05.826Z","comments":true,"path":"2019/11/19/C-Primer读书笔记-第一部分：C-基础/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/19/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9AC-%E5%9F%BA%E7%A1%80/","excerpt":"1.开始 输出运算符和输入运算符类似，都返回其左侧运算对象作为其计算结果 从键盘输入文件结束符 在windows系统中，Ctrl+Z，然后按Enter或Return键 在Unix系统中，文件结束符是Ctrl+D","text":"1.开始 输出运算符和输入运算符类似，都返回其左侧运算对象作为其计算结果 从键盘输入文件结束符 在windows系统中，Ctrl+Z，然后按Enter或Return键 在Unix系统中，文件结束符是Ctrl+D 使用文件重定向12# addItems.exe是可执行文件，下面的命令将从一个infile的文件读取销售记录到cin，并将结果（cout）写入到一个名为outfile的文件中。addItems &lt;infile &gt;outfile 2.变量和基本类型 寻址的最小单元为byte 存储的基本单元为字 通常float以1个字（32比特）表示，double为2个字（64比特），long double以3/4个字表示。 char类型会表现为带符号或者无符号的，具体视编译器而定。 当我们给带符号类型一个超出他表示范围的值时，结果是未定义的。此时，可能可以继续工作也可能崩溃或产生垃圾数据。 变量初始化1234int unit_sold = 0;int unit_sold = &#123;0&#125;; //列表初始化int unit_sold&#123;0&#125;; //列表初始化int unit_sold(0); 在函数体内部，如果试图初始化一个extern关键字标记的变量，将引发错误。 变量只能被定义一次，但可以被多次声明 12extern int i; //声明iint i; //声明并定义i 在内层作用域中访问外层作用域可以使用操作域符::value 复合类型 一条声明语句由一个基本数据类型和一个紧随其后的声明符列表组成。 &amp;和*符号12345678//&amp;和*的上下文决定了符号的意义//在声明语句中，&amp;和*用于组成复合类型；在表达式中，他们的角色有转变成运算符。 int i = 42; int &amp;r = i; //&amp;紧随类型名出现，因此是声明的一部分，r是一个引用 int *p; //*紧随类型名出现，因此是声明的一部分，p是一个指针 p = &amp;i; //&amp;出现在表达式中，是一个取地址符 *p = i; //*出现在表达式中，是一个解引用符 int &amp;r2 = *p; //&amp;是声明的一部分，*是解引用符。 引用 引用必须被初始化，一旦初始化完成，引用将和他的初始值对象一直绑定在一在。 因为引用本身不是一个对象，所以不能定义引用的引用。 指针 建议初始化所有指针。 指向指针的引用123int i = 42;int *p;int *&amp;r = p; //离变量名最近的符号对变量的类型由最直接的影响，因此，r是一个引用 const限定符 const对象必须初始化 建议：对于const变量，不管是声明还是定义，都添加extern关键字，这样只需定义一次就可以了。 指针和const 12const double pi = 3.14;const double *cptr = &amp;pi; //指向常量的指针 顶层const 顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量。 一般的，顶层const可以表示任意的对象是常量，这点对任意数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是指针类型既可以是顶层const，也可以是底层const。 当执行对象的拷贝操作时，顶层const不受什么影响。底层const能忽视，非常量可以转换成常量，反之则不行。 123456789101112131415int i = 0;int *const p1 = &amp;i; //不能改变p1的值，这是一个顶层constconst int ci = 42; //不能改变ci的值，这是一个顶层constconst int *p2 = &amp;ci; //允许改变p2的值，这是一个底层constconst int *const p3 = p2; //靠右的const是顶层const，靠左的是底层constconst int &amp;r = ci; //用于引用的const都是底层const// 拷贝ci的值i = ci; //正确，拷贝ci的值，ci是一个顶层constp2 = p3; //正确：p2和p3指向的对象类型相同，p3顶层const部分不受影响// 底层const不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。int *p = p3; //错误：p3包含底层const的定义，而p没有p2 = p3; //正确：p2和p3都是底层constp2 = &amp;i； //正确：int*能转换成const int *int &amp;r = ci; //错误：不同的int&amp;不能绑定到int常量上const int &amp;r2 = i; //正确：const int&amp;可以绑定到一个普通int上 字面值类型 常量表达式的值在编译时就得到类型，因此对声明constexpr时用到的类型必须有所限制。算术类型、指针和引用都属于字面值类型。自定义类型，IO库和string类型不属于字面值类型 auto类型说明符 auto一般会忽略顶层const，底层const会保留下来。 decltype和引用 如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上一层或多层括号，编译器就会把他当成一个表达式。123//decltype((variable))的结果永远是引用，而decltype(variable)的结果只有当variable本身是引用时才是引用。decltype((i)) &amp;d; //错误d是一个int&amp;, 必须初始化decltype(i) e; //e是一个未初始化的int 自定义数据结构struct 和 class定义时花括号后面要加分号1struct Sales&#123;&#125;; 类内初始化或者放在花括号里，或者放在等号右边，记住不能使用圆括号。 头文件保护符1234#ifndef SALES_DATA_H#define SALES_DATA_Hstruct sales&#123;&#125;;#endif 3.字符串、向量和数组命名空间using声明 每个名字都需要独立的using声明 头文件不应该使用using声明 string类型 string对象会自动忽略开头的空白，从第一个非空的字符开始读起，直到另一个空白为止。 读取整行：getline(cin,line) size()函数返回的是size_type类型，是一个无符号整型，避免与有符号类型混用（如果一个表达式有size()就不要用int了，避免问题） 不能把字面值直接相加：“1”+“2” //错误 vector vector是一个类模版 尽量使用vector而不是数组+指针 vector中能存放绝大多数对象，引用不是对象，不能存放到vector中 添加元素：push_back() vector能实现高速的增长，因此没必要在定义时初始化vector大小 迭代器 *iter 返回迭代器所指元素的引用 Iter-&gt;mem 解引用iter并获取该元素的名为mem的成员等价于(*iter).mem ++iter 令iter指向下一个元素 —iter 令iter指向上一个元素 iter1!=iter2 指向同一个元素时两者相等 Iter1==iter2 12345vector&lt;int&gt;::iterator it; //读写元素string::iterator s; //读写字符vector&lt;int&gt;::const_iterator cit; //读元素string::const_iterator cs; //读字符 所有标准库和迭代器都定义了==和!=，有些没定义&lt;，因此使用迭代器时要习惯使用!= 养成使用!=的习惯 v.begin()，v.end()返回第一个元素的指针，尾后元素 v.cbegin(), v.cend()返回const_iterator Iter1-iter2返回difference_type，为带符号整数 数组 数组大小固定 数组的下标最好定义为size_t类型 std::begin(a) 返回第一个元素 多维数组 int *p[4]; //指针数组，整形指针的数组 int (*p)[4]; //数组指针，指向含有4个整形的数组 别名： 123typedef double wages;typedef int int_array[4]; //using int_array = int[4]; //别名声明 4.表达式基础 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内容中的位置） 在需要右值的时候可以使用左值来代替，但是不能把右值当成左值使用。当一个左值被当成右值使用时，实际使用的是他的内容（值）。 布尔值不应该参与运算。（如：bool b = true; bool b2=-b,此时b2为true） 赋值运算符满足右结合率（a=b=0,ab均为0） 除非必须，否则不用递增递减运算符的后置版本（++i，将+后的值返回） （*pbeg++）等价于*(pbeg++)将返回pbeg处的值，同时将指向的位置加一 几个特殊的运算符 成员访问运算符 p-&gt;size()等价于(*p).size() 条件运算符 ？： cond?expr1:expr2; 嵌套条件运算符 cond1?expr1:cond2?expr2:expr3; sizeof运算符，返回表达式或类型名字所占的字节数,类型为size_t sizeof（type） sizeof expr vector&lt;int&gt;::size_type ix=0 逗号运算符，首先对左边的表达式求值，然后将求值结果丢弃，逗号运算符真正的结果是右侧表达式的值。 隐式类型转换 整型提升 无符号类型转换 无符号数与有符号数运算，如果无符号类型不小于有符号类型，则将有符号对象转换为无符号对象。 数组转换成指针 指针的转换 常量整数值0或者字面值nullptr能转换成任意指针类型 指向任意非常量的指针能转换成void* 指向任意对象的指针能转换成const void * 转换成布尔类型 存在一种从算数类型或指针类型向布尔类型自动转换的机制 转换成常量 允许将指向非常量类型的指针转换成指向相应常量类型的指针。 类类型的转换 显式转换static_cast/dynamic_cast/const_cast/reinterpret_cast static_cast 定义明确的类型转换double slope = static_cast&lt;double&gt;(j)/i 找回void*指针 12void *p = &amp;d;double *dp = static_cast&lt;double*&gt;(p) const_cast 只能改变运算对象底层的const，不能改变变量的类型 12const char *pc;char *p&#x3D;const_cast&lt;char*&gt;(pc); 5.语句简单语句 使用空语句应当加上注释 switch语句case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式。 每一个case都要加break;包括default。 break语句负责终止离他最近的while、do while、for或switch语句，并从这些语句之后的第一条语句开始执行。 不要在程序中使用goto语句。 异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char * 标准异常4个异常相关的头文件 exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外的信息。 stdexcept头文件定义了几种常用的异常类。 new头文件定义了bad_alloc异常类型。 type_info头文件定义了bad_cast异常类型。 stdexcept头文件定义的异常列表 exception 最常见的问题 runtime_error 只有在运行时才能检测出来的问题 range_error 运行时错误：生成的结果超出了范围 overflow_error 运行时错误：计算上溢 underflow_error 运行时错误：计算下溢 logic_error 程序逻辑错误 domain_error 逻辑错误：参数对应的值不存在 incalid_argument 逻辑错误：无效参数 length_error 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range 逻辑错误：使用超出范围的值 异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char *（内容为异常对象的字符串初始值） 6.函数函数基础 可以使用void表示函数没有形参 12void f1()&#123;&#125;void f2(void)&#123;&#125; 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。 局部对象 自动对象（在块末尾销毁） 局部静态对象（在程序的执行路径第一次经过对象定义的语句时初始化，并且直到程序终止时才被销毁，在此期间，即使对象所在的函数结束执行也不会对他有影响） 12345678910size_t count_calls()&#123; static size_t ctr = 0; return ++ctr;&#125;int main()&#123; for (size_t i=0;i!=10;++i)&#123; cout&lt;&lt;count_calls()&lt;&lt;endl; &#125; return 0;&#125; 函数声明 函数的声明和函数的定义类似，唯一的区别是函数声明无需函数体，用一个分号替代即可 1int sum(const int &amp;a, const int &amp;b); 变量为头文件中声明，源文件中定义 函数在头文件中声明，源文件中定义 含有函数声明的头文件应该被包含到定义函数的源文件中 分离式编译 1g++ main.cpp func.cpp -o mian //func函数在main中调用 分离式编译 123cc -c main.cpp # main编译到mian.occ -c func.cpp #func编译到func.occ main.o func.o -o main #生成main.exe 参数传递 如果函数无需改变引用形参的值，最好将其声明为常量引用 当用实参初始化形参时会忽略掉顶层的const。换句话说，形参的顶层const被忽略掉了。 不能将普通引用绑定到const对象上。 不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。 int main(int argc, char argv[]){} 等价int main(int argc, char *argv){} 数组形参 const int ia[]等价于const int *ia matrix指向数组的首元素，该数组的元素是由10个整数构成的数组 12void print(int (*matrix)[10], int rowsize)&#123;&#125;void print(int matrix[][10], int rowsize)&#123;&#125; 含有可变形参的函数 为了能够编写处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模版。 initializer_list&lt;string&gt; a 向initializer_list中传递一个值的序列，必须把序列放在花括号内。12345void error_msg(initializer_list&lt;string&gt; il)&#123; for (auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; end; cout &lt;&lt; endl;&#125; 不要返回局部对象的引用或指针 调用一个返回引用的函数得到左值。可以像使用其他左值那样来使用返回引用的函数的调用 123456789char &amp;get_val(string &amp;str, string::size_type ix)&#123; return str[ix];&#125;int main()&#123; string s(\"a value\"); cout &lt;&lt; s&lt;&lt;endl; //输出为a value get_val(s,0)='A'; //将s[0]改为A cout &lt;&lt; s &lt;&lt; endl; //输出为A value&#125; 返回数组的指针 123456int (*func(int i))[10]; //使用别名typedef int arrT[10];using arrT=int[10]; //与上句等价arrT* func(int i ); 重载和const形参 1Record lookup(Phone); 对于接受引用或指针的函数来说，对象是常量还是非常量对应形参不同。 123456//四个独立的重载函数Record lookup(Account&amp;); //函数作用于Account的引用Record lookup(const Account&amp;); //新函数，作用于常量引用Record lookup(Account*); //新函数，作用于指向Account的指针Record lookup(const Account*); //新函数，作用于指向常量的指针 一旦某个形参被赋予了默认值，他后面的所有形参必须有默认值 对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。在给定的作用域中，一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参后侧的所有形参必须有默认值。 内联inline只是向编译器发出一个请求，编译器可以选择忽略这个请求。 内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数。 constexpr函数 定义constexpr与其他函数类似，但是要注意：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体必须有且仅有一条return语句。 1constexpr int new_sz()&#123;return 42;&#125; constexpr被隐式的指定为内联函数。 constexpr函数体也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。 constexpr函数不一定返回常量表达式。 对于某个给定的内联函数或者constexpr函数来说，他的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。 调试帮助 assert预处理宏 assert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此可以直接使用预处理名字而无需提供using声明。 NDEBUG预处理变量 我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。 命令行关闭 1CC -D NDEBUG main.c 函数指针 声明指向函数的指针 1bool (*pf)(const string &amp;); 当把函数名作为一个值使用时，函数自动的转换成指针。 使用重载函数的指针时，指针类型必须与重载函数中的一个精确匹配。 1234void ff(int*);void ff(unsigned int);void (*pf1)(unsigned int) = ff; 形参可以是指向函数的指针 123456//第三个参数是函数类型，他会自动转换成函数指针void useBigger(const string &amp;s1,const string &amp;s2, bool pf(const stirng &amp;,const string &amp;));//等价的声明void useBigger(const string &amp;s1,const string &amp;s2, bool （*pf）(const stirng &amp;,const string &amp;)); 简化使用了函数指针的代码 1234567//Func和Func2是函数类型typedef bool Func(const string &amp;, const string &amp;);typedef decltype(lengthCompare) Func2;//FuncP和FuncP2是函数指针typedef bool(*FuncP)(const sting &amp;, const string &amp;);typedef decltype(lengthCompare) *FuncP2; 返回指向函数的指针 1234567using F = int(int*,int); //F是函数类型，不是指针using PF = int (*)(int*, int); //PF是指针F *f1(int);PF f1(int);int (*f1(int))(int*,int); 7.类 在C++中，只有被声明为const的成员函数才能被一个const类对象调用。要声明一个const类型的类成员函数，只需要在成员函数参数列表后加上关键字const在类体之外定义const成员函数时，还必须加上const关键字若将成员成员函数声明为const，则该函数不允许修改类的数据成员。 成员函数的声明必须在类的内部，他的定义则既可以在类的内部，也可以在类的外部。 12//这里const的作用是修改隐式this指针的类型string isbn() const &#123;return this-&gt;bookNo;&#125; 类外部定义的成员的名字必须包含他所属的类名。 class和struct的唯一区别是默认访问权限不同。struct中，定义在第一个访问说明符之前的成员是public的。class是private。 构造函数123456789struct Sales_data&#123; Sales_data() = default; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n)&#123;&#125; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; 编译器只有在类没有任何构造函数的情况下替我们生成一个默认的构造函数。 编译器不能为某些类合成默认的构造函数。 在C++11标准中如果我们需要默认的构造函数，可以在函数列表后面写上=default来要求编译器生成构造函数。 友元12345class Sales_data&#123; //为Sales_data的非成员函数所做的友元声明 friend Sales_data add(const Sales_data &amp;, const Sales_data&amp;); friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;);&#125;; 类可以允许其他类或者函数访问他的非公有成员，方法是令其他类或者函数成为他们的友元。 最好在类定义开始或结束前的位置集中声明友元。 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 类的其他特性 定义在类内部的成员函数自动是inline的。 定义在类外部的成员函数如果要设定为inline的，最好只在类外部定义的地方说明。 inline成员函数也应该与相应的类定义在同一个头文件中。 可变数据成员 我们以往能改变类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。 1mutable int a; 当我们提供一个类内初始值时，必须以符号=或或括号表示。 一个const 成员函数如果以引用的形式返回*this，那么他的返回类型将是一个常量引用。 类的声明 12Sales_data item1;class Sales_data item1; //等价的声明 一个类的成员类型不能是类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了，因此类允许包含指向他自身类型的引用或指针。 12345class Link_screen&#123; Screen window; Link_screen *next; Link_screen *prev;&#125; 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。 当把一个成员函数声明为友元时，必须明确指出该成员函数属于哪个类。 如果一个类想把一组重载函数声明为他的友元，他需要对这组函数中的每一个进行分别声明； 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义后。 使用全局作用域中的变量 ::a 再探构造函数 成员的初始化顺序与他们在类定义中出现的顺序一致。构造函数初始值列表中初始值的先后位置关系不会影响实际的初始化顺序。 最好令构造函数的初始值的顺序与成员声明的顺序一致。而且如果可能的话，尽量避免使用某些成员初始化另一些成员。 委托构造函数 12345678910class Sales_data&#123; public: //非委托构造函数使用对应的实参初始化成员 Sales_data(std::string s, unsigned cnt, double price): bookNo(s),units_sold(cnt),revenue(cnt * price)&#123;&#125; //其余构造函数全部委托给另一个构造函数 Sales_data():Sales_data(\"\", 0, 0)&#123;&#125; Sales_data(std::string s):Sales_data(s, 0, 0)&#123;&#125; Sales_data(std:istream &amp;is):Sales_data()&#123;read(is,*this);&#125;&#125; 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。 如果定义了其他构造函数，最好也提供一个默认的构造函数。 使用默认构造函数 12Sales_data obj; //正确Sales_data obj(); //错误，实际上定义了一个函数 抑制构造函数定义的隐式转换 使用explicit 关键字 explicit构造函数只能直接初始化不能使用拷贝形式的初始化。 聚合类 类的静态成员 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。 静态成员函数不能声明称const 的，而且我们也不能在static函数体内使用this指针。 虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或指针来访问静态成员。 12345Account ac1;Account &amp;ac2;r = ac1.rate();r = ac2-&gt;rate(); 当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句： 要想确保对象只定义一次，最好的办法是把静态的数据成员的定义与其他非内联函数的定义放在同一个文件中。 通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成他所属的类的指针或引用。 12345678class Bar&#123; public: //... private: static Bar mem1; //正确：静态成员可以是不完全类型 Bar *mem2; //正确：指针成员可以是不完全类型 Bar mem3; //错误：数据成员必须是完全类型&#125; 可以使用静态成员作为默认实参 123456class Screen&#123; public: screen&amp; clear(char = bkground); private: static const char bkground;&#125; 非静态数据成员不能作为默认实参，因为他的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。 补充size_t和size_type为了使自己的程序有很好的移植性，c++程序员应该尽量使用size_t和size_type而不是int, unsigned size_t是全局定义的类型；size_type是STL类中定义的类型属性，用以保存任意string和vector类对象的长度 string::size_type 制类型一般就是unsigned int, 但是不同机器环境长度可能不同 win32 和win64上长度差别;size_type一般也是unsigned int 使用的时候可以参考：string::size_type a =123;vectorsize_type b=234;size_t b=456;size_t 使用的时候头文件需要 cstddef ；size_type 使用的时候需要string或者vectorsizeof(string::size_type)sizeof(vector::size_type)sizeof(vector::size_type)sizeof(size_t)上述长度均相等，长度为win32:4 win64:8二者联系：在用下标访问元素时，vector使用vector::size_type作为下标类型，而数组下标的正确类型则是size_t 总结：在STL容器中使用size_type，其余情况使用size_t 实际上size_type就是size_t在标准库容器中的别名 12345class container&#123; public: typedef size_t size_type; //....&#125;; 使用!=代替&gt;、&lt;号","categories":[{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"},{"name":"基础","slug":"基础","permalink":"https://sjtu-xx.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"利用hexo搭建个人博客","slug":"利用hexo搭建个人博客","date":"2019-11-18T15:35:47.000Z","updated":"2021-02-19T02:26:06.748Z","comments":true,"path":"2019/11/18/利用hexo搭建个人博客/","link":"","permalink":"https://sjtu-xx.github.io/2019/11/18/%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"基于hexo搭建个人博客1.安装nodejs 2.添加淘宝源 1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org","text":"基于hexo搭建个人博客1.安装nodejs 2.添加淘宝源 1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 3.安装hexo 1cnpm install -g hexo-cli 4.创建空文件夹 5.切换到空文件夹 6.生成 1sudo hexo init 7.新建github仓库 仓库名必须为 用户名.github.io 8. cnpm install —save hexo-deployer-git 9.设置_config.yml 配置(repo为仓库地址，使用ssh可能会提示权限错误，更改https地址后，删除./deploygit文件夹，重新部署。) 1234deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;sjtu-xx&#x2F;sjtu-xx.github.io.git branch: master 1hexo d #部署 10.更换主题 将主题下载到theme文件夹下，然后更改_config.yml中的theme文件 123hexo cleanhexo generatehexo deploy 11.添加gitalk评论系统 新建一个仓库如blog_comment,在设置中进行授权。settings-》Developer settings - &gt; OAuth Apps -》新建 Application name 与仓库名称一致，主页url和回调url一致，为主页地址。 在icarus的config文件中添加：12345678comment: # Name of the comment plugin type: gitalk owner: sjtu-xx # (required) GitHub user name repo: blog_comment # (required) GitHub repository name client_id: xxxxxxx # (required) OAuth application client id client_secret: xxxxxxxxx # (required) OAuth application client secret admin: sjtu-xx 遇到的问题： 插入图片： https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/ icarus主题详细配置： https://cloudy-liu.github.io/2019/06/23/Hexo%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB%E5%88%B0icarus/ 家里的网络在deploy时，连接github显示timeout错误通过连接手机运营商网络可以上传连接学校的vpn也可以成功上传 hexo数学公式原生hexo并不支持数学公式，需要安装插件 mathJax。mathJax 是一款运行于浏览器中的开源数学符号渲染引擎，使用 mathJax 可以方便的在浏览器中嵌入数学公式。mathJax 使用网络字体产生高质量的排版，因此可适应各种分辨率，它的显示是基于文本的而非图片，因此显示效果更好。这些公式可以被搜索引擎使用，因此公式里的符号一样可以被搜索引擎检索到。 1.安装$ npm install hexo-math --save 2.配置在站点yml文件中添加123456math: engine: &#39;mathjax&#39; # or &#39;katex&#39; mathjax: # src: custom_mathjax_source config: # MathJax config 在文档开头加入：mathjax: true","categories":[{"name":"其他工具","slug":"其他工具","permalink":"https://sjtu-xx.github.io/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sjtu-xx.github.io/tags/hexo/"},{"name":"icarus","slug":"icarus","permalink":"https://sjtu-xx.github.io/tags/icarus/"}]}],"categories":[{"name":"CODE工具","slug":"CODE工具","permalink":"https://sjtu-xx.github.io/categories/CODE%E5%B7%A5%E5%85%B7/"},{"name":"其他工具","slug":"其他工具","permalink":"https://sjtu-xx.github.io/categories/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7/"},{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/categories/JAVA/"},{"name":"基础","slug":"JAVA/基础","permalink":"https://sjtu-xx.github.io/categories/JAVA/%E5%9F%BA%E7%A1%80/"},{"name":"工具","slug":"JAVA/工具","permalink":"https://sjtu-xx.github.io/categories/JAVA/%E5%B7%A5%E5%85%B7/"},{"name":"Linux","slug":"Linux","permalink":"https://sjtu-xx.github.io/categories/Linux/"},{"name":"高性能计算","slug":"高性能计算","permalink":"https://sjtu-xx.github.io/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"},{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/categories/%E6%9D%90%E6%96%99/"},{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://sjtu-xx.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"Python","permalink":"https://sjtu-xx.github.io/categories/Python/"},{"name":"应用","slug":"Python/应用","permalink":"https://sjtu-xx.github.io/categories/Python/%E5%BA%94%E7%94%A8/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://sjtu-xx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"基础","slug":"Python/基础","permalink":"https://sjtu-xx.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"},{"name":"第三方库","slug":"Python/第三方库","permalink":"https://sjtu-xx.github.io/categories/Python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"前端","slug":"前端","permalink":"https://sjtu-xx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"算法","slug":"算法","permalink":"https://sjtu-xx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"机器学习","slug":"机器学习","permalink":"https://sjtu-xx.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"实例分割","slug":"深度学习/实例分割","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"},{"name":"Fortran","slug":"Fortran","permalink":"https://sjtu-xx.github.io/categories/Fortran/"},{"name":"目标检测","slug":"深度学习/目标检测","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"基础理论","slug":"深度学习/基础理论","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"},{"name":"实践案例","slug":"深度学习/实践案例","permalink":"https://sjtu-xx.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sjtu-xx.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://sjtu-xx.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"JAVA","slug":"JAVA","permalink":"https://sjtu-xx.github.io/tags/JAVA/"},{"name":"IDEA","slug":"IDEA","permalink":"https://sjtu-xx.github.io/tags/IDEA/"},{"name":"markdown","slug":"markdown","permalink":"https://sjtu-xx.github.io/tags/markdown/"},{"name":"PCB","slug":"PCB","permalink":"https://sjtu-xx.github.io/tags/PCB/"},{"name":"弹性力学","slug":"弹性力学","permalink":"https://sjtu-xx.github.io/tags/%E5%BC%B9%E6%80%A7%E5%8A%9B%E5%AD%A6/"},{"name":"有限元","slug":"有限元","permalink":"https://sjtu-xx.github.io/tags/%E6%9C%89%E9%99%90%E5%85%83/"},{"name":"COMSOL","slug":"COMSOL","permalink":"https://sjtu-xx.github.io/tags/COMSOL/"},{"name":"复合材料","slug":"复合材料","permalink":"https://sjtu-xx.github.io/tags/%E5%A4%8D%E5%90%88%E6%9D%90%E6%96%99/"},{"name":"材料","slug":"材料","permalink":"https://sjtu-xx.github.io/tags/%E6%9D%90%E6%96%99/"},{"name":"强度","slug":"强度","permalink":"https://sjtu-xx.github.io/tags/%E5%BC%BA%E5%BA%A6/"},{"name":"高分子","slug":"高分子","permalink":"https://sjtu-xx.github.io/tags/%E9%AB%98%E5%88%86%E5%AD%90/"},{"name":"破坏行为","slug":"破坏行为","permalink":"https://sjtu-xx.github.io/tags/%E7%A0%B4%E5%9D%8F%E8%A1%8C%E4%B8%BA/"},{"name":"疲劳","slug":"疲劳","permalink":"https://sjtu-xx.github.io/tags/%E7%96%B2%E5%8A%B3/"},{"name":"传热","slug":"传热","permalink":"https://sjtu-xx.github.io/tags/%E4%BC%A0%E7%83%AD/"},{"name":"结构力学","slug":"结构力学","permalink":"https://sjtu-xx.github.io/tags/%E7%BB%93%E6%9E%84%E5%8A%9B%E5%AD%A6/"},{"name":"多物理场","slug":"多物理场","permalink":"https://sjtu-xx.github.io/tags/%E5%A4%9A%E7%89%A9%E7%90%86%E5%9C%BA/"},{"name":"C++","slug":"C","permalink":"https://sjtu-xx.github.io/tags/C/"},{"name":"python","slug":"python","permalink":"https://sjtu-xx.github.io/tags/python/"},{"name":"Abaqus","slug":"Abaqus","permalink":"https://sjtu-xx.github.io/tags/Abaqus/"},{"name":"CAD","slug":"CAD","permalink":"https://sjtu-xx.github.io/tags/CAD/"},{"name":"实例分割","slug":"实例分割","permalink":"https://sjtu-xx.github.io/tags/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"},{"name":"达芬奇","slug":"达芬奇","permalink":"https://sjtu-xx.github.io/tags/%E8%BE%BE%E8%8A%AC%E5%A5%87/"},{"name":"剪辑","slug":"剪辑","permalink":"https://sjtu-xx.github.io/tags/%E5%89%AA%E8%BE%91/"},{"name":"GAN","slug":"GAN","permalink":"https://sjtu-xx.github.io/tags/GAN/"},{"name":"目标检测","slug":"目标检测","permalink":"https://sjtu-xx.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"注意力机制","slug":"注意力机制","permalink":"https://sjtu-xx.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"人脸识别","slug":"人脸识别","permalink":"https://sjtu-xx.github.io/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"},{"name":"语义分割","slug":"语义分割","permalink":"https://sjtu-xx.github.io/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"},{"name":"卷积神经网络","slug":"卷积神经网络","permalink":"https://sjtu-xx.github.io/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"mtcnn","slug":"mtcnn","permalink":"https://sjtu-xx.github.io/tags/mtcnn/"},{"name":"深度学习","slug":"深度学习","permalink":"https://sjtu-xx.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"keras","slug":"keras","permalink":"https://sjtu-xx.github.io/tags/keras/"},{"name":"yolo3","slug":"yolo3","permalink":"https://sjtu-xx.github.io/tags/yolo3/"},{"name":"口罩检测","slug":"口罩检测","permalink":"https://sjtu-xx.github.io/tags/%E5%8F%A3%E7%BD%A9%E6%A3%80%E6%B5%8B/"},{"name":"RNN","slug":"RNN","permalink":"https://sjtu-xx.github.io/tags/RNN/"},{"name":"LSTM","slug":"LSTM","permalink":"https://sjtu-xx.github.io/tags/LSTM/"},{"name":"神经网络","slug":"神经网络","permalink":"https://sjtu-xx.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"numpy","slug":"numpy","permalink":"https://sjtu-xx.github.io/tags/numpy/"},{"name":"pandas","slug":"pandas","permalink":"https://sjtu-xx.github.io/tags/pandas/"},{"name":"数据分析","slug":"数据分析","permalink":"https://sjtu-xx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"seaborn","slug":"seaborn","permalink":"https://sjtu-xx.github.io/tags/seaborn/"},{"name":"数据处理","slug":"数据处理","permalink":"https://sjtu-xx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://sjtu-xx.github.io/tags/OpenCV/"},{"name":"人脸检测","slug":"人脸检测","permalink":"https://sjtu-xx.github.io/tags/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"},{"name":"vtk","slug":"vtk","permalink":"https://sjtu-xx.github.io/tags/vtk/"},{"name":"kaggle","slug":"kaggle","permalink":"https://sjtu-xx.github.io/tags/kaggle/"},{"name":"激活函数","slug":"激活函数","permalink":"https://sjtu-xx.github.io/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"name":"优化","slug":"优化","permalink":"https://sjtu-xx.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"损失函数","slug":"损失函数","permalink":"https://sjtu-xx.github.io/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"},{"name":"jupyter","slug":"jupyter","permalink":"https://sjtu-xx.github.io/tags/jupyter/"},{"name":"anaconda","slug":"anaconda","permalink":"https://sjtu-xx.github.io/tags/anaconda/"},{"name":"miniconda","slug":"miniconda","permalink":"https://sjtu-xx.github.io/tags/miniconda/"},{"name":"c++","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"},{"name":"QT","slug":"QT","permalink":"https://sjtu-xx.github.io/tags/QT/"},{"name":"机器学习","slug":"机器学习","permalink":"https://sjtu-xx.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"docker","slug":"docker","permalink":"https://sjtu-xx.github.io/tags/docker/"},{"name":"vim","slug":"vim","permalink":"https://sjtu-xx.github.io/tags/vim/"},{"name":"leetcode","slug":"leetcode","permalink":"https://sjtu-xx.github.io/tags/leetcode/"},{"name":"八皇后问题","slug":"八皇后问题","permalink":"https://sjtu-xx.github.io/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"name":"mac","slug":"mac","permalink":"https://sjtu-xx.github.io/tags/mac/"},{"name":"linux","slug":"linux","permalink":"https://sjtu-xx.github.io/tags/linux/"},{"name":"命令","slug":"命令","permalink":"https://sjtu-xx.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"后处理","slug":"后处理","permalink":"https://sjtu-xx.github.io/tags/%E5%90%8E%E5%A4%84%E7%90%86/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://sjtu-xx.github.io/tags/matplotlib/"},{"name":"latex","slug":"latex","permalink":"https://sjtu-xx.github.io/tags/latex/"},{"name":"绘图","slug":"绘图","permalink":"https://sjtu-xx.github.io/tags/%E7%BB%98%E5%9B%BE/"},{"name":"github","slug":"github","permalink":"https://sjtu-xx.github.io/tags/github/"},{"name":"c","slug":"c","permalink":"https://sjtu-xx.github.io/tags/c/"},{"name":"cmake","slug":"cmake","permalink":"https://sjtu-xx.github.io/tags/cmake/"},{"name":"qt","slug":"qt","permalink":"https://sjtu-xx.github.io/tags/qt/"},{"name":"基础","slug":"基础","permalink":"https://sjtu-xx.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"icarus","slug":"icarus","permalink":"https://sjtu-xx.github.io/tags/icarus/"}]}