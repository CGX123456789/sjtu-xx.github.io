<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Abaqus后处理常用技术</title>
    <url>/2019/11/28/Abaqus%E5%90%8E%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><a id="more"></a>
<h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p>File -&gt; Print -&gt; </p>
<h2 id="查看指定增量步的结果"><a href="#查看指定增量步的结果" class="headerlink" title="查看指定增量步的结果"></a>查看指定增量步的结果</h2><p>Result -&gt; Step/Frame</p>
<h2 id="创建显示组"><a href="#创建显示组" class="headerlink" title="创建显示组"></a>创建显示组</h2><p>Tools-&gt; Display Group -&gt; Create</p>
<h2 id="显示窗口widget设置"><a href="#显示窗口widget设置" class="headerlink" title="显示窗口widget设置"></a>显示窗口widget设置</h2><p>Viewport-&gt;Viewport Annotion options-&gt;<br><img src="后处理1.png" alt="设置界面"></p>
<h2 id="后处理不显示网格"><a href="#后处理不显示网格" class="headerlink" title="后处理不显示网格"></a>后处理不显示网格</h2><p>Options -&gt; Common -&gt;<br><img src="后处理2.png" alt="设置界面"></p>
<h2 id="设置透明背景"><a href="#设置透明背景" class="headerlink" title="设置透明背景"></a>设置透明背景</h2><p>  View-&gt;graphic options<br> <img src="./白背景.png" alt="设置界面"></p>
<h2 id="设置超出设定范围的colorbar颜色"><a href="#设置超出设定范围的colorbar颜色" class="headerlink" title="设置超出设定范围的colorbar颜色"></a>设置超出设定范围的colorbar颜色</h2><p>Options-&gt; Contour -&gt;Spectrum-&gt;Greater than max;</p>
<h2 id="abaqus多图层绘制"><a href="#abaqus多图层绘制" class="headerlink" title="abaqus多图层绘制"></a>abaqus多图层绘制</h2><ol>
<li><p>打开odb后处理文件，将图层创建好之后设置好图片的各种参数，然后在View-&gt;Overlay Plot-&gt;create创建图层</p>
</li>
<li><p>点击右侧的plot overlay可以将图层混合。</p>
</li>
<li><p>如果需要进行对某个图层进行修改，在窗口勾选对应图层的Current。然后进行修改。</p>
</li>
</ol>
<h2 id="abaqus导出清晰的后处理图片"><a href="#abaqus导出清晰的后处理图片" class="headerlink" title="abaqus导出清晰的后处理图片"></a>abaqus导出清晰的后处理图片</h2><p>abaqus在print-&gt;选择PS/EPS可以直接设定分辨率导出，但是导出的效率极低。<br>使用PNG即使导出高像素，图片仍然模糊。<br><strong>TIFF格式设置像素最大值为2730px，则可以导出较为清晰的图片</strong></p>
<p>导出的图片的字体，Arial较为合适，Times在缩放后较为模糊。</p>
<h2 id="导出Mises和PEEQ记录"><a href="#导出Mises和PEEQ记录" class="headerlink" title="导出Mises和PEEQ记录"></a>导出Mises和PEEQ记录</h2><ol>
<li>打开cae文件，设置只显示viewport中的legend,legend-&gt;setFont-&gt;arial(大小12)</li>
<li>options -&gt; common -&gt; free edges</li>
<li>Mises stress -&gt; 设置上下限(0-1e9)颜色 -&gt; spectrum min/max      PEEQ -&gt; 上下限制(0-1.390)</li>
<li>选择增量步no gnd(21,34,77)  ff20(14,18,25)</li>
<li>print-&gt; tiff-&gt;关闭reduceto256的选项-&gt; width(2730)</li>
</ol>
<h2 id="导出expansion的记录"><a href="#导出expansion的记录" class="headerlink" title="导出expansion的记录"></a>导出expansion的记录</h2><p>选择0.2F和0.5F</p>
<ol>
<li>打开cae文件，设置只显示viewport中的legend,legend-&gt; setFont-&gt; arial(大小12)</li>
<li>options -&gt; common -&gt; free edges</li>
<li>Tools -&gt; display group -&gt; create-&gt; ferrite</li>
<li>mises limit (1.552e7-3.504e8) peeq limit(0-0.15)</li>
<li>contour view -&gt; overlay plot -&gt; create -&gt; </li>
<li>shape view -&gt; overlay plot -&gt; create</li>
</ol>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>Abaqus</tag>
        <tag>后处理</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoCAD基础</title>
    <url>/2020/04/07/AutoCAD%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="cad教程网站"><a href="#cad教程网站" class="headerlink" title="cad教程网站"></a>cad教程网站</h1><a id="more"></a>
<p>总：<a href="https://zhuanlan.zhihu.com/p/34532045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34532045</a></p>
<h1 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h1><ul>
<li>要打开关于正在运行的命令信息的“帮助”，只需按 F1 键。</li>
<li>要重复上一个命令，请按 Enter 键或空格键。</li>
<li>要查看各种选项，请选择一个对象，然后单击鼠标右键，或在用户界面元素上单击鼠标右键。</li>
<li>要取消正在运行的命令或者如果感觉运行不畅，请按 Esc 键。<h2 id="极轴追踪"><a href="#极轴追踪" class="headerlink" title="极轴追踪"></a>极轴追踪</h2></li>
<li>默认情况下，极轴追踪处于打开状态并引导光标以水平或垂直方向（0 或 90 度）移动。</li>
<li>当然你也可以设置30°、45°等等<h2 id="锁定角度"><a href="#锁定角度" class="headerlink" title="锁定角度"></a>锁定角度</h2></li>
<li>如果直线的第二个点需要以 45 度角创建且长度为 8 个单位，则需要在“命令”窗口中输入 &lt;45，如图所示。<h2 id="对象捕捉"><a href="#对象捕捉" class="headerlink" title="对象捕捉"></a>对象捕捉</h2></li>
<li>输入 OSNAP 命令以设置默认对象捕捉，也称为“运行”对象捕捉。<h2 id="特性选项板"><a href="#特性选项板" class="headerlink" title="特性选项板"></a>特性选项板</h2></li>
<li>“特性”选项板是基本工具，打开它的方式有这几种：<ul>
<li>使用 PROPERTIES 命令（快捷键 PR）</li>
<li>快捷键按 CTRL+1</li>
<li>单击“常用”选项卡的“特性”面板中的小箭头<h2 id="对象选择"><a href="#对象选择" class="headerlink" title="对象选择"></a>对象选择</h2></li>
</ul>
</li>
<li>使用窗交选择（右到左选择），可选中绿色区域内的或接触该绿色区域的任何对象。</li>
<li>使用窗口选择（左向右选择），将选中完全包含在蓝色区域内的任何对象。</li>
<li>如果框选对象多了两个怎么办，例如，选择了 42 个对象，其中有两个不应选择，可以按住 Shift 键并选中这两个对象。<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2></li>
<li>COPY</li>
<li>要制作大量副本，那就使用 “阵列”命令AR<h2 id="修建和延伸"><a href="#修建和延伸" class="headerlink" title="修建和延伸"></a>修建和延伸</h2></li>
<li>一种常用技巧是将 OFFSET 命令与 TRIM 和 EXTEND 命令结合使用。在命令窗口中，修建快捷键 TR ，延伸快捷键 EX。</li>
<li>不论修建还是延伸，执行命令后不要选择边界直接再按Enter 键或空格键，此操作强制 CAD 将所有对象视作可能的边界！   </li>
<li>修建和延伸命令可以互通，例如修建时按住shift键，选择的对象就会变成延伸！<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2></li>
<li>MIRROR<h2 id="拉伸"><a href="#拉伸" class="headerlink" title="拉伸"></a>拉伸</h2></li>
<li>使用 STRETCH 命令（或在命令窗口中输入快捷键 S）并使用窗交选择选择对象。<h2 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h2></li>
<li>FILLET 命令（在命令窗口中输入快捷键 F）通过创建与两个选定对象相切的圆弧来创建圆角。<h2 id="多段线编辑"><a href="#多段线编辑" class="headerlink" title="多段线编辑"></a>多段线编辑</h2></li>
<li>PEDIT</li>
<li>在某些情况下，修改多段线的最简单方法是：分解它、进行修改，然后使用 PEDIT 命令的“合并”选项将这些对象转换回多段线。</li>
</ul>
<h1 id="注释和标注"><a href="#注释和标注" class="headerlink" title="注释和标注"></a>注释和标注</h1><ul>
<li>可以使用代表多行文字的 MTEXT 命令（或在“命令”窗口中输入 MT）来创建通用说明。在“注释”面板中提供了多行文字工具。</li>
<li><p>在 AutoCAD 中，<strong>多重引线</strong>对象用于创建具有引线的文字，例如常规标签、参照标签、索引和标注。</p>
</li>
<li><p>我们可以使用 DIMLINEAR 命令（快捷键dli）来创建水平和垂直标注（所有标注命令都以 DIM 前缀开头）。</p>
</li>
<li>使用 DIMALIGNED 命令（快捷键DAL）来创建平行于对象的标注。</li>
<li>非常不建议或者不允许直接双击更改标注尺寸，这样只会让你的后续工作越来越多！</li>
<li>可以使用 DIMSTYLE 命令（快捷键D）设定许多标注变量，以控制标注外观和行为的几乎每个微妙差异。</li>
<li><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1>更改单位：DDUNITS<br>缩放：ZOOM<br>平移：PAN</li>
</ul>
<p>新建文件：NEW<br>打开文件：OPEN<br>保存文件：SAVE<br>撤销：UNDO</p>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>CAD</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer读书笔记(第一部分：C++基础)</title>
    <url>/2019/11/19/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9AC-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h1><ul>
<li>输出运算符和输入运算符类似，都返回其左侧运算对象作为其计算结果</li>
<li>从键盘输入文件结束符<ul>
<li>在windows系统中，Ctrl+Z，然后按Enter或Return键</li>
<li>在Unix系统中，文件结束符是Ctrl+D<a id="more"></a></li>
</ul>
</li>
<li><strong>使用文件重定向</strong><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> addItems.exe是可执行文件，下面的命令将从一个infile的文件读取销售记录到cin，并将结果（cout）写入到一个名为outfile的文件中。</span></span><br><span class="line">addItems &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="2-变量和基本类型"><a href="#2-变量和基本类型" class="headerlink" title="2.变量和基本类型"></a>2.变量和基本类型</h1><ul>
<li>寻址的最小单元为byte</li>
<li>存储的基本单元为字</li>
<li>通常float以1个字（32比特）表示，double为2个字（64比特），long double以3/4个字表示。</li>
<li>char类型会表现为带符号或者无符号的，具体视编译器而定。</li>
<li>当我们给带符号类型一个超出他表示范围的值时，结果是<strong>未定义的</strong>。此时，可能可以继续工作也可能崩溃或产生垃圾数据。</li>
<li>变量初始化<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> unit_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> unit_sold = &#123;<span class="number">0</span>&#125;;  <span class="comment">//列表初始化</span></span><br><span class="line"><span class="keyword">int</span> unit_sold&#123;<span class="number">0</span>&#125;;  <span class="comment">//列表初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unit_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>在函数体内部，如果试图初始化一个extern关键字标记的变量，将引发错误。</li>
<li><p>变量只能被定义一次，但可以被多次声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">//声明i</span></span><br><span class="line"><span class="keyword">int</span> i;   <span class="comment">//声明并定义i</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在内层作用域中访问外层作用域可以使用操作域符<code>::value</code></p>
</li>
</ul>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><ul>
<li>一条声明语句由一个基本数据类型和一个紧随其后的声明符列表组成。</li>
</ul>
<h3 id="amp-和-符号"><a href="#amp-和-符号" class="headerlink" title="&amp;和*符号"></a><code>&amp;和*符号</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&amp;和*的上下文决定了符号的意义</span></span><br><span class="line"><span class="comment">//在声明语句中，&amp;和*用于组成复合类型；在表达式中，他们的角色有转变成运算符。</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">int</span> &amp;r = i;    <span class="comment">//&amp;紧随类型名出现，因此是声明的一部分，r是一个引用</span></span><br><span class="line">  <span class="keyword">int</span> *p;        <span class="comment">//*紧随类型名出现，因此是声明的一部分，p是一个指针</span></span><br><span class="line">  p = &amp;i;        <span class="comment">//&amp;出现在表达式中，是一个取地址符</span></span><br><span class="line">  *p = i;        <span class="comment">//*出现在表达式中，是一个解引用符</span></span><br><span class="line">  <span class="keyword">int</span> &amp;r2 = *p;  <span class="comment">//&amp;是声明的一部分，*是解引用符。</span></span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li>引用必须被初始化，一旦初始化完成，引用将和他的初始值对象一直绑定在一在。</li>
<li>因为引用本身不是一个对象，所以不能定义引用的引用。</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li>建议初始化所有指针。</li>
<li>指向指针的引用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;   <span class="comment">//离变量名最近的符号对变量的类型由最直接的影响，因此，r是一个引用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><ul>
<li><p>const对象必须初始化</p>
<blockquote>
<p>建议：对于const变量，不管是声明还是定义，都添加extern关键字，这样只需定义一次就可以了。</p>
</blockquote>
</li>
<li><p>指针和const</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">//指向常量的指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>顶层const</p>
<ul>
<li><p><strong>顶层const</strong>表示指针本身是个常量，<strong>底层const</strong>表示指针所指的对象是一个常量。</p>
<blockquote>
<p>一般的，顶层const可以表示任意的对象是常量，这点对任意数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是指针类型既可以是顶层const，也可以是底层const。</p>
</blockquote>
</li>
<li><p>当执行对象的拷贝操作时，顶层const不受什么影响。底层const能忽视，非常量可以转换成常量，反之则不行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;   <span class="comment">//不能改变p1的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;    <span class="comment">//不能改变ci的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;  <span class="comment">//允许改变p2的值，这是一个底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">//靠右的const是顶层const，靠左的是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;    <span class="comment">//用于引用的const都是底层const</span></span><br><span class="line"><span class="comment">// 拷贝ci的值</span></span><br><span class="line">i = ci;     <span class="comment">//正确，拷贝ci的值，ci是一个顶层const</span></span><br><span class="line">p2 = p3;    <span class="comment">//正确：p2和p3指向的对象类型相同，p3顶层const部分不受影响</span></span><br><span class="line"><span class="comment">// 底层const不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。</span></span><br><span class="line"><span class="keyword">int</span> *p = p3;     <span class="comment">//错误：p3包含底层const的定义，而p没有</span></span><br><span class="line">p2 = p3;         <span class="comment">//正确：p2和p3都是底层const</span></span><br><span class="line">p2 = &amp;i；       <span class="comment">//正确：int*能转换成const int *</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = ci;    <span class="comment">//错误：不同的int&amp;不能绑定到int常量上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i; <span class="comment">//正确：const int&amp;可以绑定到一个普通int上</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><ul>
<li>常量表达式的值在编译时就得到类型，因此对声明constexpr时用到的类型必须有所限制。算术类型、指针和引用都属于字面值类型。自定义类型，IO库和string类型不属于字面值类型</li>
</ul>
<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><ul>
<li><strong>auto一般会忽略顶层const，底层const会保留下来。</strong></li>
</ul>
<h3 id="decltype和引用"><a href="#decltype和引用" class="headerlink" title="decltype和引用"></a>decltype和引用</h3><ul>
<li>如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上一层或多层括号，编译器就会把他当成一个表达式。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decltype((variable))的结果永远是引用，而decltype(variable)的结果只有当variable本身是引用时才是引用。</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) &amp;d;    <span class="comment">//错误d是一个int&amp;, 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;       <span class="comment">//e是一个未初始化的int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>struct 和 class定义时花括号后面要加分号<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>类内初始化或者放在花括号里，或者放在等号右边，记住不能使用圆括号。</p>
</blockquote>
<h2 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sales</span>&#123;</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="3-字符串、向量和数组"><a href="#3-字符串、向量和数组" class="headerlink" title="3.字符串、向量和数组"></a>3.字符串、向量和数组</h1><h2 id="命名空间using声明"><a href="#命名空间using声明" class="headerlink" title="命名空间using声明"></a>命名空间using声明</h2><ul>
<li><p>每个名字都需要独立的using声明</p>
</li>
<li><p>头文件不应该使用using声明</p>
<h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2></li>
<li><p>string对象会自动忽略开头的空白，从第一个非空的字符开始读起，直到另一个空白为止。</p>
</li>
<li><p>读取整行：getline(cin,line)</p>
</li>
<li><p>size()函数返回的是size_type类型，是一个无符号整型，避免与有符号类型混用（如果一个表达式有size()就不要用int了，避免问题）</p>
</li>
<li><p>不能把字面值直接相加：“1”+“2” //错误</p>
</li>
</ul>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>vector是一个类模版</li>
<li><p>尽量使用vector而不是数组+指针</p>
</li>
<li><p>vector中能存放绝大多数对象，引用不是对象，不能存放到vector中</p>
</li>
<li>添加元素：push_back()</li>
<li>vector能实现高速的增长，因此没必要在定义时初始化vector大小</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>返回迭代器所指元素的引用</td>
</tr>
<tr>
<td>Iter-&gt;mem</td>
<td>解引用iter并获取该元素的名为mem的成员等价于(*iter).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>令iter指向下一个元素</td>
</tr>
<tr>
<td>—iter</td>
<td>令iter指向上一个元素</td>
</tr>
<tr>
<td>iter1!=iter2</td>
<td>指向同一个元素时两者相等</td>
</tr>
<tr>
<td>Iter1==iter2</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;   <span class="comment">//读写元素</span></span><br><span class="line"><span class="built_in">string</span>::iterator s;          <span class="comment">//读写字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cit; <span class="comment">//读元素</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator cs;   <span class="comment">//读字符</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>所有标准库和迭代器都定义了==和!=，有些没定义&lt;，因此使用迭代器时要习惯使用!=</p>
<blockquote>
<p>养成使用!=的习惯</p>
</blockquote>
</li>
<li><p>v.begin()，v.end()返回第一个元素的指针，尾后元素</p>
</li>
<li>v.cbegin(), v.cend()返回const_iterator</li>
<li>Iter1-iter2返回difference_type，为带符号整数</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组大小固定</li>
<li>数组的下标最好定义为size_t类型</li>
<li>std::begin(a) 返回第一个元素</li>
</ul>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><ul>
<li><p>int *p[4]; //指针数组，整形指针的数组</p>
</li>
<li><p>int (*p)[4]; //数组指针，指向含有4个整形的数组</p>
</li>
<li><p>别名：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>]; <span class="comment">//</span></span><br><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span>[<span class="number">4</span>]; <span class="comment">//别名声明</span></span><br></pre></td></tr></table></figure>
<h1 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4.表达式"></a>4.表达式</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内容中的位置）</li>
<li>在需要右值的时候可以使用左值来代替，但是不能把右值当成左值使用。当一个左值被当成右值使用时，实际使用的是他的内容（值）。</li>
<li>布尔值不应该参与运算。（如：bool b = true; bool b2=-b,此时b2为true）</li>
<li>赋值运算符满足右结合率（a=b=0,ab均为0）</li>
<li>除非必须，否则不用递增递减运算符的后置版本（++i，将+后的值返回）</li>
<li><code>（*pbeg++）等价于*(pbeg++)</code>将返回pbeg处的值，同时将指向的位置加一</li>
</ul>
<h2 id="几个特殊的运算符"><a href="#几个特殊的运算符" class="headerlink" title="几个特殊的运算符"></a>几个特殊的运算符</h2><ul>
<li>成员访问运算符 <code>p-&gt;size()等价于(*p).size()</code></li>
<li>条件运算符 ？：   <code>cond?expr1:expr2;</code></li>
<li>嵌套条件运算符  <code>cond1?expr1:cond2?expr2:expr3;</code></li>
<li><img src="image/image-20191115165728603.png" alt="image-20191115165728603"></li>
<li>sizeof运算符，返回表达式或类型名字所占的字节数,类型为size_t<ul>
<li>sizeof（type） </li>
<li>sizeof expr </li>
<li><code>vector&lt;int&gt;::size_type ix=0</code></li>
</ul>
</li>
<li>逗号运算符，首先对左边的表达式求值，然后将求值结果丢弃，逗号运算符真正的结果是右侧表达式的值。</li>
</ul>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><ul>
<li>整型提升</li>
<li>无符号类型转换<ul>
<li>无符号数与有符号数运算，如果无符号类型不小于有符号类型，则将有符号对象转换为无符号对象。</li>
</ul>
</li>
<li>数组转换成指针</li>
<li>指针的转换<ul>
<li>常量整数值0或者字面值nullptr能转换成任意指针类型</li>
<li>指向任意非常量的指针能转换成void*</li>
<li>指向任意对象的指针能转换成const void *</li>
</ul>
</li>
<li>转换成布尔类型<ul>
<li>存在一种从算数类型或指针类型向布尔类型自动转换的机制</li>
</ul>
</li>
<li>转换成常量<ul>
<li>允许将指向非常量类型的指针转换成指向相应常量类型的指针。</li>
</ul>
</li>
<li>类类型的转换</li>
</ul>
<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><p><code>static_cast/dynamic_cast/const_cast/reinterpret_cast</code></p>
<ul>
<li><p>static_cast</p>
<ul>
<li><p>定义明确的类型转换<code>double slope = static_cast&lt;double&gt;(j)/i</code></p>
</li>
<li><p>找回void*指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = &amp;d;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>const_cast</p>
<ul>
<li><p>只能改变运算对象底层的const，不能改变变量的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char *pc;</span><br><span class="line">char *p&#x3D;const_cast&lt;char*&gt;(pc);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="5-语句"><a href="#5-语句" class="headerlink" title="5.语句"></a>5.语句</h1><h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><ul>
<li>使用空语句应当加上注释</li>
<li>switch语句case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式。</li>
<li>每一个case都要加break;包括default。</li>
<li>break语句负责终止离他最近的while、do while、for或switch语句，并从这些语句之后的第一条语句开始执行。</li>
<li>不要在程序中使用goto语句。</li>
<li>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char *</li>
</ul>
<h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p>4个异常相关的头文件</p>
<ol>
<li>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外的信息。</li>
<li>stdexcept头文件定义了几种常用的异常类。</li>
<li>new头文件定义了bad_alloc异常类型。</li>
<li>type_info头文件定义了bad_cast异常类型。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>stdexcept头文件定义的异常列表</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>exception</td>
<td>最常见的问题</td>
</tr>
<tr>
<td>runtime_error</td>
<td>只有在运行时才能检测出来的问题</td>
</tr>
<tr>
<td>range_error</td>
<td>运行时错误：生成的结果超出了范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>运行时错误：计算上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>运行时错误：计算下溢</td>
</tr>
<tr>
<td>logic_error</td>
<td>程序逻辑错误</td>
</tr>
<tr>
<td>domain_error</td>
<td>逻辑错误：参数对应的值不存在</td>
</tr>
<tr>
<td>incalid_argument</td>
<td>逻辑错误：无效参数</td>
</tr>
<tr>
<td>length_error</td>
<td>逻辑错误：试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
<td>out_of_range</td>
<td>逻辑错误：使用超出范围的值</td>
</tr>
</tbody>
</table>
</div>
<p>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char *（内容为异常对象的字符串初始值）</p>
<h1 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><ul>
<li><p>可以使用void表示函数没有形参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。</p>
</li>
<li><p>局部对象</p>
<ul>
<li><p>自动对象（在块末尾销毁）</p>
</li>
<li><p>局部静态对象（在程序的执行路径第一次经过对象定义的语句时初始化，并且直到程序终止时才被销毁，在此期间，即使对象所在的函数结束执行也不会对他有影响）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> count_calls()&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;count_calls()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数声明</p>
<ul>
<li><p><strong>函数的声明和函数的定义类似，唯一的区别是函数声明无需函数体，用一个分号替代即可</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>变量为头文件中声明，源文件中定义</strong></p>
</li>
<li><p><strong>函数在头文件中声明，源文件中定义</strong></p>
</li>
<li><p><strong>含有函数声明的头文件应该被包含到定义函数的源文件中</strong></p>
</li>
</ul>
</li>
<li><p>分离式编译</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ main.cpp func.cpp -o mian //func函数在main中调用</span><br></pre></td></tr></table></figure>
<ul>
<li><p>分离式编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc -c main.cpp # main编译到mian.o</span><br><span class="line">cc -c func.cpp #func编译到func.o</span><br><span class="line">cc main.o func.o -o main #生成main.exe</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul>
<li><strong>如果函数无需改变引用形参的值，最好将其声明为常量引用</strong></li>
<li>当用实参初始化形参时会忽略掉顶层的const。换句话说，形参的顶层const被忽略掉了。</li>
<li>不能将普通引用绑定到const对象上。</li>
<li>不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。</li>
<li>int main(int argc, char <em>argv[]){} 等价int main(int argc, char *</em>argv){}</li>
</ul>
<h2 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h2><ul>
<li><code>const int ia[]</code>等价于<code>const int *ia</code></li>
<li>matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowsize)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowsize)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h2><ul>
<li>为了能够编写处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模版。</li>
<li><code>initializer_list&lt;string&gt; a</code></li>
<li>向initializer_list中传递一个值的序列，必须把序列放在花括号内。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="built_in">end</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>不要返回局部对象的引用或指针</strong></li>
</ul>
<p><strong>调用一个返回引用的函数得到左值。可以像使用其他左值那样来使用返回引用的函数的调用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">get_val</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span>::size_type ix)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"a value"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//输出为a value</span></span><br><span class="line">  get_val(s,<span class="number">0</span>)=<span class="string">'A'</span>;    <span class="comment">//将s[0]改为A</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//输出为A value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回数组的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line"><span class="comment">//使用别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> arrT=<span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">//与上句等价</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i )</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载和const形参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于接受引用或指针的函数来说，对象是常量还是非常量对应形参不同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//四个独立的重载函数</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;        <span class="comment">//函数作用于Account的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;  <span class="comment">//新函数，作用于常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;        <span class="comment">//新函数，作用于指向Account的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;  <span class="comment">//新函数，作用于指向常量的指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>一旦某个形参被赋予了默认值，他后面的所有形参必须有默认值</p>
</li>
<li><p>对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。在给定的作用域中，一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参后侧的所有形参必须有默认值。</p>
</li>
<li><p>内联inline只是向编译器发出一个请求，编译器可以选择忽略这个请求。</p>
</li>
<li><p>内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数。</p>
</li>
</ul>
<h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><ul>
<li><p>定义constexpr与其他函数类似，但是要注意：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体必须有且仅有一条return语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>constexpr被隐式的指定为内联函数。</p>
</li>
<li><p>constexpr函数体也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。</p>
</li>
<li><p>constexpr函数不一定返回常量表达式。</p>
</li>
<li><p>对于某个给定的内联函数或者constexpr函数来说，他的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。</p>
</li>
</ul>
<h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><ul>
<li><p>assert预处理宏</p>
<ul>
<li>assert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此可以直接使用预处理名字而无需提供using声明。</li>
</ul>
</li>
<li><p>NDEBUG预处理变量</p>
<ul>
<li><p>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。</p>
</li>
<li><p>命令行关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CC -D NDEBUG main.c</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li><p>声明指向函数的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当把函数名作为一个值使用时，函数自动的转换成指针。</p>
</li>
<li><p>使用重载函数的指针时，指针类型必须与重载函数中的一个精确匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">unsigned</span> <span class="keyword">int</span>) = ff;</span><br></pre></td></tr></table></figure>
</li>
<li><p>形参可以是指向函数的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三个参数是函数类型，他会自动转换成函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">bool</span> pf(<span class="keyword">const</span> stirng &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价的声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">bool</span> （*pf）(<span class="keyword">const</span> stirng &amp;,<span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简化使用了函数指针的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FuncP和FuncP2是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> sting &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回指向函数的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*,<span class="keyword">int</span>); <span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span> (*)(<span class="keyword">int</span>*, <span class="keyword">int</span>); <span class="comment">//PF是指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="7-类"><a href="#7-类" class="headerlink" title="7.类"></a>7.类</h1><blockquote>
<p>在C++中，只有被声明为const的成员函数才能被一个const类对象调用。<br>要声明一个const类型的类成员函数，只需要在成员函数参数列表后加上关键字const<br>在类体之外定义const成员函数时，还必须加上const关键字<br>若将成员成员函数声明为const，则该函数不允许修改类的数据成员。</p>
</blockquote>
<ul>
<li>成员函数的声明必须在类的内部，他的定义则既可以在类的内部，也可以在类的外部。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里const的作用是修改隐式this指针的类型</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类外部定义的成员的名字必须包含他所属的类名。</li>
<li>class和struct的唯一区别是默认访问权限不同。struct中，定义在第一个访问说明符之前的成员是public的。class是private。</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">    	bookNo(s), units_sold(n), revenue(p*n)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器只有在类没有任何构造函数的情况下替我们生成一个默认的构造函数。</li>
<li>编译器不能为某些类合成默认的构造函数。</li>
<li>在C++11标准中如果我们需要默认的构造函数，可以在函数列表后面写上<code>=default</code>来要求编译器生成构造函数。</li>
</ul>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="comment">//为Sales_data的非成员函数所做的友元声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>类可以允许其他类或者函数访问他的非公有成员，方法是令其他类或者函数成为他们的友元。</li>
<li>最好在类定义开始或结束前的位置集中声明友元。</li>
<li>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</li>
</ul>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><ul>
<li><p>定义在类内部的成员函数自动是inline的。</p>
</li>
<li><p>定义在类外部的成员函数如果要设定为inline的，最好只在类外部定义的地方说明。</p>
</li>
<li><p>inline成员函数也应该与相应的类定义在同一个头文件中。</p>
</li>
<li><p>可变数据成员</p>
<ul>
<li><p>我们以往能改变类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当我们提供一个类内初始值时，必须以符号=或或括号表示。</p>
</li>
<li><p>一个const 成员函数如果以引用的形式返回*this，那么他的返回类型将是一个常量引用。</p>
</li>
<li><p>类的声明</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data item1;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> <span class="title">item1</span>;</span> <span class="comment">//等价的声明</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类的成员类型不能是类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了，因此类允许包含指向他自身类型的引用或指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link_screen</span>&#123;</span></span><br><span class="line">  Screen window;</span><br><span class="line">  Link_screen *next;</span><br><span class="line">  Link_screen *prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p>
</li>
<li><p>友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。</p>
</li>
<li><p>当把一个成员函数声明为友元时，必须明确指出该成员函数属于哪个类。</p>
</li>
<li><p>如果一个类想把一组重载函数声明为他的友元，他需要对这组函数中的每一个进行分别声明；</p>
</li>
<li><p>类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义后。</p>
</li>
<li><p>使用全局作用域中的变量 <code>::a</code></p>
</li>
</ul>
<h2 id="再探构造函数"><a href="#再探构造函数" class="headerlink" title="再探构造函数"></a>再探构造函数</h2><ul>
<li><p>成员的初始化顺序与他们在<strong>类定义中出现的顺序一致</strong>。构造函数初始值列表中初始值的先后位置关系不会影响实际的初始化顺序。</p>
</li>
<li><p>最好令构造函数的初始值的顺序与成员声明的顺序一致。而且如果可能的话，尽量避免使用某些成员初始化另一些成员。</p>
</li>
<li><p>委托构造函数</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">  Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price):</span><br><span class="line">  			bookNo(s),units_sold(cnt),revenue(cnt * price)&#123;&#125;</span><br><span class="line">  <span class="comment">//其余构造函数全部委托给另一个构造函数</span></span><br><span class="line">  Sales_data():Sales_data(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">  Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s):Sales_data(s, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">  Sales_data(<span class="built_in">std</span>:istream &amp;is):Sales_data()&#123;<span class="built_in">read</span>(is,*<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。</li>
</ul>
</li>
<li><p>如果定义了其他构造函数，最好也提供一个默认的构造函数。</p>
</li>
<li><p>使用默认构造函数</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data obj; <span class="comment">//正确</span></span><br><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>; <span class="comment">//错误，实际上定义了一个函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>抑制构造函数定义的隐式转换</p>
<ul>
<li>使用explicit 关键字</li>
<li>explicit构造函数只能直接初始化不能使用拷贝形式的初始化。</li>
</ul>
</li>
<li>聚合类</li>
</ul>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><ul>
<li><p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</p>
</li>
<li><p>静态成员函数不能声明称const 的，而且我们也不能在static函数体内使用this指针。</p>
</li>
<li><p>虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或指针来访问静态成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account &amp;ac2;</span><br><span class="line"></span><br><span class="line">r = ac1.rate();</span><br><span class="line">r = ac2-&gt;rate();</span><br></pre></td></tr></table></figure>
</li>
<li><p>当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句：</p>
</li>
<li><p>要想确保对象只定义一次，最好的办法是把静态的数据成员的定义与其他非内联函数的定义放在同一个文件中。</p>
</li>
<li><p>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。</p>
</li>
<li><p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p>
</li>
<li><p>静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成他所属的类的指针或引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> Bar mem1; <span class="comment">//正确：静态成员可以是不完全类型</span></span><br><span class="line">  Bar *mem2;  <span class="comment">//正确：指针成员可以是不完全类型</span></span><br><span class="line">  Bar mem3;   <span class="comment">//错误：数据成员必须是完全类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用静态成员作为默认实参</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function">screen&amp; <span class="title">clear</span><span class="params">(<span class="keyword">char</span> = bkground)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> bkground;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非静态数据成员不能作为默认实参，因为他的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。</p>
</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="size-t和size-type"><a href="#size-t和size-type" class="headerlink" title="size_t和size_type"></a>size_t和size_type</h2><p>为了使自己的程序有很好的移植性，c++程序员应该尽量使用size_t和size_type而不是int, unsigned</p>
<p>size_t是全局定义的类型；size_type是STL类中定义的类型属性，用以保存任意string和vector类对象的长度</p>
<p>string::size_type 制类型一般就是unsigned int, 但是不同机器环境长度可能不同 win32 和win64上长度差别;size_type一般也是unsigned int</p>
<p>使用的时候可以参考：<br>string::size_type a =123;<br>vectorsize_type b=234;<br>size_t b=456;<br>size_t 使用的时候头文件需要 cstddef ；size_type 使用的时候需要string或者vector<br>sizeof(string::size_type)<br>sizeof(vector::size_type)<br>sizeof(vector::size_type)<br>sizeof(size_t)<br>上述长度均相等，长度为win32:4 win64:8<br>二者联系：在用下标访问元素时，vector使用vector::size_type作为下标类型，而数组下标的正确类型则是size_t</p>
<blockquote>
<p>总结：在STL容器中使用size_type，其余情况使用size_t</p>
<p>实际上size_type就是size_t在标准库容器中的别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">container</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="使用-代替-gt-、-lt-号"><a href="#使用-代替-gt-、-lt-号" class="headerlink" title="使用!=代替&gt;、&lt;号"></a>使用!=代替&gt;、&lt;号</h2><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C-Primer读书笔记-第二部分：标准库</title>
    <url>/2019/11/25/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<h1 id="8-IO库"><a href="#8-IO库" class="headerlink" title="8.IO库"></a>8.IO库</h1><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><h3 id="IO库类型和头文件"><a href="#IO库类型和头文件" class="headerlink" title="IO库类型和头文件"></a>IO库类型和头文件</h3><a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream,wistream从流读取数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>ostream,wostream向流写入数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>iostream，wiostream读写流</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream,wiftream从文件读取数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>ofstream,wofstream向文件写入数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>fstream，wfstream读写文件</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream,wistringstream从string读取数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>ostringstream,wostringstream向string写入数据</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>stringstream，wstringstream读写流</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>我们不能拷贝或者对IO对象赋值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream out1,out2;</span><br><span class="line">out1 = out2; <span class="comment">//错误：不能赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>; <span class="comment">//错误不能初始化ofstream参数</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2); <span class="comment">//错误：不能拷贝对象 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将流当作条件使用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。</p>
</li>
<li><p><img src="image/image-20191118170043547.png" alt="image-20191118170043547"></p>
</li>
<li><p><img src="image/image-20191118170058059.png" alt="image-20191118170058059"></p>
</li>
<li><p>带参数的clear接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复位failbit和badbit，保持其他标识位不变</span></span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">clear</span>(<span class="built_in">cin</span>.rdstate() &amp; ~<span class="built_in">cin</span>.failbit &amp; ~<span class="built_in">cin</span>.badbit)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在每个输出操作后，我们可以使用操作符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</p>
</li>
<li><p>刷新输出缓冲区</p>
<ul>
<li><p>操作符endl完成换行并刷新缓冲区的工作。</p>
</li>
<li><p>操作符ends向缓冲区插入一个空字符，然后刷新缓冲区。</p>
</li>
<li><p>操作符flush刷新缓冲区，不输出任何额外的字符。</p>
</li>
<li><p>如果想在每次输出操作后都刷新缓冲区，可以使用unitbuf操作符。他告诉流在接下来的每次写操作后都进行一次flush操作。而nounitbuf操作符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;  <span class="comment">//所有输出操作后都会立即刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuff; <span class="comment">//回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>关联输入和输出流</p>
<ul>
<li><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cout</span>); <span class="comment">//将cin和cout关联在一起（默认情况下这两者是关联的）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream</p>
</li>
</ul>
</li>
</ul>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><ul>
<li><p>使用文件流对象</p>
<ul>
<li><p>创建文件流对象时，可以提供文件名。如果提供文件名，则open会被自动调用；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;  <span class="comment">//构造ifstream并打开给定文件</span></span><br><span class="line">ofstream out;  <span class="comment">//输出文件流out</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个fstream对象离开其作用域，与之关联的文件会自动关闭。（当一个fstream对象被销毁时，close会被自动调用）</p>
</li>
</ul>
</li>
<li><p>文件模式</p>
<ul>
<li><img src="image/image-20191118171455672.png" alt="image-20191118171455672"></li>
<li><img src="image/image-20191118171509733.png" alt="image-20191118171509733"></li>
<li>只可以对ofstream或fstream设定out模式。</li>
<li>只可以对ifstream或fstream设定in模式。</li>
<li>只有当out也被设定，才可以设定trunct模式</li>
<li>只要trunc没被设定，就可以设定app模式。</li>
<li><img src="image/image-20191118171704813.png" alt="image-20191118171704813"></li>
<li>使用完流要及时close()</li>
</ul>
</li>
</ul>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><ul>
<li><p>sstream特有的操作</p>
<p><img src="image/image-20191118171744187.png" alt="image-20191118171744187"></p>
</li>
<li><p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PersonInfo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PersonInfo&gt; personInfos;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">line</span>,data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::ifstream inputFile;</span><br><span class="line">    inputFile.<span class="built_in">open</span>(<span class="string">"/Users/xuexuan/Desktop/tmp/test/123"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">std</span>::getline(inputFile,<span class="built_in">line</span>))&#123;</span><br><span class="line">        PersonInfo person;</span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">record</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">        record &gt;&gt; person.name;</span><br><span class="line">        <span class="keyword">while</span> (record &gt;&gt; data)&#123;</span><br><span class="line">            person.phones.push_back(data);</span><br><span class="line">        &#125;</span><br><span class="line">        personInfos.push_back(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item:personInfos)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">ostringstream</span> formatted, badNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nums:item.phones)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(nums))&#123;</span><br><span class="line">                formatted &lt;&lt; <span class="string">" "</span>&lt;&lt;nums;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                badNums &lt;&lt; <span class="string">"  "</span>&lt;&lt;nums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (badNums.str().empty())&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item.name &lt;&lt;<span class="string">" "</span>&lt;&lt;formatted.str()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item.name &lt;&lt;<span class="string">"  invalid:"</span>&lt;&lt; badNums.str() &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="9-顺序容器"><a href="#9-顺序容器" class="headerlink" title="9.顺序容器"></a>9.顺序容器</h1><h2 id="顺序容器的类型"><a href="#顺序容器的类型" class="headerlink" title="顺序容器的类型"></a>顺序容器的类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>容器</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td>
</tr>
<tr>
<td>list</td>
<td>双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作都很快</td>
</tr>
<tr>
<td>array</td>
<td>固定大小数组。支持快速随机访问。不能添加或删除元素</td>
</tr>
<tr>
<td>string</td>
<td>与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快</td>
</tr>
</tbody>
</table>
</div>
<p>vector\deque\list\forward_list\array\string<br>array是一种比内置数组更安全，更容易使用的数组类型。 array支持拷贝与赋值操作。<br>forward_list没有没有size操作。</p>
<h2 id="选择容器的基本原则"><a href="#选择容器的基本原则" class="headerlink" title="选择容器的基本原则"></a>选择容器的基本原则</h2><ul>
<li>除非有很好的理由选择其他容器，否则选择vector</li>
<li>如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list.</li>
<li>如果程序要求随机访问元素，应使用vector或deque</li>
<li>如果程序要求在容器中间插入或删除元素，应使用list或forward_list.</li>
<li>如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素。则：<ul>
<li>。。。</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操作：迭代器，不使用下标操作，避免随机访问。这样，在必要时选择vector和list都很方便。</p>
</blockquote>
<p>容器操作</p>
<p><img src="image/image-20200101190540050.png" alt="image-20200101190540050"></p>
<p><img src="image/image-20200101190558336.png" alt="image-20200101190558336"></p>
<ul>
<li>新标准库中容器既提供成员版本的swap，也提供非成员版本的swap。<strong>统一使用非成员版本的swap是一个好习惯</strong>。</li>
<li>当不需要写访问时，应使用cbegin和cend</li>
</ul>
<h2 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h2><h3 id="容器定义与初始化"><a href="#容器定义与初始化" class="headerlink" title="容器定义与初始化"></a>容器定义与初始化</h3><p>每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C c;</span><br><span class="line"><span class="function">C <span class="title">c1</span><span class="params">(c2)</span></span>;</span><br><span class="line">C c1 = c2; <span class="comment">// c1和c2必须是相同类型</span></span><br><span class="line">C c&#123;a,b,c&#125;;  </span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(b,e)</span></span>;  <span class="comment">//c初始化为迭代器b和e之间的元素的拷贝</span></span><br><span class="line"><span class="comment">// 只有顺序容器才能接受大小参数</span></span><br><span class="line"><span class="function">C <span class="title">seq</span><span class="params">(n)</span></span>; <span class="comment">//此函数是explicit的</span></span><br><span class="line"><span class="function">C <span class="title">seq</span><span class="params">(n,t)</span></span>;  <span class="comment">//n个t元素</span></span><br></pre></td></tr></table></figure>
<p>为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器与原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素即可。</p>
<p>虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array无此限制。</p>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p><img src="image/image-20200101192902724.png" alt="image-20200101192902724"></p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>在解引用一个迭代器或调用front或back之前检查是否有元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!c.empty())&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = *c.<span class="built_in">begin</span>(), val2 = c.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序容器中访问元素的操作</p>
<p><img src="image/image-20200101193255804.png" alt="image-20200101193255804"></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="image/image-20200101193430976.png" alt="image-20200101193430976"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><ul>
<li>改变容器大小 c .resize()</li>
</ul>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><ul>
<li>容器操作可能使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。</li>
<li>管理容量的成员函数</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>c.shrink_to_fit()</td>
<td>将capacity()减小为与size()相同大小</td>
</tr>
<tr>
<td>c.capacity()</td>
<td>不重新分配内存的话，c可以保存多少元素</td>
</tr>
<tr>
<td>c.reserve()</td>
<td>分配至少能容纳n个元素的内存空间</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>容器适配器</p>
<p>stack/queue/priority_queue</p>
</li>
<li><p>栈默认基于deque实现。</p>
</li>
</ul>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n、len2和pos2都是无符号值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cp,n)</span></span>; <span class="comment">//s是cp指向的数组中前n个字符的拷贝。此数组至少应该包含n个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2,pos2)</span></span>; <span class="comment">//s是string s2从下标pos2开始的字符的拷贝。若pos2&gt;S2.size(),构造函数未定义</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2,pos2,len2)</span></span>; <span class="comment">//s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;S2.size(),构造函数行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符</span></span><br></pre></td></tr></table></figure>
<p>子字符串操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.substr(pos,n); <span class="comment">//返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0.n的默认值为s.size()-pos,即拷贝从pos开始的所有字符</span></span><br></pre></td></tr></table></figure>
<h3 id="修改string的操作"><a href="#修改string的操作" class="headerlink" title="修改string的操作"></a>修改string的操作</h3><p><img src="image/image-20200101194839408.png" alt="image-20200101194839408"></p>
<p><img src="image/image-20200101194856656.png" alt="image-20200101194856656"></p>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="image/image-20200101195041242.png" alt="image-20200101195041242"></p>
<p><img src="image/image-20200101195050626.png" alt="image-20200101195050626"></p>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p><img src="image/image-20200101195207116.png" alt="image-20200101195207116"></p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><img src="image/image-20200101195227975.png" alt="image-20200101195227975"></p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>除了顺序容器，标准库还定义了三个顺序容器适配器：stack，queue和priority_queue。</p>
<h1 id="10-范型算法"><a href="#10-范型算法" class="headerlink" title="10.范型算法"></a>10.范型算法</h1><p>大多数算法定义在algorithm中。标准库还在numeric头文件中定义了一组数值范型算法。泛型算法本身不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作。算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p><strong>累加算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = accumulate(vec.cbegin(),vec.cend(),<span class="number">0</span>) <span class="comment">//accumulate中第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于只读取而不改变元素的算法，通常最好使用cbegin()和cend()</p>
</blockquote>
<p><strong>判等算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">equal(roster1.cbegin(),roster1.cend(),roster2.cbegin())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那些只接收一个单一迭代器来表示第二个序列的算法都假定第二个序列至少和第一个序列一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。</p>
</blockquote>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>); <span class="comment">//将每个元素置0</span></span><br><span class="line">fill_n(dest,n,val); <span class="comment">//将从dest开始的n个元素赋予val</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素</p>
</blockquote>
<p><strong>back_inserter 插入迭代器</strong></p>
<p>back_inserter定义在头文件iterator中的一个函数。接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。我们常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//空向量</span></span><br><span class="line"><span class="keyword">auto</span> it = back_inserter(vec);</span><br><span class="line">*it = <span class="number">42</span>; <span class="comment">//vec中现在有一个元素，值为42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill_n(back_inserter(vec),<span class="number">10</span>,<span class="number">0</span>); <span class="comment">//添加10个元素到vec</span></span><br></pre></td></tr></table></figure>
<h3 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//copy</span></span><br><span class="line"><span class="comment">//返回目的位置迭代器（递增后）的值</span></span><br><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="keyword">sizeof</span>(a1)/<span class="keyword">sizeof</span>(*a1)]</span><br><span class="line"><span class="keyword">auto</span> ret = copy(<span class="built_in">begin</span>(a1),<span class="built_in">end</span>(a1),a2); <span class="comment">//把a1的内容拷贝给a2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//replace</span></span><br><span class="line"><span class="comment">//将ilst中的0替换为42</span></span><br><span class="line">replace(ilst.<span class="built_in">begin</span>(),ilst.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//replace_copy</span></span><br><span class="line"><span class="comment">//保留原序列不变，将调整后的序列保存在第三个参数所指的位置</span></span><br><span class="line">replace_copy(ilst.cbegin(),ilst.cend(),back_inserter(ivec),<span class="number">0</span>,<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<h3 id="重排元素的算法"><a href="#重排元素的算法" class="headerlink" title="重排元素的算法"></a>重排元素的算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sort</span></span><br><span class="line"><span class="comment">//unique:将不重复的元素放在序列的开始部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</span><br><span class="line">    <span class="comment">//按字典排序</span></span><br><span class="line">    sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//unique返回 指向不重复区域之后第一个位置的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> end_unique = unique(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//使用vector的eraser删除重复元素</span></span><br><span class="line">    words.erase(end_unique,words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>类似于sort之类的函数有第二个版本，接受第三个参数，此参数是一个谓词。</p>
<blockquote>
<p>谓词是一个可调用的表达式。其返回结果是一个能用做条件的值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按长度由短至长排列</span></span><br><span class="line">sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//stable_sort</span></span><br><span class="line"><span class="comment">//保持元素原有顺序</span></span><br><span class="line">sort(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//find_if函数</span></span><br><span class="line">接受一个元素，</span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><blockquote>
<p>find_if 函数<br>接受一对迭代器，查找范围内第一个满足特定条件的元素。</p>
</blockquote>
<p><strong>lambda表达式</strong>的形式<code>[capture list](parameter list) -&gt; return type {function body}</code></p>
<blockquote>
<p>一个lambda只有在其捕获列表中捕获一个他所在函数中的局部变量，才能在函数中使用该变量</p>
<p>如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void</p>
</blockquote>
<p>lambda<strong>捕获和返回</strong></p>
<ul>
<li><p>如果可能的话，应避免捕获指针或引用</p>
</li>
<li><p>隐式捕获：为了只是编译器推断捕获列表，应在捕获列表中写一个<code>&amp;</code>或<code>=</code>，<code>&amp;</code>告诉编译器采用引用捕获的方式，<code>=</code>告诉编译器采用值捕获的方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">find_if(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[=](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;sz&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果希望改变被捕获的变量，就必须在参数列表开头加上关键字mutable。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1;&#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//j为43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定lambda的返回类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transform</span></span><br><span class="line"><span class="comment">// 接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。对输入序列中的每个元素调用可调用对象，并将结果写入到目的位置。</span></span><br><span class="line"><span class="comment">// 返回绝对值</span></span><br><span class="line">transform(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;v)-&gt;<span class="keyword">int</span>&#123;<span class="keyword">if</span> v&lt;<span class="number">0</span>:<span class="keyword">return</span> -v;<span class="keyword">else</span>:<span class="keyword">return</span> v;&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>bind函数位于头文件functional中，绑定格式<code>auto newCallable = bind(callable, arglist)</code>。arglist中的参数可能包含形如<code>_n</code>之类的名字，表示占位符。<code>_1</code>表示newCallable的第一个参数</p>
<blockquote>
<p>使用placeholders名字</p>
<p>名字_n都定义在placeholders命名空间中。这个空间本身定义在std命名空间中</p>
<p>using namespace std::placeholders;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="built_in">string</span>::size_type sz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的bind和lambda等价</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">                 [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> check_size(a, sz)&#125;);</span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">                 bind(check_size,_1,sz));</span><br></pre></td></tr></table></figure>
<p>bind的哪些不是占位符的参数被拷贝到bind返回的可调用对象中。如果我们希望传递给bind一个对象而不拷贝它，就必须使用ref函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),bind(<span class="built_in">print</span>,ref(os),_1,<span class="string">' '</span>))</span><br></pre></td></tr></table></figure>
<h3 id="其他迭代器"><a href="#其他迭代器" class="headerlink" title="其他迭代器"></a>其他迭代器</h3><ul>
<li>插入迭代器</li>
<li>流迭代器</li>
<li>反向迭代器</li>
<li>移动迭代器</li>
</ul>
<h4 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h4><p><code>back_inserter</code>、<code>front_inserter</code>、<code>inserter</code></p>
<blockquote>
<p><strong>插入迭代器的工作方式</strong></p>
<p>当调用inserter(c, iter) 时，得到一个迭代器，使用它时，会插入到iter原来所指的元素之前的位置</p>
<p>当调用front_inserter时，元素总是插入到第一个元素之前。</p>
</blockquote>
<h4 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从标准输入中读取数据，存入一个vector中</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_iter(<span class="built_in">cin</span>); <span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof; <span class="comment">//istream尾后迭代器（空表示尾后迭代器）</span></span><br><span class="line"><span class="keyword">while</span> (in_iter != eof)&#123;</span><br><span class="line">    vec.push_back(*in_iter++); <span class="comment">//将in_iter中的数据保存在in_iter中并读取下一条数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过copy打印vec中的元素，这比编写循环更简单。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),out_iter);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h4><p>递增一个反向迭代器会移动到前一个位置，递减一个反向迭代器会移动到后一个位置。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><div class="table-container">
<table>
<thead>
<tr>
<th>——-</th>
<th>——-</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入迭代器</td>
<td>只读、不写；单遍扫描，只能递增</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>只写、不读；单遍扫描，只能递增</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>可读写；多遍扫描，只能递增</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>可读写；多遍扫描，可递增递减</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>可读写，多遍扫描，支持全部迭代器运算</td>
</tr>
</tbody>
</table>
</div>
<p>array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。</p>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>大多数算法具有如下四种形式之一：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">alg(beg,<span class="built_in">end</span>,other args)</span><br><span class="line">alg(beg,<span class="built_in">end</span>,dest,other args)</span><br><span class="line">alg(beg,<span class="built_in">end</span>,beg2,other args)</span><br><span class="line">alg(beg,<span class="built_in">end</span>,beg2,end2,other args)</span><br></pre></td></tr></table></figure></p>
<h4 id="接受单个目标迭代器的算法"><a href="#接受单个目标迭代器的算法" class="headerlink" title="接受单个目标迭代器的算法"></a>接受单个目标迭代器的算法</h4><p>算法假定：按需要写入数据，不管写入多少元素都是安全的<br>如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已经存在的元素内。更常见的情况是，dest被绑定到一个插入迭代器，或是一个ostream_iterator。</p>
<h4 id="接受第二个输入序列的算法"><a href="#接受第二个输入序列的算法" class="headerlink" title="接受第二个输入序列的算法"></a>接受第二个输入序列的算法</h4><p>算法假定从beg2开始的范围与beg和end所表示的范围至少一样大。</p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>一些算法使用重载形式传递一个谓词 (unique)</p>
<h4 id="if版本的算法"><a href="#if版本的算法" class="headerlink" title="_if版本的算法"></a>_if版本的算法</h4><p>接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值。接受谓词的算法都有附加的_if前缀：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg,<span class="built_in">end</span>,val);   <span class="comment">//查找输入范围中val第一次出现的位置</span></span><br><span class="line">find_if(beg,<span class="built_in">end</span>,pred);   <span class="comment">//查找第一个使pred为真的元素</span></span><br></pre></td></tr></table></figure></p>
<h4 id="区分拷贝元素的版本和不拷贝元素的版本"><a href="#区分拷贝元素的版本和不拷贝元素的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝元素的版本"></a>区分拷贝元素的版本和不拷贝元素的版本</h4><p>写到额外空间的算法都在名字后面附加一个_copy:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reverse(beg,<span class="built_in">end</span>);</span><br><span class="line">reverse_copy(beg,<span class="built_in">end</span>,dest);  <span class="comment">//将元素按逆序拷贝到dest</span></span><br></pre></td></tr></table></figure></p>
<h3 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h3><p>list和forward_list成员函数版本的算法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lst.merge(lst2);  将来自lst2的元素合并入lst，lst2变为空。lst和lst2都必须是有序的，使用&lt;运算符</span><br><span class="line">lst.merge(lst2,comp); 将来自lst2的元素合并入lst，lst2变为空。lst和lst2都必须是有序的，使用compare</span><br><span class="line">lst.<span class="built_in">remove</span>(val); 调用erase删除掉与给定值相等的元素</span><br><span class="line">lst.reverse();</span><br><span class="line">lst.sort();</span><br><span class="line">lst.unique();</span><br></pre></td></tr></table></figure></p>
<h1 id="11-关联容器"><a href="#11-关联容器" class="headerlink" title="11.关联容器"></a>11.关联容器</h1><p><strong>关联容器</strong>支持高效的关键字查找和访问。<br>两个主要的关联容器：<code>set</code>和<code>map</code>。<br>|容器类型|描述|<br>|——————-|————-|<br>|按关键字有序保存元素||<br>|map|关联数组：保存关键字-值对|<br>|set|关键字即值，即只保存关键字的容器|<br>|multimap|关键字可重复初夏你的map|<br>|multiset|关键字可重复出现的set|<br>|无序集合||<br>|unordered_map|用哈希函数组织的map|<br>|unordered_set|用哈希函数组织的set|<br>|unordered_multimap|哈希组织的map：关键字可重复出现|<br>|unordered_multiset|哈希组织的set：关键字可重复出现|</p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p><strong>使用map</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计每个单词出现的次数</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;<span class="keyword">word</span>)&#123;</span><br><span class="line">	++word_count[<span class="keyword">word</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w:word_count)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; w.second &lt;&lt; ((w.second&gt;<span class="number">1</span>)?<span class="string">"times"</span>:<span class="string">"time"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用set</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计每个单词出现的次数</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>,<span class="string">"But"</span>,<span class="string">"And"</span>,<span class="string">"the"</span>,<span class="string">"but"</span>,<span class="string">"and"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;<span class="keyword">word</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (exclude.<span class="built_in">find</span>(<span class="keyword">word</span>)==exclude.<span class="built_in">end</span>())</span><br><span class="line">		++ word_count[<span class="keyword">word</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器支持普通容器的所有操作。不支持顺序容器的位置相关操作（如push_back等）。</p>
<h3 id="关联容器的定义"><a href="#关联容器的定义" class="headerlink" title="关联容器的定义"></a>关联容器的定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;  <span class="comment">//空容器</span></span><br><span class="line"><span class="comment">//列表初始化</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>,<span class="string">"But"</span>,<span class="string">"And"</span>,<span class="string">"the"</span>,<span class="string">"but"</span>,<span class="string">"and"</span>&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; authors = &#123;&#123;<span class="string">"Joyce"</span>,<span class="string">"James"</span>&#125;,</span><br><span class="line">						&#123;<span class="string">"Austen"</span>,<span class="string">"Jane"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i!=<span class="number">0</span>; ++i)&#123;</span><br><span class="line">	ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset(ivec.cbegin(),ivec.cend());</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; miset(ivec.cbegin(),ivec.cend());</span><br></pre></td></tr></table></figure>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>关键字类型必须定义元素的比较方法<br><strong>使用关键字类型的比较函数</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当使用decltype来获得一个函数的指针时，必须加上一个*来指出我们要使用一个给定函数类型的指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.isbn()&lt;rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(compareIsbn) *&gt; bookstore(compareIsbn);</span><br></pre></td></tr></table></figure></p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>pair类型定义在头文件utility中。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; anon;</span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">line</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; author&#123;<span class="string">"James"</span>,<span class="string">"Joyce"</span>&#125;;</span><br></pre></td></tr></table></figure><br>pair的数据成员是public的，两个成员分别命名为first和second。</p>
<p><img src="image/image-20200102190613569.png" alt="image-20200102190613569"></p>
<h2 id="关联容器的操作"><a href="#关联容器的操作" class="headerlink" title="关联容器的操作"></a>关联容器的操作</h2><p>关联容器额外的类型别名</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>——————</th>
<th>——————</th>
</tr>
</thead>
<tbody>
<tr>
<td>key_type</td>
<td></td>
</tr>
<tr>
<td>mapped_type</td>
<td></td>
</tr>
<tr>
<td>value_type</td>
</tr>
</tbody>
</table>
</div>
<p><img src="image/image-20200102191018921.png" alt="image-20200102191018921"></p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.cbegin(); <span class="comment">// *map_it是一个指向word_count中第一个元素的引用</span></span><br><span class="line"><span class="keyword">while</span> (map_it != word_count.<span class="built_in">end</span>())&#123;</span><br><span class="line">	count&lt;&lt; map_it -&gt; first &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; map_it -&gt; second &lt;&lt; <span class="string">"times"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++map_it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>set类型中的元素是const的，map中的元素是pair，其第一个成员是const的。</li>
<li>由于关联容器中的元素不能通过他们的关键字进行快速查找，因此对其使用泛型算法是一个坏主意。使用关联容器定义的专用的find成员比泛型find快的多。</li>
<li>实际编程中，如果我们真要对一个关联容器使用算法，要么是将他作为一个源序列，要么是当作一个目的位置。</li>
</ul>
<h3 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line">set1.insert(ivec.<span class="built_in">begin</span>(),ivec.<span class="built_in">end</span>());</span><br><span class="line">set1.insert(&#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>&#125;);</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line">word_count.insert(&#123;<span class="keyword">word</span>,<span class="number">1</span>&#125;);</span><br><span class="line">word_count.insert(make_pair(<span class="keyword">word</span>,<span class="number">1</span>));</span><br><span class="line">word_count.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">size_t</span>&gt;(<span class="keyword">word</span>,<span class="number">1</span>));</span><br><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">size_t</span>&gt;::value_type(<span class="keyword">word</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><img src="image/image-20200102192548970.png" alt="image-20200102192548970"></p>
<p>insert具有返回值。对于不包含重复关键字的容器，添加单一元素的insert和emplace返回一个pair,pair的第一个元素为指向具有给定关键字的元素的迭代器，second是一个指示关键字插入成功还是已经存在在容器中的bool值。</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.erase(k); <span class="comment">//删除关键字为k的元素，返回size_t值，指出删除元素的数量</span></span><br><span class="line">c.erase(p); <span class="comment">//删除迭代器指向的元素</span></span><br><span class="line">c.erase(b,e); <span class="comment">//删除b和e之间的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>不能对multimap和unordered_multimap进行下标操作。</p>
<p>与其他下标运算符不同的是，<strong>如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[k];  <span class="comment">//返回关键字为k的元素；如果k不在map中，则进行值初始化</span></span><br><span class="line">c.at(k); <span class="comment">//如果k不在c中抛出out_of_range异常</span></span><br></pre></td></tr></table></figure>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">find</span>(k); <span class="comment">//返回一个迭代器，指向第一个关键字为k的元素。如果不存在，指向尾后迭代器。</span></span><br><span class="line">c.count(k); <span class="comment">//返回关键字等于k的元素的数量。</span></span><br><span class="line">c.lower_bound(k); <span class="comment">//返回一个迭代器，指向第一个关键字不小于k的元素</span></span><br><span class="line">c.upper_bound(k); <span class="comment">//返回一个迭代器，指向第一个关键字大于k的元素</span></span><br></pre></td></tr></table></figure>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>无序关联容器使用哈希函数。</p>
<p>无序容器在储存上组织为一个桶，每个桶保存零个或多个元素。无序容器使用哈希函数将元素映射到桶。</p>
<p>无序容器的管理操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//桶接口</span></span><br><span class="line">c.bucket_count(); <span class="comment">//正在使用的桶的数目</span></span><br><span class="line">c.max_bucket_count();</span><br><span class="line">c.bucket_size(n); <span class="comment">//第n个桶中的元素个数</span></span><br><span class="line">c.bucket(k);  <span class="comment">//关键字为k的元素在哪个桶中</span></span><br><span class="line"><span class="comment">//桶迭代</span></span><br><span class="line">local_iterator 用来访问桶中元素的迭代器类型</span><br><span class="line">const_local_iterator</span><br><span class="line">c.<span class="built_in">begin</span>(n),c.<span class="built_in">begin</span>(n) 桶n的首元素迭代器和尾后迭代器</span><br><span class="line">c.cbegin(n),c.cbegin(n)</span><br><span class="line"><span class="comment">//哈希策略</span></span><br><span class="line">c.load_factor(); <span class="comment">// 每个桶的平均元素的数量</span></span><br><span class="line">c.max_load_factor();</span><br><span class="line">c.rehash(n); <span class="comment">//重组存储，使得bucket_count&gt;n而且bucket_count&gt;size/max_load_facor</span></span><br><span class="line">c.reserve(n); <span class="comment">//重组存储，是的c可以保存n个元素不必rehash</span></span><br></pre></td></tr></table></figure>
<h1 id="12-动态内存"><a href="#12-动态内存" class="headerlink" title="12.动态内存"></a>12.动态内存</h1><ul>
<li>静态内存保存局部static对象、类static成员以及定义在任何函数之外的变量。分配在静态内存中的对象由编译器自动创建和销毁。</li>
<li>栈内存用来保存函数内的非static对象。</li>
<li>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间</strong>或<strong>堆</strong>。程序用堆来储存动态分配的对象。</li>
</ul>
<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>智能指针定义在头文件memory中</p>
<ul>
<li><code>shared_ptr</code>允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>独占所指向的对象</li>
<li><code>weak_ptr</code>，是一种弱引用，指向shared_ptr所管理的对象</li>
</ul>
<h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>智能指针也是模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shared_ptr和unique_ptr都支持的操作</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; sp 空智能指针，可以指向T类型的对象</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; up</span><br><span class="line">p 将p用作一个条件判断，如果p指向一个对象则为<span class="literal">true</span></span><br><span class="line">*p 解引用p</span><br><span class="line">p-&gt;mem</span><br><span class="line">p.<span class="built_in">get</span>()  返回p中保存的指针。要小心使用，如果智能指针释放了对象，返回的指针指向的对象也就消失了</span><br><span class="line">swap(p,q) 交换p和q中的指针</span><br><span class="line">    </span><br><span class="line"><span class="comment">//shared_ptr独有的操作</span></span><br><span class="line">make_shared&lt;T&gt; (args)</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt;p(q)   p是智能指针q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换成T*</span><br><span class="line">p=q   此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为<span class="number">0</span>，则将其管理的原内存释放。</span><br><span class="line">p.unique()  若p.use_count()为<span class="number">1</span>返回<span class="literal">true</span>，否则<span class="literal">false</span></span><br><span class="line">p.use_count()  返回与p共享对象的智能指针的数量；可能很慢，主要用于调试</span><br></pre></td></tr></table></figure>
<h4 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p4 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>,<span class="string">'9'</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p5 = make_shared&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//进行值初始化</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果将shared_ptr保存在容器中，而后不再需要全部元素，而只要其中的一部分元素，要记得使用erase删除不再需要的那些元素。</p>
</blockquote>
<h4 id="程序使用动态内存的原因"><a href="#程序使用动态内存的原因" class="headerlink" title="程序使用动态内存的原因"></a>程序使用动态内存的原因</h4><ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><h4 id="使用new动态分配和初始化"><a href="#使用new动态分配和初始化" class="headerlink" title="使用new动态分配和初始化"></a>使用new动态分配和初始化</h4><p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'9'</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>; <span class="comment">//默认初始化为空string</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(); <span class="comment">//值初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi1 = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//默认初始化，*pi1的值未定义</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="keyword">new</span> <span class="keyword">int</span>();  <span class="comment">//值初始化为0,*pi2为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放动态内存</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> p2; <span class="comment">//释放空指针总是对的</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>new和delete内存管理常见的三个问题</strong></p>
<p>1.忘记delete内存<br>2.使用已经释放的对象<br>3.同一块内存使用两次</p>
</blockquote>
<h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);  <span class="comment">//错误：必须直接初始化</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)); <span class="comment">//正确：进行了值初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义和改变shared_ptr的其他方法</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q);  <span class="comment">//p管理内置指针q所指向的对象</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(u);  <span class="comment">//p从unique_ptr u处接管了对象的所有权；将u置空</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q,d);  <span class="comment">//p接管了内置指针q所指对象的所有权。q将使用可调用对象d来代替delete</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(p2,d);  <span class="comment">//p是shared_ptr p2的拷贝，唯一的区别是使用可调用对象d代替delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若p是唯一指向其对象的shared_ptr, reset会释放此对象。若传递了可选的参数内置指针q，会令q指向p，否则将p置空</span></span><br><span class="line">p.reset();  </span><br><span class="line">p.reset(q);</span><br><span class="line">p.reset(q,d);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要混合使用普通指针和智能指针，也不要使用get初始化另一个智能指针或为另一个智能指针赋值</p>
</blockquote>
<h3 id="其他shared-ptr操作"><a href="#其他shared-ptr操作" class="headerlink" title="其他shared_ptr操作"></a>其他shared_ptr操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">//错误：不能将一个指针赋予shared_ptr</span></span><br><span class="line">p.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>));  <span class="comment">//正确：p指向一个新对象</span></span><br><span class="line"><span class="comment">//reset会更新引用计数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>智能指针使用规范</strong></p>
<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()初始化或reset另一个之智能指针</li>
<li>如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，指针就变为无效了。</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。</li>
</ul>
</blockquote>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>初始化unique_ptr也必须采用值初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Stearklwjer"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p1(p2); <span class="comment">//错误：unique_ptr不支持拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr操作</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; u1;  <span class="comment">//空unique_ptr（使用delete释放指针）</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T,D&gt; u2;  <span class="comment">//空unique_ptr，使用D释放指针</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T,D&gt; u(d); <span class="comment">//空unique_ptr,指向类型为T的对象，用类型为D的对象d来代替delete</span></span><br><span class="line">u = <span class="literal">nullptr</span>;  <span class="comment">//释放u所指的对象，将u置空</span></span><br><span class="line">u.reset(); </span><br><span class="line">u.reset(q);  <span class="comment">//将u指向q</span></span><br><span class="line">u.reset(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>可以拷贝或赋值一个将要销毁的unique_ptr，比如函数返回值。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会释放。</p>
<p><img src="image/image-20200102214647056.png" alt="image-20200102214647056"></p>
<p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，必须调用lock()。</p>
<p><code>if (shared_ptr&lt;int&gt; np = wp.lock()){}</code></p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><blockquote>
<p>当一个应用需要可变数量的对象时，使用vector。</p>
</blockquote>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()]; <span class="comment">//pia指向第一个int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//释放动态数组</span></span><br><span class="line"><span class="keyword">delete</span> [] pia;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理new分配的数组的unique_ptr</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span> []&gt; up(<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>]);</span><br><span class="line">up.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr不直接管理动态数组，如果希望使用shared_ptr管理动态数组，必须提供自己定义的删除器</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p)&#123;<span class="keyword">delete</span> p;&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：动态数组类型并不是数组类型</p>
</blockquote>
<p><img src="image/image-20200102215952297.png" alt="image-20200102215952297"></p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>allocator提供一种内存感知的内存分配方法。</p>
<p><img src="image/image-20200102220158133.png" alt="image-20200102220158133"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C-Primer读书笔记-第四部分：高级主题</title>
    <url>/2020/01/05/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9A%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="17-标准库特殊实施"><a href="#17-标准库特殊实施" class="headerlink" title="17.标准库特殊实施"></a>17.标准库特殊实施</h1><a id="more"></a>
<h2 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h2><p>tuple支持的操作</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tuple<T1,T2,...,Tn> t;</td>
<td>t是一个tuple，成员数为n，所有成员都进行值初始化</td>
</tr>
<tr>
<td>tuple<T1,T2,...,Tn> t(v1,v2,…,vn);</td>
<td>t是一个tuple，成员类型为T1…Tn。每个成员都用对应的vi进行初始化。此函数是explicit的。</td>
</tr>
<tr>
<td>make_tuple(v1,v2,…,vn);</td>
<td>返回一个用给定初始值初始化的tuple。tuple的类型从初始值的类型判断。</td>
</tr>
<tr>
<td>t1==t2</td>
<td></td>
</tr>
<tr>
<td>t1!=t2</td>
<td></td>
</tr>
<tr>
<td><code>get&lt;i&gt;(t)</code></td>
<td>返回t的第i个数据成员的引用；如果t是一个左值，结果返回一个左值引用；如果t是一个右值，结果返回一个右值引用。tuple所有成员都是public的。</td>
</tr>
<tr>
<td><code>tuple_size&lt;tupleType&gt;::value</code></td>
<td>一个类模板，可以通过一个tuple类型来初始化。她有一个名为value的public constexpr static数据成员，类型为size_t,表示给定tuple类型中成员的数量。</td>
</tr>
<tr>
<td>tuple_element<i,tupleType>::type</td>
<td>一个类模板，可以通过一个整型常量和一个tuple类型来初始化。她有一个名为type的public成员，表示给定tuple类型中指定成员的类型。</td>
</tr>
</tbody>
</table>
</div>
<p>tuple的一个常见用途是从一个函数返回多个值。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类</th>
<th>类说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>regex</td>
<td>表示有一个正则表达式的类</td>
</tr>
<tr>
<td>regex_match</td>
<td>讲一个字符序列与一个正则表达式匹配</td>
</tr>
<tr>
<td>regex_search</td>
<td>寻找第一个与正则表达式匹配的子序列</td>
</tr>
<tr>
<td>regex_replace</td>
<td>是用给定格式替换一个正则表达式</td>
</tr>
<tr>
<td>sregex_iterator</td>
<td>迭代器适配器，调用regex_search来遍历一个string中所有匹配的字串</td>
</tr>
<tr>
<td>smatch</td>
<td>容器类，保存在string中搜索的结果</td>
</tr>
<tr>
<td>ssub_match</td>
<td>string中匹配的表达式的结果</td>
</tr>
</tbody>
</table>
</div>
<p>默认情况，regex使用的正则表达式语言是ECMAScript。在ECMAScript中，模式[[:alpha:]]匹配任意字母。</p>
<p>regex选项：定义在regex和regex_constants::syntax_option_type</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>icase</td>
<td>在匹配过程中忽略大小写</td>
</tr>
<tr>
<td>nosubs</td>
<td>不保存匹配的子表达式</td>
</tr>
<tr>
<td>optimize</td>
<td>执行速度优先与构造速度</td>
</tr>
<tr>
<td>ECMAScript</td>
<td>使用ECMA-262指定的语法</td>
</tr>
<tr>
<td>basic</td>
<td>使用POSIX基本的正则表达式语法</td>
</tr>
<tr>
<td>extended</td>
<td>使用POSIX扩展的正则表达式语法</td>
</tr>
<tr>
<td>awk</td>
<td>使用POSIX版本的awk语言的语法</td>
</tr>
<tr>
<td>grep</td>
<td>使用POSIX版本的grep的语法</td>
</tr>
<tr>
<td>egrep</td>
<td>使用POSIX版本的egrep的语法</td>
</tr>
</tbody>
</table>
</div>
<p>使用<code>regex r(&quot;[[:alnum:]]+\\.(cpp|cxx|xx)$&quot;,regex::icase)</code></p>
<blockquote>
<p>一个正则表达式所表示的“程序”是在运行时而非编译时编译的。正则表达式的编译是一个非常慢的操作，特别是在你使用了扩展的正则表达式语法或是复杂的正则表达式时。应该努力避免创建很多不必要的regex。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>迭代器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sregex_iterator it(b,e,r)</td>
<td>一个sregex_iterator,遍历迭代器b和e表示的string。他调用sregex_search(b,e,r)将it定位到输入中第一个匹配的位置。</td>
</tr>
<tr>
<td>sregex_iterator end;</td>
<td>sregex_iterator的尾后迭代器。</td>
</tr>
<tr>
<td>*it</td>
<td></td>
</tr>
<tr>
<td>it-&gt;</td>
<td></td>
</tr>
<tr>
<td>++it</td>
<td></td>
</tr>
<tr>
<td>it++</td>
<td></td>
</tr>
<tr>
<td>it1==it2</td>
<td></td>
</tr>
<tr>
<td>it1!=it2</td>
</tr>
</tbody>
</table>
</div>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>定义在头文件random中：随机数引擎类和随机数分布类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">default_random_engine e; <span class="comment">//生成随机无符号数</span></span><br><span class="line">e();</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>引擎操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Engine e</td>
<td>默认构造函数，使用默认种子</td>
</tr>
<tr>
<td>Engine e(s)</td>
<td>使用整数值s作为种子</td>
</tr>
<tr>
<td>e.seed(s)</td>
<td></td>
</tr>
<tr>
<td>e.min()</td>
<td>该引擎可生成的最小值和最大值</td>
</tr>
<tr>
<td>e.max()</td>
<td></td>
</tr>
<tr>
<td>Engine::result_type</td>
<td>该引擎生成的unsigned整型类型</td>
</tr>
<tr>
<td>e.discard(u)</td>
<td>将引擎推进u步，u的类型为unsigned long long</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>分布</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>uniform_int_distribution<unsigned> u(0,9)</td>
<td>生成0到9之间均匀分布的随机数</td>
</tr>
<tr>
<td>uniform_real_distribution<unsigned> u(0,1)</td>
<td>生成0到1之间的随机实数</td>
</tr>
<tr>
<td>normal_distribution&lt;&gt; n(4,1.5)</td>
<td>均值4，标准差1.5</td>
</tr>
<tr>
<td>bernoulli_distribution(0.55)</td>
<td>是一个普通类，返回bool值</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; good_randVec()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//由于我们希望引擎和分布对象保持状态，因此应该将他们定义为static的，从而每次调用都生成新的数</span></span><br><span class="line">    <span class="keyword">static</span> default_random_engine e;</span><br><span class="line">    <span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;++i)</span><br><span class="line">        ret.push_back(u(e));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO库再探"><a href="#IO库再探" class="headerlink" title="IO库再探"></a>IO库再探</h2><p>格式化输入输出</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolalpha</td>
<td>将true和false输出为字符串</td>
</tr>
<tr>
<td>noboolalpha</td>
<td>将true和false输出为0，1</td>
</tr>
<tr>
<td>showbase</td>
<td>对整型值输出表示进制的前缀</td>
</tr>
<tr>
<td>noshowbase</td>
<td>不生成表示进制的前缀</td>
</tr>
<tr>
<td>showpoint</td>
<td>对浮点值总是显示小数点</td>
</tr>
<tr>
<td>noshowpoint</td>
<td>只有当浮点值包含小数部分时才显示小数点</td>
</tr>
<tr>
<td>showpos</td>
<td>对非负数显示+</td>
</tr>
<tr>
<td>noshowpos</td>
<td>对非负数不显示+</td>
</tr>
<tr>
<td>uppercase</td>
<td>在十六进制中打印0X，在科学计数法中打印E</td>
</tr>
<tr>
<td>nouppercase</td>
<td>在十六进制中打印0x，在科学计数法中打印e</td>
</tr>
<tr>
<td>dec</td>
<td>整数显示为十进制</td>
</tr>
<tr>
<td>hex</td>
<td>整数显示为十六进制</td>
</tr>
<tr>
<td>oct</td>
<td>整数显示为八进制</td>
</tr>
<tr>
<td>left</td>
<td>在值的右侧添加填充字符</td>
</tr>
<tr>
<td>right</td>
<td>在值的左侧添加填充字符</td>
</tr>
<tr>
<td>internal</td>
<td>在符号和值之间添加填充字符</td>
</tr>
<tr>
<td>fixed</td>
<td>浮点值显示为定点十进制</td>
</tr>
<tr>
<td>scientific</td>
<td>浮点值现实为科学计数法</td>
</tr>
<tr>
<td>hexfloat</td>
<td>浮点值显示为十六进制</td>
</tr>
<tr>
<td>defaultfloat</td>
<td>重置浮点数格式为十进制</td>
</tr>
<tr>
<td>unitbuf</td>
<td>每次输出操作后都刷新缓存区</td>
</tr>
<tr>
<td>nounitbuf</td>
<td>恢复正常的缓冲区刷新方式</td>
</tr>
<tr>
<td>skipws</td>
<td>输入运算符跳过空白符</td>
</tr>
<tr>
<td>noskipws</td>
<td>输入运算符不跳过空白符</td>
</tr>
<tr>
<td>flush</td>
<td>刷新ostream缓冲区</td>
</tr>
<tr>
<td>ends</td>
<td>插入空字符，然后刷新ostream缓冲区</td>
</tr>
<tr>
<td>endl</td>
<td>插入换行，然后刷新ostream缓冲区</td>
</tr>
</tbody>
</table>
</div>
<p>iomanio中的操作符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>setfill(ch)</td>
<td>用ch填充空白</td>
</tr>
<tr>
<td>setprecision(n)</td>
<td>将浮点精度设置为n</td>
</tr>
<tr>
<td>setw(w)</td>
<td>读或写值的宽度为w个字符</td>
</tr>
<tr>
<td>setbase(b)</td>
<td>将整数输出为b进制</td>
</tr>
</tbody>
</table>
</div>
<h3 id="流随机访问"><a href="#流随机访问" class="headerlink" title="流随机访问"></a>流随机访问</h3><p>seek和tell函数</p>
<p>g输入，p输出</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tellg()</td>
<td>返回一个输入流中（tellg）或输出流中（tellp）标记当前位置</td>
</tr>
<tr>
<td>tellp()</td>
<td></td>
</tr>
<tr>
<td>seekg(pos)</td>
<td></td>
</tr>
<tr>
<td>seekp(pos)</td>
<td></td>
</tr>
<tr>
<td>seekg(off,from)</td>
<td>定位到from之前或之后off个字符：from可以是(beg,cur,end)</td>
</tr>
<tr>
<td>seekp(off,from)</td>
</tr>
</tbody>
</table>
</div>
<h1 id="18-用于大型程序的工具"><a href="#18-用于大型程序的工具" class="headerlink" title="18.用于大型程序的工具"></a>18.用于大型程序的工具</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li>一个异常如果没有被捕获，则它将终止当前的程序。程序将调用标准库函数terminate</li>
<li>通常情况下，如果catch接收的异常与某个继承体系有关，最好将该catch的参数定义成引用类型。</li>
<li><p>重新抛出仍然是一个throw语句，只不过不包含表达式<code>throw;</code>。</p>
</li>
<li><p>处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块。</p>
</li>
<li>一旦一个noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺。</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul>
<li><p>一个命名空间的定义包含两部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。</p>
</li>
<li><p>命名空间结束后无需分号。</p>
</li>
<li><p>命名空间可以是不连续的，命名空间可以定义在几个不同的部分。</p>
</li>
<li>命名空间中定义的成员可以直接使用名字，无须前缀；命名空间之外定义的成员必须使用含有前缀的名字</li>
<li>未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。</li>
<li>命名空间的别名：<code>namespace primer=cplusplusprimer</code></li>
<li><code>using namespace A;</code> 把A中的名字</li>
<li>对于using声明，只是简单的令名字在局部作用域内有效。using指示是令整个命名空间的所有内容变得有效。通常情况下，命名空间中会有一些不能出现在局部作用域中的定义。因此，using指令一般被看做是出现在最近的外层作用域中。</li>
</ul>
<h1 id="特殊工具与技术"><a href="#特殊工具与技术" class="headerlink" title="特殊工具与技术"></a>特殊工具与技术</h1><h2 id="控制内存分配"><a href="#控制内存分配" class="headerlink" title="控制内存分配"></a>控制内存分配</h2><h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h3><ol>
<li>new</li>
</ol>
<p>执行new实际上执行了三步操作。</p>
<ul>
<li>new表达式调用一个名为<code>operator new（或者operator new[]）</code>的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间 以便存储特定类型的对象。</li>
<li>编译器运行响应的构造函数以构造这些对象，并为其传入初始值。</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针。</li>
</ul>
<ol>
<li>delete</li>
</ol>
<p>两步操作。</p>
<ul>
<li>对所指的对象或者数组中的元素执行对应的析构函数</li>
<li>编译器调用名为<code>operator delete(或 operator delete[])</code>的标准库函数释放内存空间。</li>
</ul>
<h4 id="malloc函数和free函数"><a href="#malloc函数和free函数" class="headerlink" title="malloc函数和free函数"></a>malloc函数和free函数</h4><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e); <span class="comment">//e必须是指针，如果转换失败返回0</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e);  <span class="comment">//e必须是左值，如果转换失败抛出bad_cast异常</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e); <span class="comment">//e不能是左值，如果转换失败抛出bad_cast异常</span></span><br></pre></td></tr></table></figure>
<h3 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h3><p>typeid运算符允许程序向表达式提问，你的对象是什么类型？</p>
<p><code>typeid(e)</code>返回<code>type_info</code>类型的对象</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C-Primer读书笔记-第三部分：类设计者的工具</title>
    <url>/2020/01/02/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="13-拷贝控制"><a href="#13-拷贝控制" class="headerlink" title="13.拷贝控制"></a>13.拷贝控制</h1><a id="more"></a>
<h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><p>五种特殊的成员函数：<strong>拷贝构造函数、拷贝赋值构造函数、移动构造函数、移动赋值构造函数、析构函数</strong></p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul>
<li>拷贝构造函数的第一个参数必须是引用类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Foo(); <span class="comment">//默认构造函数</span></span><br><span class="line">    	Foo(<span class="keyword">const</span> Foo&amp;);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>拷贝初始化时依靠拷贝构造函数或移动构造函数来完成的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dots</span><span class="params">(<span class="number">10</span>,<span class="string">'.'</span>)</span></span>; <span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(dots)</span></span>; <span class="comment">//直接初始化</span></span><br><span class="line"><span class="built_in">string</span> s2 = dots; <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-999"</span>; <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> nines = <span class="built_in">string</span>(<span class="number">100</span>,<span class="string">'9'</span>); <span class="comment">//拷贝初始化</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用</p>
</blockquote>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;); <span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类未定义拷贝赋值运算符，编译器会为他生成一个合成拷贝赋值运算符。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	~Foo(); <span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>析构函数没有返回值，也不接受参数。</p>
</li>
<li><p>与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，智能指针在析构阶段会自动销毁。</p>
</li>
<li>析构函数体本身并不直接销毁成员。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。 </li>
</ul>
<h3 id="三-五原则"><a href="#三-五原则" class="headerlink" title="三/五原则"></a>三/五原则</h3><p>三个基本操作：拷贝构造函数、拷贝赋值构造函数、析构函数</p>
<h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//拷贝控制成员</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;);</span><br><span class="line">    ~Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在类内使用=default修饰成员的声明时，合成的函数将隐式地声明为内联的。</p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>可以通过将拷贝构造函数和拷贝复制构造函数定义为删除的函数来阻止拷贝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span>&#123;</span></span><br><span class="line">    NoCopy() = <span class="keyword">default</span>;</span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">//阻止拷贝</span></span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">//阻止赋值</span></span><br><span class="line">    ~NoCopy() = <span class="keyword">default</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>析构函数不能是删除的成员。对于析构函数已删除的成员，不能定义该类型的变量或释放指向该类型动态分配对象的指针。</p>
</blockquote>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// value-like implementation of HasPtr</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()): </span><br><span class="line">		ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// each HasPtr  has its own copy of the string to which ps points</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;p): </span><br><span class="line">		ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*p.ps)), i(p.i) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line"></span><br><span class="line">	~HasPtr() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span>    i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">	swap(lhs.ps, rhs.ps); <span class="comment">// swap the pointers, not the string data</span></span><br><span class="line">	swap(lhs.i, rhs.i);   <span class="comment">// swap the int members</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> *newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);  <span class="comment">// copy the underlying string</span></span><br><span class="line">	<span class="keyword">delete</span> ps;       <span class="comment">// free the old memory</span></span><br><span class="line">	ps = newp;       <span class="comment">// copy data from rhs into this object</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;    <span class="comment">// return this object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HasPtr <span class="title">f</span><span class="params">(HasPtr hp)</span>  <span class="comment">// HasPtr passed by value, so it is copied</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HasPtr ret = hp; <span class="comment">// copies the given HasPtr</span></span><br><span class="line">	<span class="comment">// process ret</span></span><br><span class="line">	<span class="keyword">return</span> ret;      <span class="comment">// ret and hp are destroyed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="function">HasPtr <span class="title">h</span><span class="params">(<span class="string">"hi mom!"</span>)</span></span>;  <span class="comment">// allocates a new copy of "hi mom!"</span></span><br><span class="line">	f(h);  <span class="comment">// copy constructor copies h in the call to f</span></span><br><span class="line">		   <span class="comment">// that copy is destroyed when f exits</span></span><br><span class="line">&#125;  <span class="comment">// h is destroyed on exit, which destroys its allocated memory</span></span><br></pre></td></tr></table></figure>
<h3 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reference counted version of HasPtr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// constructor allocates a new string and a new counter, </span></span><br><span class="line">	<span class="comment">// which it sets to 1</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()): </span><br><span class="line">	  ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// copy constructor copies all three data members </span></span><br><span class="line">	<span class="comment">// and increments the counter</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;p): </span><br><span class="line">		ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125;</span><br><span class="line"></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;);</span><br><span class="line"></span><br><span class="line">	~HasPtr();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span>    i;</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> *use;  <span class="comment">// member to track how many objects share *ps</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;   <span class="comment">// if the reference count goes to 0</span></span><br><span class="line">		<span class="keyword">delete</span> ps;       <span class="comment">// delete the string</span></span><br><span class="line">		<span class="keyword">delete</span> use;      <span class="comment">// and the counter</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs) </span><br><span class="line">&#123;</span><br><span class="line">	++*rhs.use;  <span class="comment">// increment the use count of the right-hand operand</span></span><br><span class="line">	<span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;   <span class="comment">// then decrement this object's counter</span></span><br><span class="line">		<span class="keyword">delete</span> ps;       <span class="comment">// if no other users </span></span><br><span class="line">		<span class="keyword">delete</span> use;      <span class="comment">// free this object's allocated members</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps = rhs.ps;         <span class="comment">// copy data from rhs into this object</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	use = rhs.use; </span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;        <span class="comment">// return this object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HasPtr <span class="title">f</span><span class="params">(HasPtr hp)</span> <span class="comment">// HasPtr passed by value, so it is copied</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HasPtr ret;</span><br><span class="line">	ret = hp;        <span class="comment">// assignment copies the given HasPtr</span></span><br><span class="line">	<span class="comment">// proces ret</span></span><br><span class="line">	<span class="keyword">return</span> ret;      <span class="comment">// ret and hp are destroyed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="function">HasPtr <span class="title">h</span><span class="params">(<span class="string">"hi mom!"</span>)</span></span>;</span><br><span class="line">	HasPtr h2 = h;  <span class="comment">// no new memory is allocated, </span></span><br><span class="line">	                <span class="comment">// h and h2 share the same underlying string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h是Foo中的一个HasPtr对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(lhs.h,rhs.h) <span class="comment">//错误，使用了标准库版本的swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h是Foo中的一个HasPtr对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.h,rhs.h) <span class="comment">//使用了HasPtr版本的swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值运算符中使用swap</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)&#123;</span><br><span class="line">    swap(*<span class="keyword">this</span>,rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><blockquote>
<p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p>
<p><strong>右值和左值</strong></p>
<p>左值指的是可以取地址的变量，记住，左值与右值的根本区别在于能否获取内存地址，而能否赋值不是区分的依据。通常临时量均为右值。</p>
<p>临时变量（右值）生命周期<br>a) 临时对象应该在完整表达式结束时销毁<br>b) 常量左值引用会延长临时变量的生命</p>
</blockquote>
<p>右值引用：通过&amp;&amp;而不是&amp;获得右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i;  <span class="comment">//正确：r引用i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i; <span class="comment">//错误：不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i*<span class="number">42</span>;  <span class="comment">//错误：i*42是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i*<span class="number">42</span>;  <span class="comment">//正确：我们可以将一个const的引用绑定到一个右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i*<span class="number">42</span>;  <span class="comment">//正确：将rr2绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>
<h4 id="左值持久，右值短暂"><a href="#左值持久，右值短暂" class="headerlink" title="左值持久，右值短暂"></a>左值持久，右值短暂</h4><p>左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>
<p>右值引用：</p>
<ul>
<li>所引用的对象即将被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>不能将一个右值引用绑定到一个右值引用类型的变量上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;  <span class="comment">//正确：字面值常量是一个右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1;  <span class="comment">//错误：表达式rr1是左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = <span class="built_in">std</span>::<span class="built_in">move</span>(rr1);  <span class="comment">//正确（move位于头文件utility中）</span></span><br></pre></td></tr></table></figure>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><blockquote>
<p>不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept</p>
</blockquote>
<p>移动构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line">    :elements(s.elements),first_free(s.first_free)&#123;</span><br><span class="line">        s.elements=s.first_free = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>移动赋值运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">    <span class="comment">//直接检测自赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)&#123;</span><br><span class="line">        <span class="comment">//释放已有的元素</span></span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        <span class="comment">//从rhs接管资源</span></span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝。</p>
</blockquote>
<h4 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h4><p>一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。</p>
<p>通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器。函数接受一个迭代器参数，返回一个移动迭代器。</p>
<blockquote>
<p>不要随意使用移动操作。</p>
<p>在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用std::move。</p>
</blockquote>
<h3 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h3><blockquote>
<p>区分移动和拷贝重载函数通常有一个版本接受一个const T&amp;，而另一个版本接受T&amp;&amp;。</p>
<p>一般来说，我们不需要为函数操作定义接受一个const X&amp;&amp;或是一个X&amp;参数的版本。当我们希望从实参窃取数据时，通常传递一个右值引用。为了达到这一目的，实参不能是const的。类似的，拷贝操作不应改变对象。</p>
</blockquote>
<h4 id="右值和左值引用成员函数"><a href="#右值和左值引用成员函数" class="headerlink" title="右值和左值引用成员函数"></a>右值和左值引用成员函数</h4><p>强制运算对象是左值可以使用引用限定符（<code>&amp;</code>或<code>&amp;&amp;</code>）。引用限定符&amp;表示本对象（this）是一个左值，&amp;&amp;表示本对象是一个右值。<code>const &amp;</code>限定符表示本对象是一个const或左值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) &amp;;  <span class="comment">//只能向可修改的左值赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo &amp;Foo::<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;rhs) &amp;&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于&amp;限定的函数，我们只能将他用于左值，对于&amp;&amp;限定的函数，只能用于右值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Foo &amp;<span class="title">retFoo</span><span class="params">()</span></span>;  <span class="comment">//返回一个引用；（左值）</span></span><br><span class="line"><span class="function">Foo <span class="title">retVal</span><span class="params">()</span></span>;  <span class="comment">//返回一个值；（右值）</span></span><br><span class="line">Foo i,j;    <span class="comment">//i和j是左值</span></span><br><span class="line">i = j;  <span class="comment">//i是左值</span></span><br><span class="line">retFoo() = j;  <span class="comment">//正确：retFoo()返回一个左值</span></span><br><span class="line">retVal() = j;  <span class="comment">//错误：retVal()返回一个右值</span></span><br><span class="line">i = retVal();  <span class="comment">//正确：可以将一个右值作为赋值操作的右侧运算对象</span></span><br></pre></td></tr></table></figure>
<p>const和&amp;限定符可同时使用，const在前。</p>
<h1 id="14-重载运算符与类型转换"><a href="#14-重载运算符与类型转换" class="headerlink" title="14.重载运算符与类型转换"></a>14.重载运算符与类型转换</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>重载函数名由关键字operator和要定义的运算符号共同组成。</li>
<li>对二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。</li>
<li>如果一个运算符函数是成员函数，则他的第一个（左侧）运算对象绑定到隐式的this指针上。</li>
<li>只能重载已有的运算符，而无权发明新的运算符</li>
</ul>
<blockquote>
<p>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。</p>
</blockquote>
<h4 id="选择作为成员还是非成员函数"><a href="#选择作为成员还是非成员函数" class="headerlink" title="选择作为成员还是非成员函数"></a>选择作为成员还是非成员函数</h4><ul>
<li>赋值（=）、下标（[]）、调用（()）、成员访问箭头(-&gt;)运算符必须是成员。</li>
<li>复合赋值运算符（+=）一般来说应该是成员，但非必须。</li>
<li>改变运算对象的运算符或与给定类型密切相关的运算符，如递增、递减、解引用等，通常应该是成员。</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，他们通常应该是普通的非成员函数。</li>
</ul>
<p>如果我们把运算符定义成成员函数时，他的左侧运算对象必须是运算符所属类别的一个对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s =<span class="string">"world"</span>;</span><br><span class="line"><span class="built_in">string</span> t = s + <span class="string">"!"</span>;  <span class="comment">//正确：我们能把一个const char*加到一个string对象中</span></span><br><span class="line"><span class="built_in">string</span> u = <span class="string">"hi"</span> + s;  <span class="comment">//如果+是string的成员，则产生错误</span></span><br></pre></td></tr></table></figure>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&gt;&gt;(ostream &amp;, <span class="keyword">const</span> Sales_data &amp;);</span><br></pre></td></tr></table></figure>
<p>令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节。</p>
<p>与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。</p>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><ul>
<li>如果一个类含有判断两个对象是否相等的操作，则他显然应该把函数定义成operator==而非一个普通的命名函数。</li>
<li>如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否有重复的数据。</li>
</ul>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><ul>
<li>下标运算符必须是成员函数。</li>
<li>如果一个类包含下标运算符，则他通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)&#123;<span class="keyword">return</span>  element[n];&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;<span class="keyword">return</span>  element[n];&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++();  <span class="comment">//前置运算符</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--();  <span class="comment">//后置运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>类型转换函数的一般类型如下：<code>operator type() const</code></p>
<blockquote>
<p>类型转换函数必须是类的成员函数；他不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是const。</p>
</blockquote>
<p>显式的类型转换运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si)+<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>如果表达式被用作条件，则编译器会将显示的类型转换自动应用于他。换句话说，当表达式出现在下列位置时，显式的类型转换被隐式的执行：</p>
<ul>
<li>if、while、do语句的条件部分</li>
<li>for语句头的条件表达式</li>
<li>逻辑非、或、与（！，||，&amp;&amp;）的运算对象</li>
<li>条件运算符（?:）的条件表达式</li>
</ul>
<blockquote>
<p>向bool的类型转换通常用在条件部分，因此operator bool一般定义为explicit的。</p>
<p>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。</p>
</blockquote>
<ul>
<li><strong>除了显式地向bool类型转换外，尽量避免定义类型转换函数并尽可能的显示那些“显然正确”的非现实构造函数</strong></li>
</ul>
<blockquote>
<p>在调用重载函数时，如果需要额外的标准类型转化，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</p>
<p>表达式中运算符的候选函数集既包含成员函数，也应该包括非成员函数。</p>
</blockquote>
<h1 id="15-面向对象程序设计"><a href="#15-面向对象程序设计" class="headerlink" title="15.面向对象程序设计"></a>15.面向对象程序设计</h1><h2 id="定义基类与派生类"><a href="#定义基类与派生类" class="headerlink" title="定义基类与派生类"></a>定义基类与派生类</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Item sold at an undiscounted price</span></span><br><span class="line"><span class="comment">// derived classes will define various discount strategies</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, Quote&amp;);</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Quote&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Quote(): price(<span class="number">0.0</span>) &#123; &#125;</span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price):</span><br><span class="line">                     bookNo(book), price(sales_price) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// virtual destructor needed </span></span><br><span class="line">	<span class="comment">// if a base pointer pointing to a derived object is deleted</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() &#123; &#125; <span class="comment">// dynamic binding for the destructor</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns the total sales price for the specified number of items</span></span><br><span class="line">    <span class="comment">// derived classes will override and apply different discount algorithms</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">               </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// virtual function to return a dynamically allocated copy of itself</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Quote(*<span class="keyword">this</span>);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo; <span class="comment">// ISBN number of this item</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price;       <span class="comment">// normal, undiscounted price</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abstract base class to hold the discount rate and quantity</span></span><br><span class="line"><span class="comment">// derived classes will implement pricing strategies using these data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">    Disc_quote(): quantity(<span class="number">0</span>), discount(<span class="number">0.0</span>) &#123; &#125;</span><br><span class="line">    Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line">              <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">                 Quote(book, price),</span><br><span class="line">                 quantity(qty), discount(disc) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">double</span>&gt; discount_policy() <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(quantity, discount); &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> quantity; <span class="comment">// purchase size for the discount to apply</span></span><br><span class="line">    <span class="keyword">double</span> discount;      <span class="comment">// fractional discount to apply</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>基类通常应该定义一个虚析构函数。即使该函数不执行任何实际操作也是如此。</li>
<li>基类通过在其成员函数的声明语句之前添加关键字virtual使得该函数执行动态绑定。</li>
<li>如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</li>
<li>继承自多个基类的类，基类以逗号分隔。</li>
<li>派生类的作用域嵌套在积累的作用域之内。</li>
<li>派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</li>
<li>派生类的声明中包含类名，但不包含他的派生列表。</li>
<li>防止继承发生的办法，在类名后加一个关键字final。</li>
<li>我们可以把基类的指针或引用绑定到派生类的对象上。这意味着，当使用基类的引用（或指针）时，我们并不清楚该引用（或指针）所绑定对象的真是类型。</li>
<li>智能指针类也支持派生类向基类的类型转。</li>
<li>不存在基类向派生类的隐式转换</li>
<li>从基类向派生类的类型转换只对指针或引用类型有效。</li>
<li>派生类向基类的类型转换也可能会由于访问受限而变得不可行。</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  <span class="comment">//隐藏：派生类的函数屏蔽了与其同名的基类函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  <span class="comment">//多态、覆盖</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    B b;  </span><br><span class="line">    A *p = &amp;a;  </span><br><span class="line">    p-&gt;foo();  <span class="comment">//输出1</span></span><br><span class="line">    p-&gt;fun();  <span class="comment">//输出2</span></span><br><span class="line">    p = &amp;b;  </span><br><span class="line">    p-&gt;foo();  <span class="comment">//取决于指针类型，输出1</span></span><br><span class="line">    p-&gt;fun();  <span class="comment">//取决于对象类型，输出4，体现了多态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 。</p>
<p>引入纯虚函数的原因：</p>
<pre><code>   （1）为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。

   （2）在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 
</code></pre><p>包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。</p>
<pre><code>   虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。
</code></pre><p>虚函数是C++中用于实现多态的机制。核心理念就是<strong>通过基类访问派生类定义的函数</strong>。如果父类或者祖先类中函数func()为虚函数，则子类及后代类中，函数func()是否加virtual关键字，都将是虚函数。为了提高程序的可读性，建议后代中虚函数都加上virtual关键字。</p>
<ul>
<li>一个派生类的函数如果覆盖了某个继承而来的虚函数，则他的形参类型必须与被他覆盖的虚函数完全一致。</li>
<li>派生类中虚函数的返回类型也必须与基类中的完全一致。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。</li>
<li>final说明符说明该函数不能被覆盖。</li>
<li>override说明符说明该函数应该覆盖基类的函数。如果没有正确覆盖，则会报错。</li>
</ul>
<h4 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h4><p>如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。</p>
<p>如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使试运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。</p>
<blockquote>
<p>如果基函数使用默认实参， 则基类和派生类中定义的默认实参最好一致。</p>
</blockquote>
<h4 id="回避虚函数机制"><a href="#回避虚函数机制" class="headerlink" title="回避虚函数机制"></a>回避虚函数机制</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::neet_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>何时用？通常是当一个派生类的虚函数调用它覆盖的积累的虚函数版本时。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ul>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问权。</li>
<li>派生类成员函数或友元对基类成员的访问权限只与基类中的访问说明符有关。</li>
<li>派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> priv_mem;  <span class="comment">//private成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">//正确：派生类能访问protected成员</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;</span><br><span class="line">    <span class="comment">//错误：private成员对于派生类来说是不可访问的</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> priv_mem;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span>:</span><span class="keyword">private</span> Base&#123;</span><br><span class="line">    <span class="comment">//private不影响对基类的访问权限</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pub_Derv d1;</span><br><span class="line">Priv_Derv d2;</span><br><span class="line">d1.pub_mem();  <span class="comment">//正确</span></span><br><span class="line">d2.pub_mem();  <span class="comment">//错误:pub_mem在派生类中是private的</span></span><br></pre></td></tr></table></figure>
<h4 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h4><ul>
<li>只有当D共有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或私有的，则用户代码不能使用该转换。</li>
<li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接积累的类型转换对于派生类的成员和友元来说永远是可访问的。</li>
<li>如果D继承B的方式是公有的或受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。</li>
</ul>
<h4 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h4><ul>
<li>不能继承友元关系；每个类负责控制各自成员的访问权限。</li>
</ul>
<h4 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h4><p>改变派生类继承的某个名字的访问级别，通过使用using声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>() <span class="keyword">const</span> &#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//保留对象尺寸相关的成员的访问级别</span></span><br><span class="line">    <span class="keyword">using</span> Base::<span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚函数的作用域"><a href="#虚函数的作用域" class="headerlink" title="虚函数的作用域"></a>虚函数的作用域</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::fcn() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fcn()"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// hides fcn in the base; this fcn is not virtual</span></span><br><span class="line">    <span class="comment">// D1 inherits the definition of Base::fcn() </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;      <span class="comment">// parameter list differs from fcn in Base</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// new virtual function that does not exist in Base</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D1::fcn(<span class="keyword">int</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::fcn(int)"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> D1::f2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// nonvirtual function hides D1::fcn(int)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;    <span class="comment">// overrides virtual fcn from Base</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;    <span class="comment">// overrides virtual f2 from D1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D2::fcn(<span class="keyword">int</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::fcn(int)"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> D2::fcn() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::fcn()"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> D2::f2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 dobj, *dp = &amp;dobj;</span><br><span class="line">    dp-&gt;fcn(<span class="number">42</span>); <span class="comment">// ok: static call to D1::fcn(int)</span></span><br><span class="line"></span><br><span class="line">    Base bobj;  D1 d1obj; D2 d2obj;</span><br><span class="line"></span><br><span class="line">    Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">    bp1-&gt;fcn(); <span class="comment">// virtual call, will call Base::fcn at run time</span></span><br><span class="line">    bp2-&gt;fcn(); <span class="comment">// virtual call, will call Base::fcn at run time</span></span><br><span class="line">    bp3-&gt;fcn(); <span class="comment">// virtual call, will call D2::fcn at run time</span></span><br><span class="line"></span><br><span class="line">	D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;</span><br><span class="line">	d1p-&gt;f2(); <span class="comment">// virtual call, will call D1::f2() at run time</span></span><br><span class="line">	d2p-&gt;f2(); <span class="comment">// virtual call, will call D2::f2() at run time</span></span><br><span class="line">	Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 =  &amp;d2obj;</span><br><span class="line">	p2-&gt;fcn(<span class="number">42</span>);  <span class="comment">// statically bound, calls D1::fcn(int)</span></span><br><span class="line">	p3-&gt;fcn(<span class="number">42</span>);  <span class="comment">// statically bound, calls D2::fcn(int)</span></span><br><span class="line"></span><br><span class="line">    Base* bp = &amp;d1obj; D1 *dp1 = &amp;d2obj; D2 *dp2 = &amp;d2obj;</span><br><span class="line">    dp1-&gt;fcn(<span class="number">10</span>); <span class="comment">// static call to D1::fcn(int)</span></span><br><span class="line">    dp2-&gt;fcn(<span class="number">10</span>); <span class="comment">// static call to D2::fcn(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。</p>
<p>虚析构函数将组织合成移动操作。</p>
<h4 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h4><p>默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，必须在派生类的构造函数初始化列表中显式地使用基类的拷贝（或移动）构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D (<span class="keyword">const</span> D&amp; d):Base(d)  <span class="comment">//拷贝基类成员</span></span><br><span class="line">        <span class="comment">/* D的成员的初始值 */</span>&#123;&#125;  </span><br><span class="line">    D (D&amp;&amp; d):Base(<span class="built_in">std</span>::<span class="built_in">move</span>(d))  <span class="comment">//移动基类成员</span></span><br><span class="line">        <span class="comment">/* D的成员的初始值 */</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>派生类的赋值运算符必须显式地为其基类部分赋值</li>
<li>派生类析构函数只负责销毁由派生类自己分配的资源</li>
</ul>
<blockquote>
<p>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p>
</blockquote>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>类不能继承默认、拷贝和移动构造函数。派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>:</span><span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Disc_quote::Disc_quote;  <span class="comment">//继承Disc_quote的构造函数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    等价于</span></span><br><span class="line"><span class="comment">    Bulk_quote(const std::string&amp; book,double price):Disc_quote(book,price)&#123;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于using声明语句不能指定explicit或constexper。所以基类是explicit或constexper的，那么派生类具有相同的属性。</li>
<li>当一个基类构造函数含有默认实参，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</li>
<li>如果基类有几个构造函数，大多数情况下派生类会继承所有这些构造函数。除了两个例外：1.如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数不会被继承。2.默认、拷贝和移动构造函数不会被继承。</li>
</ul>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><h3 id="在容器中放置指针而非对象"><a href="#在容器中放置指针而非对象" class="headerlink" title="在容器中放置指针而非对象"></a>在容器中放置指针而非对象</h3><h1 id="16-模板与泛型编程"><a href="#16-模板与泛型编程" class="headerlink" title="16.模板与泛型编程"></a>16.模板与泛型编程</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h4 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h4><p>类型参数前必须使用关键字class或typename，两者含义相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">foo</span><span class="params">(T* p)</span></span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>非类型模板参数表示一个值而非一个类型。通过特定的类型名指定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N,<span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N],<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数模板和类模板成员函数的定义通常放在头文件中</p>
</blockquote>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化类模板</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;</span><br></pre></td></tr></table></figure>
<p>定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member-name(parm-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>当我们使用一个类模板类型时，必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。</p>
<h4 id="模板类型别名"><a href="#模板类型别名" class="headerlink" title="模板类型别名"></a>模板类型别名</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//新标准</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors;  <span class="comment">//authors是一个pair&lt;string,string&gt;</span></span><br></pre></td></tr></table></figure>
<p>C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望通过一个模板类型参数的类型成员，就必须显式告诉编译器改名字是一个类型。通过使用关键字typename来实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> T::<span class="function">value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!c.empty())</span><br><span class="line">        <span class="keyword">return</span> c.back();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="默认模板实参"></a>默认模板实参</h4><p>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参，就必须在模板名之后跟一个尖括号对：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>=<span class="title">int</span>&gt; <span class="title">class</span> <span class="title">Number</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Numbers(T v=<span class="number">0</span>):val(v)&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision;  <span class="comment">//空表示希望使用默认类型</span></span><br></pre></td></tr></table></figure>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>一个类可以包含本身是模板的成员函数。这种成员被称为成员模板。成员模板不能是虚函数。</p>
<p>与类模板的普通函数成员不同，成员模板是函数模板。当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">	Blob&lt;T&gt;::Blob&lt;It b, It e:</span><br><span class="line">		data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(b,e))&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显式实例化避免这种开销：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;  <span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;         <span class="comment">//实例化定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>            <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>
<p>对于一个给定的实例化版本，可能有多个声明，但只能有一个定义。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的类型转换cast</title>
    <url>/2020/07/22/C-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2cast/</url>
    <content><![CDATA[<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><a id="more"></a>
<p>static_cast用于基本上想要逆转隐式转换的情况，但有一些限制和添加。static_cast不执行运行时检查。如果您知道您引用的是特定类型的对象，则应该使用此方法，因此检查将是不必要的。例子:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">func(<span class="keyword">void</span> *data) &#123;</span><br><span class="line">    MyClass* -&gt; <span class="keyword">void</span>*的转换是隐式的</span><br><span class="line">    MyClass* c = <span class="keyword">static_cast</span>&lt;MyClass*&gt;(data);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass c;</span><br><span class="line">    start_thread(&amp;func， &amp;c) <span class="comment">//将调用func(&amp;c)</span></span><br><span class="line">    . join ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在本例中，您知道您传递了一个MyClass对象，因此不需要运行时检查来确保这一点。</p>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>当你不知道对象的动态类型时，dynamic_cast很有用。如果引用的对象不包含被转换为基类的类型，则返回空指针(在这种情况下，当转换为引用时，会抛出bad_cast异常)。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (JumpStm *j = <span class="keyword">dynamic_cast</span>&lt;JumpStm*&gt;(&amp;stm)) &#123;</span><br><span class="line">…</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExprStm *e = <span class="keyword">dynamic_cast</span>&lt;ExprStm*&gt;(&amp;stm)) &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果向下转换(转换到派生类)且参数类型不是多态的，则不能使用dynamic_cast。例如，以下代码是无效的，因为Base不包含任何虚函数:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span>:</span>Base &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	Base *b = &amp;d;</span><br><span class="line">	<span class="keyword">dynamic_cast</span> &lt;Derived* &gt; (b);/ /无效</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于static_cast和dynamic_cast，“up-cast”(转换到基类)始终是有效的，而且不需要任何转换，因为“up-cast”是隐式转换。</p>
<h3 id="常规cast"><a href="#常规cast" class="headerlink" title="常规cast"></a>常规cast</h3><p>这些转换也称为c型转换。C风格的转换基本上等同于尝试一系列c++转换，并进行第一次有效的c++转换，而不考虑dynamic_cast。不用说，它结合了所有的const_cast、static_cast和reinterpret_cast，因此功能更加强大，但是它也不安全，因为它没有使用dynamic_cast。</p>
<p>另外，c样式的强制转换不仅允许您这样做，而且还允许您安全地强制转换到一个私有基类，而“等效的”static_cast序列会为此给出一个编译时错误。</p>
<p>有些人喜欢c风格的类型转换，因为它们很简洁。我只将它们用于数字类型转换，并在涉及用户定义的类型时使用适当的c++类型转换，因为它们提供了更严格的检查。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Abaqus有限元分析</title>
    <url>/2020/06/25/Abaqus%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="接触"><a href="#接触" class="headerlink" title="接触"></a>接触</h1><a id="more"></a>
<h2 id="ABAQUS中的两种接触方式"><a href="#ABAQUS中的两种接触方式" class="headerlink" title="ABAQUS中的两种接触方式"></a>ABAQUS中的两种接触方式</h2><h3 id="小滑移（两接触面之间只有很小的滑动）"><a href="#小滑移（两接触面之间只有很小的滑动）" class="headerlink" title="小滑移（两接触面之间只有很小的滑动）"></a>小滑移（两接触面之间只有很小的滑动）</h3><p>分析的开始就确定了从面节点和主面的哪一部分发生接触，在整个分析过程中，这种接触关系不再发生变化。小滑移的计算代价小于有限滑移。</p>
<h3 id="有限滑移（两个接触面之间任意滑动）"><a href="#有限滑移（两个接触面之间任意滑动）" class="headerlink" title="有限滑移（两个接触面之间任意滑动）"></a>有限滑移（两个接触面之间任意滑动）</h3><p>要求主面是光滑的，否则会出现收敛问题</p>
<h2 id="接触属性的定义"><a href="#接触属性的定义" class="headerlink" title="接触属性的定义"></a>接触属性的定义</h2><p>1.法向作用：ABAQUS中的接触压力和间隙的关系默认是“硬接触”，即接触面之间能够传递的接触压力大小不受限制，当接触压力为负或零时，接触面发生分离。</p>
<h2 id="定义两接触面的距离"><a href="#定义两接触面的距离" class="headerlink" title="定义两接触面的距离"></a>定义两接触面的距离</h2><p>通过ADJUST关键字定义。小于ADJUST时认为接触</p>
<h2 id="过盈接触（CONTACT-INTERFERENCE）"><a href="#过盈接触（CONTACT-INTERFERENCE）" class="headerlink" title="过盈接触（CONTACT INTERFERENCE）"></a>过盈接触（CONTACT INTERFERENCE）</h2><p>过盈量为负值表示过盈接触，正值表示两个面之间存在间隙</p>
<h2 id="接触分析中的收敛问题"><a href="#接触分析中的收敛问题" class="headerlink" title="接触分析中的收敛问题"></a>接触分析中的收敛问题</h2><h3 id="MSG文件"><a href="#MSG文件" class="headerlink" title="MSG文件"></a>MSG文件</h3><p><code>CONTACT CHANGE SUMMARY：1 closures 10 openings</code>，从面的节点有闭合和开放两种状态。<br>无法收敛的集中常见情况：</p>
<ol>
<li>闭合与开放的数目不断减少，但不断出现<code>1 closures 0 openings</code>和<code>0 closures 1 openings</code>，这种情况无法通过减小时间增量步达到收敛。</li>
<li>闭合与开放时而减小时而增大。这种情况应当减小时间增量步再看。</li>
<li>闭合与开放减小速度慢。调整最大迭代次数。</li>
</ol>
<h3 id="出现收敛问题"><a href="#出现收敛问题" class="headerlink" title="出现收敛问题"></a>出现收敛问题</h3><ol>
<li>检查接触关系，边界条件和约束<br>View -&gt; ODB View -&gt; 显示连接</li>
<li>消除刚体位移<br>出现不确定的刚体位移时，在MSG文件中会显示数值奇异警告信息，有时还会显示负特征值警告信息<br>检查刚体的约束条件</li>
<li>使用绑定约束<br>如果某一对接触面的接触状态对整个模型的影响不大，或者这一对接触面在整个分析过程中始终密切接触，就可以考虑将他们的接触关系改为绑定约束，从而大大减少计算接触状态所需的迭代。</li>
<li>建立平稳的接触关系<br>不要在一个增量步施加所有的载荷。<br>应先定义一个只有很小载荷的增量步，在下一步中再施加真实载荷。</li>
<li>细化网格<br>一般圆角处至少10个单元</li>
<li>正确定义主面和从面<ul>
<li>刚度大、网格粗的为主面</li>
<li>主面在发生接触的部位不要有大的尖角或凹角</li>
<li>如果主面和从面在几何位置上没有发生重叠，则一个面的法向应指向另一个面所在的一侧</li>
<li>如果是有限滑移，在整个分析过程中尽量不要让从面结点落到主面外</li>
</ul>
</li>
<li>使用一阶单元</li>
<li>避免过约束</li>
<li>慎重定义摩擦</li>
<li>减小初始时间增量步</li>
<li>解决震颤问题<ul>
<li>确保主面足够大</li>
<li>使用自动过盈接触限度有助于解决震颤</li>
<li>主面足够光滑</li>
<li>如果模型有较长的柔性部件，并且接触压力较小，就应将接触属性设置为软接触。如果只有很少的从面结点和主面接触，就应细化接触面网络，或将接触属性设置为软接触。</li>
</ul>
</li>
</ol>
<blockquote>
<p>ABAQUS接触问题无法使用多线程进行计算</p>
</blockquote>
<h1 id="材料非线性"><a href="#材料非线性" class="headerlink" title="材料非线性"></a>材料非线性</h1><ol>
<li>塑性</li>
<li>超弹性</li>
<li>粘弹性（时间硬化模型，应变硬化模型，双曲正弦模型）</li>
</ol>
<h1 id="结构模态分析"><a href="#结构模态分析" class="headerlink" title="结构模态分析"></a>结构模态分析</h1><p>动力学分析是将惯性力包含在动力学平衡方程式中：</p>
<script type="math/tex; mode=display">M\ddot{u}+I-f=0</script><p>其中M是结构质量，$\ddot{u}$是加速度，I是内力，f是外力</p>
<p>无载荷情况下：$M\ddot{u}+I=0$</p>
<p>对于无阻尼系统上式可化为：$M\ddot{u}+Ku=0$，方程解的形式为$u=\phi exp(i\bar{\omega}t)$，将上式代入运动方程中就会得到特征值问题方程$K\phi_i=\lambda M\phi_i$。该系统有n个特征值，此时n是有限元模型的自由度数。$\bar{\omega}_i$是结构的第i阶固有频率，$\phi_i$是相应的第i阶特征向量。</p>
<p>阻尼的设定：</p>
<ul>
<li>直接模态阻尼（定义每阶振型的临界阻尼比）</li>
<li>Rayleigh阻尼（质量矩阵和刚度矩阵的线性组合）</li>
<li>复合阻尼（定义每种材料的临界阻尼比）</li>
</ul>
<p>模态分析步骤</p>
<ul>
<li><strong>建模</strong>。必须定义密度，只能使用线性单元和线性材料，非线性性质将被忽略。</li>
<li><strong>定义分析步</strong>。定义一个线性摄动步的频率提取分析步。模态提取选项和其他选项。</li>
<li><strong>施加边界条件，载荷并求解</strong></li>
</ul>
<h1 id="结构谐响应分析"><a href="#结构谐响应分析" class="headerlink" title="结构谐响应分析"></a>结构谐响应分析</h1><p>谐响应分析主要用来确定线性结构在承受持续的周期载荷时的周期性响应。在谐响应分析中的非线性特性将被忽略。</p>
<p>谐响应分析通常用于如下结构的设计与分析：</p>
<ul>
<li>旋转设备的支座、固定装置和部件等</li>
<li>受涡流影响的结构，包括涡轮叶片，飞机机翼，桥和塔等。</li>
</ul>
<h1 id="结构多体系统分析"><a href="#结构多体系统分析" class="headerlink" title="结构多体系统分析"></a>结构多体系统分析</h1><p>注意：</p>
<ul>
<li>在部件、装配模块或相互作用模块中定义连接单元和约束所需定义的参考点和基准坐标系。</li>
<li>在相互作用模块中定义连接属性，连接单元和约束</li>
<li>在载荷模块中定义载荷和边界条件，以及连接单元载荷和连接单元边界条件</li>
<li>在分析步模块中，默认的输出变量是不包括连接单元的，需要单独进行连接单元的历史输出变量。</li>
<li>是否考虑几何非线性</li>
</ul>
<h1 id="ABAQUS-Explicit显式分析"><a href="#ABAQUS-Explicit显式分析" class="headerlink" title="ABAQUS/Explicit显式分析"></a>ABAQUS/Explicit显式分析</h1><h2 id="显示方法与隐式方法的区别"><a href="#显示方法与隐式方法的区别" class="headerlink" title="显示方法与隐式方法的区别"></a>显示方法与隐式方法的区别</h2><blockquote>
<p>所谓<strong>显式</strong>指的是增量步结束时的状态仅依赖于该增量步开始时的位移、速度和加速度，这种方法可以精确的积分常值的加速度。为了使该方法产生精确的结果，要求时间增量要足够小，所以在增量步中的加速度几乎为常数。由于时间增量必须很小，所以需要大量的增量步。<br>由于在显式分析中不需要求解联立方程组，所以每一个增量步的计算成本很低。</p>
</blockquote>
<p>显式算法最大优点是有较好的稳定性。</p>
<p>动态显式算法采用动力学方程的一些差分格式(如广泛使用的中心差分法、线性加速度法等),不用直接求解切线刚度,不需要进行平衡迭代,计算速度快,时间步长只要取的足够小,一般不存在收敛性问题。 显式算法不需要迭代,也不需要组集总刚,因此需要的内存也比隐式算法要少。并且数值计算过程可以很容易地进行并行计算,程序编制也相对简单。但显式算法要求质量矩阵为对角矩阵,而且只有在单元级计算尽可能少时速度优势才能发挥, 因而往往采用减缩积分方法,容易激发沙漏模式,影响应力和应变的计算精度。”</p>
<p>静态显式法基于率形式的平衡方程组与Euler向前差分法,不需要迭代求解。由于平衡方程式仅在率形式上得到满足,所以得出的结果会慢慢偏离正确值。为了减少相关误差,必须每步使用很小的增量。这个方法目前应用比较少。</p>
<p><strong>显式算法和隐式算法比较</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>算法</th>
<th>显式算法</th>
<th>隐式算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>(01)适用问题</td>
<td>动力学(动态)</td>
<td>静力学(静态)</td>
</tr>
<tr>
<td>(02)阻尼</td>
<td>人工阻尼</td>
<td>数值阻尼</td>
</tr>
<tr>
<td>(03)每步求解方法</td>
<td>矩阵乘法</td>
<td>线性方程组</td>
</tr>
<tr>
<td>(04)大矩阵(总刚)</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>(05)数据存贮量</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>(06)每步计算速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>(07)迭代收敛性</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>(08)确定解</td>
<td>有确定解</td>
<td>可能是病态无确定解</td>
</tr>
<tr>
<td>(09)时步稳定性</td>
<td>有条件</td>
<td>无条件</td>
</tr>
<tr>
<td>(10)时间步</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>(11)计算精度</td>
<td>低</td>
<td>高</td>
</tr>
</tbody>
</table>
</div>
<p>显式算法基于动力学方程无需迭代；静态隐式算法基于虚功原理需要迭代。</p>
<h2 id="ABAQUS-Explicit显式分析解决的问题"><a href="#ABAQUS-Explicit显式分析解决的问题" class="headerlink" title="ABAQUS/Explicit显式分析解决的问题"></a>ABAQUS/Explicit显式分析解决的问题</h2><ul>
<li>复杂的接触问题</li>
<li>高速动力学事件</li>
<li>复杂的后屈曲问题（随着载荷增加，结构的刚度发生剧烈变化）</li>
<li>高度非线性的准静态问题（复杂的接触，如锻造、滚压、薄板成型）</li>
<li>材料的退化和失效问题（其常导致严重的收敛困难）</li>
</ul>
<h1 id="ABAQUS用户子程序"><a href="#ABAQUS用户子程序" class="headerlink" title="ABAQUS用户子程序"></a>ABAQUS用户子程序</h1><h2 id="编写用户子程序的条件"><a href="#编写用户子程序的条件" class="headerlink" title="编写用户子程序的条件"></a>编写用户子程序的条件</h2><ul>
<li>用户子程序不能嵌套，任何用户子程序都不能调用任何其他用户子程序，但可以调用用户自己编写的Fortran子程序和ABAQUS应用程序。当用户编写Fortran子程序时，建议子程序名以K开头，以免和ABAQUS内部程序冲突。</li>
<li>ABAQUS应用程序必须由用户子程序调用。</li>
<li>当用户在用户子程序中利用open打开外部文档时：1.设备号只能选择15～18和大于100的设备号，其余的已经被ABAQUS占用；2.用户需要提供外部文件的绝对路径而不是相对路径。</li>
</ul>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>Abaqus</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发与多线程笔记2</title>
    <url>/2020/08/01/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h2 id="第二节-线程启动、结束，创建线程多法、join，detach"><a href="#第二节-线程启动、结束，创建线程多法、join，detach" class="headerlink" title="第二节 线程启动、结束，创建线程多法、join，detach"></a>第二节 线程启动、结束，创建线程多法、join，detach</h2><a id="more"></a>
<p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200801154015102.png" alt="在这里插入图片描述"></p>
<h3 id="一、范例演示线程运行的开始"><a href="#一、范例演示线程运行的开始" class="headerlink" title="一、范例演示线程运行的开始"></a>一、范例演示线程运行的开始</h3><ul>
<li>程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕</li>
<li>主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行</li>
<li>整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】</li>
</ul>
<p>创建一个线程：</p>
<ol>
<li>包含头文件thread</li>
<li>写初始函数</li>
<li>在main中创建thread</li>
</ol>
<p>必须要明白：有两个线程在跑，相当于整个程序中有两条线在同时走，即使一条被阻塞，另一条也能运行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程开始运行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//-------------</span></span><br><span class="line">	<span class="comment">//-------------</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程运行完毕"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//(1)创建了线程，线程执行起点（入口）是myPrint；(2)执行线程</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//(2)阻塞主线程并等待myPrint执行完，当myPrint执行完毕，join()就执行完毕，主线程继续往下执行</span></span><br><span class="line">	myThread.join();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置断点可看到主线程等待子线程的过程</span></span><br><span class="line">	<span class="comment">//F11逐语句，就是每次执行一行语句，如果碰到函数调用，它就会进入到函数里面</span></span><br><span class="line">	<span class="comment">//F10逐过程，碰到函数时，不进入函数，把函数调用当成一条语句执行</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//(3)传统多线程程序中，主线程要等待子线程执行完毕，然后自己才能向下执行</span></span><br><span class="line">	<span class="comment">//detach:分离，主线程不再与子线程汇合，不再等待子线程</span></span><br><span class="line">	<span class="comment">//detach后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管</span></span><br><span class="line">	<span class="comment">//myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//(4)joinable()判断是否可以成功使用join()或者detach()</span></span><br><span class="line">	<span class="comment">//如果返回true，证明可以调用join()或者detach()</span></span><br><span class="line">	<span class="comment">//如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了</span></span><br><span class="line">	<span class="keyword">if</span> (myThread.joinable())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"可以调用可以调用join()或者detach()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"不能调用可以调用join()或者detach()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重要补充："><a href="#重要补充：" class="headerlink" title="重要补充："></a>重要补充：</h2><p><strong>线程类参数是一个可调用对象。</strong><br>一组可执行的语句称为可调用对象，c++中的可调用对象可以是<strong>函数、函数指针、lambda表达式、bind创建的对象或者重载了函数调用运算符的类对象。</strong></p>
<h3 id="二、其他创建线程的方法"><a href="#二、其他创建线程的方法" class="headerlink" title="二、其他创建线程的方法"></a>二、其他创建线程的方法</h3><p>①创建一个类，并编写圆括号重载函数，初始化一个该类的对象，把该对象作为线程入口地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ta</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程开始运行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//-------------</span></span><br><span class="line">		<span class="comment">//-------------</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程运行完毕"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数里的：</span></span><br><span class="line">	Ta ta;</span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(ta)</span></span>; <span class="comment">//对象被复制到线程中去。主线程结束子线程也不会出现问题。</span></span><br><span class="line">	<span class="comment">//GCC的实现是拷贝了两次.</span></span><br><span class="line">  <span class="comment">//看了6.3.0源码,thread里拷贝了两次.</span></span><br><span class="line">  <span class="comment">//第一次构造bind,这里msvc和gcc都是需要一次拷贝,</span></span><br><span class="line">  <span class="comment">//区别是msvc直接make_unique tuple去invoke,</span></span><br><span class="line">  <span class="comment">//gcc是先构造一个bind,再把bind移动到unique_ptr里.</span></span><br><span class="line">	<span class="comment">//如果创建了移动构造函数，则只调用一次拷贝</span></span><br><span class="line">	myThread.join();</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<p>②lambda表达式创建线程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数中</span></span><br><span class="line"><span class="keyword">auto</span> lambdaThread = [] &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程开始执行了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//-------------</span></span><br><span class="line">		<span class="comment">//-------------</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程开始执行了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(lambdaThread)</span></span>;</span><br><span class="line">	myThread.join();</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>③把某个类中的某个函数作为线程的入口地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetMsg</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveMsh</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//main函数里</span></span><br><span class="line">    Data_ s;</span><br><span class="line">    <span class="comment">//第一个&amp;意思是取址，第二个&amp;意思是引用，相当于std::ref(s)</span></span><br><span class="line">    <span class="comment">//thread oneobj(&amp;Data_::SaveMsh,s)传值也是可以的</span></span><br><span class="line">    <span class="comment">//在其他的构造函数中&amp;obj是不会代表引用的，会被当成取地址</span></span><br><span class="line">    <span class="function">thread <span class="title">oneobj</span><span class="params">(&amp;Data_::SaveMsh,&amp;s)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">twoobj</span><span class="params">(&amp;Data_::GetMsg,&amp;s)</span></span>;</span><br><span class="line">    oneobj.join();</span><br><span class="line">    twoobj.join();</span><br></pre></td></tr></table></figure>
<h2 id="第三节-线程传参详解，detach-大坑，成员函数做线程函数"><a href="#第三节-线程传参详解，detach-大坑，成员函数做线程函数" class="headerlink" title="第三节 线程传参详解，detach()大坑，成员函数做线程函数"></a>第三节 线程传参详解，detach()大坑，成员函数做线程函数</h2><p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200801162842421.png" alt="在这里插入图片描述"></p>
<p><strong>一、传递临时对象作为线程参数</strong><br><em>1.1要避免的陷阱1：</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i, <span class="keyword">char</span>* pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果线程从主线程detach了</span></span><br><span class="line">	<span class="comment">//i不是mvar真正的引用，实际上值传递，即使主线程运行完毕了，子线程用i仍然是安全的，但仍不推荐传递引用</span></span><br><span class="line">	<span class="comment">//推荐改为const int i</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//pmybuf还是指向原来的字符串，所以这么写是不安全的</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pmybuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mvar = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; mvary = mvar;</span><br><span class="line">	<span class="keyword">char</span> mybuf[] = <span class="string">"this is a test"</span>;</span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, mvar, mybuf)</span></span>;<span class="comment">//第一个参数是函数名，后两个参数是函数的参数</span></span><br><span class="line">	myThread.join();</span><br><span class="line">	<span class="comment">//myThread.detach();</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>
<p><em>1.2要避免的陷阱2：</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">string</span>&amp; pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pmybuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mvar = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; mvary = mvar;</span><br><span class="line">	<span class="keyword">char</span> mybuf[] = <span class="string">"this is a test"</span>;</span><br><span class="line">	<span class="comment">//如果detach了，这样仍然是不安全的</span></span><br><span class="line">	<span class="comment">//因为存在主线程运行完了，mybuf被回收了，系统采用mybuf隐式类型转换成string</span></span><br><span class="line">	<span class="comment">//推荐先创建一个临时对象thread myThread(myPrint, mvar, string(mybuf));就绝对安全了。。。。</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, mvar, mybuf)</span></span>;</span><br><span class="line">	myThread.join();</span><br><span class="line">	<span class="comment">//myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>
<p><em>1.3总结</em></p>
<ul>
<li>如果传递int这种简单类型，<strong>推荐使用值传递，不要用引用和指针</strong></li>
<li>如果传递类对象，<strong>避免使用隐式类型转换</strong>，全部都是创建线程这一行就创建出临时对象，然后在函数参数里，用引用来接，否则还会创建出一个对象</li>
<li>终极结论：建议不使用detach</li>
</ul>
<p><strong>二、临时对象作为线程参数继续讲</strong><br><em>2.1线程id概念</em></p>
<ul>
<li>id是个数字，每个线程（不管是主线程还是子线程）实际上都对应着一个数字，而且每个线程对应的这个数字都不一样</li>
<li>线程id可以用C++标准库里的函数来获取。std::this_thread::get_id()来获取</li>
</ul>
<p><strong>三、传递类对象、智能指针作为线程参数</strong><br><em>3.1</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> m_i; <span class="comment">//m_i即使实在const中也可以被修改</span></span><br><span class="line">	A(<span class="keyword">int</span> i) :m_i(i) &#123;&#125; <span class="comment">//类型转换构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> A&amp; pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pmybuf.m_i = <span class="number">199</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程myPrint的参数地址是"</span> &lt;&lt; &amp;pmybuf &lt;&lt; <span class="string">"thread = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">myObj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//myPrint(const A&amp; pmybuf)中引用不能去掉，如果去掉会多创建一个对象</span></span><br><span class="line">	<span class="comment">//const也不能去掉，去掉会出错(因为thread要求传入一个右值)</span></span><br><span class="line">	<span class="comment">//即使是传递的const引用，但在子线程中还是会调用拷贝构造函数构造一个新的对象，</span></span><br><span class="line">	<span class="comment">//所以在子线程中修改m_i的值不会影响到主线程</span></span><br><span class="line">	<span class="comment">//如果希望子线程中修改m_i的值影响到主线程，可以用thread myThread(myPrint, std::ref(myObj));</span></span><br><span class="line">	<span class="comment">//这样const就是真的引用了，myPrint定义中的const就可以去掉了，类A定义中的mutable也可以去掉了</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, myObj)</span></span>;</span><br><span class="line">	myThread.join();</span><br><span class="line">	<span class="comment">//myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>
<p><em>3.2</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</span><br><span class="line">	<span class="comment">//独占式指针只能通过std::move()才可以传递给另一个指针</span></span><br><span class="line">	<span class="comment">//传递后up就指向空，新的ptn指向原来的内存</span></span><br><span class="line">	<span class="comment">//所以这时就不能用detach了，因为如果主线程先执行完，ptn指向的对象就被释放了</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, <span class="built_in">std</span>::move(up))</span></span>;</span><br><span class="line">	myThread.join();</span><br><span class="line">	<span class="comment">//myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++中类所占空间的大小</title>
    <url>/2020/07/20/C-%E4%B8%AD%E7%B1%BB%E6%89%80%E5%8D%A0%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>struct,class<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Empyt</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> c; <span class="comment">// static 变量不占用S的存储空间，S为空，那么S占用一个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *b = &amp;a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*:"</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int:"</span>&lt;&lt;<span class="keyword">sizeof</span>(c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">long</span> d;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"long:"</span> &lt;&lt;<span class="keyword">sizeof</span>(d)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"long long:"</span> &lt;&lt; <span class="keyword">sizeof</span>(f) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> m;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"double:"</span> &lt;&lt; <span class="keyword">sizeof</span>(m) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Empyt: "</span>&lt;&lt;<span class="keyword">sizeof</span>(Empyt)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"S: "</span>&lt;&lt;<span class="keyword">sizeof</span>(S)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在64位系统中的结果如下,static 的变量占用全局的内存. 和全局变量分配的内存在同一个区域里面.所以sizeof（s）的时候没有将其计算在内。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Char: 1</span><br><span class="line"></span><br><span class="line">*: 8</span><br><span class="line"></span><br><span class="line">int: 4</span><br><span class="line"></span><br><span class="line">long: 8</span><br><span class="line"></span><br><span class="line">long long: 8</span><br><span class="line"></span><br><span class="line">double: 8</span><br><span class="line"></span><br><span class="line">Empyt: 1</span><br><span class="line"></span><br><span class="line">S: 1</span><br></pre></td></tr></table></figure></p>
<h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>字节对齐的细节和编译器实现相关，但一般而言，满足三个准则：</p>
<p>1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；<br>2) 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；<br>3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节；</p>
<h2 id="字节对齐实际计算方法"><a href="#字节对齐实际计算方法" class="headerlink" title="字节对齐实际计算方法"></a>字节对齐实际计算方法</h2><p>看了以后还是不是很理解，也很正常，我们自己试试差不多就能理解了，通俗点讲，就是类（结构体）占用的大小永远都是其内定义的最宽（就是所占字节最大的变量）字节的整数倍，如果不是，那么编译器会自动帮你补上，如K，最宽的类型是int，占四个字节，加上一个char 一个字节 =5，不能被4整除哇，所以编译器将其自动补齐为8。我们再改一改K：</p>
<p>struct K{</p>
<pre><code>int a;

char b;

char c;
</code></pre><p>};</p>
<p>这时候K 占几个字节？ 没错，答案还是8，看到这里是不是觉得自己应该掌握了， 哈哈，还没有，我们再看下面，我们把K当中的变量顺序换一换：</p>
<p>struct K{</p>
<pre><code>char b;

int a;

char c;
</code></pre><p>};</p>
<p>是不是感觉没什么变化，我们只把int a 放在了 b 的下面。答案还是8吗？看我都这么说了，结果肯定不是啦，为先说下答案，是12，知道为什么了吗？看到答案为想大家也应该明白了，类当中的空间存储是自上而下的，我还是通俗点讲，先发现char b，字节大小为1，然后往下走碰到了 a 四个字节，这时候对b 进行自动补齐，字节大小变为八，也就是b的偏移量变成了3.继续走又给c分配四个字节，最后结果就是12.那之前为什么是8呢，很简单呀因为 前面的b，c 共同占用四个字节（他们是连在一起的）</p>
<p>所以现在懂了吗，出个小题目：</p>
<p>struct K{</p>
<pre><code>int a;

long f;

char c;

int b;

char e;

char g;

char h;

char i;

char j;
</code></pre><p>};</p>
<p>现在k占几个字节？</p>
<p>·</p>
<p>·</p>
<p>答案是32<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/monster_acm/java/article/details/81169289" target="_blank" rel="noopener">https://blog.csdn.net/monster_acm/java/article/details/81169289</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发与多线程笔记3</title>
    <url>/2020/08/01/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h2 id="第四节-创建多个线程、数据共享问题分析、案例代码"><a href="#第四节-创建多个线程、数据共享问题分析、案例代码" class="headerlink" title="第四节 创建多个线程、数据共享问题分析、案例代码"></a>第四节 创建多个线程、数据共享问题分析、案例代码</h2><a id="more"></a>
<p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200801171458878.png" alt="在这里插入图片描述"></p>
<p><strong>一、创建和等待多个线程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TextThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">/*  …  */</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">"执行结束"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//main函数里     vector threadagg;</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">         threadagg.push_back(thread(TextThread));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">         threadagg[i].join();</span><br><span class="line">     &#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<ul>
<li>把thread对象放入到容器中管理，看起来像个thread对象数组，对一次创建大量的线程并对大量线程进行管理有好处</li>
<li>多个线程执行顺序是乱的，跟操作系统内部对线程的运行调度机制有关</li>
</ul>
<p><strong>二：数据共享问题分析</strong><br><em>2.1 只读的数据</em></p>
<ul>
<li>是安全稳定的</li>
</ul>
<p><em>2.2 有读有写</em></p>
<ul>
<li>若不加处理，就会出错</li>
<li>最简单的防止崩溃方法：读的时候不能写，写的时候不能读。</li>
<li>如果写的动作分10小步，由于任务切换，导致各种诡异的事情发生（最可能的还是崩溃）</li>
</ul>
<h2 id="第五节-互斥量概念、用法、死锁演示及解决详解"><a href="#第五节-互斥量概念、用法、死锁演示及解决详解" class="headerlink" title="第五节 互斥量概念、用法、死锁演示及解决详解"></a>第五节 互斥量概念、用法、死锁演示及解决详解</h2><p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200801173936607.png" alt="在这里插入图片描述"></p>
<p><strong>一、互斥量（mutex）的基本概念</strong></p>
<ul>
<li>互斥量就是个类对象，可以理解为一把锁，多个线程尝试用lock()成员函数来加锁，只有一个线程能锁定成功，如果没有锁成功，那么流程将卡在lock()这里不断尝试去锁定。</li>
<li>互斥量使用要小心，保护数据不多也不少，少了达不到效果，多了影响效率。</li>
</ul>
<p><strong>二、互斥量的用法</strong><br>包含<code>#include&lt;mutex&gt;</code>头文件<br><strong>2.1 lock()，unlock()</strong></p>
<ul>
<li>步骤：1.lock()，2.操作共享数据，3.unlock()。</li>
<li>lock()和unlock()要成对使用</li>
</ul>
<p><strong>2.2 lock_guard类模板</strong></p>
<ul>
<li><code>std::lock_guard&lt;std::mutex&gt; sbguard(myMutex);</code>取代lock()和unlock()</li>
<li>lock_guard构造函数执行了mutex::lock();在作用域结束时，调用析构函数，执行mutex::unlock()</li>
</ul>
<p><strong>三、死锁</strong><br><em>3.1 死锁演示</em><br>死锁至少有两个互斥量mutex1，mutex2。</p>
<ul>
<li>a.线程A执行时，这个线程先锁mutex1，并且锁成功了，然后去锁mutex2的时候，出现了上下文切换。</li>
<li>b.线程B执行，这个线程先锁mutex2，因为mutex2没有被锁，即mutex2可以被锁成功，然后线程B要去锁mutex1.</li>
<li>c.此时，死锁产生了，A锁着mutex1，需要锁mutex2，B锁着mutex2，需要锁mutex1，两个线程没办法继续运行下去。。。</li>
</ul>
<p><em>3.2 死锁的一般解决方案：</em><br>只要保证多个互斥量上锁的顺序一样就不会造成死锁。</p>
<p><em>3.3 std::lock()函数模板</em></p>
<ul>
<li>std::lock(mutex1,mutex2……); 一次锁定多个互斥量（一般这种情况很少），用于处理多个互斥量。</li>
<li><strong>如果互斥量中一个没锁住，它就等着，等所有互斥量都锁住，才能继续执行。如果有一个没锁住，就会把已经锁住的释放掉（要么互斥量都锁住，要么都没锁住，防止死锁）</strong></li>
</ul>
<p><em>3.4 std::lock_guard的std::adopt_lock参数</em></p>
<ul>
<li>std::lock_guardstd::mutex my_guard(my_mutex,std::adopt_lock);<br>加入adopt_lock后，在调用lock_guard的构造函数时，不再进行lock();</li>
<li>adopt_guard为结构体对象，起一个标记作用，表示这个互斥量已经lock()，不需要在lock()。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"插插插插插插插插插插插插插插插插插插插插入一个元素"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//lock_guard&lt;mutex&gt; sbguard(myMutex1, adopt_lock);</span></span><br><span class="line">				lock(myMutex1, myMutex2);</span><br><span class="line">				<span class="comment">//myMutex2.lock();</span></span><br><span class="line">				<span class="comment">//myMutex1.lock();</span></span><br><span class="line">				msgRecvQueue.push_back(i);</span><br><span class="line">				myMutex1.unlock();</span><br><span class="line">				myMutex2.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">outMsgLULProc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		myMutex1.lock();</span><br><span class="line">		myMutex2.lock();</span><br><span class="line">		<span class="keyword">if</span> (!msgRecvQueue.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"删删删删删删删删删删删删删删删删删删删删删删删除元素"</span> &lt;&lt; msgRecvQueue.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			msgRecvQueue.pop_front();</span><br><span class="line">			myMutex2.unlock();</span><br><span class="line">			myMutex1.unlock();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		myMutex2.unlock();</span><br><span class="line">		myMutex1.unlock();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (outMsgLULProc())</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"空空空空空空空空空空空空空空空空空空空空空空空空空空数组为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">	mutex myMutex1;</span><br><span class="line">	mutex myMutex2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A myobja;</span><br><span class="line">	mutex myMutex;</span><br><span class="line">	<span class="function">thread <span class="title">myOutMsgObj</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">myInMsgObj</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	myOutMsgObj.join();</span><br><span class="line">	myInMsgObj.join();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第六节-unique-lock（类模板）详解"><a href="#第六节-unique-lock（类模板）详解" class="headerlink" title="第六节 unique_lock（类模板）详解"></a>第六节 unique_lock（类模板）详解</h2><p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200801201321081.png" alt="在这里插入图片描述"></p>
<p><strong>1.unique_lock取代lock_guard</strong><br>unique_lock比lock_guard灵活很多（多出来很多用法），效率差一点。<br><code>unique_lock&lt;mutex&gt; myUniLock(myMutex);</code></p>
<blockquote>
<p>std::chrono::milliseconds sec(20000);</p>
<p>std::this_thread::sleep_for(sec);</p>
</blockquote>
<p><strong>2.unique_lock的第二个参数</strong><br><em>2.1 std::adopt_lock：</em></p>
<ul>
<li>表示这个互斥量已经被lock()，即不需要在构造函数中lock这个互斥量了。</li>
<li>前提：必须提前lock</li>
<li>lock_guard中也可以用这个参数</li>
</ul>
<p><em>2.2 std::try_to_lock：</em></p>
<ul>
<li>尝试用mutx的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里；</li>
<li>使用try_to_lock的原因是防止其他的线程锁定mutex太长时间，导致本线程一直阻塞在lock这个地方</li>
<li>前提：不能提前lock();</li>
<li>owns_locks()方法判断是否拿到锁，如拿到返回true</li>
</ul>
<p><em>2.3 std::defer_lock：</em></p>
<ul>
<li>如果没有第二个参数就对mutex进行加锁，加上defer_lock是始化了一个没有加锁的mutex</li>
<li>不给它加锁的目的是以后可以调用unique_lock的一些方法</li>
<li>前提：不能提前lock</li>
</ul>
<p><strong>3.unique_lock的成员函数（前三个与std::defer_lock联合使用）</strong><br><em>3.1 lock()：加锁。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_lock&lt;mutex&gt; myUniLock(myMutex， defer_lock);</span><br><span class="line">myUniLock.lock();</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>不用自己unlock();</p>
<p><em>3.2 unlock()：解锁。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_lock&lt;mutex&gt; myUniLock(myMutex， defer_lock);</span><br><span class="line">myUniLock.lock();</span><br><span class="line"><span class="comment">//处理一些共享代码</span></span><br><span class="line">myUniLock.unlock();</span><br><span class="line"><span class="comment">//处理一些非共享代码</span></span><br><span class="line">myUniLock.lock();</span><br><span class="line"><span class="comment">//处理一些共享代码</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>因为一些非共享代码要处理，可以暂时先unlock()，用其他线程把它们处理了，处理完后再lock()。</p>
<p><em>3.3 try_lock()：尝试给互斥量加锁</em><br>如果拿不到锁，返回false，否则返回true。</p>
<p><em>3.4 release()：</em></p>
<ul>
<li>unique_lock<br>myUniLock(myMutex);相当于把myMutex和myUniLock绑定在了一起，<strong>release()就是解除绑定，返回它所管理的mutex对象的指针，并释放所有权</strong></li>
<li><code>mutex* ptx = myUniLock.release();</code>所有权由ptx接管，如果原来mutex对象处理加锁状态，就需要ptx在以后进行解锁了。</li>
</ul>
<p>lock的代码段越少，执行越快，整个程序的运行效率越高。<br>a.锁住的代码少，叫做粒度细，执行效率高；<br>b.锁住的代码多，叫做粒度粗，执行效率低；</p>
<p><strong>4.unique_lock所有权的传递</strong><br>unique_lock myUniLock(myMutex);把myMutex和myUniLock绑定在了一起，也就是myUniLock拥有myMutex的所有权。类似unique_ptr<br><em>1. 使用move转移</em></p>
<ul>
<li>myUniLock拥有myMutex的所有权，myUniLock可以把自己对myMutex的所有权转移，但是不能复制。</li>
<li>unique_lock myUniLock2(std::move(myUniLock));<br>现在myUniLock2拥有myMutex的所有权。</li>
</ul>
<p><em>2. 在函数中return一个临时变量，即可以实现转移</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_lock&lt;mutex&gt; aFunction()</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; myUniLock(myMutex);</span><br><span class="line">    <span class="comment">//移动构造函数那里讲从函数返回一个局部的unique_lock对象是可以的</span></span><br><span class="line">    <span class="comment">//返回这种局部对象会导致系统生成临时的unique_lock对象，并调用unique_lock的移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> myUniLock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第七节-单例设计模式共享数据分析、解决，call-once"><a href="#第七节-单例设计模式共享数据分析、解决，call-once" class="headerlink" title="第七节 单例设计模式共享数据分析、解决，call_once"></a>第七节 单例设计模式共享数据分析、解决，call_once</h2><p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200801205212329.png" alt="在这里插入图片描述"></p>
<p><strong>1.设计模式</strong></p>
<ul>
<li>程序灵活，维护起来可能方便，用设计模式理念写出来的代码很晦涩，但是别人接管、阅读代码都会很痛苦</li>
<li>老外应付特别大的项目时，把项目的开发经验、模块划分经验，总结整理成设计模式</li>
<li>中国零几年设计模式刚开始火时，总喜欢拿一个设计模式往上套，导致一个小小的项目总要加几个设计模式，本末倒置</li>
<li>设计模式有其独特的优点，要活学活用，不要深陷其中，生搬硬套</li>
</ul>
<p><strong>2.单例设计模式：</strong><br>整个项目中，有某个或者某些特殊的类，只能创建一个属于该类的对象。<br>单例类：只能生成一个对象。</p>
<p><strong>3.单例设计模式共享数据分析、解决</strong><br>面临问题：需要在自己创建的线程中来创建单例类的对象，这种线程可能不止一个。我们可能面临GetInstance()这种成员函数需要互斥。<br>可以在加锁前判断m_instance是否为空，否则每次调用Singelton::getInstance()都要加锁，十分影响效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>	<span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">mutex myMutex;</span><br><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singelton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singelton * <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双重锁定 提高效率</span></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			lock_guard&lt;mutex&gt; myLockGua(myMutex);</span><br><span class="line">			<span class="keyword">if</span> (instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				instance = <span class="keyword">new</span> Singelton;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singelton() &#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> Singelton *instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singelton * Singelton::instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singelton2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singelton2* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singelton2() &#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> Singelton2 * instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singelton2 * Singelton2::instance = <span class="keyword">new</span> Singelton2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singelton * singer = Singelton::getInstance();</span><br><span class="line">	Singelton * singer2 = Singelton::getInstance();</span><br><span class="line">	<span class="keyword">if</span> (singer == singer2)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"二者是同一个实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"二者不是同一个实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------		以下 是 饿汉式	------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Singelton2 * singer3 = Singelton2::getInstance();</span><br><span class="line">	Singelton2 * singer4 = Singelton2::getInstance();</span><br><span class="line">	<span class="keyword">if</span> (singer3 == singer4)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"二者是同一个实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"二者不是同一个实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556</span></span><br></pre></td></tr></table></figure>
<p>如果觉得在单例模式new了一个对象，而没有自己delete掉，这样不合理。可以增加一个类中类CGarhuishou，new一个单例类时创建一个静态的CGarhuishou对象，这样在程序结束时会调用CGarhuishou的析构函数，释放掉new出来的单例对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singelton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	  <span class="function"><span class="keyword">static</span> Singelton * <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">static</span> CGarhuishou huishou;</span><br><span class="line">            instance = <span class="keyword">new</span> Singelton;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">CGarhuishou</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~CGarhuishou()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Singelton::instance)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">delete</span> Singelton::instance;</span><br><span class="line">				Singelton::instance = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singelton() &#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> Singelton *instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singelton * Singelton::instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><strong>4.std::call_once()：</strong><br>函数模板，该函数的第一个参数为标记，第二个参数是一个函数名（如a()）。<br>功能：<strong>能够保证函数a()只被调用一次。</strong>具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。<br>call_once()需要与一个标记结合使用，这个标记为std::once_flag；其实once_flag是一个结构，call_once()就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态。</p>
<p>多个线程同时执行时，一个线程会等待另一个线程先执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">once_flag g_flag;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singelton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateInstance</span><span class="params">()</span><span class="comment">//call_once保证其只被调用一次</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singelton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕</span></span><br><span class="line">	  <span class="function"><span class="keyword">static</span> Singelton *<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         call_once(g_flag, CreateInstance);</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">	  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singelton() &#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> Singelton *instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singelton * Singelton::instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="第八节-condition-variable、wait、notify-one、notify-all"><a href="#第八节-condition-variable、wait、notify-one、notify-all" class="headerlink" title="第八节 condition_variable、wait、notify_one、notify_all"></a>第八节 condition_variable、wait、notify_one、notify_all</h2><p><img src="image/2020051310403813.png" alt="在这里插入图片描述"></p>
<p><strong>一、条件变量condition_variable、wait、notify_one、notify_all</strong><br>std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mymutex1;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; sbguard1(mymutex1);</span><br><span class="line"><span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">condition.wait(sbguard1, [<span class="keyword">this</span>] &#123;<span class="keyword">if</span> (!msgRecvQueue.empty())</span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                                &#125;);</span><br><span class="line"> </span><br><span class="line">condition.wait(sbguard1);</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>wait()用来等一个东西</p>
<p>如果第二个参数的lambda表达式返回值是false，那么wait()将<strong>解锁互斥量，并阻塞到本行</strong><br>如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。</p>
<p>阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；</p>
<p>如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样</p>
<p>wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。</p>
<p>当其他线程用notify_one()将本线程wait()唤醒后，这个wait恢复后</p>
<p>1、wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁</p>
<p>2.1、如果wait有第二个参数就判断这个lambda表达式。</p>
<ul>
<li>a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒</li>
<li>b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。</li>
</ul>
<p>2.2、如果wait没有第二个参数，则wait返回，流程走下去。</p>
<p>流程只要走到了wait()下面则互斥量一定被锁住了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"inMsgRecvQueue插入一个元素"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; sbguard1(mymutex1);</span><br><span class="line">            msgRecvQueue.push_back(i); </span><br><span class="line">            <span class="comment">//尝试把wait()线程唤醒,执行完这行，</span></span><br><span class="line">            <span class="comment">//那么outMsgRecvQueue()里的wait就会被唤醒</span></span><br><span class="line">            <span class="comment">//只有当另外一个线程正在执行wait()时notify_one()才会起效，否则没有作用</span></span><br><span class="line">            condition.notify_one();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> command = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; sbguard2(mymutex1);</span><br><span class="line">            <span class="comment">// wait()用来等一个东西</span></span><br><span class="line">            <span class="comment">// 如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行</span></span><br><span class="line">            <span class="comment">// 阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；</span></span><br><span class="line">            <span class="comment">//当 wait() 被 notify_one() 激活时，会先执行它的 条件判断表达式 是否为 true，</span></span><br><span class="line">            <span class="comment">//如果为true才会继续往下执行</span></span><br><span class="line">            condition.wait(sbguard2, [<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">if</span> (!msgRecvQueue.empty())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;&#125;);</span><br><span class="line">            command = msgRecvQueue.front();</span><br><span class="line">            msgRecvQueue.pop_front();</span><br><span class="line">            <span class="comment">//因为unique_lock的灵活性，我们可以随时unlock，以免锁住太长时间</span></span><br><span class="line">            sbguard2.unlock(); </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"outMsgRecvQueue()执行，取出第一个元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">	<span class="built_in">std</span>::mutex mymutex1;</span><br><span class="line">	<span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A myobja;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">myoutobj</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">myinobj</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	myinobj.join();</span><br><span class="line">	myoutobj.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二、深入思考</strong></p>
<p>上面的代码可能导致出现一种情况：<br>因为outMsgRecvQueue()与inMsgRecvQueue()并不是一对一执行的，所以当程序循环执行很多次以后，可能在msgRecvQueue 中已经有了很多消息，但是，outMsgRecvQueue还是被唤醒一次只处理一条数据。这时可以考虑把outMsgRecvQueue多执行几次，或者对inMsgRecvQueue进行限流。</p>
<p><strong>三、notify_all()</strong></p>
<p>notify_one()：通知一个线程的wait()</p>
<p>notify_all()：通知所有线程的wait()</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++并发与多线程笔记1</title>
    <url>/2020/08/01/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h2 id="一、并发、进程、线程的基本概念和综述"><a href="#一、并发、进程、线程的基本概念和综述" class="headerlink" title="一、并发、进程、线程的基本概念和综述"></a>一、并发、进程、线程的基本概念和综述</h2><p>并发，线程，进程要求必须掌握<br><a id="more"></a></p>
<h3 id="1-1-并发"><a href="#1-1-并发" class="headerlink" title="1.1 并发"></a>1.1 并发</h3><ul>
<li><strong>两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；</strong></li>
<li>以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。并发的假象（不是真正的并发），切换（上下文切换）时要保存变量的状态、执行进度等，存在时间开销；</li>
<li>随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。能够实现真正的并行执行多个任务（硬件并发）</li>
<li>使用并发的原因：主要就是同时可以干多个事，提高性能</li>
</ul>
<h3 id="1-2-可执行程序"><a href="#1-2-可执行程序" class="headerlink" title="1.2 可执行程序"></a>1.2 可执行程序</h3><ul>
<li>磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）</li>
</ul>
<h3 id="1-3-进程"><a href="#1-3-进程" class="headerlink" title="1.3 进程"></a>1.3 进程</h3><ul>
<li>运行一个可执行程序，在windows下，可双击；在linux下，./文件名</li>
<li>进行，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。</li>
</ul>
<h3 id="1-4-线程"><a href="#1-4-线程" class="headerlink" title="1.4 线程"></a>1.4 线程</h3><p> ①</p>
<ul>
<li>a)<strong>每个进程（执行起来的可执行程序），都有唯一的一个主线程</strong></li>
<li>b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了</li>
<li>ctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码</li>
<li>线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路<br><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200801151515911.png" alt="在这里插入图片描述"></li>
</ul>
<p>②</p>
<ul>
<li>除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至区不同的地方</li>
<li>每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）</li>
</ul>
<p>③</p>
<ul>
<li>多线程（并发）</li>
<li><strong>线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间</strong></li>
</ul>
<p>必须使用多线程的案例<br><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"><br><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200801151515898.png" alt="在这里插入图片描述"></p>
<h2 id="二、并发的实现方法"><a href="#二、并发的实现方法" class="headerlink" title="二、并发的实现方法"></a>二、并发的实现方法</h2><p>实现并发的手段：<br>a）通过多个进程实现并发<br>b）在单独的进程中，写代码创建除了主线程之外的其他线程来实现并发</p>
<h3 id="2-1-多进程并发"><a href="#2-1-多进程并发" class="headerlink" title="2.1 多进程并发"></a>2.1 多进程并发</h3><ul>
<li>比如账号服务器一个进程，游戏服务器一个进程。</li>
<li>服务器进程之间存在通信（同一个电脑上：管道，文件，消息队列，共享内存）；（不同电脑上：socket通信技术）</li>
</ul>
<h3 id="2-2-多线程并发"><a href="#2-2-多线程并发" class="headerlink" title="2.2 多线程并发"></a>2.2 多线程并发</h3><ul>
<li>线程：感觉像是轻量级的进程。每个进程有自己独立的运行路径，但一个进程中的所有线程共享地址空间（共享内存），全局变量、全局内存、全局引用都可以在线程之间传递，所以多线程开销远远小于多进程</li>
<li>多进程并发核多线程并发可以混合使用，但建议优先考虑多线程技术</li>
<li>本课程中只讲多线程并发技术</li>
</ul>
<h2 id="三、C-11新标准线程库"><a href="#三、C-11新标准线程库" class="headerlink" title="三、C++11新标准线程库"></a>三、C++11新标准线程库</h2><p><em>以往</em></p>
<ul>
<li>windows：CreateThread(), _beginthread(),_beginthreadexe()创建线程；linux：pthread_create()创建线程；不能跨平台</li>
<li>临界区，互斥量</li>
<li>POSIX thread(pthread):跨平台，但要做一番配置，也不方便</li>
</ul>
<p><em>C++11</em></p>
<ul>
<li>从C++11新标准，C++语言本身增加对多线程的支持，意味着可移植性（跨平台），这大大减少开发人员的工作量</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++并发与多线程笔记5</title>
    <url>/2020/08/02/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[<h2 id="第十二节-windows临界区、其他各种mutex互斥量"><a href="#第十二节-windows临界区、其他各种mutex互斥量" class="headerlink" title="第十二节 windows临界区、其他各种mutex互斥量"></a>第十二节 windows临界区、其他各种mutex互斥量</h2><a id="more"></a>
<p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200802122204747.png" alt="在这里插入图片描述"></p>
<p><strong>一和二、windows临界区</strong><br>Windows临界区，同一个线程是可以重复进入的，但是进入的次数与离开的次数必须相等。<br>C++互斥量则不允许同一个线程重复加锁。</p>
<p>windows临界区是在windows编程中的内容，了解一下即可，效果几乎可以等同于c++11的mutex<br>包含#include <windows.h><br>windows中的临界区同mutex一样，可以保护一个代码段。但windows的临界区可以进入多次，离开多次，但是进入的次数与离开的次数必须相等，不会引起程序报异常出错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WINDOWSJQ_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 把收到的消息传入队列</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"收到消息，并放入队列 "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  __WINDOWSJQ_</span></span><br><span class="line">			EnterCriticalSection(&amp;my_winsec);	<span class="comment">//	进入临界区</span></span><br><span class="line">			<span class="comment">//EnterCriticalSection(&amp;my_winsec);	//	可以再次进入临界区,程序不会出错</span></span><br><span class="line">			msgRecvQueue.push_back(i);</span><br><span class="line">			LeaveCriticalSection(&amp;my_winsec);	<span class="comment">//	离开临界区</span></span><br><span class="line">			<span class="comment">//LeaveCriticalSection(&amp;my_winsec);	//	如果进入两次，必须离开两次不会报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span></span></span><br><span class="line">			my_mutex.lock();</span><br><span class="line">			msgRecvQueue.push_back(i);</span><br><span class="line">			my_mutex.unlock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//  __WINDOWSJQ_</span></span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"消息入队结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从队列中取出消息</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  __WINDOWSJQ_</span></span><br><span class="line">			EnterCriticalSection(&amp;my_winsec);	<span class="comment">//	进入临界区</span></span><br><span class="line">			<span class="keyword">if</span> (!msgRecvQueue.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 队列不为空</span></span><br><span class="line">				<span class="keyword">int</span> num = msgRecvQueue.front();</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"从消息队列中取出 "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				msgRecvQueue.pop_front();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 消息队列为空</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"消息队列为空 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			LeaveCriticalSection(&amp;my_winsec);	<span class="comment">//	离开临界区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span></span></span><br><span class="line">			my_mutex.lock();</span><br><span class="line">			<span class="keyword">if</span> (!msgRecvQueue.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 队列不为空</span></span><br><span class="line">				<span class="keyword">int</span> num = msgRecvQueue.front();</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"从消息队列中取出 "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				msgRecvQueue.pop_front();</span><br><span class="line">				my_mutex.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 消息队列为空</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"消息队列为空 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				my_mutex.unlock();</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//  __WINDOWSJQ_</span></span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"消息出队结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A()</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWSJQ_</span></span><br><span class="line">		InitializeCriticalSection(&amp;my_winsec);	<span class="comment">//	用临界区之前要初始化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __WINDOWSJQ_</span></span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">	mutex my_mutex;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWSJQ_</span></span><br><span class="line">	CRITICAL_SECTION my_winsec;	<span class="comment">//	windows中的临界区，非常类似C++11中的mutex</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __WINDOWSJQ_</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A myobj;</span><br><span class="line">	<span class="function">thread	<span class="title">myInMsgObj</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;myobj)</span></span>;</span><br><span class="line">	<span class="function">thread	<span class="title">myOutMsgObj</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;myobj)</span></span>;</span><br><span class="line">	myInMsgObj.join();</span><br><span class="line">	myOutMsgObj.join();</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107</span></span><br></pre></td></tr></table></figure>
<p><strong>三、自动析构技术</strong><br>C++：lock_guard防止忘了释放信号量，自动释放<br>windows：可以写个类自动释放临界区：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWinLock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CWinLock(CRITICAL_SECTION *pCritmp)</span><br><span class="line">    &#123;</span><br><span class="line">        my_winsec =pCritmp;</span><br><span class="line">        EnterCriticalSection(my_winsec);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CWinLock()</span><br><span class="line">    &#123;</span><br><span class="line">        LeaveCriticalSection(my_winsec)</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CRITICAL_SECTION *my_winsec;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>上述这种类RAII类（Resource Acquisition is initialization），即资源获取及初始化。容器，智能指针属于这种类。</p>
<p><strong>四、递归独占互斥量 std::recursive_mutex</strong><br>std::mutex 独占式互斥量</p>
<p>std::recursive_mutex：允许在同一个线程中同一个互斥量多次被 lock() ，（但是递归加锁的次数是有限制的，太多可能会报异常），效率要比mutex低。</p>
<p>如果你真的用了 recursive_mutex 要考虑代码是否有优化空间，如果能调用一次 lock()就不要调用多次。</p>
<p><strong>五、带超时的互斥量 std::timed_mutex 和 std::recursive_timed_mutex</strong></p>
<p><em>5.1 std::timed_mutex：是待超时的独占互斥量</em></p>
<ul>
<li>try_lock_for()：</li>
</ul>
<p>等待一段时间，如果拿到了锁，或者超时了未拿到锁，就继续执行（有选择执行）如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">timeout</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (my_mymutex.try_lock_for(timeout))&#123;</span><br><span class="line">    <span class="comment">//......拿到锁返回ture</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::chrono::milliseconds sleeptime(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(sleeptime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<ul>
<li>try_lock_until()：</li>
</ul>
<p>参数是一个未来的时间点，在这个未来的时间没到的时间内，如果拿到了锁头，流程就走下来，如果时间到了没拿到锁，流程也可以走下来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">timeout</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (my_mymutex.try_lock_until(chrono::steady_clock::now() + timeout))&#123;</span><br><span class="line">    <span class="comment">//......拿到锁返回ture</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::chrono::milliseconds sleeptime(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(sleeptime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>两者的区别就是一个参数是时间段，一个参数是时间点</p>
<p><em>5.2 std::recursive_timed_mutex：是待超时的递归独占互斥量</em></p>
<h2 id="第十三章-补充知识、线程池浅谈、数量谈、总结"><a href="#第十三章-补充知识、线程池浅谈、数量谈、总结" class="headerlink" title="第十三章 补充知识、线程池浅谈、数量谈、总结"></a>第十三章 补充知识、线程池浅谈、数量谈、总结</h2><p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200802122217536.png" alt="在这里插入图片描述"></p>
<p><strong>一、补充一些知识点</strong><br><em>1.1 虚假唤醒：</em><br>notify_one或者notify_all唤醒wait()后，实际有些线程可能不满足唤醒的条件，就会造成虚假唤醒，可以在wait中再次进行判断解决虚假唤醒。<br>解决：wait中要有第二个参数（lambda），并且这个lambda中要正确判断所处理的公共数据是否存在。</p>
<p><em>2.2 atomic：</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; atm = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; atm &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>这里只有读取atm是原子操作，但是整个这一行代码 cout &lt;&lt; atm &lt;&lt; endl; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; atm = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> atm2 = atm; <span class="comment">//不可以</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>这种拷贝初始化不可以，会报错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">int</span>&gt; atm2(atm.load());</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>load()：以原子方式读atomic对象的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">atm2.store(<span class="number">12</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>原子操作实质上是：不允许在进行原子对象操作时进行CPU的上下文切换。</p>
<p><strong>二、浅谈线程池：</strong><br>场景设想：服务器程序， 每来一个客户端，就创建一个新线程为这个客户提供服务。</p>
<p>问题：</p>
<p>1、2万个玩家，不可能给每个玩家创建一个新线程，此程序写法在这种场景下不通。</p>
<p>2、程序稳定性问题：编写代码中，“时不时地突然”创建一个线程，这种写法，一般情况下不会出错，但是不稳定的；</p>
<p>线程池：把一堆线程弄到一起，统一管理。这种统一管理调度，循环利用的方式，就叫做线程池。</p>
<p>实现方式：程序启动时，一次性创建好一定数量的线程。这种方式让人更放心，觉得程序代码更稳定。</p>
<p><strong>三、线程创建数量谈：</strong></p>
<p>1、线程创建的数量极限的问题</p>
<p>一般来讲，2000个线程基本就是极限；再创建就会崩溃。</p>
<p>2、线程创建数量建议</p>
<p>a、采用某些计数开发程序提供的建议，遵照建议和指示来确保程序高效执行。</p>
<p>b、创建多线程完成业务；考虑可能被阻塞的线程数量，创建多余最大被阻塞线程数量的线程，如100个线程被阻塞再充值业务，开110个线程就是很合适的</p>
<p>c、线程创建数量尽量不要超过500个，尽量控制在200个之内；</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++并发与多线程笔记4</title>
    <url>/2020/08/02/C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<h2 id="第九节、async、future、packaged-task、promise"><a href="#第九节、async、future、packaged-task、promise" class="headerlink" title="第九节、async、future、packaged_task、promise"></a>第九节、async、future、packaged_task、promise</h2><a id="more"></a>
<p><img src="image/20200513104145145.png" alt="在这里插入图片描述"></p>
<p><strong>本节内容需要包含头文件#include</strong> </p>
<p><strong>一、std::async、std::future创建后台任务并返回值</strong><br><strong>std::async</strong>是一个函数模板，用来启动一个异步任务，启动起来一个异步任务之后，它返回一个<strong>std::future</strong>对象，这个对象是个类模板。</p>
<p>什么叫“启动一个异步任务”？就是自动创建一个线程，并开始 执行对应的线程入口函数，它返回一个std::future对象，这个std::future对象中就含有线程入口函数所返回的结果，我们可以通过调用future对象的成员函数get()来获取结果。</p>
<p>std::future提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，但是在不久的将来，这个线程执行完毕的时候，你就能够拿到结果了，所以，大家这么理解：future中保存着一个值，这个值是在将来的某个时刻能够拿到。</p>
<p>std::future对象的<strong>get()成员函数</strong>会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像join()但是，它是可以获取结果的。</p>
<p>std::future对象的<strong>wait()成员函数</strong>，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> mypar)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> mypar;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">12</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result1 = <span class="built_in">std</span>::async(mythread);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result1.get() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//卡在这里等待mythread()执行完毕，拿到结果</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//类成员函数</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result2 = <span class="built_in">std</span>::async(&amp;A::mythread, &amp;a, tmp); <span class="comment">//第二个参数是对象引用才能保证线程里执行的是同一个对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result2.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">//或者result2.wait();</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536</span></span><br></pre></td></tr></table></figure>
<p>我们通过向std::async()传递一个参数，该参数是std::launch类型（枚举类型），来达到一些特殊的目的：</p>
<p><em>1、std::launch::deferred：</em><br>（defer推迟，延期）表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行；如果wait()或者get()没有被调用，则不会执行。<br>实际上根本就没有创建新线程。std::lunch::deferred意思时延迟调用，并没有创建新线程，是在主线程中调用的线程入口函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred ,mythread);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result1.get() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//卡在这里等待mythread()执行完毕，拿到结果</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>
<p><img src="image/2020051310433493.png" alt="在这里插入图片描述"></p>
<p>永远都会先打印出continue…，然后才会打印出mythread() start和mythread() end等信息。</p>
<p><em>2、std::launch::async，在调用async函数的时候就开始创建新线程。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async ,mythread);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result1.get() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p><strong>二、std::packaged_task：打包任务，把任务包装起来。</strong><br>类模板，它的模板参数是各种可调用对象，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> mypar)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//我们把函数mythread通过packaged_task包装起来</span></span><br><span class="line">   <span class="comment">//参数是一个int，返回值类型是int</span></span><br><span class="line">   <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; mypt(mythread);</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::ref(mypt), <span class="number">1</span>)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt.get_future(); </span><br><span class="line">	<span class="comment">//std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>
<p><em>可调用对象可由函数换成lambda表达式</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; mypt([](<span class="keyword">int</span> mypar) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::chrono::milliseconds dura(<span class="number">5000</span>);</span><br><span class="line">		<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	&#125;); </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::ref(mypt), <span class="number">1</span>)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt.get_future(); </span><br><span class="line">	<span class="comment">//std::future对象里包含有线程入口函数的返回结果，这里result保存mythread返回的结果。</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>
<p>packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象<br><em>lambda的直接调用</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; mypt([](<span class="keyword">int</span> mypar) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::chrono::milliseconds dura(<span class="number">5000</span>);</span><br><span class="line">		<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	&#125;); </span><br><span class="line"> </span><br><span class="line">	mypt(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt.get_future();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p><em>std::promise，类模板</em><br>我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; &amp;tmp, <span class="keyword">int</span> clac)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> result = clac;</span><br><span class="line">	tmp.set_value(result); <span class="comment">//结果保存到了tmp这个对象中</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;&gt; task_vec;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; myprom;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(mythread, <span class="built_in">std</span>::ref(myprom), <span class="number">180</span>)</span></span>;</span><br><span class="line">	t1.join(); </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; fu1 = myprom.get_future(); <span class="comment">//promise和future绑定，用于获取线程返回值</span></span><br><span class="line">	<span class="keyword">auto</span> result = fu1.get();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>
<p>总结：通过promise保存一个值，在将来某个时刻我们通过吧一个future绑定到这个promise上，来得到绑定的值</p>
<p>注意：使用thread时，必须 join() 或者 detach() 否则程序会报异常</p>
<p><strong>小结：</strong></p>
<p>我们学习这些东西的目的并不是，要把他们都用到实际开发中。</p>
<p>相反，如果我们能够用最少的东西写出一个稳定的，高效的多线程程序，更值得赞赏。</p>
<p>我们为了成长必须阅读一些高手写的代码，从而实现自己代码的积累；</p>
<h2 id="第十节-future其他成员函数、shared-future、atomic"><a href="#第十节-future其他成员函数、shared-future、atomic" class="headerlink" title="第十节 future其他成员函数、shared_future、atomic"></a>第十节 future其他成员函数、shared_future、atomic</h2><p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70-20200802120836532.png" alt="在这里插入图片描述"></p>
<p><strong>一、std::future 的成员函数</strong><br>1、<strong>std::future_status status</strong> = result.<strong>wait_for</strong>(std::chrono::seconds(几秒));<br>卡住当前流程，等待std::async()的异步任务运行一段时间，然后返回其状态std::future_status。如果std::async()的参数是std::launch::deferred（延迟执行），则不会卡住主流程。<br>std::future_status是枚举类型，表示异步任务的执行状态。类型的取值有<br><strong>std::future_status::timeout<br>std::future_status::ready<br>std::future_status::deferred</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async(mythread);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果</span></span><br><span class="line">	<span class="comment">//等待1秒</span></span><br><span class="line">   <span class="built_in">std</span>::future_status status = result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">		<span class="comment">//超时：表示线程还没有执行完</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"超时了，线程还没有执行完"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//类成员函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure>
<p><img src="image/20200513105124529.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//std::chrono::milliseconds dura(5000);</span></span><br><span class="line">	<span class="comment">//std::this_thread::sleep_for(dura);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, mythread);</span><br><span class="line">	<span class="comment">//std::future&lt;int&gt; result = std::async(mythread);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; result1.get() &lt;&lt; endl; //卡在这里等待mythread()执行完毕，拿到结果</span></span><br><span class="line">	<span class="built_in">std</span>::future_status status = result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">6</span>));</span><br><span class="line">	<span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">		<span class="comment">//超时：表示线程还没有执行完</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"超时了，线程还没有执行完"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">		<span class="comment">//表示线程成功放回</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程执行成功，返回"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::deferred) &#123;</span><br><span class="line">		<span class="comment">//如果设置 std::future&lt;int&gt; result = std::async(std::launch::deferred, mythread);，则本条件成立</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程延迟执行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637</span></span><br></pre></td></tr></table></figure>
<p>get()只能使用一次，比如如果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = result.get();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>就会报告异常<br>因为get()函数的设计是一个移动语义，相当于将result中的值移动到了a中，再次get就报告了异常。</p>
<p><strong>二、std::shared_future：也是个类模板</strong><br>std::future的 get() 成员函数是转移数据</p>
<p>std::shared_future 的 get()成员函数是复制数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>()&gt; mypt(mythread);</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::ref(mypt))</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt.get_future();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">bool</span> ifcanget = result.valid(); <span class="comment">//判断future 中的值是不是一个有效值</span></span><br><span class="line">	<span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; result_s(result.share()); <span class="comment">//执行完毕后result_s里有值，而result里空了</span></span><br><span class="line">	<span class="comment">//std::shared_future&lt;int&gt; result_s(std::move(result));</span></span><br><span class="line">   <span class="comment">//通过get_future返回值直接构造一个shared_future对象</span></span><br><span class="line">   <span class="comment">//std::shared_future&lt;int&gt; result_s(mypt.get_future());</span></span><br><span class="line">   t1.join();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> myresult1 = result_s.get();</span><br><span class="line">	<span class="keyword">auto</span> myresult2 = result_s.get();</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br></pre></td></tr></table></figure>
<p><strong>三、std::atomic原子操作</strong></p>
<p><em>3.1 原子操作概念引出范例：</em><br>互斥量：多线程编程中 用于保护共享数据：先锁住， 操作共享数据， 解锁。</p>
<p>有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。</p>
<p>即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条C语句会被拆成3、4条汇编语句来执行，所以仍然有可能混乱）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> g_count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		g_count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"正常情况下结果应该是200 0000次，实际是"</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p><img src="image/20200513105255690.png" alt="在这里插入图片描述"></p>
<p>使用mutex解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> g_count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mymutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; u1(mymutex);</span><br><span class="line">		g_count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"正常情况下结果应该是200 0000次，实际是"</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>
<p><img src="image/20200513105322661.png" alt="在这里插入图片描述"></p>
<p><em>3.2 基本的std::atomic用法范例</em><br>大家可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</p>
<p>原子操作：在多线程中不会被打断的程序执行片段。</p>
<p>从效率上来说，原子操作要比互斥量的方式效率要高。</p>
<p>互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。</p>
<p>原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。</p>
<p>std::atomic来代表原子操作，是个类模板。其实std::atomic是用来封装某个类型的值的</p>
<p>需要添加#include 头文件</p>
<p>范例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; g_count = <span class="number">0</span>; <span class="comment">//封装了一个类型为int的 对象（值）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		g_count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"正常情况下结果应该是200 0000次，实际是"</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>
<p><img src="image/20200513105403722.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; g_ifEnd = <span class="literal">false</span>; <span class="comment">//封装了一个类型为bool的 对象（值）</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (g_ifEnd == <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"运行中"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"运行结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	g_ifEnd = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"程序执行完毕"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>
<p><img src="image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p><strong>总结：</strong><br>1、原子操作一般用于计数或者统计（如累计发送多少个数据包，累计接收到了多少个数据包），多个线程一起统计，这种情况如果不使用原子操作会导致统计发生混乱。</p>
<p>2、写商业代码时，如果不确定结果的影响，最好自己先写一小段代码调试。或者不要使用。</p>
<h2 id="第十一节-std-atomic续谈、std-async深入谈"><a href="#第十一节-std-atomic续谈、std-async深入谈" class="headerlink" title="第十一节 std::atomic续谈、std::async深入谈"></a>第十一节 std::atomic续谈、std::async深入谈</h2><p><img src="image/20200513105654641.png" alt="在这里插入图片描述"></p>
<p><strong>一、std::atomic续谈</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; g_count = <span class="number">0</span>; <span class="comment">//封装了一个类型为int的 对象（值）</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		 <span class="comment">//虽然g_count使用了原子操作模板，但是这种写法既读又写，</span></span><br><span class="line">		 <span class="comment">//会导致计数错误</span></span><br><span class="line">             g_count = g_count + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"正常情况下结果应该是200 0000次，实际是"</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>
<p><img src="image/20200513105723318.png" alt="在这里插入图片描述"></p>
<p>一般atomic原子操作，针对++，–，+=，-=，&amp;=，|=，^=是支持的，其他操作不一定支持。</p>
<p><strong>二、std::async深入理解</strong><br><em>2.1 std::async参数详述，async 用来创建一个异步任务</em></p>
<p>延迟调用参数 std::launch::deferred【延迟调用】，std::launch::async【强制创建一个线程】</p>
<p>std::async()我们一般不叫创建线程（他能够创建线程），我们一般叫它创建一个异步任务。</p>
<p>std::async和std::thread最明显的不同，就是 async 有时候并不创建新线程。</p>
<p>①如果用std::launch::deferred 来调用async？</p>
<p>延迟到调用 get() 或者 wait() 时执行，如果不调用就不会执行</p>
<p>②如果用std::launch::async来调用async？</p>
<p>强制这个异步任务在新线程上执行，这意味着，系统必须要创建出新线程来运行入口函数。</p>
<p>③如果同时用 std::launch::async | std::launch::deferred</p>
<p>这里这个或者关系意味着async的行为可能是 std::launch::async 创建新线程立即执行， 也可能是 std::launch::deferred 没有创建新线程并且延迟到调用get()执行，由<strong>系统根据实际情况来决定采取</strong>哪种方案</p>
<p>④不带额外参数 std::async(mythread)，只给async 一个入口函数名，此时的系统给的默认值是 std::launch::async | std::launch::deferred 和 ③ 一样，有系统自行决定异步还是同步运行。</p>
<p><em>2.2 std::async和std::thread()区别：</em></p>
<p>std::thread()如果系统资源紧张可能出现创建线程失败的情况，如果创建线程失败那么程序就可能崩溃，而且不容易拿到函数返回值（不是拿不到）<br>std::async()创建异步任务。可能创建线程也可能不创建线程，并且容易拿到线程入口函数的返回值；</p>
<p><em>由于系统资源限制：</em><br>①如果用std::thread创建的线程太多，则可能创建失败，系统报告异常，崩溃。</p>
<p>②如果用std::async，一般就不会报异常，因为如果系统资源紧张，无法创建新线程的时候，async不加额外参数的调用方式就不会创建新线程。而是在后续调用get()请求结果时执行在这个调用get()的线程上。</p>
<p>如果你强制async一定要创建新线程就要使用 std::launch::async 标记。承受的代价是，系统资源紧张时可能崩溃。</p>
<p>③根据经验，一个程序中线程数量 不宜超过100~200 。</p>
<p><em>2.3 async不确定性问题的解决</em><br>不加额外参数的async调用时让系统自行决定，是否创建新线程。</p>
<p>std::future result = std::async(mythread);<br>问题焦点在于这个写法，任务到底有没有被推迟执行。</p>
<p>通过wait_for返回状态来判断：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::future_status status = result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">6</span>));</span><br><span class="line"><span class="comment">//std::future_status status = result.wait_for(6s);</span></span><br><span class="line">	<span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">		<span class="comment">//超时：表示线程还没有执行完</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"超时了，线程还没有执行完"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">		<span class="comment">//表示线程成功放回</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程执行成功，返回"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::deferred) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程延迟执行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++数组</title>
    <url>/2020/07/24/C-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>c++中的数组真的是个神奇的存在,数组仅在定义其的域范围内可确定大小.<br><a id="more"></a><br>本文需要解决C++中关于数组的2个问题：<br>\1. 数组作为函数参数，传值还是传址？<br>\2. 函数参数中的数组元素个数能否确定？</p>
<p>先看下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testArrayArg</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"in func..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"array address: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"array size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"array element count: "</span> &lt;&lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"changing the 4th element's value to 10."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  a[<span class="number">3</span>] = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"in main..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"array address: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"array size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"array element count: "</span> &lt;&lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  testArrayArg(a);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"the 4th element's value: "</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p>in main…<br>array address: 0012FF4C<br>array size: 20<br>array element count: 5</p>
<p>in func…<br>array address: 0012FF4C<br>array size: 4<br>array element count: 1<br>changing the 4th element’s value to 10.</p>
<p>the 4th element’s value: 10</p>
<p>当我们直接将数组a作为参数调用testArrayArg()时，实参与形参的地址均是0012FF4C。并且，在testArrayArg()中将a[3]的值修改为10后，返回main()函数中，a[3]的值也已经改变。这些都说明<strong>C++中数组作为函数参数是传址</strong>。</p>
<p>特别需要注意的是，在main()中，数组的大小是可以确定的。</p>
<p>array size: 20<br>array element count: 5</p>
<p>但作为函数参数传递后，其大小信息丢失，只剩下数组中第一个元素的信息。</p>
<p>array size: 4<br>array element count: 1</p>
<p>这是因为C++实际上是将数组作为指针来传递，而该指针指向数组的第一个元素。至于后面数组在哪里结束，C++的函数传递机制并不负责。</p>
<p>上面的特性可总结为，<strong>数组仅在定义其的域范围内可确定大小</strong>。</p>
<p>因此，如果在接受数组参数的函数中访问数组的各个元素，需在定义数组的域范围将数组大小作为另一辅助参数传递。则有另一函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testArrayArg2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> arrayLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"the last element in array is: "</span> &lt;&lt; a[arrayLength - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可在main()中这样调用：</p>
<p>testArrayArg2(a, sizeof(a) / sizeof(a[0]));</p>
<p>这样，testArrayArg2()中便可安全地访问数组元素了。</p>
<h1 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int t[10]&#123;1, 2, 3, 4, 5, 5&#125;;</span><br><span class="line">    int *p&#x3D;t;</span><br><span class="line">    p++;</span><br><span class="line">    &#x2F;&#x2F; 下面输出的都是t[1]的地址</span><br><span class="line">    std::cout &lt;&lt; t+1&lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt; p&lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt; &amp;t[0]+1&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能执行t++</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++零碎知识点</title>
    <url>/2020/07/24/C-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="#define和const的区别"></a><code>#define</code>和<code>const</code>的区别</h2><a id="more"></a>
<p>define没有数据类型，const可以定义数据类型。</p>
<p>编译器可以对const进行类型检查，不能对define进行类型检查。</p>
<h2 id="malloc-free和new-delete的区别"><a href="#malloc-free和new-delete的区别" class="headerlink" title="malloc/free和new/delete的区别"></a>malloc/free和new/delete的区别</h2><p>malloc和free是标准库函数，new和delete是c++的运算符。</p>
<p>都可用于动态申请和释放内存。</p>
<h2 id="C-不是类型安全的"><a href="#C-不是类型安全的" class="headerlink" title="C++不是类型安全的"></a>C++不是类型安全的</h2><p>reinterpret cast可以强制转换</p>
<h2 id="判断操作系统位数"><a href="#判断操作系统位数" class="headerlink" title="判断操作系统位数"></a>判断操作系统位数</h2><p>sizeof查看指针长度</p>
<h2 id="几种const"><a href="#几种const" class="headerlink" title="几种const"></a>几种const</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p;  <span class="comment">// 指向const char的指针</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *p;  <span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> p;  <span class="comment">// 指向char的常指针</span></span><br></pre></td></tr></table></figure>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>显式：函数参数不能进行隐式类型转换</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组实参传递给函数时，传递的是地址。函数也无法通过sizeof(p)/sizeof(p[0])计算机制。但是可以通过下标访问函数元素。</p>
<h2 id="C-中的全局变量不是由main函数引起的。"><a href="#C-中的全局变量不是由main函数引起的。" class="headerlink" title="C++中的全局变量不是由main函数引起的。"></a>C++中的全局变量不是由main函数引起的。</h2><h2 id="将“引用”作为函数参数有哪些特点？"><a href="#将“引用”作为函数参数有哪些特点？" class="headerlink" title="将“引用”作为函数参数有哪些特点？"></a>将“引用”作为函数参数有哪些特点？</h2><p><1>传递引用给函数和传递指针的效果是一样的</p>
<p><2>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作(当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好)</p>
<p><3>与指针作为函数的参数，需要分配存储单元，且容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参，而引用更容易使用、更清晰</p>
<h2 id="“引用”与多态的关系？"><a href="#“引用”与多态的关系？" class="headerlink" title="“引用”与多态的关系？"></a>“引用”与多态的关系？</h2><p>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例</p>
<p>例:Class A; Class B : Class A{…}; B b; A&amp; ref = b;</p>
<h2 id="只能用intialization-list而不能用assignment"><a href="#只能用intialization-list而不能用assignment" class="headerlink" title="只能用intialization list而不能用assignment"></a>只能用intialization list而不能用assignment</h2><p>对于const和reference类型成员变量，它们只能够被初始化而不能做赋值操作，因此只能用初始化列表。</p>
<p>还有一种情况就是，类的构造函数需要调用其基类的构造函数的时候。</p>
<h2 id="空类大小"><a href="#空类大小" class="headerlink" title="空类大小"></a>空类大小</h2><p>空类大小等于1，是因为编译器为了区分不同的类，在类中加的一个char型。</p>
<h2 id="如何打印出当前源文件的文件名以及源文件的当前行号？"><a href="#如何打印出当前源文件的文件名以及源文件的当前行号？" class="headerlink" title="如何打印出当前源文件的文件名以及源文件的当前行号？"></a>如何打印出当前源文件的文件名以及源文件的当前行号？</h2><p>答案：<br>cout &lt;&lt; <strong>FILE</strong> ;<br>cout&lt;&lt;<strong>LINE</strong> ;<br><strong>FILE</strong>和<strong>LINE</strong>是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。</p>
<h2 id="main主函数执行完毕后，是否可能会再执行一段代码，给出说明？"><a href="#main主函数执行完毕后，是否可能会再执行一段代码，给出说明？" class="headerlink" title="main主函数执行完毕后，是否可能会再执行一段代码，给出说明？"></a>main主函数执行完毕后，是否可能会再执行一段代码，给出说明？</h2><p>答案：可以，可以用_onexit注册一个函数，它会在main之后执行int fn1(void), fn2(void), fn3(void), fn4 (void);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">String</span> <span class="title">str</span><span class="params">(<span class="string">"zhanglin"</span>)</span></span>;</span><br><span class="line">       _onexit( fn1 );</span><br><span class="line">       _onexit( fn2 );</span><br><span class="line">       _onexit( fn3 );</span><br><span class="line">       _onexit( fn4 );</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">"This is executed first.n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">"next.n"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">"executed "</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">"is "</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">"This "</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何判断一段程序是由C-编译程序还是由C-编译程序编译的？"><a href="#如何判断一段程序是由C-编译程序还是由C-编译程序编译的？" class="headerlink" title="如何判断一段程序是由C 编译程序还是由C++编译程序编译的？"></a>如何判断一段程序是由C 编译程序还是由C++编译程序编译的？</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"c++"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"c"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="文件中有一组整数，要求排序后输出到另一个文件中"><a href="#文件中有一组整数，要求排序后输出到另一个文件中" class="headerlink" title="文件中有一组整数，要求排序后输出到另一个文件中"></a>文件中有一组整数，要求排序后输出到另一个文件中</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Order</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">int</span> count = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> tag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j] &gt; data[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                tag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> temp = data[j];</span><br><span class="line">                data[j] = data[j + <span class="number">1</span>];</span><br><span class="line">                data[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!in) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"file error"</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (!in.eof()) &#123;</span><br><span class="line">        in &gt;&gt; temp;</span><br><span class="line">        data.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    Order(data);</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"result.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!out) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"file error!"</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> item:data)</span><br><span class="line">        out &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="节点的定义方式"><a href="#节点的定义方式" class="headerlink" title="节点的定义方式"></a>节点的定义方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">//建立一个Node对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">a</span>;</span> <span class="comment">//1</span></span><br><span class="line">Node* b; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><ol>
<li><p>逆序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">////41</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">ReverseList</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p1 = head;</span><br><span class="line">    Node *p2 = head-&gt;next;</span><br><span class="line">    Node *p3 = p2-&gt;next;</span><br><span class="line">    p1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p3 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p3;</span><br><span class="line">        p3 = p3-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = p1;</span><br><span class="line">    head = p2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Merge</span><span class="params">(Node *head1, Node *head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *head = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *p2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (head1-&gt;data &lt; head2-&gt;data) &#123;</span><br><span class="line">        head = head1;</span><br><span class="line">        p1 = head1-&gt;next;</span><br><span class="line">        p2 = head2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = head2;</span><br><span class="line">        p1 = head1;</span><br><span class="line">        p2 = head2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *pcurhead = head;</span><br><span class="line">    <span class="keyword">while</span> (p1-&gt;next != <span class="literal">nullptr</span> &amp;&amp; p2-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;next &lt; p2-&gt;next) &#123;</span><br><span class="line">            pcurhead-&gt;next = p1-&gt;next;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pcurhead-&gt;next = p2-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pcurhead-&gt;next = p2;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (p2-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pcurhead-&gt;next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并链表（递归）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">Merge</span><span class="params">(Node *head1, Node *head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *head;</span><br><span class="line">    <span class="keyword">if</span> (head1-&gt;data &lt; head2-&gt;data) &#123;</span><br><span class="line">        head = head1;</span><br><span class="line">        head-&gt;next = Merge(head1-&gt;next, head2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = head2;</span><br><span class="line">        head-&gt;next = Merge(head1, head2-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表中是否有环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_loop</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *slow_ptr = head;</span><br><span class="line">    Node *fast_ptr = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast_ptr != <span class="literal">nullptr</span> &amp;&amp; fast_ptr-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow_ptr = slow_ptr-&gt;next;</span><br><span class="line">        fast_ptr = fast_ptr-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast_ptr==slow_ptr)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>strcpy的实现</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *strDest, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span> </span>&#123;</span><br><span class="line">    assert((strDest != <span class="literal">nullptr</span>) &amp;&amp; (strSrc != <span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">char</span> *address = strDest;</span><br><span class="line">    <span class="keyword">while</span> ((*strDest++ = *strSrc++) != <span class="string">'\0'</span> );</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>strlen的实现<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dst)</span> </span>&#123;</span><br><span class="line">    assert(dst != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*dst++ != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="malloc和free的使用"><a href="#malloc和free的使用" class="headerlink" title="malloc和free的使用"></a>malloc和free的使用</h2><p>free只是告诉操作系统，指针P所指向的这块内存我不实用了！由操作系统负责收回。而指针P他的空间中存储的还是原来的空间的地址。<br>当然在free之后再解引用指针就回发生段错误，所以每次free之后，最好p=NULL;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="string">'g'</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, *p); <span class="comment">// g</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="include-与-＃include-“file-h”的区别？"><a href="#include-与-＃include-“file-h”的区别？" class="headerlink" title="include 与 ＃include “file.h”的区别？"></a>include<file.h> 与 ＃include “file.h”的区别？</h2><p>答：前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。</p>
<h2 id="堆栈溢出一般是由什么原因导致的？"><a href="#堆栈溢出一般是由什么原因导致的？" class="headerlink" title="堆栈溢出一般是由什么原因导致的？"></a>堆栈溢出一般是由什么原因导致的？</h2><ol>
<li>没有回收垃圾资源</li>
<li>层次太深的递归调用</li>
</ol>
<h2 id="写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。"><a href="#写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。" class="headerlink" title="写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。"></a>写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。</h2><p><code>#define MIN(A,B) ((A) &lt;= (B) ？ (A) : (B))</code></p>
<h2 id="不能做switch-的参数类型是？"><a href="#不能做switch-的参数类型是？" class="headerlink" title="不能做switch()的参数类型是？"></a>不能做switch()的参数类型是？</h2><p>C/C++中：<br>支持byte,char,short,int,long,bool,整数bai类型和du枚举类型。<br>不支持float，double，string</p>
<h2 id="什么函数不能声明为虚函数："><a href="#什么函数不能声明为虚函数：" class="headerlink" title="什么函数不能声明为虚函数："></a>什么函数不能声明为虚函数：</h2><p>一个类中将所有的成员函数都尽可能地设置为虚函数总是有益的。<br>设置虚函数须注意：<br>1：只有类的成员函数才能说明为虚函数；<br>2：静态成员函数不能是虚函数；<br>3：内联函数不能为虚函数；<br>4：构造函数不能是虚函数；<br>5：析构函数可以是虚函数，而且通常声明为虚函数。</p>
<p>写inline virtual void f(),不能保证函数f()一定是内联的，只能保证f()是虚函数（从而保证此函数一定不是内联函数）</p>
<h2 id="static-全局变量、局部变量、函数与普通全局变量、局部变量、函数有什么区别？static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"><a href="#static-全局变量、局部变量、函数与普通全局变量、局部变量、函数有什么区别？static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？" class="headerlink" title="static 全局变量、局部变量、函数与普通全局变量、局部变量、函数有什么区别？static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"></a>static 全局变量、局部变量、函数与普通全局变量、局部变量、函数有什么区别？static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？</h2><p>全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。<br>这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>
<p>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。</p>
<p>static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件</p>
<p>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;</p>
<p>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；</p>
<p>static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p>
<p>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。 </p>
<h2 id="volatile的含义"><a href="#volatile的含义" class="headerlink" title="volatile的含义"></a>volatile的含义</h2><p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>C++中零碎知识点拾遗</title>
    <url>/2020/07/22/C-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>STL(标准模板库)，是目前C++内置支持的library。它的底层利用了C++类模板和函数模板的机制，由三大部分组成：容器、算法和迭代器。<br><a id="more"></a></p>
<p>目前STL有六大组件:</p>
<ul>
<li>容器 container</li>
<li>算法 algorthm</li>
<li>迭代器 iterator</li>
<li>仿函数 function object</li>
<li>适配器 adaptor</li>
<li>空间配置器 allocator</li>
</ul>
<h1 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h1><ol>
<li>覆盖</li>
</ol>
<p>覆盖是指子类重新定义父类的虚函数的做法。</p>
<ol>
<li>重载</li>
</ol>
<p>重载是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</p>
<h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><p>SOLID原则</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>简称</th>
<th>英文名</th>
<th>中文名</th>
</tr>
</thead>
<tbody>
<tr>
<td>SRP</td>
<td>The Single Responsibility Principle</td>
<td>单一职责原则</td>
</tr>
<tr>
<td>OCP</td>
<td>The Open Closed Principle</td>
<td>开放封闭原则</td>
</tr>
<tr>
<td>LSP</td>
<td>The Liskov Substitution Principle</td>
<td>里氏替换原则</td>
</tr>
<tr>
<td>ISP</td>
<td>The Interface Segregation Principle</td>
<td>接口分离原则</td>
</tr>
<tr>
<td>DIP</td>
<td>The Dependency Inversion Principle</td>
<td>一来导致原则</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>S:单一责任原则。就一个类而言,应该仅有一个引起它变化的原因,如果你能想到多于一个的动机去改变一个类,那么这个类就具有多于一个的职责.应该把多于的指责分离出去,分别再创建一些类来完成每一个职责。注重的是职责，主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节。</li>
<li>O:开闭原则。一个软件实体应当对扩展开放,对修改关闭.说的是,再设计一个模块的时候,应当使这个模块可以在不被修改的前提下被扩展.换言之,应当可以在不必修改源代码的情况下改变这个模块的行为，在保持系统一定稳定性的基础上，对系统进行扩展。这是面向对象设计（OOD）的基石，也是最重要的原则。对新增开放，对修改关闭。主要是用多态性，面向接口面层。</li>
<li>L:里氏替换原则。 换言之,一个软件实体如果使用的是一个基类的话,那么一定适用于其子类,而且它根本不能察觉出基类对象和子类对象的区别.只有衍生类可以替换基类，软件单位的功能才能不受影响，基类才能真正被复用，而衍生类也能够在基类的基础上增加新功能。反过来的代换不成立。父类可用的情况下，子类也可以使用。也就是说子类条件更严格。</li>
<li>I:接口分离原则。一个类对另外一个类的依赖是建立在最小的接口上。使用多个专门的接口比使用单一的总接口要好.根据客户需要的不同,而为不同的客户端提供不同的服务是一种应当得到鼓励的做法.就像”看人下菜碟”一样,要看客人是谁,再提供不同档次的饭菜。注重对接口依赖的隔离，主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</li>
<li>D:依赖倒置原则。抽象不应当依赖于细节,细节应当依赖于抽象。高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象，主要是面向接口编程而非面向实现编程。</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li>创建型模式（Creational Patterns）用于构建对象，以便它们可以从实现系统中分离出来。</li>
<li>结构型模式（Structural Patterns）用于在许多不同的对象之间形成大型对象结构。</li>
<li>行为型模式（Behavioral Patterns）用于管理对象之间的算法、关系和职责。</li>
</ul>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><ul>
<li><a href="http://blog.csdn.net/liang19890820/article/details/61615495" target="_blank" rel="noopener">单例模式</a>（Singleton Pattern）<br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/70653800" target="_blank" rel="noopener">抽象工厂模式</a> （Abstract Factory Pattern）<br>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/66968761" target="_blank" rel="noopener">建造者模式</a>（Builder Pattern）<br>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/70652858" target="_blank" rel="noopener">工厂方法模式</a> （Factory Method Pattern）<br>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/66969965" target="_blank" rel="noopener">原型模式</a>（Prototype Pattern）<br>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><ul>
<li><a href="http://blog.csdn.net/liang19890820/article/details/66973296" target="_blank" rel="noopener">适配器模式</a>（Adapter Pattern）<br>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/79501177" target="_blank" rel="noopener">桥接模式</a>（Bridge Pattern）<br>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/66973836" target="_blank" rel="noopener">装饰者模式</a>（Decorator Pattern）<br>动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/71240662" target="_blank" rel="noopener">组合模式</a>（Composite Pattern）<br>将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/70850367" target="_blank" rel="noopener">外观模式</a>（Facade Pattern）<br>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/79629690" target="_blank" rel="noopener">享元模式</a>（Flyweight Pattern）<br>运用共享技术有效地支持大量细粒度的对象。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/78533179" target="_blank" rel="noopener">代理模式</a>（Proxy Pattern）<br>为其他对象提供一个代理以控制对这个对象的访问。</li>
</ul>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><ul>
<li><a href="http://blog.csdn.net/liang19890820/article/details/79403900" target="_blank" rel="noopener">模版方法模式</a> （Template Method Pattern）<br>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/62060457" target="_blank" rel="noopener">命令模式</a>（Command Pattern）<br>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</li>
<li>迭代器模式（Iterator Pattern）<br>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/61925314" target="_blank" rel="noopener">观察者模式</a>（Observer Pattern）<br>定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/79242388" target="_blank" rel="noopener">中介者模式</a>（Mediator Pattern）<br>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/79292435" target="_blank" rel="noopener">备忘录模式</a> （Memento Pattern）<br>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</li>
<li>解释器模式（Interpreter Pattern）<br>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/78647519" target="_blank" rel="noopener">状态模式</a>（State Pattern）<br>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/79242297" target="_blank" rel="noopener">策略模式</a>（Strategy Pattern）<br>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户端。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/79077715" target="_blank" rel="noopener">职责链模式</a> （Chain of Responsibility Pattern）<br>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/79364406" target="_blank" rel="noopener">访问者模式</a> （Visitor Pattern）<br>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li>
</ul>
<h1 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h1><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；</p>
<p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</p>
<p>如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</p>
<p>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</p>
<h1 id="智能指针的用法"><a href="#智能指针的用法" class="headerlink" title="智能指针的用法"></a>智能指针的用法</h1><ul>
<li>使用std::unique_ptr时，你不打算持有到同一对象的多个引用。例如，将其用作指向内存的指针，该内存在进入某些范围时被分配，而在退出范围时被取消分配。指针在一个确定的范围存在。</li>
<li>使用std::shared_ptr当你想从多个地方是指你的对象-并且不希望你的对象是去分配，直到所有这些提法本身就没了。</li>
<li>std::weak_ptr当您确实想从多个位置引用对象时，请使用-对于可以忽略和取消分配的引用（因此，当您尝试取消引用时，它们只会指出对象已消失）。避免循环引用。</li>
</ul>
<p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。</p>
<p>weak_ptr的使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : a(<span class="number">3</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Destructor..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sp(<span class="keyword">new</span> A());</span><br><span class="line">    weak_ptr&lt;A&gt; wp(sp);</span><br><span class="line">    <span class="comment">//sp.reset();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shared_ptr</span>&lt;A&gt; pa = wp.lock())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pa-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"wp指向对象为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Owner</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Owner&gt; other;</span><br><span class="line">    ~Owner()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"destroyed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Owner&gt; p1 (<span class="keyword">new</span> Owner());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Owner&gt; p2 (<span class="keyword">new</span> Owner());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p1:"</span>&lt;&lt;p1&lt;&lt;<span class="string">" p2:"</span>&lt;&lt;p2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    p1-&gt;other = p2; <span class="comment">// p1 references p2</span></span><br><span class="line">    p2-&gt;other = p1; <span class="comment">// p2 references p1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的循环引用，在程序结束时，无法正确析构对象。<br>如果采用weak_ptr则可以析构。</p>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><p>深拷贝指的是将对象的值保存。<br>浅拷贝副本的某些成员可能引用与原始对象相同的对象。</p>
<p>浅拷贝：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *pi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X()</span><br><span class="line">        : pi(<span class="keyword">new</span> <span class="keyword">int</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    X(<span class="keyword">const</span> X&amp; copy)   <span class="comment">// &lt;-- copy ctor</span></span><br><span class="line">        : i(copy.i), pi(copy.pi)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>深拷贝：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *pi;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X()</span><br><span class="line">        : pi(<span class="keyword">new</span> <span class="keyword">int</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    X(<span class="keyword">const</span> X&amp; copy)   <span class="comment">// &lt;-- copy ctor</span></span><br><span class="line">        : i(copy.i), pi(<span class="keyword">new</span> <span class="keyword">int</span>(*copy.pi))  <span class="comment">// &lt;-- note this line in particular!</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>COMSOL复合材料模拟</title>
    <url>/2020/08/16/COMSOL%E5%A4%8D%E5%90%88%E6%9D%90%E6%96%99%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>参考链接：<a href="https://cn.comsol.com/model/micromechanics-and-stress-analysis-of-a-composite-cylinder-67001" target="_blank" rel="noopener">https://cn.comsol.com/model/micromechanics-and-stress-analysis-of-a-composite-cylinder-67001</a><br><a id="more"></a></p>
<h1 id="COMSOL复合材料模拟"><a href="#COMSOL复合材料模拟" class="headerlink" title="COMSOL复合材料模拟"></a>COMSOL复合材料模拟</h1><p>纤维复合材料通常为薄层材料，纤维在层中呈单一取向。</p>
<p>薄层使用两种方法模拟：Layerwise (LW) theory，Equivalent Single Layer (ESL)<br>theory</p>
<h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><p>对符合材料的分析内容包含以下几个部分：</p>
<ul>
<li>微机械分析</li>
<li>使用LW理论进行应力分析</li>
<li>使用ESL理论进行应力分析</li>
</ul>
<h3 id="微机械分析"><a href="#微机械分析" class="headerlink" title="微机械分析"></a>微机械分析</h3><p>假设复合材料由碳纤维单向排列在环氧树脂基体中。碳纤维占据了60%的体积。</p>
<p><img src="cube.jpg" alt=""></p>
<h4 id="材料属性"><a href="#材料属性" class="headerlink" title="材料属性"></a>材料属性</h4><p>碳纤维T300假设为横观各向同性（正交）；环氧树脂假设为各向同性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>材料性能</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>$E_1,E_2,E_3$ </td>
<td>{230,15,15}GPa</td>
</tr>
<tr>
<td>$G_{12},G_{23},G_{13}$ </td>
<td>{15,7,15}GPa</td>
</tr>
<tr>
<td>$\upsilon_{12}.\upsilon_{23},\upsilon_{13}$</td>
<td>{0.2,0.07,0.2}</td>
</tr>
<tr>
<td>$rho$</td>
<td>1800$kg/m^3$</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>材料性能</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>4GPa</td>
</tr>
<tr>
<td>$\upsilon$</td>
<td>0.35</td>
</tr>
<tr>
<td>$\rho$</td>
<td>1100$kg/m^3$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="cell周期性"><a href="#cell周期性" class="headerlink" title="cell周期性"></a>cell周期性</h4><p>使用cell periodicity节点应用周期性边界条件。</p>
<h3 id="基于LW理论的应力分析"><a href="#基于LW理论的应力分析" class="headerlink" title="基于LW理论的应力分析"></a>基于LW理论的应力分析</h3><h4 id="LW理论"><a href="#LW理论" class="headerlink" title="LW理论"></a>LW理论</h4><p>LW理论考虑了表面以及厚度方向的位移自由度。从本构方程角度看，类似于三维固体。适用于厚板。</p>
<h4 id="几何和边界条件"><a href="#几何和边界条件" class="headerlink" title="几何和边界条件"></a>几何和边界条件</h4><p><b>几何</b></p>
<p>长0.5m,半径0.1m的圆柱</p>
<p><b>边界条件</b></p>
<ul>
<li>圆柱体的一端固定</li>
<li>另一端有滚柱支撑</li>
<li>1kN的力施加在1/4外表面</li>
</ul>
<p><img src="cylinder.jpg" alt=""></p>
<p><b>堆叠顺序和材料属性</b></p>
<p>材料由5层1mm厚的层组成。不同层纤维取向不同，0，45，90，-45，0</p>
<h3 id="ESL理论进行应力分析"><a href="#ESL理论进行应力分析" class="headerlink" title="ESL理论进行应力分析"></a>ESL理论进行应力分析</h3><p>ESL理论中考虑了薄层中面的位移和旋转自由度（类似与3D壳单元），因此计算量比LW理论要小得多。适用于薄板、中厚板。</p>
<h2 id="建模过程"><a href="#建模过程" class="headerlink" title="建模过程"></a>建模过程</h2><blockquote>
<p>选择周期性边界条件后，在周期性边界的右上角可以自动创建研究和材料。</p>
</blockquote>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>COMSOL</tag>
        <tag>复合材料</tag>
      </tags>
  </entry>
  <entry>
    <title>COMSOL学习笔记(多物理场基础)</title>
    <url>/2020/08/04/COMSOL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h2><a id="more"></a>
<h3 id="映射网格"><a href="#映射网格" class="headerlink" title="映射网格"></a>映射网格</h3><p>要求相对规则的几何。可以通过边组参数设置对应的边组。</p>
<h3 id="虚拟操作"><a href="#虚拟操作" class="headerlink" title="虚拟操作"></a>虚拟操作</h3><p>不改变几何的情况下，忽略一些结构</p>
<h2 id="求解器"><a href="#求解器" class="headerlink" title="求解器"></a>求解器</h2><h3 id="直接求解vs迭代求解"><a href="#直接求解vs迭代求解" class="headerlink" title="直接求解vs迭代求解"></a>直接求解vs迭代求解</h3><h4 id="直接求解"><a href="#直接求解" class="headerlink" title="直接求解"></a>直接求解</h4><ul>
<li>相当于求逆矩阵<ul>
<li>LU分解</li>
</ul>
</li>
<li>直接求解<ul>
<li>MUMPS：稳定性高，占用内存大</li>
<li>PARDISO：稳定性一般，占用内存小</li>
<li>SPOOLES：稳定性高，占用内存小，计算慢<h4 id="迭代求解"><a href="#迭代求解" class="headerlink" title="迭代求解"></a>迭代求解</h4></li>
</ul>
</li>
<li>依靠良好的预处理器<ul>
<li>不完全LU</li>
<li>稀疏近似逆</li>
<li>多重格点</li>
</ul>
</li>
<li>高效，计算量小</li>
<li>需要控制终止条件，对多物理场需要手动调整。</li>
</ul>
<h3 id="全耦合vs分离"><a href="#全耦合vs分离" class="headerlink" title="全耦合vs分离"></a>全耦合vs分离</h3><h4 id="全耦合"><a href="#全耦合" class="headerlink" title="全耦合"></a>全耦合</h4><ul>
<li>单矩阵<ul>
<li>内存消耗大</li>
<li>更多CPU装配时间</li>
<li>更复杂的结构</li>
</ul>
</li>
<li>单线性求解器</li>
<li>牛顿法</li>
</ul>
<h4 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h4><ul>
<li>多个矩阵</li>
<li>多个单个线性求解器</li>
<li>需要迭代<ul>
<li>耦合越强，迭代越多</li>
<li>Anderson加速</li>
</ul>
</li>
<li>初始值猜测是阶段性的。</li>
</ul>
<h3 id="稳态日志"><a href="#稳态日志" class="headerlink" title="稳态日志"></a>稳态日志</h3><ul>
<li>SolEst：基于误差估计的解</li>
<li>ResEst：基于误差估计的残差</li>
<li><code>#Res</code>：残差装配数</li>
<li><code>#Jac</code>：Jacobian装配</li>
<li><code>#Sol</code>：线性代数系统解的数量</li>
<li>Linlt：线性迭代数</li>
<li>LinErr：线性代数系统误差估计</li>
<li>LinRes：线性代数系统残差</li>
</ul>
<h3 id="时间步的日志"><a href="#时间步的日志" class="headerlink" title="时间步的日志"></a>时间步的日志</h3><p>步：n，时间$t_n$,步长：$k_n$,阶数：p</p>
<ul>
<li>Tfail：自适应步长的失败次数</li>
<li>NLfail：代数方程组的失败次数</li>
</ul>
<h3 id="稳态和瞬态问题"><a href="#稳态和瞬态问题" class="headerlink" title="稳态和瞬态问题"></a>稳态和瞬态问题</h3><ul>
<li>从单物理场开始；如果可能先考虑线性</li>
<li>逐渐引入非线性<ul>
<li>使用负载逐步增加，非线性逐步增加，稳态逐步化等。</li>
</ul>
</li>
<li>避免不连续数据<ul>
<li>使用平滑近似</li>
</ul>
</li>
<li>当增加多物理场时：<ul>
<li>从（物理场）自动生成的求解配置开始</li>
<li>从自动生成的网格开始</li>
<li>逐步增强耦合</li>
</ul>
</li>
</ul>
<h3 id="参数化扫描"><a href="#参数化扫描" class="headerlink" title="参数化扫描"></a>参数化扫描</h3><p>在稳态/瞬态选项卡中添加的扫描可以调用上一步结果进行迭代计算。</p>
<p>在研究中添加的结果每次从头计算。</p>
<h3 id="线性求解器：技巧"><a href="#线性求解器：技巧" class="headerlink" title="线性求解器：技巧"></a>线性求解器：技巧</h3><h4 id="如果直接求解器报错或警告"><a href="#如果直接求解器报错或警告" class="headerlink" title="如果直接求解器报错或警告"></a>如果直接求解器报错或警告</h4><ul>
<li>换一个主元预阈值</li>
<li>换一种预排序方法</li>
<li>换一个直接求解器<h4 id="如果迭代求解器不收敛或报错“未定义值”"><a href="#如果迭代求解器不收敛或报错“未定义值”" class="headerlink" title="如果迭代求解器不收敛或报错“未定义值”"></a>如果迭代求解器不收敛或报错“未定义值”</h4></li>
<li>查看正在使用的物理场预置求解器。</li>
<li>但别局限于迭代/预调节器设置，问题更可能发生在：<ul>
<li>太不稳定 -&gt; 非标准矩阵</li>
<li>网格质量较差 -&gt; 非标准矩阵</li>
<li>强材料非线性 -&gt; 非标准矩阵</li>
<li>非物理非线性迭代 -&gt; 非标准矩阵</li>
</ul>
</li>
</ul>
<h3 id="非线性求解器技巧"><a href="#非线性求解器技巧" class="headerlink" title="非线性求解器技巧"></a>非线性求解器技巧</h3><ul>
<li>使用更小的阻尼因子<ul>
<li>会导致更多的迭代</li>
</ul>
</li>
<li>减小“恢复阻尼因子”</li>
<li>每次迭代更新Jacobian<ul>
<li>资源消耗更大</li>
</ul>
</li>
<li>允许更多迭代步</li>
<li>改进初始猜测值（稳态）</li>
</ul>
<h3 id="时间步"><a href="#时间步" class="headerlink" title="时间步"></a>时间步</h3><p>研究中的时间步是输出的时间步长。</p>
<p>求解器中的时间步长是计算的时间步长。</p>
<h3 id="瞬态研究：时间步进选择"><a href="#瞬态研究：时间步进选择" class="headerlink" title="瞬态研究：时间步进选择"></a>瞬态研究：时间步进选择</h3><div class="table-container">
<table>
<thead>
<tr>
<th>时间步</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>自由</td>
<td>基于局部误差估计的自适应时间步长。\n如果非线性回路不收敛就减小，如果误差估计不满秩就减小</td>
</tr>
<tr>
<td>严格</td>
<td>和自由相同，但求解输入时间点。</td>
</tr>
<tr>
<td>中级</td>
<td>和自由相同，至少在每个输入时间步上计算。</td>
</tr>
<tr>
<td>手动</td>
<td>基于全局表达式或基于值列表进行用户控制</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Ctrl+F5查看变量位置</p>
</blockquote>
<h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><h3 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h3><p>标注某个点的变量信息，在绘图组中添加标注，在标注—&gt;文本下输入<code>eval(expr,unit)</code>来计算表达式。</p>
<h3 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h3><p>在组件—&gt;定义中添加定义值，然后在研究中，更新解。显示时，在标注文本中<code>eval(maxop1(spf.U),unit)</code>，位置设定为<code>maxop1(spf.U,x)</code>等</p>
<h3 id="数据集操作"><a href="#数据集操作" class="headerlink" title="数据集操作"></a>数据集操作</h3><ul>
<li>降维截取数据集</li>
<li>升维生成数据集</li>
<li>合并：对两个结果进行和差商积等操作</li>
</ul>
<h3 id="派生值"><a href="#派生值" class="headerlink" title="派生值"></a>派生值</h3><ul>
<li>可设置计算组</li>
<li>点计算、全局计算</li>
<li>平均值、最大、最小、积分、其他</li>
</ul>
<blockquote>
<p>派生值中的最大值等只能用于后处理</p>
<p>组件-》定义中的最大值可用于模型参数设定。</p>
<p>快捷键</p>
<p><strong>F1</strong>：当前节点的帮助文档。</p>
<p><strong>Ctrl+F1</strong>：整体帮助文档。</p>
</blockquote>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>COMSOL</tag>
        <tag>多物理场</tag>
      </tags>
  </entry>
  <entry>
    <title>COMSOL学习笔记（传热）</title>
    <url>/2020/08/06/COMSOL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BC%A0%E7%83%AD%EF%BC%89/</url>
    <content><![CDATA[<p>COMSOL传热多物理场<br><a id="more"></a></p>
<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="能量守恒（广义传热方程）"><a href="#能量守恒（广义传热方程）" class="headerlink" title="能量守恒（广义传热方程）"></a>能量守恒（广义传热方程）</h3><script type="math/tex; mode=display">\rho C_p \frac{\partial T}{\partial t}+\nabla\cdot(-k\nabla T)=Q-\rho C_p u\cdot\nabla T+\tau :S+\frac{T}{\rho}(\frac{\partial\rho}{\partial T})_p (\frac{\partial p_a}{\partial t}+u\cdot\nabla p_a)</script><blockquote>
<p>ctrl + / 变量输入提示</p>
</blockquote>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>COMSOL</tag>
        <tag>传热</tag>
      </tags>
  </entry>
  <entry>
    <title>COMSOL学习笔记（结构力学）</title>
    <url>/2020/08/06/COMSOL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BB%93%E6%9E%84%E5%8A%9B%E5%AD%A6%EF%BC%89/</url>
    <content><![CDATA[<p>教程地址：<a href="https://www.bilibili.com/video/BV1R7411u7cP?p=55" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1R7411u7cP?p=55</a></p>
<p>课件地址：<a href="https://github.com/sjtu-xx/COMSOL-" target="_blank" rel="noopener">https://github.com/sjtu-xx/COMSOL-</a><br><a id="more"></a></p>
<h3 id="模态分析"><a href="#模态分析" class="headerlink" title="模态分析"></a>模态分析</h3><p>在进行模态分析时，如果直接添加研究-&gt;特征频率，则会忽略载荷的影响。</p>
<p>如果需要考虑载荷的影响，需要进行研究-&gt;特征频率、预应力。（实际上是先计算包含应力的稳态，然后将结果进行特征频率分析，分析时勾选几何非线性。）</p>
<blockquote>
<p>特征频率的分析对结果进行了归一化，所以结果中的变形并不是真实的变形。</p>
<ul>
<li>每一个特征值下的变形幅度经过缩放。</li>
<li>不同特征值之间的变形幅度不能进行比较。</li>
<li>只能看振型，而不能当作真实形变。</li>
</ul>
</blockquote>
<h3 id="屈曲分析"><a href="#屈曲分析" class="headerlink" title="屈曲分析"></a>屈曲分析</h3><p>主要用于研究结构在特定载荷下的稳定性以及确定结构失稳的临界载荷。</p>
<h4 id="线性屈曲"><a href="#线性屈曲" class="headerlink" title="线性屈曲"></a>线性屈曲</h4><p>是以小位移小应变的线弹性理论为基础的。分析中不考虑结构在受载变形过程中结构构型的变化，也就是在外力施加的各个阶段，总是在结构初始构型上建立平衡方程。</p>
<h4 id="非线性屈曲"><a href="#非线性屈曲" class="headerlink" title="非线性屈曲"></a>非线性屈曲</h4><p>几何非线性失稳分析</p>
<p>弹塑性失稳分析</p>
<p>非线性后屈曲分析</p>
<blockquote>
<p>一致对：</p>
<p>​        两个表面位移等连续</p>
<p>接触对：</p>
<p>​        两个表面位移不一定连续</p>
<p>弹簧基础是相对地面的，对于结构之间的连接不能使用弹簧基础。</p>
</blockquote>
<h3 id="对称结构"><a href="#对称结构" class="headerlink" title="对称结构"></a>对称结构</h3><p>使用对称边界条件，不但要求几何对称，还要求载荷，约束以及解也对称。</p>
<p>使用镜像数据集绘制完成的3D几何下的解。</p>
<h3 id="板壳理论"><a href="#板壳理论" class="headerlink" title="板壳理论"></a>板壳理论</h3><h4 id="薄板：（Kirchhoff-love假设）"><a href="#薄板：（Kirchhoff-love假设）" class="headerlink" title="薄板：（Kirchhoff-love假设）"></a>薄板：（Kirchhoff-love假设）</h4><p>• 平行于板中面的各层互不挤压。<br>• 直法线假定:忽略剪应力和所引起的剪切变形，且认为板弯曲时沿板厚方向各点的挠度相等。<br>• 中面内各点都无平行于中面的位移。</p>
<h4 id="中厚板（comsol板接口）"><a href="#中厚板（comsol板接口）" class="headerlink" title="中厚板（comsol板接口）"></a>中厚板（comsol板接口）</h4><p>• Reissner<br>不再采用直法线假定，而是采用直线假定，板内各点的挠度不等于中面挠度。</p>
<h4 id="厚壳"><a href="#厚壳" class="headerlink" title="厚壳"></a>厚壳</h4><p>Mindlin-Reissner理论<br>将Reissner理论推广到壳</p>
<h3 id="梁接口"><a href="#梁接口" class="headerlink" title="梁接口"></a>梁接口</h3><h4 id="Euler-Bernouli梁"><a href="#Euler-Bernouli梁" class="headerlink" title="Euler-Bernouli梁"></a>Euler-Bernouli梁</h4><ul>
<li>变形前垂直梁中心线的界面，变形后仍为平面</li>
<li>变形后横截面与变形后的轴线相垂直</li>
</ul>
<h4 id="Timoshenko梁"><a href="#Timoshenko梁" class="headerlink" title="Timoshenko梁"></a>Timoshenko梁</h4><ul>
<li>变形前垂直梁中心线的界面，变形后仍为平面。</li>
<li>考虑横向剪切变形影响的情况，原来垂直于中心线的截面变形后不再与中心线垂直。</li>
</ul>
<h3 id="复合材料模拟"><a href="#复合材料模拟" class="headerlink" title="复合材料模拟"></a>复合材料模拟</h3><p><a href="https://cn.comsol.com/model/micromechanics-and-stress-analysis-of-a-composite-cylinder-67001" target="_blank" rel="noopener">https://cn.comsol.com/model/micromechanics-and-stress-analysis-of-a-composite-cylinder-67001</a></p>
<h4 id="等效单层理论（ESL）"><a href="#等效单层理论（ESL）" class="headerlink" title="等效单层理论（ESL）"></a>等效单层理论（ESL）</h4><p>将整个层和结构按均匀材料属性计算，并只在中面求解。用于薄层</p>
<h4 id="分层理论（LW）"><a href="#分层理论（LW）" class="headerlink" title="分层理论（LW）"></a>分层理论（LW）</h4><p>具备沿厚度方向求解并可用于包含层分离区域的较厚层和结构。用于稍厚的层。</p>
<h2 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h2><h3 id="几何非线性"><a href="#几何非线性" class="headerlink" title="几何非线性"></a>几何非线性</h3><ul>
<li>大变形需要在研究中开启几何非线性。</li>
<li>有限旋转需要在研究中开启几何非线性。</li>
<li>后屈曲分析。</li>
</ul>
<p>几何非线性的应变项包含了高阶位移项，因此相比于不适用几何非线性的应变小。看上去像是强化了一样，可以看做是应力强化。</p>
<p>对于无穷小旋转，$sin\theta$被近似为$\theta$。对于有限旋转，$sin\theta$不能被近似。</p>
<h3 id="材料非线性"><a href="#材料非线性" class="headerlink" title="材料非线性"></a>材料非线性</h3><ul>
<li>塑形、超弹性、粘弹性、蠕变</li>
</ul>
<h3 id="蠕变"><a href="#蠕变" class="headerlink" title="蠕变"></a>蠕变</h3><p>对于时间依赖的本构，要勾选计算耗散能。</p>
<h3 id="接触问题"><a href="#接触问题" class="headerlink" title="接触问题"></a>接触问题</h3><blockquote>
<p>源面和目标面（与abaqus中的主面和从面类似）<br>源面选择较硬的面，如果硬度相同，选择凹边界为源。<br>目标边界需要更精细的网格</p>
</blockquote>
<p>罚函数法速度快，容易收敛。但计算没有增广拉格朗日法精确。</p>
<blockquote>
<p>变量缩放<br>需要在研究-&gt;场变量中调整缩放因子，使得结果大致处于相同的量级，提高收敛性。</p>
</blockquote>
<p>收敛性：</p>
<ul>
<li>时间步进：向后差分格式</li>
<li>求解器采用的步长：精确</li>
<li>因变量：接触压力的缩放因子</li>
</ul>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>COMSOL</tag>
        <tag>结构力学</tag>
      </tags>
  </entry>
  <entry>
    <title>COMSOL疲劳</title>
    <url>/2020/07/31/COMSOL%E7%96%B2%E5%8A%B3/</url>
    <content><![CDATA[<h1 id="COMSOL仿真"><a href="#COMSOL仿真" class="headerlink" title="COMSOL仿真"></a>COMSOL仿真</h1><a id="more"></a>
<h2 id="COMSOL-Multiphysics"><a href="#COMSOL-Multiphysics" class="headerlink" title="COMSOL Multiphysics"></a>COMSOL Multiphysics</h2><h2 id="结构疲劳与损伤仿真"><a href="#结构疲劳与损伤仿真" class="headerlink" title="结构疲劳与损伤仿真"></a>结构疲劳与损伤仿真</h2><p>视频地址：<a href="https://cn.comsol.com/video/simulation-of-structural-fatigue-and-damage-webinar-cn" target="_blank" rel="noopener">https://cn.comsol.com/video/simulation-of-structural-fatigue-and-damage-webinar-cn</a></p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><p>S-N曲线</p>
<p>环境、表面粗糙度、残余应力等都会影响材料的疲劳寿命</p>
</li>
<li><p>$R=\frac{\sigma<em>{min}}{\sigma</em>{max}}$ </p>
<p>R=-1: 对称循环</p>
<p>R=0：脉冲测试</p>
</li>
<li><p>分类</p>
<ul>
<li>高周疲劳：弹性变形、应力范围控制</li>
<li>低周疲劳（几千次）：塑性变形、应变范围控制</li>
</ul>
</li>
<li><p>裂纹</p>
<ul>
<li>疲劳裂纹通常出现在表面</li>
<li>接触分析时通常出现在内部。</li>
</ul>
</li>
</ul>
<h3 id="仿真方法"><a href="#仿真方法" class="headerlink" title="仿真方法"></a>仿真方法</h3><p>单个载荷周期的结果—-》疲劳后处理</p>
<h3 id="疲劳模型"><a href="#疲劳模型" class="headerlink" title="疲劳模型"></a>疲劳模型</h3><p><strong>应力寿命</strong></p>
<p><img src="1.png" alt=""></p>
<p><strong>应变寿命</strong> 常用于低周疲劳</p>
<p><img src="2.png" alt=""></p>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>COMSOL</tag>
        <tag>疲劳</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA基础</title>
    <url>/2020/09/06/CUDA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h1><a id="more"></a>
<h2 id="并行编程模型"><a href="#并行编程模型" class="headerlink" title="并行编程模型"></a>并行编程模型</h2><ul>
<li>共享存储模型</li>
<li>线程模型</li>
<li>消息传递模型</li>
<li>数据并行模型</li>
</ul>
<p>具体实例：OpenMP、MPI、Single Program Multiple Data（SPMD）、MPMD</p>
<h2 id="设计并行处理程序和系统"><a href="#设计并行处理程序和系统" class="headerlink" title="设计并行处理程序和系统"></a>设计并行处理程序和系统</h2><ul>
<li>自动和手动并行</li>
<li>理解问题和程序</li>
<li>分块分割</li>
<li>通讯</li>
<li>同步</li>
<li>数据依赖</li>
</ul>
<blockquote>
<p>指令流水线：取指，译码，执行，访存，写回。</p>
</blockquote>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p>FLOPS:floating-point operations per second<br>GPU: graphic processing unit</p>
<p>GPU是异构、众核、处理器，针对吞吐优化。</p>
<p>高效GPU任务具备的条件：</p>
<ul>
<li>具有成千上万的独立工作<ul>
<li>尽量利用大量的ALU单元</li>
<li>大量的片元切换掩藏延迟</li>
</ul>
</li>
<li>可以共享指令流<ul>
<li>适用于SIMD处理</li>
</ul>
</li>
<li>最好是计算密集的任务<ul>
<li>通信和计算开销比例合适</li>
<li>不要受制于访存带宽</li>
</ul>
</li>
</ul>
<p>CPU-GPU交互</p>
<ul>
<li>GPU、CPU拥有各自的内存空间。</li>
<li>通过PCIE总线互连（8～16GHz）。</li>
<li>交互开销大。</li>
</ul>
<h2 id="CUDA编程概念"><a href="#CUDA编程概念" class="headerlink" title="CUDA编程概念"></a>CUDA编程概念</h2><p>Thread，block，grid是CUDA编程上的概念，为了方便程序员软件设计，组织线程。</p>
<ul>
<li>thread：一个CUDA的并行程序会被以许多个threads来执行。</li>
<li>block：数个threads会被群组成一个block，同一个block中的threads可以同步，也可以通过shared memory通信。</li>
<li>grid：多个blocks则会再构成grid。</li>
</ul>
<p>软硬件对应关系：<br>thread: thread processor<br>block: SM（streaming multiprocessor） 共享内存shared memory<br>每个设备拥有global memory</p>
<h1 id="CUDA编程"><a href="#CUDA编程" class="headerlink" title="CUDA编程"></a>CUDA编程</h1><h2 id="CUDA术语"><a href="#CUDA术语" class="headerlink" title="CUDA术语"></a>CUDA术语</h2><p>Host主机端：通常指CPU，采用ANSI标准C语言编程</p>
<p>Device设备端：通常指GPU，采用扩ANSI标准扩展的C语言编程</p>
<p>Host和Device拥有各自的存储器。</p>
<p>CUDA编程包括Host和Device编码，</p>
<p>kernel：数据并行处理函数。</p>
<p>grid: 一维或多维线程块</p>
<p>block：多个线程（一二三维）。</p>
<ul>
<li>一个grid里面每个block中的线程数相同</li>
<li>block内部的每个线程可以：同步，访问共享存储器</li>
</ul>
<p>每个block对应在一个SM上</p>
<p>device代码段可以：</p>
<ul>
<li>读写每个线程的寄存器</li>
<li>读写每个线程的local memory</li>
<li>读写每个block的shared memory</li>
<li>读写每个grid的global memory</li>
<li>读每个grid的constant memory</li>
</ul>
<p>host代码段可以：</p>
<ul>
<li>读写每个grid的global memory和constant memory</li>
</ul>
<blockquote>
<p>global memory和constant memory都在GPU芯片中</p>
</blockquote>
<p>cudaMalloc() 在设备端分配global memory<br>cudaFree() 在设备端释放内存</p>
<p>cuda内存传输：host和device的内存传输</p>
<ul>
<li><code>cudaMemcpy(Md,M,size,cudaMemcpyHostToDevice)</code></li>
<li><code>cudaMemcpy(P,Pd,size,cudaMemcpyDeviceToHost)</code></li>
</ul>
<h2 id="cuda-矩阵乘法"><a href="#cuda-矩阵乘法" class="headerlink" title="cuda 矩阵乘法"></a>cuda 矩阵乘法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">MatrixMulkernel</span><span class="params">(<span class="keyword">float</span>* Md,<span class="keyword">float</span>* Nd,<span class="keyword">float</span>* Pd,<span class="keyword">int</span> Width)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tx= threadIdx.x;</span><br><span class="line">    <span class="keyword">int</span> ty= threadIdy.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> Pvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;<span class="built_in">width</span>;++k)&#123;</span><br><span class="line">        <span class="keyword">float</span> Mdelement = Md[ty * Md.<span class="built_in">width</span> +k];</span><br><span class="line">        <span class="keyword">float</span> Ndelement = Nd[k * Nd.<span class="built_in">width</span> + tx];</span><br><span class="line">        Pvalue += Mdelement * Ndelement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pd[ty * <span class="built_in">width</span> + tx] = Pvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixMulOnDevice</span><span class="params">(<span class="keyword">float</span>* M, <span class="keyword">float</span>* N, <span class="keyword">float</span>* P, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">width</span> * <span class="built_in">width</span> *<span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load M and N to device memory</span></span><br><span class="line">    cudaMalloc(Md,<span class="built_in">size</span>);</span><br><span class="line">    cudaMemcpy(Md,M,<span class="built_in">size</span>,cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMalloc(Nd,<span class="built_in">size</span>);</span><br><span class="line">    cudaMemcpy(Nd,N,<span class="built_in">size</span>,cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    cudaMalloc(Pd,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function">dim3 <span class="title">dimBlock</span><span class="params">(<span class="built_in">width</span>,<span class="built_in">width</span>)</span></span>; <span class="comment">// 1个block含width*width个线程</span></span><br><span class="line">    <span class="function">dim3 <span class="title">dimGrid</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    MatrixMulKernel&lt;&lt;&lt;dimGrid,dimBlock&gt;&gt;&gt;(Md,Nd,Pd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read p from device</span></span><br><span class="line">    cudaMemcpy(P,Pd,<span class="built_in">size</span>,cudaMemcpyDeviceToHost);</span><br><span class="line">    cudaFree(Md);</span><br><span class="line">    cudaFree(Nd);</span><br><span class="line">    cudaFree(Pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cuda函数声明"><a href="#cuda函数声明" class="headerlink" title="cuda函数声明"></a>cuda函数声明</h2><div class="table-container">
<table>
<thead>
<tr>
<th>声明</th>
<th>执行</th>
<th>调用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__global__ void KernelFunc()</code></td>
<td>设备端</td>
<td>主机端</td>
</tr>
<tr>
<td><code>__device__ float DeviceFunc()</code></td>
<td>设备端</td>
<td>设备端</td>
</tr>
<tr>
<td><code>__host__ float HostFunc()</code></td>
<td>主机端</td>
<td>主机端</td>
</tr>
</tbody>
</table>
</div>
<p><code>__global__</code>返回类型必须是void</p>
<blockquote>
<p>global和device函数</p>
<p>少用递归、不要用静态变量、少用malloc、小心通过指针实现函数调用</p>
</blockquote>
<p>向量数据类型</p>
<ul>
<li>通过<code>.x,.y,.z,.w</code>进行访问</li>
<li>部分函数列表</li>
</ul>
<p>常用的数学函数：<br>intrinsic function:<code>__</code>开头，损失一定精度，但速度大幅提高</p>
<p>线程同步：<br><code>__syncthreads();</code> 要求线程的执行时间尽量接近。只在一个块内部进行同步。</p>
<p>在if-else中使用同步可能死锁：不同的目的地。</p>
<p>Warp：一个block内部的一组线程</p>
<p>Warp中的线程切换是0开销的。</p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>local memory实际上存放在global memory当中。</p>
<p>shared memory可全速读写。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量声明</th>
<th>存储器</th>
<th>作用域</th>
<th>生命期</th>
</tr>
</thead>
<tbody>
<tr>
<td>单独的自动变量而不是数组</td>
<td>寄存器</td>
<td>thread</td>
<td>kernel</td>
</tr>
<tr>
<td>自动变量数组</td>
<td>local</td>
<td>thread</td>
<td>kernel</td>
</tr>
<tr>
<td><code>__shared__ int sharedVar&#39;</code></td>
<td>shared</td>
<td>block</td>
<td>kernel</td>
</tr>
<tr>
<td><code>__device__ int globalVar</code></td>
<td>global</td>
<td>grid</td>
<td>application</td>
</tr>
<tr>
<td><code>__constant__ int constantVar;</code></td>
<td>constant</td>
<td>grid</td>
<td>application</td>
</tr>
</tbody>
</table>
</div>
<p>global和constant变量</p>
<ul>
<li>host可以通过以下函数访问：<ul>
<li><code>cudaGetSymbolAddress()</code></li>
<li><code>cudaGetSymbolSize()</code></li>
<li><code>cudaMemcpyToSymbol()</code></li>
<li><code>cudaMemcpyFromSymbol()</code></li>
</ul>
</li>
<li>constants变量必须在函数外声明</li>
</ul>
<p>原子操作：<br><code>atomicAdd</code></p>
<h2 id="CUDA程序优化"><a href="#CUDA程序优化" class="headerlink" title="CUDA程序优化"></a>CUDA程序优化</h2><p>有效的数据并行算法+针对GPU架构特性的优化 = 优化的算法</p>
<h3 id="并行规约"><a href="#并行规约" class="headerlink" title="并行规约"></a>并行规约</h3><p>warp分割</p>
<p>Block被分割为32为单位的线程组，叫做warp。</p>
<p>warp是最基本的调度单元，warp一直执行相同的指令。</p>
<p>warp分割原则：threadIdx是连续增加的一组。</p>
<h3 id="访存合并"><a href="#访存合并" class="headerlink" title="访存合并"></a>访存合并</h3><h3 id="SM资源动态分割"><a href="#SM资源动态分割" class="headerlink" title="SM资源动态分割"></a>SM资源动态分割</h3><h3 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h3><ul>
<li>减少传输<ul>
<li>中间数据直接在GPU分配，操作，释放</li>
<li>有时更适合在GPU上进行重复计算</li>
<li>如果没有减少数据传输的话，将CPU代码移植到GPU可能无法提升性能。</li>
</ul>
</li>
<li>组团传输<ul>
<li>大块传输好于小块。</li>
</ul>
</li>
<li>内存传输与计算时间重叠。<ul>
<li>双缓存</li>
</ul>
</li>
</ul>
<p>避免每个线程访问连续的空间。相邻线程访问相邻的空间。</p>
<p>bank冲突：同一个周期对shared memory中同一个bank进行访问。</p>
<p>shared memory和registers一样快，如果没有bank冲突的话。</p>
<p>CUDA中的Texture内存。</p>
<p>优点：</p>
<ul>
<li>数据被缓存<ul>
<li>特别适用于无法合并访存的场合</li>
</ul>
</li>
<li>支持过滤</li>
<li>Wrap模式</li>
<li>一二三维寻址</li>
</ul>
<p><code># of blocks &gt; # of SM</code>尽可能保证每个SM至少有一个work group在执行</p>
<p>块大小必须是32的倍数。最小64，通常采用128or256。依赖于问题本身，需要实验确定。</p>
<p>隐藏延时：需要有足够多的线程来掩藏延时。</p>
<p>循环展开：<br>自动实现<code>#pragma unroll BLOCK_SIZE</code></p>
]]></content>
      <categories>
        <category>高性能计算</category>
      </categories>
  </entry>
  <entry>
    <title>Davinci教程</title>
    <url>/2020/02/25/Davinci%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>在家闲的无聊，随便学学，<a href="https://www.bilibili.com/video/av91200016/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">B站链接</a><br><strong>B站影视剧风达芬奇教程</strong><br><a id="more"></a></p>
<h1 id="软件初始设置"><a href="#软件初始设置" class="headerlink" title="软件初始设置"></a>软件初始设置</h1><p>偏好设置 -&gt; 用户 -&gt; 项目加载与保存 -&gt; 打开<strong>实时保存与项目备份</strong></p>
<h1 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h1><h2 id="素材导入"><a href="#素材导入" class="headerlink" title="素材导入"></a>素材导入</h2><p>在媒体中将素材分类导入到各个媒体文件夹中。</p>
<h2 id="快编和剪辑"><a href="#快编和剪辑" class="headerlink" title="快编和剪辑"></a>快编和剪辑</h2><p><strong>剪辑</strong><br>将视频拖拽到浏览窗口后，通过<code>I</code>和<code>O</code>键设置入口和出口，之后将截取的视频拖拽到时间线即可。</p>
<p><strong>添加特效</strong><br>在特效库中将效果拖拽到时间线对应的视频进行添加。<br>添加之后通过效果检查器面板设置参数</p>
<p><strong>快编</strong><br>快编适合粗剪</p>
<h2 id="Fusion"><a href="#Fusion" class="headerlink" title="Fusion"></a>Fusion</h2><p>不推荐使用其制作特效。特效推荐使用AE等。</p>
<h1 id="剪辑"><a href="#剪辑" class="headerlink" title="剪辑"></a>剪辑</h1><h2 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h2><p>设置缓存的目录：文件 -&gt; 项目设置 -&gt; 主设置 -&gt; 工作文件夹<br>设置帧率：文件 -&gt; 项目设置 -&gt; 主设置 -&gt; 时间线格式 -&gt; 时间线帧率/播放帧率(25)(因为国内交流电频率50Hz)</p>
<h2 id="资源导入"><a href="#资源导入" class="headerlink" title="资源导入"></a>资源导入</h2><p>先导入所有素材，然后文件夹分类</p>
<h2 id="视频剪辑"><a href="#视频剪辑" class="headerlink" title="视频剪辑"></a>视频剪辑</h2><p>设置出入点<code>I</code>和<code>O</code>键<br>拖入时间线时可以在浮动的框口中选择只导入画面或音频<br>创建时间线：建议创建时间线然后再进行拖拽<br>时间线操作：</p>
<ul>
<li>时间线缩放：alt+鼠标中键   或  ctrl+加号/减号</li>
</ul>
<p>图标功能：<br><img src="1.png" alt=""><br>修剪编辑模式：前后素材一起移动<br>动态修剪模式：不常用<br>切刀：快捷键B（command+B）<br>插入片段：在片段之间插入<br>覆盖片段：覆盖重合的部分<br>替换片段：替换对应的片段<br>磁力<br>链接：链接视频和音频<br>锁定：锁定时间线的位置</p>
<p>如果只导入视频，可以按下<code>F</code>来匹配帧，从而可以从素材显示窗口再导入音频。</p>
<h1 id="效果添加"><a href="#效果添加" class="headerlink" title="效果添加"></a>效果添加</h1><p>在特效库中将效果拖拽到时间线对应的视频进行添加。<br>添加之后通过效果检查器面板设置参数</p>
<h2 id="调整效果检查器面板参数"><a href="#调整效果检查器面板参数" class="headerlink" title="调整效果检查器面板参数"></a>调整效果检查器面板参数</h2><ul>
<li>直接输入</li>
<li>鼠标拖动数字</li>
<li>alt+鼠标拖动（精细操作）</li>
</ul>
<p>实时面板左下角可以进行裁切或变换等。<br><img src="2.png" alt=""></p>
<h2 id="涉及到时间的特效"><a href="#涉及到时间的特效" class="headerlink" title="涉及到时间的特效"></a>涉及到时间的特效</h2><ul>
<li>关键帧<br>通过效果检查及面板参数后面的菱形添加关键帧<br>在两个关键帧之间可以进行调整<br>在时间线上点击菱形</li>
</ul>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p><code>ctrl+c</code>复制<br>右键片段粘贴属性<br>不同比例的素材统一，防止出现黑边：项目-&gt;图像缩放调整-&gt;输入缩放调整</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>redgiant红巨星宇宙</p>
<h1 id="代理生成"><a href="#代理生成" class="headerlink" title="代理生成"></a>代理生成</h1><p>为了使视频流畅播放，就需要对素材进行优化。<br>几种方法：</p>
<ol>
<li>菜单栏-&gt; 播放 -&gt; 代理模式 -&gt; 选择更低的分辨率</li>
<li>优化媒体文件（将媒体文件优化到一个更优的文件）<ul>
<li>选择媒体文件，右键-&gt; 生成优化的媒体文件（编码设置：文件-&gt;项目设置-&gt;主设置-&gt;优化的媒体和渲染缓存，工作文件夹-&gt;…）</li>
<li>复杂操作后仍然会卡顿：播放-&gt;渲染缓存</li>
</ul>
</li>
</ol>
<h1 id="智能媒体文件夹与双时间线剪辑"><a href="#智能媒体文件夹与双时间线剪辑" class="headerlink" title="智能媒体文件夹与双时间线剪辑"></a>智能媒体文件夹与双时间线剪辑</h1><p>通常剪辑视频分为Aroll和Broll，Aroll代表内容的核心框架，Broll为帮助描述主内容的画面等。通常流程为Aroll-&gt;Broll-&gt;特效。<br><strong>智能媒体文件夹</strong>：通过各种信息将素材文件进行分类。<br><strong>双时间线剪辑</strong>：时间线右上角</p>
<ul>
<li>一个时间线放素材和裁剪</li>
<li>将有用的片段拉到第二个时间线，防止对视频的破坏（编辑-》删除空隙）</li>
</ul>
<h1 id="快编界面"><a href="#快编界面" class="headerlink" title="快编界面"></a>快编界面</h1><p>一次性快速浏览大量素材<br>选中素材按下c键可以快速进行自动调色</p>
]]></content>
      <categories>
        <category>其他工具</category>
      </categories>
      <tags>
        <tag>达芬奇</tag>
        <tag>剪辑</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架</title>
    <url>/2020/05/02/Django%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="一个简单的web框架"><a href="#一个简单的web框架" class="headerlink" title="一个简单的web框架"></a>一个简单的web框架</h1><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f4</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> pymysql</span><br><span class="line">    <span class="comment"># 创建连接</span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'123'</span>, db=<span class="string">'db666'</span>)</span><br><span class="line">    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line">    cursor.execute(<span class="string">"select id,username,password from userinfo"</span>)</span><br><span class="line">    user_list = cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">    f = open(<span class="string">'hostlist.html'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    data = f.read()</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基于第三方工具实现的模板渲染</span></span><br><span class="line">    <span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line">    template = Template(data)</span><br><span class="line">    data = template.render(xxxxx=user_list, user=<span class="string">'dsafsdfsdf'</span>)</span><br><span class="line">    <span class="keyword">return</span> data.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由系统</span></span><br><span class="line">routers = [</span><br><span class="line">      (<span class="string">'/host.html'</span>, f4),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn,addr = sock.accept() <span class="comment"># hang住</span></span><br><span class="line">        <span class="comment"># 有人来连接了</span></span><br><span class="line">        <span class="comment"># 获取用户发送的数据</span></span><br><span class="line">        data = conn.recv(<span class="number">8096</span>)</span><br><span class="line">        data = str(data,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        headers,bodys = data.split(<span class="string">'\r\n\r\n'</span>)</span><br><span class="line">        temp_list = headers.split(<span class="string">'\r\n'</span>)</span><br><span class="line">        method,url,protocal = temp_list[<span class="number">0</span>].split(<span class="string">' '</span>)</span><br><span class="line">        conn.send(<span class="string">b"HTTP/1.1 200 OK\r\n\r\n"</span>)</span><br><span class="line"></span><br><span class="line">        func_name = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> routers:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == url:</span><br><span class="line">                func_name = item[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> func_name:</span><br><span class="line">            response = func_name(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response = <span class="string">b"404"</span></span><br><span class="line"></span><br><span class="line">        conn.send(response)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>
<h1 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="创建程序"><a href="#创建程序" class="headerlink" title="创建程序"></a>创建程序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建django程序</span><br><span class="line">django-admin startproject &lt;sitename&gt;</span><br><span class="line">cd &lt;sitename&gt;</span><br><span class="line"># 创建app(后台和用户分开，多个不相关功能分开)</span><br><span class="line">python manage.py startapp xx</span><br><span class="line"># 启动服务</span><br><span class="line">python manage.py runserver 127.0.0.1:8080</span><br><span class="line"></span><br><span class="line">########## 配置</span><br><span class="line"># 配置模板路径</span><br><span class="line">settings.py中的template</span><br><span class="line"># 静态文件目录</span><br><span class="line">settings.py中添加STATICFILES_DIRS&#x3D;((path),)</span><br><span class="line"># 额外配置</span><br><span class="line">注释</span><br><span class="line">MIDDLEWARE &#x3D; [</span><br><span class="line">    &#39;django.middleware.security.SecurityMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    # &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="程序目录"><a href="#程序目录" class="headerlink" title="程序目录"></a>程序目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sitename</span><br><span class="line">    settings.py # Django配置文件</span><br><span class="line">    urls.py # 路由系统：url-&gt;函数</span><br><span class="line">    wsgi.py # 定义用于django的socket，wsgiref | uwsgi</span><br><span class="line">app</span><br><span class="line">    admin.py # django自带后台管理</span><br><span class="line">    model.py # 写类，根据类创建数据库表</span><br><span class="line">    test.py # 写单元测试</span><br><span class="line">    apps.py # app配置</span><br><span class="line">    views.py # 也可以改成目录 </span><br><span class="line">manage.py # 对当前django的所有操作基于manage</span><br></pre></td></tr></table></figure>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 元素</span><br><span class="line">&#123;&#123;user&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 列表元素</span><br><span class="line">&#123;&#123;users.0&#125;&#125;</span><br><span class="line">&#123;&#123;users.1&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 字典元素</span><br><span class="line">&#123;&#123;users.key&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 循环</span><br><span class="line">&#123;% for item in users %&#125;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line"># 判断</span><br><span class="line">&#123;% if a&#x3D;&#x3D;b %&#125;</span><br><span class="line">    &lt;asdfasdf&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;asfasdfadf&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模态对话框Ajax"><a href="#模态对话框Ajax" class="headerlink" title="模态对话框Ajax"></a>模态对话框Ajax</h3><p>模态对话框使用form表单提交会刷新页面，为了不刷新，可以使用ajax<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/jquery-3.2.0.js/"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">ajax_add_teacher</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">            url:<span class="string">'/modal_add_teacher/'</span>,</span></span><br><span class="line"><span class="actionscript">            type:<span class="string">'POST'</span>,</span></span><br><span class="line"><span class="javascript">            data:&#123;<span class="string">'tname'</span>:$(<span class="string">'#tname'</span>).val()&#125;,</span></span><br><span class="line"><span class="actionscript">            dataType:<span class="string">"JSON"</span>, <span class="comment">//将data作为json字符串解析为json对象</span></span></span><br><span class="line"><span class="actionscript">            traditional:<span class="literal">true</span>, <span class="comment">//如果数据中有list或dict</span></span></span><br><span class="line"><span class="actionscript">            success: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (data == <span class="string">'ok'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                    location.href = <span class="string">'/teachers'</span>; <span class="comment">//页面跳转</span></span></span><br><span class="line"><span class="actionscript">                    location.reload(); <span class="comment">//对当前页面进行刷新</span></span></span><br><span class="line"><span class="actionscript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    $(<span class="string">'#errormsg'</span>).text(data);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="前端json"><a href="#前端json" class="headerlink" title="前端json"></a>前端json</h4><p>JSON.parse(字符串) -&gt; 对象<br>JSON.stringify(对象) -&gt; 字符串<br>通过点取值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dic = <span class="built_in">JSON</span>.parse(args)</span><br><span class="line">dic.key</span><br></pre></td></tr></table></figure></p>
<h4 id="js阻止默认事件发生"><a href="#js阻止默认事件发生" class="headerlink" title="js阻止默认事件发生"></a>js阻止默认事件发生</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"www.baidu.com"</span> <span class="attr">onclick</span>=<span class="string">"return funca();"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">funca</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> False;</span></span><br><span class="line">    &#125;    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="js绑定事件"><a href="#js绑定事件" class="headerlink" title="js绑定事件"></a>js绑定事件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"xx"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#xx"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h2><p>常用的样式</p>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>添加 <code>&lt;link rel=&#39;stylesheet&#39; href=&#39;/static/bootstrap.css&#39;&gt;&lt;/link&gt;</code><br>添加属性 class=‘xasdf’</p>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>根据窗口大小，自适应布局<br>@media关键字</p>
<h3 id="母版"><a href="#母版" class="headerlink" title="母版"></a>母版</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//母版文件 muban.html</span><br><span class="line">&#123;% block xx %&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">//文件</span><br><span class="line">&#123;% extends 'muban.html'%&#125;</span><br><span class="line">&#123;% block xx %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>一般css、content、js三个block</p>
<h2 id="fontawesome"><a href="#fontawesome" class="headerlink" title="fontawesome"></a>fontawesome</h2><p>常用的图标</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>保存在浏览器端的键值对<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = redirect(<span class="string">"/classes/"</span>)</span><br><span class="line">obj.set_cookie(<span class="string">"ticket"</span>,<span class="string">"kjaskldfjaskdf"</span>,max_age=<span class="number">10</span>,path=<span class="string">"/"</span>,domain=<span class="literal">None</span>) //生效时间<span class="number">10</span>s 推荐, path表示cookie在哪个路径生效,domain对域名的划分（默认当前域名），</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">cur_time = datetime.datetime.utcnow()</span><br><span class="line">time_delta = datetime.timdelta(seconds=<span class="number">123</span>)</span><br><span class="line">obj.set_cookie(<span class="string">"ticket"</span>,<span class="string">"kjaskldfjaskdf"</span>,expires=cur_time+time_delta) //知道目标时间都生效</span><br><span class="line"></span><br><span class="line">set_salt_cookie(<span class="string">"ticket"</span>,<span class="string">"kjaskldfjaskdf"</span>,salt=<span class="string">"asdf"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取</span><br><span class="line">request.get_signed_cookie(<span class="string">"ticket"</span>,salt=<span class="string">"asdf"</span>)</span><br><span class="line">request.COOKIE.get(<span class="string">"ticket"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>django：路由、视图、母版、ORM()<br>torando：路由、视图、母版、自由(mysql,SqlAchemy)<br>flask：路由、视图、母版(第三方)、自由(mysql,SqlAchemy)</p>
<h2 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># path第一个参数为正则表达式模板</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line">path(<span class="string">r"edit/"</span>,views.edit)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 00</span></span><br><span class="line">path(<span class="string">r"^edit$"</span>,views.edit) <span class="comment"># 匹配edit开头，终止的url地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">path(<span class="string">r"edit/(w+)/(w+)/"</span>,views.edit)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(request,a1,a2)</span>:</span></span><br><span class="line">    <span class="comment"># a1为正则表达式匹配的值，这里为(w+)中的内容，严格按照顺序从前到后</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">path(<span class="string">r"edit/(?P&lt;a2&gt;w+)/(?P&lt;a1&gt;w+)/"</span>,views.edit)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(request,a1,a2)</span>:</span></span><br><span class="line">    <span class="comment"># a1为正则表达式匹配的值，这里为(w+)中的内容，按照&lt;&gt;中的进行赋值</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urls.py</span><br><span class="line">    <span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> include</span><br><span class="line">    path(<span class="string">'app01'</span>,include(<span class="string">'app01.urls'</span>))</span><br><span class="line">app01.urls.py</span><br><span class="line">    path(<span class="string">'index'</span>,views.index)</span><br></pre></td></tr></table></figure>
<h3 id="别名反向生成url"><a href="#别名反向生成url" class="headerlink" title="别名反向生成url"></a>别名反向生成url</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line">path(<span class="string">"login/(?P&lt;a1&gt;\w+)"</span>,views.login,name=<span class="string">"n1"</span>)</span><br><span class="line">v = reverse(<span class="string">"n1"</span>,kwargs=&#123;<span class="string">'a1'</span>:<span class="number">1111</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">path(<span class="string">"login/"</span>,views.login,name=<span class="string">"m1"</span>)</span><br><span class="line">&#123;% url <span class="string">'m1'</span> %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CBV和FBV"><a href="#CBV和FBV" class="headerlink" title="CBV和FBV"></a>CBV和FBV</h2><h3 id="CBV"><a href="#CBV" class="headerlink" title="CBV"></a>CBV</h3><p>一个URL对应一个类<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">path(<span class="string">r'^login.html$'</span>, views.Login.as_view()),</span><br><span class="line"></span><br><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span><span class="params">(View)</span>:</span>  <span class="comment"># 继承View类作为父类</span></span><br><span class="line">    <span class="comment"># #重写父类方法，该方法可作为装饰器功能</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span>  <span class="comment"># 自定制 dispatch方法，除了可以利用父类中原dispatch方法，还可以自定制处理逻辑</span></span><br><span class="line">        print(<span class="string">'before'</span>)</span><br><span class="line">        obj = super(Login,self).dispatch(request, *args, **kwargs) <span class="comment"># 传入Login对象作为参数，调用父类中的方法</span></span><br><span class="line">        print(<span class="string">'after'</span>)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span>  <span class="comment"># 请求为get请求时，自动调用该方法</span></span><br><span class="line">        <span class="comment"># return HttpResponse('Login.get')</span></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'login.html'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span>   <span class="comment"># 请求是POST请求时，自动调用该方法</span></span><br><span class="line">        print(request.POST.get(<span class="string">'user'</span>))</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'Login.post'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="ORM操作"><a href="#ORM操作" class="headerlink" title="ORM操作"></a>ORM操作</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> __init__.py文件</span><br><span class="line">(ORM默认使用SQLlite连接数据库,需改成Mysql)</span><br><span class="line"></span><br><span class="line">添加：</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置setting文件中重写数数据库配置</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line"><span class="string">'default'</span>: &#123;</span><br><span class="line"><span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line"><span class="string">'NAME'</span>:<span class="string">'s4day70db'</span>,</span><br><span class="line"><span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line"><span class="string">'PASSWORD'</span>: <span class="string">''</span>,</span><br><span class="line"><span class="string">'HOST'</span>: <span class="string">'localhost'</span>,</span><br><span class="line"><span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(models.Model)</span>:</span>   <span class="comment"># 在数据库中的表名为模块名_UserInfo</span></span><br><span class="line">    nid = models.BigAutoField(primary_key=<span class="literal">True</span>) <span class="comment">#可不写，默认会生成表中的id字段 # 自增 主键</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># settings配置文件中安装app01模块</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ……</span><br><span class="line">    <span class="string">'app01'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行语句</span></span><br><span class="line">python manage.py makemigrations  <span class="comment">#生成数据表配置文件，包含生成及修改等信息</span></span><br><span class="line">python manage.py migrate  <span class="comment">#执行生成的配置文件</span></span><br></pre></td></tr></table></figure>
<h3 id="修改表-删除表"><a href="#修改表-删除表" class="headerlink" title="修改表/删除表"></a>修改表/删除表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    ……</span><br><span class="line">    age = models.IntegerField(default=<span class="number">1</span>) <span class="comment"># 新增字段时需设置默认值/允许为空</span></span><br><span class="line">    <span class="comment"># age = models.IntegerField(null=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行语句：</span></span><br><span class="line">python manage.py makemigrations  <span class="comment">#生成数据表配置文件，包含生成及修改等信息</span></span><br><span class="line">python manage.py migrate  <span class="comment">#执行生成的配置文件</span></span><br></pre></td></tr></table></figure>
<h3 id="创建外键关联"><a href="#创建外键关联" class="headerlink" title="创建外键关联"></a>创建外键关联</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserGroup</span><span class="params">(models.Model)</span>:</span> <span class="comment">#等同于主表，需将该类写在子表前面</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(models.Model)</span>:</span>   <span class="comment"># 外键所在的表等同于子表</span></span><br><span class="line">    ……</span><br><span class="line">    ug = models.ForeignKey(<span class="string">'UserGroup'</span>,null=<span class="literal">True</span>,on_delete=<span class="string">''</span>) <span class="comment"># 外键关联字段关联UserGroup表中的Id字段，ug在UserInfo数据表中的字段为ug_id</span></span><br></pre></td></tr></table></figure>
<h3 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增</span></span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line">models.UserGroup.objects.create(title=<span class="string">'销售部'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line">models.UserGroup.objects.filter(id=<span class="number">2</span>).delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line"> models.UserGroup.objects.filter(id=<span class="number">2</span>).update(title=<span class="string">'公关部'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 查</span></span><br><span class="line">group_list = models.UserGroup.objects.all() <span class="comment"># 所有</span></span><br><span class="line">group_list = models.UserGroup.objects.filter(id=<span class="number">1</span>)</span><br><span class="line">group_list = models.UserGroup.objects.filter(id__gt=<span class="number">1</span>) <span class="comment">#大于1</span></span><br><span class="line">group_list = models.UserGroup.objects.filter(id__lt=<span class="number">1</span>) <span class="comment">#小于1</span></span><br></pre></td></tr></table></figure>
<h3 id="连表操作"><a href="#连表操作" class="headerlink" title="连表操作"></a>连表操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建表</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserType</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 用户类型</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 用户表    </span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    ut = models.ForeignKey(<span class="string">'UserType'</span>,on_delete=<span class="string">''</span>)   <span class="comment"># 关联UserType表中的id字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># models.UserType.objects.create(title='普通用户')</span></span><br><span class="line"><span class="comment"># models.UserType.objects.create(title='二逼用户')</span></span><br><span class="line"><span class="comment"># models.UserType.objects.create(title='牛逼用户')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name='方少伟',age=18,ut_id=1)</span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name='由秦兵',age=18,ut_id=2)</span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name='刘庚',age=18,ut_id=2)</span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name='陈涛',age=18,ut_id=3)</span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name='王者',age=18,ut_id=3)</span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name='杨涵',age=18,ut_id=1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一对多的正向操作（让存在外键的从表进行跨表，去查询关联主表中的字段）：</span></span><br><span class="line"><span class="comment"># 获得Queryset对象格式数据（格式：对象名.外键字段名.关联表字段名）</span></span><br><span class="line">obj = models.UserInfo.objects.all().first()   <span class="comment"># 获取一条数据，无需再obj[0]来获取具体的对象</span></span><br><span class="line">print(obj.name,obj.age,obj.ut.title) <span class="comment"># 获取跨表后的字段用obj.ut.title方式，ut是外键关联中的字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得查询结果为字典格式组合成列表类型的Queryset数据,可用list方法转换成列表格式（从表中的外键字段名__主表中的字段名）</span></span><br><span class="line">v1 = models.UserInfo.objects.values(<span class="string">'id'</span>,<span class="string">'name'</span>,<span class="string">'ut__title'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得查询结果为元组格式组合成列表类型的Queryset数据,可用List转换成列表（从表中的外键字段名__主表中的字段名）</span></span><br><span class="line">result = models.UserInfo.objects.all().values_list(<span class="string">'id'</span>,<span class="string">'name'</span>.<span class="string">'ut__title'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一对多的反向操作(让主表进行跨表，去查询（有外键关联字段）从表中相应的字段作为查询条件或查询结果)：</span></span><br><span class="line"><span class="comment"># 获得Queryset对象格式的数据,(格式：主表的QuerySet对象名.从***表名__set.all()***)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># （一个用户类型下可以有很多用户，获得所有用户类型对应的用户信息数据）：</span></span><br><span class="line">obj = models.UserType.objects.all().first()</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> obj.userinfo_set.all(): </span><br><span class="line">	print(row.name,row.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得字典格式Queryset对象格式的数据,需要转换成json字符串格式通过ajax返回数据时，可用list方法转换成列表（从表表名小写__主表字段名）</span></span><br><span class="line">v2 = models.UserType.objects.values(<span class="string">'id'</span>,<span class="string">'title'</span>,<span class="string">'userinfo__name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得元组格式Queryset对象格式的数据,需要转换成json字符串格式通过ajax返回数据时，可用list方法转换成列表。（外键字段名__从表字段名）</span></span><br><span class="line">result = models.UserType.objects.all().values_list(<span class="string">'id'</span>,<span class="string">'name'</span>,<span class="string">'userinfo__name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跨表</span></span><br><span class="line"><span class="comment"># 正向查询：</span></span><br><span class="line"><span class="number">1.</span> q = UserInfo.objects.all().first()</span><br><span class="line">q.ug.title</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> </span><br><span class="line">UserInfo.objects.values(<span class="string">'nid'</span>,<span class="string">'ug_id'</span>)              </span><br><span class="line">UserInfo.objects.values(<span class="string">'nid'</span>,<span class="string">'ug_id'</span>,<span class="string">'ug__title'</span>)  </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> UserInfo.objects.values_list(<span class="string">'nid'</span>,<span class="string">'ug_id'</span>,<span class="string">'ug__title'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向查询：</span></span><br><span class="line"><span class="number">1.</span> 小写的表名_set</span><br><span class="line">obj = UserGroup.objects.all().first()</span><br><span class="line">  result = obj.userinfo_set.all() [userinfo对象,userinfo对象,]</span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> 小写的表名</span><br><span class="line">v = UserGroup.objects.values(<span class="string">'id'</span>,<span class="string">'title'</span>)          </span><br><span class="line">v = UserGroup.objects.values(<span class="string">'id'</span>,<span class="string">'title'</span>,<span class="string">'小写的从表名称'</span>)          </span><br><span class="line">v = UserGroup.objects.values(<span class="string">'id'</span>,<span class="string">'title'</span>,<span class="string">'小写的从表名称__age'</span>)      </span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> 小写的表名</span><br><span class="line">v = UserGroup.objects.values_list(<span class="string">'id'</span>,<span class="string">'title'</span>)          </span><br><span class="line">v = UserGroup.objects.values_list(<span class="string">'id'</span>,<span class="string">'title'</span>,<span class="string">'小写的表名称'</span>)          </span><br><span class="line">v = UserGroup.objects.values_list(<span class="string">'id'</span>,<span class="string">'title'</span>,<span class="string">'小写的表名称__age'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_list = models.UserInfo.objects.all().order_by(<span class="string">'-id'</span>,<span class="string">'name'</span>) </span><br><span class="line"><span class="comment"># —id代表降序，id代表升序</span></span><br></pre></td></tr></table></figure>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># group by</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count,Sum,Max,Min</span><br><span class="line">v =models.UserInfo.objects.values(<span class="string">'ut_id'</span>).annotate(xxxx=Count(<span class="string">'id'</span>))</span><br><span class="line"><span class="comment"># 等价于SELECT `app01_userinfo`.`ut_id`, COUNT(`app01_userinfo`.`id`) AS `xxxx` </span></span><br><span class="line"><span class="comment"># FROM</span></span><br><span class="line"><span class="comment"># `app01_userinfo` </span></span><br><span class="line"><span class="comment"># GROUP BY `app01_userinfo`.`ut_id`</span></span><br><span class="line"><span class="comment"># ORDER BY NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 带有having 分组条件过滤</span></span><br><span class="line">v =models.UserInfo.objects.values(<span class="string">'ut_id'</span>).annotate(xxxx=Count(<span class="string">'id'</span>)).filter(xxxx__gt=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 等价于SELECT `app01_userinfo`.`ut_id`, COUNT(`app01_userinfo`.`id`) AS `xxxx` </span></span><br><span class="line"><span class="comment"># FROM</span></span><br><span class="line"><span class="comment"># `app01_userinfo` GROUP BY `app01_userinfo`.`ut_id`</span></span><br><span class="line"><span class="comment"># HAVING COUNT(`app01_userinfo`.`id`) &gt; 2 </span></span><br><span class="line"><span class="comment"># ORDER BY NULL</span></span><br><span class="line"></span><br><span class="line">v =models.UserInfo.objects.filter(id__gt=<span class="number">2</span>).values(<span class="string">'ut_id'</span>).annotate(xxxx=Count(<span class="string">'id'</span>)).filter(xxxx__gt=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 等价于SELECT `app01_userinfo`.`ut_id`, COUNT(`app01_userinfo`.`id`) AS `xxxx` </span></span><br><span class="line"><span class="comment"># FROM </span></span><br><span class="line"><span class="comment"># `app01_userinfo`</span></span><br><span class="line"><span class="comment">#  WHERE</span></span><br><span class="line"><span class="comment">#  `app01_userinfo`.`id` &gt; 2 </span></span><br><span class="line"><span class="comment"># GROUP BY</span></span><br><span class="line"><span class="comment">#  `app01_userinfo`.`ut_id`</span></span><br><span class="line"><span class="comment">#  HAVING </span></span><br><span class="line"><span class="comment"># COUNT(`app01_userinfo`.`id`) &gt; 2 ORDER BY NULL</span></span><br><span class="line"></span><br><span class="line">分组格式：model.类名.objects.values(显示的字段名).annotate(作为字段查结结果的别名=Count(字段id/<span class="number">1</span>))</span><br><span class="line">  <span class="comment"># annotate依赖于values</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件过滤</span></span><br><span class="line">models.UserInfo.objects.filter(id__gt=<span class="number">1</span>)  <span class="comment"># id&gt;1</span></span><br><span class="line">……（id__lt=<span class="number">1</span>） <span class="comment"># id&lt;1</span></span><br><span class="line">……(id__lte=<span class="number">1</span>) <span class="comment">#id&lt;=1</span></span><br><span class="line">……(id__gte=<span class="number">1</span>) <span class="comment"># id&gt;=1</span></span><br><span class="line">……(id__in=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#id in [1,2,3]</span></span><br><span class="line">……(name__startswith=<span class="string">'xxxx'</span>)  <span class="comment">#</span></span><br><span class="line">……(name__contains=<span class="string">'xxxx'</span>) <span class="comment">#</span></span><br><span class="line">……exclude(id=<span class="number">1</span>)  <span class="comment"># not in (id=1)</span></span><br></pre></td></tr></table></figure>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul>
<li><p>F</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line">models.UserInfo.objects.all().update(age=F(<span class="string">"age"</span>)+<span class="number">1</span>)  <span class="comment"># F()用来取对象中某列值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Q(构造复杂的查询条件)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象方式(不推荐)</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">models.UserInfo.objects.filter(Q(id__gt=<span class="number">1</span>))</span><br><span class="line">models.UserInfo.objects.filter(Q(id=<span class="number">8</span>) | Q(id=<span class="number">2</span>)) <span class="comment"># or</span></span><br><span class="line">models.UserInfo.objects.filter(Q(id=<span class="number">8</span>) &amp; Q(id=<span class="number">2</span>)) <span class="comment"># and</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">q1 = Q()</span><br><span class="line">q1.connector = <span class="string">'OR'</span></span><br><span class="line">q1.children.append((<span class="string">'id__gt'</span>, <span class="number">1</span>))</span><br><span class="line">q1.children.append((<span class="string">'id'</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 通过OR将3个条件进行连接组装</span></span><br><span class="line"></span><br><span class="line">q2 = Q()</span><br><span class="line">q2.connector = <span class="string">'OR'</span></span><br><span class="line">q2.children.append((<span class="string">'c1'</span>, <span class="number">1</span>))</span><br><span class="line">q2.children.append((<span class="string">'c1'</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">q3 = Q()</span><br><span class="line">q3.connector = <span class="string">'AND'</span> <span class="comment">#通过AND将2个条件进行连接组装</span></span><br><span class="line">q3.children.append((<span class="string">'id'</span>, <span class="number">1</span>))</span><br><span class="line">q3.children.append((<span class="string">'id'</span>, <span class="number">2</span>))</span><br><span class="line">q1.add(q3,<span class="string">'OR'</span>) <span class="comment">#还可将q3嵌入到q1条件组中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将q1和q2条件组通过AND汇总到一起，q1和q2内部分别用or组合条件</span></span><br><span class="line">con = Q()</span><br><span class="line">con.add(q1, <span class="string">'AND'</span>)</span><br><span class="line">con.add(q2, <span class="string">'AND'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">condition_dict = &#123;  <span class="comment">#用户将选择的条件组合成字典格式</span></span><br><span class="line">    <span class="string">'k1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    <span class="string">'k2'</span>:[<span class="number">1</span>,],</span><br><span class="line">&#125;</span><br><span class="line">con = Q()</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> condition_dict.items():</span><br><span class="line">    q = Q()</span><br><span class="line">    q.connector = <span class="string">'OR'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> v:</span><br><span class="line">        q.children.append((<span class="string">'id'</span>, i))</span><br><span class="line">    con.add(q,<span class="string">'AND'</span>)</span><br><span class="line">models.UserInfo.objects.filter(con)</span><br><span class="line"></span><br><span class="line">***********************************************************************</span><br><span class="line">q1 = Q()</span><br><span class="line">q1.connector = <span class="string">'OR'</span></span><br><span class="line">q1.children.append((<span class="string">'id'</span>, <span class="number">1</span>))</span><br><span class="line">q1.children.append((<span class="string">'id'</span>, <span class="number">10</span>))</span><br><span class="line">q1.children.append((<span class="string">'id'</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q2 = Q()</span><br><span class="line">q2.connector = <span class="string">'OR'</span></span><br><span class="line">q2.children.append((<span class="string">'c1'</span>, <span class="number">1</span>))</span><br><span class="line">q2.children.append((<span class="string">'c1'</span>, <span class="number">10</span>))</span><br><span class="line">q2.children.append((<span class="string">'c1'</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">q3 = Q()</span><br><span class="line">q3.connector = <span class="string">'AND'</span></span><br><span class="line">q3.children.append((<span class="string">'id'</span>, <span class="number">1</span>))</span><br><span class="line">q3.children.append((<span class="string">'id'</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">q1.add(q3,<span class="string">'OR'</span>)</span><br><span class="line"></span><br><span class="line">con = Q()</span><br><span class="line">con.add(q1, <span class="string">'AND'</span>)</span><br><span class="line">con.add(q2, <span class="string">'AND'</span>)</span><br><span class="line"><span class="comment">#以上构造结果等介于(id=1 or id = 10 or id=9 or (id=1 and id=2)) and (c1=1 or c1=10 or c1=9)</span></span><br></pre></td></tr></table></figure>
<h3 id="extra-添加额外的自定义sql语句"><a href="#extra-添加额外的自定义sql语句" class="headerlink" title="extra(添加额外的自定义sql语句)"></a>extra(添加额外的自定义sql语句)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models.UserInfo.objects.extra(self, select=<span class="literal">None</span>, where=<span class="literal">None</span>, params=<span class="literal">None</span>, tables=<span class="literal">None</span>, order_by=<span class="literal">None</span>, select_params=<span class="literal">None</span>)</span><br><span class="line"> a. 映射</span><br><span class="line"> select </span><br><span class="line"> select_params=<span class="literal">None</span></span><br><span class="line">select 此处 <span class="keyword">from</span> 表</span><br><span class="line"> b. 条件</span><br><span class="line"> where=<span class="literal">None</span></span><br><span class="line"> params=<span class="literal">None</span>,</span><br><span class="line"> select * <span class="keyword">from</span> 表 where 此处</span><br><span class="line"> c. 表</span><br><span class="line"> tables</span><br><span class="line"> select * <span class="keyword">from</span> 表,此处</span><br><span class="line"> c. 排序</span><br><span class="line">order_by=<span class="literal">None</span></span><br><span class="line"> select * <span class="keyword">from</span> 表 order by 此处</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> v = models.UserInfo.objects.all().extra(</span><br><span class="line">    select=&#123;</span><br><span class="line">        <span class="string">'n'</span>:<span class="string">"select count(1) from app01_usertype where id=%s or id=%s"</span>,</span><br><span class="line">        <span class="string">'m'</span>:<span class="string">"select count(1) from app01_usertype where id=%s or id=%s"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    select_params=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> v:</span><br><span class="line">    print(obj.name,obj.id,obj.n) </span><br><span class="line"><span class="comment"># 等价于将查询结果作为字段显示列：</span></span><br><span class="line"><span class="comment"># select</span></span><br><span class="line"><span class="comment"># id,</span></span><br><span class="line"><span class="comment"># name,</span></span><br><span class="line"><span class="comment"># (select count(1) from tb) as n</span></span><br><span class="line"><span class="comment"># from xb where ....</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">models.UserInfo.objects.extra(</span><br><span class="line">select=&#123;<span class="string">'newid'</span>:<span class="string">'select count(1) from app01_usertype where id&gt;%s'</span>&#125;,</span><br><span class="line">select_params=[<span class="number">1</span>,],</span><br><span class="line">where = [<span class="string">'age&gt;%s'</span>],</span><br><span class="line">params=[<span class="number">18</span>,],</span><br><span class="line">order_by=[<span class="string">'-age'</span>],</span><br><span class="line">tables=[<span class="string">'app01_usertype'</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于原生sql语句如下：</span></span><br><span class="line"><span class="comment"># select </span></span><br><span class="line"><span class="comment"># app01_userinfo.id,</span></span><br><span class="line"><span class="comment"># (select count(1) from app01_usertype where id&gt;1) as newid</span></span><br><span class="line"><span class="comment"># from app01_userinfo,app01_usertype</span></span><br><span class="line"><span class="comment"># where </span></span><br><span class="line"><span class="comment"># app01_userinfo.age &gt; 18</span></span><br><span class="line"><span class="comment"># order by </span></span><br><span class="line"><span class="comment"># app01_userinfo.age desc</span></span><br><span class="line"></span><br><span class="line">result = models.UserInfo.objects.filter(id__gt=<span class="number">1</span>).extra(</span><br><span class="line">where=[<span class="string">'app01_userinfo.id &lt; %s'</span>],</span><br><span class="line">params=[<span class="number">100</span>,],</span><br><span class="line">tables=[<span class="string">'app01_usertype'</span>],</span><br><span class="line">order_by=[<span class="string">'-app01_userinfo.id'</span>],</span><br><span class="line">select=&#123;<span class="string">'uid'</span>:<span class="number">1</span>,<span class="string">'sw'</span>:<span class="string">"select count(1) from app01_userinfo"</span>&#125; <span class="comment">#添加查询字段</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># SELECT (1) AS "uid", (select count(1) from app01_userinfo) AS "sw", "app01_userinfo"."id", "app01_userinfo"."name", "app01_userinfo"."age", "app01_userinfo"."ut_id" </span></span><br><span class="line"><span class="comment"># FROM</span></span><br><span class="line"><span class="comment">#  "app01_userinfo" , "app01_usertype" </span></span><br><span class="line"><span class="comment"># WHERE</span></span><br><span class="line"><span class="comment">#  ("app01_userinfo"."id" &gt; 1 AND (app01_userinfo.id &lt; 100))</span></span><br><span class="line"><span class="comment">#  ORDER BY ("app01_userinfo".id) </span></span><br><span class="line"><span class="comment"># DESC</span></span><br></pre></td></tr></table></figure>
<h3 id="原生sql语句"><a href="#原生sql语句" class="headerlink" title="原生sql语句"></a>原生sql语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection, connections</span><br><span class="line">cursor = connection.cursor() </span><br><span class="line"> <span class="comment"># cursor = connections['default'].cursor()</span></span><br><span class="line">cursor.execute(<span class="string">"""SELECT * from auth_user where id = %s"""</span>, [<span class="number">1</span>])</span><br><span class="line">row = cursor.fetchone() <span class="comment"># fetchall()/fetchmany(..)</span></span><br></pre></td></tr></table></figure>
<h3 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #</span></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all</span><span class="params">(self)</span></span></span><br><span class="line"><span class="function">    # 获取所有的数据对象</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">filter</span><span class="params">(self, *args, **kwargs)</span></span></span><br><span class="line"><span class="function">    # 条件查询</span></span><br><span class="line"><span class="function">    # 条件可以是：参数，字典，<span class="title">Q</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">exclude</span><span class="params">(self, *args, **kwargs)</span></span></span><br><span class="line"><span class="function">    # 条件查询</span></span><br><span class="line"><span class="function">    # 条件可以是：参数，字典，<span class="title">Q</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">select_related</span><span class="params">(self, *fields)</span></span></span><br><span class="line"><span class="function">     性能相关：表之间进行<span class="title">join</span>连表操作，一次性获取关联的数据。</span></span><br><span class="line"><span class="function">     <span class="title">model</span>.<span class="title">tb</span>.<span class="title">objects</span>.<span class="title">all</span><span class="params">()</span>.<span class="title">select_related</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     <span class="title">model</span>.<span class="title">tb</span>.<span class="title">objects</span>.<span class="title">all</span><span class="params">()</span>.<span class="title">select_related</span><span class="params">(<span class="string">'外键字段'</span>)</span></span></span><br><span class="line"><span class="function">     <span class="title">model</span>.<span class="title">tb</span>.<span class="title">objects</span>.<span class="title">all</span><span class="params">()</span>.<span class="title">select_related</span><span class="params">(<span class="string">'外键字段__外键字段'</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">prefetch_related</span><span class="params">(self, *lookups)</span></span></span><br><span class="line"><span class="function">    性能相关：多表连表操作时速度会慢，使用其执行多次<span class="title">SQL</span>查询在<span class="title">Python</span>代码中实现连表操作。</span></span><br><span class="line"><span class="function">            # 获取所有用户表</span></span><br><span class="line"><span class="function">            # 获取用户类型表<span class="title">where</span> <span class="title">id</span> <span class="title">in</span> <span class="params">(用户表中的查到的所有用户ID)</span></span></span><br><span class="line"><span class="function">            <span class="title">models</span>.<span class="title">UserInfo</span>.<span class="title">objects</span>.<span class="title">prefetch_related</span><span class="params">(<span class="string">'外键字段'</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">            from django.db.models import Count, Case, When, IntegerField</span><br><span class="line">            Article.objects.annotate(</span><br><span class="line">                numviews=Count(Case(</span><br><span class="line">                    When(readership__what_time__lt=treshold, then=<span class="number">1</span>),</span><br><span class="line">                    output_field=CharField(),</span><br><span class="line">                ))</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            students = Student.objects.all().annotate(num_excused_absences=models.Sum(</span><br><span class="line">                models.Case(</span><br><span class="line">                    models.When(absence__type=<span class="string">'Excused'</span>, then=<span class="number">1</span>),</span><br><span class="line">                default=<span class="number">0</span>,</span><br><span class="line">                output_field=models.IntegerField()</span><br><span class="line">            )))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">annotate</span><span class="params">(self, *args, **kwargs)</span></span></span><br><span class="line"><span class="function">    # 用于实现聚合<span class="title">group</span> <span class="title">by</span>查询</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">    from django.db.models import Count, Avg, Max, Min, Sum</span><br><span class="line"></span><br><span class="line">    v = models.UserInfo.objects.values(<span class="string">'u_id'</span>).annotate(uid=Count(<span class="string">'u_id'</span>))</span><br><span class="line">    <span class="comment"># SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id</span></span><br><span class="line"></span><br><span class="line">    v = models.UserInfo.objects.values(<span class="string">'u_id'</span>).annotate(uid=Count(<span class="string">'u_id'</span>)).filter(uid__gt=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &gt; 1</span></span><br><span class="line"></span><br><span class="line">    v = models.UserInfo.objects.values(<span class="string">'u_id'</span>).annotate(uid=Count(<span class="string">'u_id'</span>,distinct=<span class="literal">True</span>)).filter(uid__gt=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distinct</span><span class="params">(self, *field_names)</span></span></span><br><span class="line"><span class="function">    # 用于<span class="title">distinct</span>去重</span></span><br><span class="line"><span class="function">    <span class="title">models</span>.<span class="title">UserInfo</span>.<span class="title">objects</span>.<span class="title">values</span><span class="params">(<span class="string">'nid'</span>)</span>.<span class="title">distinct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    # <span class="title">select</span> <span class="title">distinct</span> <span class="title">nid</span> <span class="title">from</span> <span class="title">userinfo</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    注：只有在<span class="title">PostgreSQL</span>中才能使用<span class="title">distinct</span>进行去重</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">order_by</span><span class="params">(self, *field_names)</span></span></span><br><span class="line"><span class="function">    # 用于排序</span></span><br><span class="line"><span class="function">    <span class="title">models</span>.<span class="title">UserInfo</span>.<span class="title">objects</span>.<span class="title">all</span><span class="params">()</span>.<span class="title">order_by</span><span class="params">(<span class="string">'-id'</span>,<span class="string">'age'</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">extra</span><span class="params">(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None)</span></span></span><br><span class="line"><span class="function">    # 构造额外的查询条件或者映射，如：子查询</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Entry</span>.<span class="title">objects</span>.<span class="title">extra</span><span class="params">(select=&#123;<span class="string">'new_id'</span>: <span class="string">"select col from sometable where othercol &gt; %s"</span>&#125;, select_params=<span class="params">(<span class="number">1</span>,)</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">Entry</span>.<span class="title">objects</span>.<span class="title">extra</span><span class="params">(where=[<span class="string">'headline=%s'</span>], params=[<span class="string">'Lennon'</span>])</span></span></span><br><span class="line"><span class="function">    <span class="title">Entry</span>.<span class="title">objects</span>.<span class="title">extra</span><span class="params">(where=[<span class="string">"foo='a' OR bar = 'a'"</span>, <span class="string">"baz = 'a'"</span>])</span></span></span><br><span class="line"><span class="function">    <span class="title">Entry</span>.<span class="title">objects</span>.<span class="title">extra</span><span class="params">(select=&#123;<span class="string">'new_id'</span>: <span class="string">"select id from tb where id &gt; %s"</span>&#125;, select_params=<span class="params">(<span class="number">1</span>,)</span>, order_by=[<span class="string">'-nid'</span>])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="title">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 倒序</span></span><br><span class="line">    models.UserInfo.objects.all().order_by(<span class="string">'-nid'</span>).reverse()</span><br><span class="line">    <span class="comment"># 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">defer</span><span class="params">(self, *fields)</span>:</span></span><br><span class="line">    models.UserInfo.objects.defer(<span class="string">'username'</span>,<span class="string">'id'</span>)</span><br><span class="line">    或</span><br><span class="line">    models.UserInfo.objects.filter(...).defer(<span class="string">'username'</span>,<span class="string">'id'</span>)</span><br><span class="line">    <span class="comment">#映射中排除某列数据</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">only</span><span class="params">(self, *fields)</span>:</span></span><br><span class="line">    <span class="comment">#仅取某个表中的数据</span></span><br><span class="line">     models.UserInfo.objects.only(<span class="string">'username'</span>,<span class="string">'id'</span>)</span><br><span class="line">     或</span><br><span class="line">     models.UserInfo.objects.filter(...).only(<span class="string">'username'</span>,<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">using</span><span class="params">(self, alias)</span>:</span></span><br><span class="line">     指定使用的数据库，参数为别名（setting中的设置）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #</span></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">raw</span><span class="params">(self, raw_query, params=None, translations=None, using=None)</span>:</span></span><br><span class="line">    <span class="comment"># 执行原生SQL</span></span><br><span class="line">    models.UserInfo.objects.raw(<span class="string">'select * from userinfo'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名</span></span><br><span class="line">    models.UserInfo.objects.raw(<span class="string">'select id as nid from 其他表'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为原生SQL设置参数</span></span><br><span class="line">    models.UserInfo.objects.raw(<span class="string">'select id as nid from userinfo where nid&gt;%s'</span>, params=[<span class="number">12</span>,])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将获取的到列名转换为指定列名</span></span><br><span class="line">    name_map = &#123;<span class="string">'first'</span>: <span class="string">'first_name'</span>, <span class="string">'last'</span>: <span class="string">'last_name'</span>, <span class="string">'bd'</span>: <span class="string">'birth_date'</span>, <span class="string">'pk'</span>: <span class="string">'id'</span>&#125;</span><br><span class="line">    Person.objects.raw(<span class="string">'SELECT * FROM some_other_table'</span>, translations=name_map)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定数据库</span></span><br><span class="line">    models.UserInfo.objects.raw(<span class="string">'select * from userinfo'</span>, using=<span class="string">"default"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">################### 原生SQL ###################</span></span><br><span class="line">    <span class="keyword">from</span> django.db <span class="keyword">import</span> connection, connections</span><br><span class="line">    cursor = connection.cursor()  <span class="comment"># cursor = connections['default'].cursor()</span></span><br><span class="line">    cursor.execute(<span class="string">"""SELECT * from auth_user where id = %s"""</span>, [<span class="number">1</span>])</span><br><span class="line">    row = cursor.fetchone() <span class="comment"># fetchall()/fetchmany(..)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self, *fields)</span>:</span></span><br><span class="line">    <span class="comment"># 获取每行数据为字典格式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">values_list</span><span class="params">(self, *fields, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 获取每行数据为元祖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dates</span><span class="params">(self, field_name, kind, order=<span class="string">'ASC'</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 根据时间进行某一部分进行去重查找并截取指定内容</span></span><br><span class="line">    <span class="comment"># kind只能是："year"（年）, "month"（年-月）, "day"（年-月-日）</span></span><br><span class="line">    <span class="comment"># order只能是："ASC"  "DESC"</span></span><br><span class="line">    <span class="comment"># 并获取转换后的时间</span></span><br><span class="line">        - year : 年<span class="number">-01</span><span class="number">-01</span></span><br><span class="line">        - month: 年-月<span class="number">-01</span></span><br><span class="line">        - day  : 年-月-日</span><br><span class="line"></span><br><span class="line">    models.DatePlus.objects.dates(<span class="string">'ctime'</span>,<span class="string">'day'</span>,<span class="string">'DESC'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datetimes</span><span class="params">(self, field_name, kind, order=<span class="string">'ASC'</span>, tzinfo=None)</span>:</span></span><br><span class="line">    <span class="comment"># 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间</span></span><br><span class="line">    <span class="comment"># kind只能是 "year", "month", "day", "hour", "minute", "second"</span></span><br><span class="line">    <span class="comment"># order只能是："ASC"  "DESC"</span></span><br><span class="line">    <span class="comment"># tzinfo时区对象</span></span><br><span class="line">    models.DDD.objects.datetimes(<span class="string">'ctime'</span>,<span class="string">'hour'</span>,tzinfo=pytz.UTC)</span><br><span class="line">    models.DDD.objects.datetimes(<span class="string">'ctime'</span>,<span class="string">'hour'</span>,tzinfo=pytz.timezone(<span class="string">'Asia/Shanghai'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    pip3 install pytz</span></span><br><span class="line"><span class="string">    import pytz</span></span><br><span class="line"><span class="string">    pytz.all_timezones</span></span><br><span class="line"><span class="string">    pytz.timezone(‘Asia/Shanghai’)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">none</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 空QuerySet对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####################################</span></span><br><span class="line"><span class="comment"># METHODS THAT DO DATABASE QUERIES #</span></span><br><span class="line"><span class="comment">####################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">   <span class="comment"># 聚合函数，获取字典类型聚合结果</span></span><br><span class="line">   <span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count, Avg, Max, Min, Sum</span><br><span class="line">   result = models.UserInfo.objects.aggregate(k=Count(<span class="string">'u_id'</span>, distinct=<span class="literal">True</span>), n=Count(<span class="string">'nid'</span>))</span><br><span class="line">   ===&gt; &#123;'k': 3, 'n': 4&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="comment"># 获取个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">   <span class="comment"># 获取单个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">   <span class="comment"># 创建对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_create</span><span class="params">(self, objs, batch_size=None)</span>:</span></span><br><span class="line">    <span class="comment"># 批量插入</span></span><br><span class="line">    <span class="comment"># batch_size表示一次插入的个数</span></span><br><span class="line">    objs = [</span><br><span class="line">        models.DDD(name=<span class="string">'r11'</span>),</span><br><span class="line">        models.DDD(name=<span class="string">'r22'</span>)</span><br><span class="line">    ]</span><br><span class="line">    models.DDD.objects.bulk_create(objs, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_or_create</span><span class="params">(self, defaults=None, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 如果存在，则获取，否则，创建</span></span><br><span class="line">    <span class="comment"># defaults 指定创建时，其他字段的值</span></span><br><span class="line">    obj, created = models.UserInfo.objects.get_or_create(username=<span class="string">'root1'</span>, defaults=&#123;<span class="string">'email'</span>: <span class="string">'1111111'</span>,<span class="string">'u_id'</span>: <span class="number">2</span>, <span class="string">'t_id'</span>: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_or_create</span><span class="params">(self, defaults=None, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 如果存在，则更新，否则，创建</span></span><br><span class="line">    <span class="comment"># defaults 指定创建时或更新时的其他字段</span></span><br><span class="line">    obj, created = models.UserInfo.objects.update_or_create(username=<span class="string">'root1'</span>, defaults=&#123;<span class="string">'email'</span>: <span class="string">'1111111'</span>,<span class="string">'u_id'</span>: <span class="number">2</span>, <span class="string">'t_id'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="comment"># 获取第一个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="comment"># 获取最后一个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_bulk</span><span class="params">(self, id_list=None)</span>:</span></span><br><span class="line">   <span class="comment"># 根据主键ID进行查找</span></span><br><span class="line">   id_list = [<span class="number">11</span>,<span class="number">21</span>,<span class="number">31</span>]</span><br><span class="line">   models.DDD.objects.in_bulk(id_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="comment"># 删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 更新</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="comment"># 是否有结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># select_related:查询主动做连表，一次性获取所有连表中的数据（性能相关：数据量少的情况下使用）</span></span><br><span class="line">q = models.UserInfo.objects.all().select_related(<span class="string">'ut'</span>,<span class="string">'gp'</span>)</span><br><span class="line"><span class="comment">#等价于select * from userinfo inner join usertype on ...</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> q:</span><br><span class="line">    print(row.name,row.ut.title) <span class="comment">#采用.的形式获取连表数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prefetch_related：不做连表，但会做多次查询（性能相关：数据量多，查询频繁下使用）</span></span><br><span class="line"> q = models.UserInfo.objects.all().prefetch_related(<span class="string">'ut'</span>)</span><br><span class="line"><span class="comment"># select * from userinfo;</span></span><br><span class="line"><span class="comment"># Django内部：ut_id = [2,4]</span></span><br><span class="line"><span class="comment"># select * from usertype where id in [2,4]</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> q:</span><br><span class="line">    print(row.id,row.ut.title)</span><br></pre></td></tr></table></figure>
<h3 id="多对多操作"><a href="#多对多操作" class="headerlink" title="多对多操作"></a>多对多操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动创建第三张关联表（推荐，手动更灵活）</span></span><br><span class="line"><span class="comment"># models</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    nick = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Love</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    b = models.ForeignKey(<span class="string">'Boy'</span>,on_delete=<span class="string">''</span>)</span><br><span class="line">    g = models.ForeignKey(<span class="string">'Girl'</span>,on_delete=<span class="string">''</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span> <span class="comment">#添加联合唯一字段</span></span><br><span class="line">    unique_together = [</span><br><span class="line">        (<span class="string">'b'</span>,<span class="string">'g'</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># views</span></span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line">objs = [</span><br><span class="line">    models.Boy(name=<span class="string">'方少伟'</span>),</span><br><span class="line">    models.Boy(name=<span class="string">'由秦兵'</span>),</span><br><span class="line">    models.Boy(name=<span class="string">'陈涛'</span>),</span><br><span class="line">    models.Boy(name=<span class="string">'闫龙'</span>),</span><br><span class="line">    models.Boy(name=<span class="string">'吴彦祖'</span>),</span><br><span class="line">]</span><br><span class="line">models.Boy.objects.bulk_create(objs,<span class="number">5</span>) <span class="comment"># 批量添加数据</span></span><br><span class="line"></span><br><span class="line">objss = [</span><br><span class="line">    models.Girl(nick=<span class="string">'小鱼'</span>),</span><br><span class="line">    models.Girl(nick=<span class="string">'小周'</span>),</span><br><span class="line">    models.Girl(nick=<span class="string">'小猫'</span>),</span><br><span class="line">    models.Girl(nick=<span class="string">'小狗'</span>),</span><br><span class="line">]</span><br><span class="line">models.Girl.objects.bulk_create(objss,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 查询和方少伟有关系的姑娘</span></span><br><span class="line"><span class="comment"># 第一种查询方式：跨表反向查询，获得对象</span></span><br><span class="line"><span class="comment"># obj = models.Boy.objects.filter(name='方少伟').first()</span></span><br><span class="line"><span class="comment"># love_list = obj.love_set.all() # 反向查询，获得所有love表中的对象</span></span><br><span class="line"><span class="comment"># for row in love_list:</span></span><br><span class="line"><span class="comment">#     print(row.g.nick)   # 获得对应的姑娘数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种查询方式：连表查询（正向查询），直接查询love表，获得对象</span></span><br><span class="line"><span class="comment"># love_list = models.Love.objects.filter(b__name='方少伟') #获得Queryset对象</span></span><br><span class="line"><span class="comment"># for row in love_list:</span></span><br><span class="line"><span class="comment">#     print(row.g.nick)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># （推荐）第三种查询方式：只发送一次sql连接请求，获得字典,属于正向查询</span></span><br><span class="line"><span class="comment"># love_list = models.Love.objects.filter(b__name='方少伟').values('g__nick')</span></span><br><span class="line"><span class="comment"># for item in love_list:   # 获得字典格式的列表，[&#123;'g__nick':'xxx&#125;,]                     </span></span><br><span class="line"><span class="comment">#     print(item['g__nick'])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># （推荐）第四种查询方式：相当于inner join方式连表查询，只发送一次sql连接请求，获得对象</span></span><br><span class="line"><span class="comment"># love_list = models.Love.objects.filter(b__name='方少伟').select_related('g')</span></span><br><span class="line"><span class="comment"># for obj in love_list: # 获得对象</span></span><br><span class="line"><span class="comment">#     print(obj.g.nick)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结：多对多都是先获得关联表中的数据，再进行跨表操作</span></span><br><span class="line"><span class="comment"># 对象格式用.（点）进行跨表     字典和元组采用_（双下划线）进行跨表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Django自动生成第三张关联表（无法再手动添加其它字段）</span></span><br><span class="line"><span class="comment"># models</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    m = models.ManyToManyField(<span class="string">'Girl'</span>) <span class="comment">#自动生成关联表m，以两张表中的id字段作为关联字段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    nick = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"><span class="comment"># views</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增</span></span><br><span class="line"><span class="comment"># obj = models.Boy.objects.filter(name='方少伟').first()</span></span><br><span class="line"><span class="comment"># obj.m.add(2)</span></span><br><span class="line"><span class="comment"># obj.m.add(2,4) # 创建关联表的多条数据</span></span><br><span class="line"><span class="comment"># obj.m.add(*[1,3]) # 以列表形式创建多条数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line"><span class="comment"># obj.m.remove(1)</span></span><br><span class="line"><span class="comment"># obj.m.remove(2,3) # 删除关联表的多条数据</span></span><br><span class="line"><span class="comment"># obj.m.remove(*[4,])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># obj.m.set([1,])  # 覆盖数据库所有数据,重置</span></span><br><span class="line"><span class="comment"># obj = models.Boy.objects.filter(name='方少伟').first()</span></span><br><span class="line"><span class="comment"># obj.m.clear() # 删除所有与方少伟的关联数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line"><span class="comment"># 正向查询出单条数据</span></span><br><span class="line"><span class="comment"># obj = models.Boy.objects.filter(name='方少伟').first()</span></span><br><span class="line"><span class="comment"># # girl_list = obj.m.all() </span></span><br><span class="line"><span class="comment"># girl_list = obj.m.filter(nick='小鱼') # 相当于从从表跨表到主表查询</span></span><br><span class="line"><span class="comment"># print(girl_list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向查询出多条数据</span></span><br><span class="line"><span class="comment"># obj = models.Girl.objects.filter(nick='小鱼').first()</span></span><br><span class="line"><span class="comment"># print(obj.id,obj.nick)</span></span><br><span class="line"><span class="comment"># boy_list = obj.boy_set.all()   # 相当于从主表跨表到从表反向查询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动与自动结合</span></span><br><span class="line"><span class="comment"># models</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    m = models.ManyToManyField(to=<span class="string">'Girl'</span>,through=<span class="string">"Love"</span>,through_fields=(<span class="string">'b'</span>,<span class="string">'g'</span>,))</span><br><span class="line">    <span class="comment"># 可不写to关键字</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    nick = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Love</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    b = models.ForeignKey(<span class="string">'Boy'</span>,on_delete=<span class="string">''</span>)</span><br><span class="line">    g = models.ForeignKey(<span class="string">'Girl'</span>,on_delete=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        unique_together = [</span><br><span class="line">            (<span class="string">'b'</span>,<span class="string">'g'</span>),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># views</span></span><br><span class="line"></span><br><span class="line">obj = models.Boy.objects.filter(name=<span class="string">'方少伟'</span>).first()</span><br><span class="line">obj.m.add(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># obj.m.remove(1)</span></span><br><span class="line"><span class="comment"># obj.m.clear() 可以</span></span><br><span class="line">v = obj.m.all()</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure>
<h3 id="连表操作（多对多自关联）"><a href="#连表操作（多对多自关联）" class="headerlink" title="连表操作（多对多自关联）"></a>连表操作（多对多自关联）</h3><p>原理：等同于复制出一张新表<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    nickname = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">    gender_choices = (</span><br><span class="line">        (<span class="number">1</span>,<span class="string">'男'</span>),</span><br><span class="line">        (<span class="number">2</span>,<span class="string">'女'</span>),</span><br><span class="line">    )</span><br><span class="line">    gender = models.IntegerField(choices=gender_choices)</span><br><span class="line">    m = models.ManyToManyField(<span class="string">'UserInfo'</span>) <span class="comment"># 多对多自关联字段，自动生成第二张表，字段分别为from_userinfo_id和to_userinfo_id; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表中的m属性不会在userinfo表中生成m字段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="comment"># 查男生（通过m字段查询属于正向操作）</span></span><br><span class="line">xz = models.UserInfo.objects.filter(id=<span class="number">1</span>).first() <span class="comment">#id为1代表男生的1条数据</span></span><br><span class="line">u = xz.m.all()</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> u:</span><br><span class="line">    print(row.nickname)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查女生(通过表名称_set查询属于反向操作)</span></span><br><span class="line">xz = models.UserInfo.objects.filter(id=<span class="number">4</span>).first() <span class="comment">#id为4代表女生的1条数据</span></span><br><span class="line">v = xz.userinfo_set.all()</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> v:</span><br><span class="line">    print(row.nickname)</span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure><br><strong>外键自关联（常用于评论表功能）</strong><br>等同于复制出一张新表，用原表中的外键作连表操作<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    评论表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    news_id = models.IntegerField()            <span class="comment"># 新闻ID</span></span><br><span class="line">    content = models.CharField(max_length=<span class="number">32</span>)  <span class="comment"># 评论内容</span></span><br><span class="line">    user = models.CharField(max_length=<span class="number">32</span>)     <span class="comment"># 评论者</span></span><br><span class="line">    reply = models.ForeignKey(<span class="string">'Comment'</span>,null=<span class="literal">True</span>,blank=<span class="literal">True</span>,related_name=<span class="string">'xxxx'</span>) <span class="comment">#related_name表示反向查询时，代替 表名_set 和 表名__字段名 </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   新闻ID                         reply_id</span></span><br><span class="line"><span class="string">1   1        别比比    root         null</span></span><br><span class="line"><span class="string">2   1        就比比    root         null</span></span><br><span class="line"><span class="string">3   1        瞎比比    shaowei      null</span></span><br><span class="line"><span class="string">4   2        写的正好  root         null</span></span><br><span class="line"><span class="string">5   1        拉倒吧    由清滨         2</span></span><br><span class="line"><span class="string">6   1        拉倒吧1    xxxxx         2</span></span><br><span class="line"><span class="string">7   1        拉倒吧2    xxxxx         5</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">新闻1</span></span><br><span class="line"><span class="string">    别比比</span></span><br><span class="line"><span class="string">    就比比</span></span><br><span class="line"><span class="string">        - 拉倒吧</span></span><br><span class="line"><span class="string">            - 拉倒吧2</span></span><br><span class="line"><span class="string">        - 拉倒吧1</span></span><br><span class="line"><span class="string">    瞎比比</span></span><br><span class="line"><span class="string">新闻2：</span></span><br><span class="line"><span class="string">    写的正好</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>分组获取数据<code>UserGroup.objects.all()[10:20]</code></p>
<h3 id="内置分页"><a href="#内置分页" class="headerlink" title="内置分页"></a>内置分页</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator,Page,PageNotAnInteger,EmptyPage</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">	user_list = models.UserInfo.objects.all() <span class="comment">#获得所有数据库数据</span></span><br><span class="line">	paginator = Paginator(user_list,<span class="number">10</span>) <span class="comment">#设置每页显示的总条数</span></span><br><span class="line">	current_page = request.GET.get(<span class="string">'page'</span>)<span class="comment"># 获得当前页数</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">	    posts = paginator.page(current_page) <span class="comment">#设置当前页数对应的数据</span></span><br><span class="line">	<span class="keyword">except</span> PageNotAnInteger <span class="keyword">as</span> e: <span class="comment">#当前页面数非整数</span></span><br><span class="line">	    posts = paginator.page(<span class="number">1</span>) </span><br><span class="line">	<span class="keyword">except</span> EmptyPage <span class="keyword">as</span> e: <span class="comment">#当前页码数为空</span></span><br><span class="line">	    posts = paginator.page(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,&#123;<span class="string">'posts'</span>:posts&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for row in posts.object_list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; row.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if posts.has_previous %&#125; #是否有上一页</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/index.html?page=&#123;&#123; posts.previous_page_number &#125;&#125;"</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% if posts.has_next %&#125; #是否有下一页</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/index.html?page=&#123;&#123; posts.next_page_number &#125;&#125;"</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义分页"><a href="#自定义分页" class="headerlink" title="自定义分页"></a>自定义分页</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> utils.pager <span class="keyword">import</span> PageInfo</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom</span><span class="params">(request)</span>:</span></span><br><span class="line">    all_count = models.UserInfo.objects.all().count() </span><br><span class="line">    page_info = PageInfo(request.GET.get(<span class="string">'page'</span>),all_count,<span class="number">10</span>,<span class="string">'/custom.html'</span>,<span class="number">11</span>)</span><br><span class="line">    user_list = models.UserInfo.objects.all()[page_info.start():page_info.end()]</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'custom.html'</span>,&#123;<span class="string">'user_list'</span>:user_list,<span class="string">'page_info'</span>:page_info&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageInfo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,current_page,all_count,per_page,base_url,show_page=<span class="number">11</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param current_page:</span></span><br><span class="line"><span class="string">        :param all_count: 数据库总行数</span></span><br><span class="line"><span class="string">        :param per_page: 每页显示行数</span></span><br><span class="line"><span class="string">        :param base_url:</span></span><br><span class="line"><span class="string">        :param show_page:分页码范围，默认为11</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.current_page = int(current_page)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            self.current_page = <span class="number">1</span></span><br><span class="line">        self.per_page=per_page</span><br><span class="line">        a,b = divmod(all_count,per_page) <span class="comment">#返回一个包含商和余数的元组</span></span><br><span class="line">        <span class="keyword">if</span> b: <span class="comment"># 数据库总数/页面总数后还有多余的数据，所以还需要加1页来显示剩余的数据</span></span><br><span class="line">            a = a+<span class="number">1</span></span><br><span class="line">        self.all_pager= a <span class="comment"># 总页数</span></span><br><span class="line">        self.show_page= show_page</span><br><span class="line">        self.base_url= base_url</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 页码数对应的展示数据内容</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.current_page<span class="number">-1</span>) * self.per_page <span class="comment"># 起始数据位置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.current_page * self.per_page</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 组装分页模块</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pager</span><span class="params">(self)</span>:</span></span><br><span class="line">        page_list=[]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算中间页码数显示起始数和结尾数</span></span><br><span class="line">        half = int((self.show_page<span class="number">-1</span>)/<span class="number">2</span>) <span class="comment"># 中间页码数</span></span><br><span class="line">        <span class="comment"># 如果数据总页数 &lt; 分页码范围11</span></span><br><span class="line">        <span class="keyword">if</span> self.all_pager &lt; self.show_page:</span><br><span class="line">            begin =<span class="number">1</span></span><br><span class="line">            stop=self.all_pager + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果数据总页数 &gt; 分页码范围11</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果当前页 &lt;=5,永远显示1,11</span></span><br><span class="line">            <span class="keyword">if</span> self.current_page &lt;= half:</span><br><span class="line">                begin =<span class="number">1</span></span><br><span class="line">                stop = self.show_page + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.current_page + half &gt; self.all_pager:</span><br><span class="line">                    begin = self.all_pager - self.show_page + <span class="number">1</span></span><br><span class="line">                    stop = self.all_pager + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    begin = self.current_page - half</span><br><span class="line">                    stop = self.current_page + half + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 组装‘上一页’选项</span></span><br><span class="line">        <span class="keyword">if</span> self.current_page &lt;= <span class="number">1</span>:</span><br><span class="line">            prev = <span class="string">"&lt;li&gt;&lt;a href='#'&gt;上一页&lt;/a&gt;&lt;/li&gt;"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev = <span class="string">"&lt;li&gt;&lt;a href='%s?page=%s'&gt;上一页&lt;/a&gt;&lt;/li&gt;"</span>%(self.base_url,self.current_page<span class="number">-1</span>,)</span><br><span class="line">        page_list.append(prev)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 组装中间页码数显示</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(begin, stop):</span><br><span class="line">            <span class="keyword">if</span> i == self.current_page:</span><br><span class="line">                temp = <span class="string">"&lt;li class='active'&gt;&lt;a  href='%s?page=%s'&gt;%s&lt;/a&gt;&lt;/li&gt;"</span> % (self.base_url, i, i,)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = <span class="string">"&lt;li&gt;&lt;a href='%s?page=%s'&gt;%s&lt;/a&gt;&lt;/li&gt;"</span> % (self.base_url, i, i,)</span><br><span class="line">            page_list.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 组装'下一页'选项</span></span><br><span class="line">        <span class="keyword">if</span> self.current_page &gt;= self.all_pager:</span><br><span class="line">            nex = <span class="string">"&lt;li&gt;&lt;a href='#'&gt;下一页&lt;/a&gt;&lt;/li&gt;"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nex = <span class="string">"&lt;li&gt;&lt;a href='%s?page=%s'&gt;下一页&lt;/a&gt;&lt;/li&gt;"</span> %(self.base_url,self.current_page+<span class="number">1</span>,)</span><br><span class="line">        page_list.append(nex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(page_list)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for row in user_list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; row.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">aria-label</span>=<span class="string">"Page navigation"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">      &#123;&#123; page_info.pager|safe &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="XSS攻击-跨站脚本攻击"><a href="#XSS攻击-跨站脚本攻击" class="headerlink" title="XSS攻击(跨站脚本攻击)"></a>XSS攻击(跨站脚本攻击)</h2><p>页面script代码攻击(如评论中的scrpt代码攻击)<br>item中如果有script代码会自动执行<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% for item in msg %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; item|safe&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> #需要给响应的值添加safe</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CSRF-跨站请求伪装攻击"><a href="#CSRF-跨站请求伪装攻击" class="headerlink" title="CSRF(跨站请求伪装攻击)"></a>CSRF(跨站请求伪装攻击)</h2><p><strong>方法1</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"/csrf1.html"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;   # 需添加服务器发送的csrf随机字符串，才能访问成功</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"submitForm();"</span>&gt;</span>Ajax提交<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>方法2</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">submitForm</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">        var token = $.cookie('csrftoken'); # 获得浏览器里cookies中的csrf随机字符串</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> user = $(<span class="string">'#user'</span>).val();</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">            url: <span class="string">'/csrf1.html'</span>,</span></span><br><span class="line"><span class="actionscript">            type: <span class="string">'POST'</span>,</span></span><br><span class="line">            headers:&#123;'X-CSRFToken': token&#125;, # 将数据添加到请求头中，让Django去取，硬性规定</span><br><span class="line"><span class="actionscript">            data: &#123; <span class="string">"user"</span>:user&#125;,</span></span><br><span class="line"><span class="actionscript">            success:<span class="function"><span class="keyword">function</span><span class="params">(arg)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(arg);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="simple-tag和filter"><a href="#simple-tag和filter" class="headerlink" title="simple_tag和filter"></a>simple_tag和filter</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; name|upper &#125;&#125; # upper表示内置函数,将所有字母变大写</span><br></pre></td></tr></table></figure>
<p><strong>自定义函数</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 步骤1 创建templatetags文件夹，再创建xx.py模块</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line">register = template.Library() <span class="comment"># 规定写法，不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register.filter # 该定义的方法只能传入2个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_upper</span><span class="params">(value,arg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> value + arg</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.filter  # 应用于html模版中的if判断语名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_bool</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register.simple_tag # 推荐使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_lower</span><span class="params">(value,a1,a2,a3)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> value + a1 + a2 + a3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.views</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'test.html'</span>,&#123;<span class="string">'name'</span>:<span class="string">'aaaaAA'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. html</span></span><br><span class="line"><span class="comment"># &#123;% load xx %&#125;&#123;#导入加载xx模块#&#125;</span></span><br><span class="line"><span class="comment"># &lt;h2&gt;filter&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">#     &#123;&#123; name|my_upper:"666" &#125;&#125; # 最多支持2个参数</span></span><br><span class="line"><span class="comment">#     &#123;&#123; name|upper &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     &#123;% if name|my_bool %&#125;</span></span><br><span class="line"><span class="comment">#         &lt;h3&gt;真&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">#     &#123;% else %&#125;</span></span><br><span class="line"><span class="comment">#         &lt;h3&gt;假&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">#     &#123;% endif %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;h2&gt;tag&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">#     &#123;% my_lower "ALEX" "x" "SB" "V" %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. setting注册程序块</span></span><br></pre></td></tr></table></figure></p>
<h2 id="include小组件"><a href="#include小组件" class="headerlink" title="include小组件"></a>include小组件</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// pub.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>特别漂亮的组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>标题：&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>内容：&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">&#123;% include 'pub.html' %&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h2 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h2><p>admin<br>django amdin是django提供的一个后台管理页面，改管理页面提供完善的html和css，使得你在通过Model创建完数据库表之后，就可以对数据进行增删改查，而使用django admin 则需要以下步骤：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建后台管理员</span></span><br><span class="line"><span class="comment"># 配置url</span></span><br><span class="line"><span class="comment"># 注册和配置django admin后台管理页面</span></span><br><span class="line"><span class="comment"># 1、创建后台管理员</span></span><br><span class="line"><span class="comment"># python manage.py createsuperuser</span></span><br><span class="line"><span class="comment"># 2、配置后台管理url</span></span><br><span class="line"><span class="comment"># url(r'^admin/', include(admin.site.urls))</span></span><br><span class="line"><span class="comment"># 3、注册和配置django admin 后台管理页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a、在admin中执行如下配置</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span>  models</span><br><span class="line">  </span><br><span class="line">admin.site.register(models.UserType)</span><br><span class="line">admin.site.register(models.UserInfo)</span><br><span class="line">admin.site.register(models.UserGroup)</span><br><span class="line">admin.site.register(models.Asset)</span><br><span class="line"><span class="comment"># b、设置数据表名称</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserType</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = <span class="string">'用户类型'</span></span><br><span class="line">        verbose_name_plural = <span class="string">'用户类型'</span></span><br><span class="line"><span class="comment"># c、打开表之后，设定默认显示，需要在model中作如下配置</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserType</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__unicode__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span>  models</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = (<span class="string">'username'</span>, <span class="string">'password'</span>, <span class="string">'email'</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">admin.site.register(models.UserType)</span><br><span class="line">admin.site.register(models.UserInfo,UserInfoAdmin)</span><br><span class="line">admin.site.register(models.UserGroup)</span><br><span class="line">admin.site.register(models.Asset)</span><br><span class="line"><span class="comment"># d、为数据表添加搜索功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span>  models</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = (<span class="string">'username'</span>, <span class="string">'password'</span>, <span class="string">'email'</span>)</span><br><span class="line">    search_fields = (<span class="string">'username'</span>, <span class="string">'email'</span>)</span><br><span class="line">  </span><br><span class="line">admin.site.register(models.UserType)</span><br><span class="line">admin.site.register(models.UserInfo,UserInfoAdmin)</span><br><span class="line">admin.site.register(models.UserGroup)</span><br><span class="line">admin.site.register(models.Asset)</span><br><span class="line"><span class="comment"># e、添加快速过滤</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span>  models</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = (<span class="string">'username'</span>, <span class="string">'password'</span>, <span class="string">'email'</span>)</span><br><span class="line">    search_fields = (<span class="string">'username'</span>, <span class="string">'email'</span>)</span><br><span class="line">    list_filter = (<span class="string">'username'</span>, <span class="string">'email'</span>)</span><br><span class="line">      </span><br><span class="line">admin.site.register(models.UserType)</span><br><span class="line">admin.site.register(models.UserInfo,UserInfoAdmin)</span><br><span class="line">admin.site.register(models.UserGroup)</span><br><span class="line">admin.site.register(models.Asset)</span><br></pre></td></tr></table></figure></p>
<h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><blockquote>
<p>cookie是保存在客户端浏览器上的键值对，<br>Session是保存在服务端的数据（本质是键值对），用于保持会话<br>因为单独使用cookies，它会保留用户具体的明文形式（不转化成字符串的敏感信息）发送给浏览器（不安全），所以推荐使用session，<br>session发送的是随机字符串，不包含用户敏感信息（安全），其中session依赖于cookies,在服务端储存的是{随机字符串：键值对}</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'login.html'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        u = request.POST.get(<span class="string">'user'</span>)</span><br><span class="line">        p = request.POST.get(<span class="string">'pwd'</span>)</span><br><span class="line">        obj = models.UserAdmin.objects.filter(username=u,password=p).first()</span><br><span class="line">        <span class="keyword">if</span> obj:</span><br><span class="line">            <span class="comment"># 1. 生成随机字符串</span></span><br><span class="line">            <span class="comment"># 2. 通过cookie发送给客户端</span></span><br><span class="line">            <span class="comment"># 3. 服务端保存</span></span><br><span class="line">            <span class="comment"># &#123;</span></span><br><span class="line">            <span class="comment">#   随机字符串1: &#123;'username':'alex','email':x''...&#125;</span></span><br><span class="line">            <span class="comment"># &#125;</span></span><br><span class="line">            request.session[<span class="string">'username'</span>] = obj.username</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">'/index/'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">'login.html'</span>,&#123;<span class="string">'msg'</span>:<span class="string">'用户名或密码错误'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="comment"># 获取客户端cookies中的随机字符串，去session中查找有无该字符串， 再通过字符串去session对应key的value中查看是有username，并获得它对应的值</span></span><br><span class="line"></span><br><span class="line">    v = request.session.get(<span class="string">'username'</span>)   <span class="comment">#  v为username对应的具体值</span></span><br><span class="line">    <span class="keyword">if</span> v:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'登录成功:%s'</span> %v)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/login/'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="session的方法"><a href="#session的方法" class="headerlink" title="session的方法"></a>session的方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">     <span class="comment"># 获取、设置、删除Session中数据</span></span><br><span class="line">     request.session[<span class="string">'k1'</span>]</span><br><span class="line">     request.session.get(<span class="string">'k1'</span>,<span class="literal">None</span>)</span><br><span class="line">     request.session[<span class="string">'k1'</span>] = <span class="number">123</span></span><br><span class="line">     request.session.setdefault(<span class="string">'k1'</span>,<span class="number">123</span>) <span class="comment"># 存在则不设置</span></span><br><span class="line">     <span class="keyword">del</span> request.session[<span class="string">'k1'</span>]</span><br><span class="line"> </span><br><span class="line">     <span class="comment"># 所有 键、值、键值对</span></span><br><span class="line">     request.session.keys()</span><br><span class="line">     request.session.values()</span><br><span class="line">     request.session.items()</span><br><span class="line">     request.session.iterkeys()</span><br><span class="line">     request.session.itervalues()</span><br><span class="line">     request.session.iteritems()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     <span class="comment"># 用户session的随机字符串</span></span><br><span class="line">     request.session.session_key</span><br><span class="line"> </span><br><span class="line">     <span class="comment"># 将所有Session失效日期小于当前日期的数据删除</span></span><br><span class="line">     request.session.clear_expired()</span><br><span class="line"> </span><br><span class="line">     <span class="comment"># 检查 用户session的随机字符串 在数据库中是否</span></span><br><span class="line">     request.session.exists(<span class="string">"session_key"</span>)</span><br><span class="line"> </span><br><span class="line">     <span class="comment"># 删除当前用户的所有Session数据</span></span><br><span class="line">     request.session.delete(<span class="string">"session_key"</span>)</span><br><span class="line"> </span><br><span class="line">     request.session.set_expiry(value)</span><br><span class="line">         * 如果value是个整数，session会在些秒数后失效。</span><br><span class="line">         * 如果value是个datatime或timedelta，session就会在这个时间后失效。</span><br><span class="line">         * 如果value是<span class="number">0</span>,用户关闭浏览器session就会失效。</span><br><span class="line">         * 如果value是<span class="literal">None</span>,session会依赖全局session失效策略。</span><br></pre></td></tr></table></figure>
<p>settings<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># SESSION_COOKIE_NAME = "sessionid"                        # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串</span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_PATH = "/"                                # Session的cookie保存的路径</span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_DOMAIN = None                              # Session的cookie保存的域名</span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_SECURE = False                             # 是否Https传输cookie</span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_HTTPONLY = True                            # 是否Session的cookie只支持http传输</span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_AGE = 1209600                              # Session的cookie失效日期（2周）</span></span><br><span class="line"><span class="comment"># SESSION_EXPIRE_AT_BROWSER_CLOSE = False                   # 是否关闭浏览器使得Session过期</span></span><br><span class="line"><span class="comment"># SESSION_SAVE_EVERY_REQUEST = False（推荐True）             # 是否每次请求都保存Session，默认修改之后才保存</span></span><br><span class="line"></span><br><span class="line">SESSION_ENGINE = <span class="string">'django.contrib.sessions.backends.db'</span>   <span class="comment"># 数据库（默认）</span></span><br><span class="line">SESSION_ENGINE = <span class="string">'django.contrib.sessions.backends.cached_db'</span>   <span class="comment">#引擎，缓存+数据库，推荐使用</span></span><br><span class="line">SESSION_ENGINE = <span class="string">'django.contrib.sessions.backends.cache'</span>  <span class="comment"># 缓存</span></span><br><span class="line">SESSION_ENGINE = <span class="string">'django.contrib.sessions.backends.file'</span> <span class="comment"># 文件</span></span><br><span class="line">SESSION_ENGINE = <span class="string">'django.contrib.sessions.backends.signed_cookies'</span>  <span class="comment"># cookie</span></span><br><span class="line">SESSION_CACHE_ALLAS =<span class="string">'default'</span>                             <span class="comment"># 使用缓存别名</span></span><br></pre></td></tr></table></figure></p>
<h2 id="用户登录demo"><a href="#用户登录demo" class="headerlink" title="用户登录demo"></a>用户登录demo</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># model</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    nickname = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">63</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    nickname = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">63</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2G</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    b = models.ForeignKey(to=<span class="string">'Boy'</span>, to_field=<span class="string">'id'</span>,on_delete=<span class="string">''</span>)</span><br><span class="line">    g = models.ForeignKey(to=<span class="string">'Girl'</span>, to_field=<span class="string">'id'</span>,on_delete=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># urls</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    url(<span class="string">r'^login.html$'</span>, account.login),</span><br><span class="line">    url(<span class="string">r'^index.html$'</span>, love.index),</span><br><span class="line">    url(<span class="string">r'^loginout.html$'</span>,account.loginout),</span><br><span class="line">    url(<span class="string">r'^others.html$'</span>,love.others),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># views/account</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse,redirect</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户登陆 </span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'login.html'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        user = request.POST.get(<span class="string">'username'</span>)</span><br><span class="line">        pwd = request.POST.get(<span class="string">'password'</span>)</span><br><span class="line">        gender = request.POST.get(<span class="string">'gender'</span>)</span><br><span class="line">        rmb = request.POST.get(<span class="string">'rmb'</span>)</span><br><span class="line">        <span class="comment"># 性别判断</span></span><br><span class="line">        <span class="keyword">if</span> gender == <span class="string">"1"</span>:</span><br><span class="line">            obj = models.Boy.objects.filter(username=user,password=pwd).first()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj = models.Girl.objects.filter(username=user,password=pwd).first()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj:</span><br><span class="line">            <span class="comment"># 未登录</span></span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">'login.html'</span>,&#123;<span class="string">'msg'</span>: <span class="string">'用户名或密码错误'</span>&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            request.session[<span class="string">'user_info'</span>] = &#123;<span class="string">'user_id'</span>:obj.id,<span class="string">'gender'</span>:gender,<span class="string">'username'</span>:user,<span class="string">'nickname'</span>:obj.nickname&#125;</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">'/index.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loginout</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    注销</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">'user_info'</span>):</span><br><span class="line">        request.session.clear() <span class="comment"># 清除服务端数据库session（推荐）</span></span><br><span class="line">        <span class="comment"># request.session.delete(request.session.session_key) # 清除客户端cookie中的session</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">'/login.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># views/love</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,redirect,HttpResponse</span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    首页信息展示</span></span><br><span class="line"><span class="string">    :param request: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.session.get(<span class="string">'user_info'</span>): <span class="comment"># 获取浏览器中的session随机字符串</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/login.html'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 男：女生列表</span></span><br><span class="line">        <span class="comment"># 女：男生列表</span></span><br><span class="line">        gender = request.session.get(<span class="string">'user_info'</span>).get(<span class="string">'gender'</span>)</span><br><span class="line">        <span class="keyword">if</span> gender == <span class="string">'1'</span>:</span><br><span class="line">            user_list  = models.Girl.objects.all()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            user_list = models.Boy.objects.all()</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,&#123;<span class="string">'user_list'</span>:user_list&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">others</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取与当前用户有关系的异性</span></span><br><span class="line"><span class="string">    :param request:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    current_user_id = request.session.get(<span class="string">'user_info'</span>).get(<span class="string">'user_id'</span>)</span><br><span class="line">    gender = request.session.get(<span class="string">'user_info'</span>).get(<span class="string">'gender'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gender == <span class="string">'1'</span>:</span><br><span class="line">        user_list = models.B2G.objects.filter(b_id=current_user_id).values(<span class="string">'g__nickname'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        user_list = models.B2G.objects.filter(g_id=current_user_id).values(<span class="string">'b__nickname'</span>)</span><br><span class="line">    print(<span class="string">'result'</span>, user_list)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'others.html'</span>,&#123;<span class="string">'user_list'</span>:user_list&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># login.html</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"/login.html"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        性别：</span><br><span class="line">            男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">            女<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"rmb"</span> <span class="attr">value</span>=<span class="string">"11"</span>  /&gt;</span> 一个月免登录</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span>&#123;&#123; msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 建立html组件：user_header</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前用户:&#123;&#123; request.session.user_info.nickname &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/logout.html"</span>&gt;</span>注销<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># index.html</span><br><span class="line">&#123;% include 'user_header.html' %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>异性列表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/others.html"</span>&gt;</span>查看和我有关系的异性<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for row in user_list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; row.nickname &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># others.html</span><br><span class="line">&#123;% include 'user_header.html' %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>有关系的异性列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for row in user_list %&#125;</span><br><span class="line">        &#123;% if row.g__nickname %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; row.g__nickname &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; row.b__nickname &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p><img src="1.png" alt=""><br>中间件是django路由转发之前或返回response时进行的操作。用于对所有请求或一部分请求做批量处理。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle1</span><span class="params">(MiddleMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 一般不要返回值，否则会阻止之后的中间件执行，从最后一个中间件的process_response返回，（旧版本从当前的request返回）</span></span><br><span class="line">        print(<span class="string">"asxafs"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,request,response)</span>:</span></span><br><span class="line">        <span class="comment"># 必须有返回值</span></span><br><span class="line">        print(<span class="string">"print"</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"><span class="comment"># process_request(self,request)</span></span><br><span class="line"><span class="comment"># process_view(self, request, callback, callback_args, callback_kwargs)</span></span><br><span class="line"><span class="comment"># process_template_response(self,request,response)  # 视图函数中有render才会执行</span></span><br><span class="line"><span class="comment"># process_exception(self, request, exception)</span></span><br><span class="line"><span class="comment"># process_response(self, request, response)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="MVC和MTV"><a href="#MVC和MTV" class="headerlink" title="MVC和MTV"></a>MVC和MTV</h2><p>文件划分方式<br>MVC： model(数据库，模型) views(模版) controller(业务处理)<br>MTV： model(数据库，模型) template(模板) views(业务逻辑)</p>
<p>django ： MTV</p>
<h2 id="Form组件"><a href="#Form组件" class="headerlink" title="Form组件"></a>Form组件</h2><p>需要对请求的数据进行验证<br>一般form提交，如果不满足要求：</p>
<ul>
<li>判断后无法记住上次输出，页面会刷新。</li>
</ul>
<h3 id="一般Form组件的使用"><a href="#一般Form组件的使用" class="headerlink" title="一般Form组件的使用"></a>一般Form组件的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> Form,fields</span><br><span class="line"><span class="comment"># -------定义Form验证规则类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span><span class="params">(Form)</span>:</span></span><br><span class="line">    <span class="comment"># html标签name属性=Form类的字段名</span></span><br><span class="line">    <span class="comment"># 正则验证: 不能为空,6-18</span></span><br><span class="line">    username = fields.CharField(</span><br><span class="line">        max_length=<span class="number">18</span>,</span><br><span class="line">        min_length=<span class="number">6</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">            <span class="string">'required'</span>: <span class="string">'用户名不能为空'</span>,</span><br><span class="line">            <span class="string">'min_length'</span>: <span class="string">'太短了'</span>,</span><br><span class="line">            <span class="string">'max_length'</span>: <span class="string">'太长了'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 正则验证: 不能为空，16+</span></span><br><span class="line">    password = fields.CharField(min_length=<span class="number">16</span>,required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span>  <span class="comment">#Form表单提交形式</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'login.html'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       obj = LoginForm(request.POST) <span class="comment">#将提交的数据交给Form组件验证</span></span><br><span class="line">       <span class="keyword">if</span> obj.is_valid():</span><br><span class="line">           <span class="comment"># 用户输入格式正确</span></span><br><span class="line">           print(obj.cleaned_data) <span class="comment"># 字典类型,只包含Form组件校验后的字段数据</span></span><br><span class="line">           <span class="keyword">return</span> redirect(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="comment"># 用户输入格式错误</span></span><br><span class="line">           print(obj.errors)</span><br><span class="line">           <span class="keyword">return</span> render(request,<span class="string">'login.html'</span>,&#123;<span class="string">'obj'</span>:obj&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/login/"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span>&#123;&#123;obj.errors.username.0 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>&#123;&#123;obj.errors.password.0  &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Form和Ajax提交验证（Ajax提交不会刷新，上次内容自动保留）"><a href="#Form和Ajax提交验证（Ajax提交不会刷新，上次内容自动保留）" class="headerlink" title="Form和Ajax提交验证（Ajax提交不会刷新，上次内容自动保留）"></a>Form和Ajax提交验证（Ajax提交不会刷新，上次内容自动保留）</h3><p><a href="https://www.cnblogs.com/wupeiqi/articles/6144178.html" target="_blank" rel="noopener">https://www.cnblogs.com/wupeiqi/articles/6144178.html</a><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"f1"</span> <span class="attr">action</span>=<span class="string">"/login/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span> /&gt;</span>&#123;&#123; obj.errors.user.0 &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span> /&gt;</span>&#123;&#123; obj.errors.pwd.0 &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"submitForm();"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/jquery-1.12.4.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">submitForm</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'.c1'</span>).remove();</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">            url: <span class="string">'/ajax_login/'</span>,</span></span><br><span class="line"><span class="actionscript">            type: <span class="string">'POST'</span>,</span></span><br><span class="line"><span class="javascript">            data: $(<span class="string">'#f1'</span>).serialize(),<span class="comment">// 序列化：user=alex&amp;pwd=456&amp;csrftoen=dfdf</span></span></span><br><span class="line"><span class="actionscript">            dataType:<span class="string">"JSON"</span>,</span></span><br><span class="line"><span class="actionscript">            success:<span class="function"><span class="keyword">function</span><span class="params">(arg)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(arg);</span></span><br><span class="line">                if(arg.status)&#123;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">                    $.each(arg.msg,function(index,value)&#123;  #index为字段名，value为错误值                     </span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> tag = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span></span><br><span class="line">                        tag.innerHTML = value[0];</span><br><span class="line"><span class="actionscript">                        tag.className = <span class="string">'c1'</span>;</span></span><br><span class="line"><span class="javascript">                        $(<span class="string">'#f1'</span>).find(<span class="string">'input[name="'</span>+ index +<span class="string">'"]'</span>).after(tag);</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span><span class="params">(Form)</span>:</span> <span class="comment">#定义Form组件类，用来验证请求数据</span></span><br><span class="line">    user = fields.CharField(required=<span class="literal">True</span>,min_length=<span class="number">6</span>)</span><br><span class="line">    pwd = fields.CharField(min_length=<span class="number">18</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ajax_login</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line">    ret=&#123;<span class="string">'status'</span>:<span class="literal">True</span>,<span class="string">'msg'</span>:<span class="literal">None</span>&#125;</span><br><span class="line">    obj = LoginForm(request.POST)</span><br><span class="line">    <span class="keyword">if</span> obj.is_valid():</span><br><span class="line">        print(obj.cleaned_data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ret[<span class="string">'status'</span>]=<span class="literal">False</span></span><br><span class="line">        ret[<span class="string">'msg'</span>]=obj.errors <span class="comment"># 获得字典，k为字段名，v为错误信息列表</span></span><br><span class="line">    v=json.dumps(ret)</span><br><span class="line">    print(obj.errors) <span class="comment">#print时，会自动调用__str__(),在该方法中将字典组装成了&lt;ul&gt;标签</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(v)</span><br></pre></td></tr></table></figure>
<h3 id="Form组件常见字段"><a href="#Form组件常见字段" class="headerlink" title="Form组件常见字段"></a>Form组件常见字段</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForm</span><span class="params">(Form)</span>:</span></span><br><span class="line">    t1 = fields.CharField(</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        max_length=<span class="number">8</span>,</span><br><span class="line">        min_length=<span class="number">2</span>,</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">            <span class="string">'required'</span>: <span class="string">'不能为空'</span>,</span><br><span class="line">            <span class="string">'max_length'</span>: <span class="string">'太长'</span>,</span><br><span class="line">            <span class="string">'min_length'</span>: <span class="string">'太短'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    t2 = fields.IntegerField(</span><br><span class="line">        min_value=<span class="number">10</span>,</span><br><span class="line">        max_value=<span class="number">1000</span>,</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">            <span class="string">'required'</span>: <span class="string">'t2不能为空'</span>,</span><br><span class="line">            <span class="string">'invalid'</span>: <span class="string">'t2格式错误，必须是数字'</span>,  <span class="comment"># 格式错误</span></span><br><span class="line">            <span class="string">'min_value'</span>: <span class="string">'必须大于10'</span>,</span><br><span class="line">            <span class="string">'max_value'</span>: <span class="string">'必须小于1000'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    t3 = fields.EmailField(</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">            <span class="string">'required'</span>: <span class="string">'t3不能为空'</span>,</span><br><span class="line">            <span class="string">'invalid'</span>: <span class="string">'t3格式错误，必须是邮箱格式'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 为空，长度，格式，正则</span></span><br><span class="line">    t4=fields.URLField()</span><br><span class="line">    t5=fields.SlugField()</span><br><span class="line">    t6=fields.GenericIPAddressField()</span><br><span class="line">    t7=fields.DateField()</span><br><span class="line">    t8=fields.DateTimeField()</span><br><span class="line">    t9=fields.RegexField(<span class="string">'139\d+'</span>)  <span class="comment"># 自定义正则表达式的字段验证规则</span></span><br><span class="line"></span><br><span class="line">widget=widgets.Select, <span class="comment"># ******** 用于指定生成怎样的HTML，select，text,input/. # 插件 </span></span><br><span class="line">label=<span class="string">'用户名'</span>,  <span class="comment"># 在前端可以通过obj.t1.label使用</span></span><br><span class="line">disabled=<span class="literal">False</span>,              <span class="comment"># 是否可以编辑</span></span><br><span class="line">label_suffix=<span class="string">'---&gt;'</span>,            <span class="comment"># Label内容后缀  需要在html模版中添加&#123;&#123; obj.as_p &#125;&#125;来显示出所有Form类中定义的字段</span></span><br><span class="line">initial=<span class="string">'666'</span>,            <span class="comment"># 无用，猜测有问题应该在input框中显示默认值</span></span><br><span class="line">help_text=<span class="string">'。。。。。。'</span>,  <span class="comment"># 提供帮助信息</span></span><br></pre></td></tr></table></figure>
<h3 id="Form组件之保留上次输入框内容"><a href="#Form组件之保留上次输入框内容" class="headerlink" title="Form组件之保留上次输入框内容"></a>Form组件之保留上次输入框内容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 采用Form组件生成的表单组件作为页面标签才能完成保留上次输入框的数据</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/register/"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">novalidate</span>&gt;</span> #novalidate是忽略浏览器的表单验证规则</span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; obj.user &#125;&#125; &#123;&#123; obj.errors.user.0 &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; obj.email &#125;&#125; &#123;&#123; obj.errors.email.0 &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; obj.password &#125;&#125; &#123;&#123; obj.errors.password.0 &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; obj.phone &#125;&#125; &#123;&#123; obj.errors.phone.0 &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>  /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegiterForm</span><span class="params">(Form)</span>:</span></span><br><span class="line">    user = fields.CharField(min_length=<span class="number">8</span>)</span><br><span class="line">    email = fields.EmailField()</span><br><span class="line">    password = fields.CharField()</span><br><span class="line">    phone = fields.RegexField(<span class="string">'139\d+'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        obj = RegiterForm()</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'register.html'</span>,&#123;<span class="string">'obj'</span>:obj&#125;) <span class="comment"># 只返回表单组件类的HTML文本，无数值返回</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        obj = RegiterForm(request.POST) <span class="comment"># 因用户提交了数据，Form组件会返回带有输入框值的HTML文本</span></span><br><span class="line">        <span class="keyword">if</span> obj.is_valid():</span><br><span class="line">            print(obj.cleaned_data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(obj.errors)</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'register.html'</span>,&#123;<span class="string">'obj'</span>:obj&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
  </entry>
  <entry>
    <title>Effective C++笔记</title>
    <url>/2020/01/06/Effective-C-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><a id="more"></a>
<h2 id="尽量以const，enum，inline替换-define"><a href="#尽量以const，enum，inline替换-define" class="headerlink" title="尽量以const，enum，inline替换#define"></a>尽量以const，enum，inline替换#define</h2><p>通常C++要求对使用的任何东西提供定义式，但如果他是class专属常量，又是static且为整数类型（integral type,例如int，char，bool），则无需特殊处理。只要不取他们的地址，可以声明并使用它们而无需使用定义式。但如果要取某个class专属常量的地址，就必须提供定义式。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;  <span class="comment">//常量声明式</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源文件中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns; <span class="comment">//NumTurns的定义</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>对于单纯常量，最好以const对象或enum替换#defines</li>
<li>对于形似函数的宏，最好改用inline函数替换#defines</li>
</ul>
<h2 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h2><p>const关键字：如果const出现在<code>*</code>左侧，表示物体是常量；如果出现在右侧，表示指针是常量。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种表示方法一致</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> Widget* pw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Widget <span class="keyword">const</span>* pw)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>令函数返回一个常量值，往往可以降低因客户端而造成的意外</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs);</span><br></pre></td></tr></table></figure>
<p>这样可以避免</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((a * b) = c)这样的错误。</span><br></pre></td></tr></table></figure>
<p>对于即使在const对象中也可能被更改的对象，使用mutable关键字进行修饰<br>const对象调用non-const对象是一种错误的行为</p>
<h2 id="确定对象在使用前已先被初始化"><a href="#确定对象在使用前已先被初始化" class="headerlink" title="确定对象在使用前已先被初始化"></a>确定对象在使用前已先被初始化</h2><ul>
<li>对于内置类型，定义的时候一定要初始化，因为读取为初始化的值是未定义的</li>
<li>对于非内置类型，初始化责任落在构造函数上。确保每一个构造函数都讲对象的每一个成员初始化。</li>
</ul>
<p><strong>注意不要混淆赋值和初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;address,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; &amp;phones)</span><br><span class="line">&#123;</span><br><span class="line">	theName = name;       <span class="comment">//这些都是赋值</span></span><br><span class="line">    theAddress = address; <span class="comment">//而非初始化</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，进行赋值之前，会调用成员的默认构造函数，然后才是赋值。这样性能不够好。可以换成如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;address,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; &amp;phones)</span><br><span class="line">  : theName(name),</span><br><span class="line">  	theAddress(address),</span><br><span class="line">    thePhones(phones),</span><br><span class="line">    numTimesConsulted(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外初始化列表中，成员话初始化的次序是类中定义的变量次序一样的。</p>
<ul>
<li><p>对于不同编译单元的non local static对象的初始化顺序是未定义的</p>
<p>所谓编译单元是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含入得头文件。</p>
<p>static对象，其寿命从被构造出来知道程序结束为止。</p>
<p>non-local，指的是对象位于global或位于namespace作用于，抑或是class内或file作用于内被声明为static</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> numDisks() <span class="keyword">const</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">FileSystem</span> tfs;</span><br></pre></td></tr></table></figure>
<p>另一个文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory(params);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Director::Director(params)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks(); <span class="comment">//使用tfs对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在客户端决定创建一个Directory对象，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在，初始化次序的重要性显现出来了：除非tfs在tempDir之前先被初始化，否则会用到尚未初始化的tfs。</p>
</li>
</ul>
<p>  解决方案：</p>
<p>  把每个non-local static对象搬到自己的专属函数内，这些函数返回一个refrence指向它所含的对象。这个是单例模式一个常见的实现手法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">FileSystem</span> &amp;<span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">FileSystem</span> fs;</span><br><span class="line">  <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Director &amp;<span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Director td;</span><br><span class="line">  <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用static对象可能会在多线程环境下造成race condition。</p>
<h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h1><h2 id="了解C-默认编写并调用哪些函数"><a href="#了解C-默认编写并调用哪些函数" class="headerlink" title="了解C++默认编写并调用哪些函数"></a>了解C++默认编写并调用哪些函数</h2><ul>
<li>如果没有自己编写构造函数，C++会生成一个不带参数的默认构造函数。</li>
<li>在非特殊情况下，C++会自动生成拷贝构造函数、赋值运算符以及析构函数<br>特殊情况指的是：如果类中有引用类型或者有const类型，此时由于引用类型和const类型不能重新赋值，所以编译器这个时候不会自动生成赋值运算符和拷贝构造函数。</li>
</ul>
<h2 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>如果一个类不希望被拷贝，那么其拷贝构造函数和赋值函数应该不生效。对于外部调用来讲，将拷贝构造函数和赋值函数声明为private就可以了。但是，如果类的成员函数和友元来调用，还是可以通过编译的，这个时候，可以只声明private类型的拷贝构造函数和赋值函数，而不去实现它们，这样友元或成员函数试图调用它们的时候，就会报链接错误。</p>
<p>如果希望在编译的时候就讲问题暴露出来，可以使用如下方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Uncopyable() &#123;&#125;</span><br><span class="line">    ~Uncopyable() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Uncopyable(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">    Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span><span class="keyword">private</span> Uncopyable&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>为求阻止HomeForSale对象被拷贝，我们唯一需要做的就是继承Uncopyable。</p>
<p>当成员函数或者友元函数，尝试拷贝HomeForSale对象，编译器变试着生成一个copy构造函数和一个copy assignment操作符，这样会去调用其base class的对应函数，这会被编译器拒绝，因为base class的拷贝函数是private。</p>
<ul>
<li>为驳回编译器自动提供的机能，可将响应的成员函数声明为private并且不予实现。</li>
</ul>
<h2 id="为多态基类声明virtual构造函数"><a href="#为多态基类声明virtual构造函数" class="headerlink" title="为多态基类声明virtual构造函数"></a>为多态基类声明virtual构造函数</h2><p>任何class只要带有virtual函数，都几乎确定应该也有一个virtual析构函数。<br>如果class不含virtual函数，通常表示他不愿意被用作一个base class。此时令析构函数为virtual往往是个馊主意。<br>纯虚函数可以在类外提供定义。</p>
<h2 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h2><p>怎么样实现不让异常逃离析构函数呢？</p>
<p>假设一个数据库连接的类，为了防止客户忘记关闭连接，往往会在析构的时候尝试关闭连接，例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBCONN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">~DBCONN()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">  	db.<span class="built_in">close</span>();</span><br><span class="line">  &#125;<span class="keyword">catch</span> </span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">//记下错误，继续执行或者调用abort，终止程序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DB db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种处理方式的缺点是，客户没有太多选择，要么是abort终止程序，要么是继续执行。</p>
<p>为了让客户有选择，可以单独提供一个close函数，让用户自己处理异常。如果用户决定自己不处理，那么析构函数的时候再采用一个默认的方式来处理。</p>
<h2 id="不要在构造函数和析构函数中调用虚函数"><a href="#不要在构造函数和析构函数中调用虚函数" class="headerlink" title="不要在构造函数和析构函数中调用虚函数"></a>不要在构造函数和析构函数中调用虚函数</h2><p>在构造函数中，调用构造函数的顺序是基类-&gt;子类，当基类在构造的时候，子类的部分还没有开始构造，这时候，如果调用虚函数，只会调用基类版本的，不符合虚函数的语义。</p>
<p>在析构函数中，调用析构函数的顺序是子类-&gt;基类，当基类在析构的时候，子类的部分已经析构完成，这时候，如果调用虚函数，同样只会调用基类版本的，不符合虚函数的语义。</p>
<h2 id="令operator-返回自身的引用"><a href="#令operator-返回自身的引用" class="headerlink" title="令operator=返回自身的引用"></a>令operator=返回自身的引用</h2><p>一般赋值操作，希望可以写成连续的形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>对于上述形式，则必须返回一个自身的引用。</p>
<p>类似的<code>+=</code>,<code>*=</code>等等都应该返回自身的引用。</p>
<h2 id="在operator-中处理“自我赋值”"><a href="#在operator-中处理“自我赋值”" class="headerlink" title="在operator=中处理“自我赋值”"></a>在operator=中处理“自我赋值”</h2><p>改良版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;w)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;w)</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  p = <span class="keyword">new</span> Test(*w.p);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类虽然是能避免自我赋值问题，但是，如果new Test抛出了异常，那么Widget最终会持有一个指针指向一块被删除的Test，这样的指针是有害的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">  Test *porg = p;</span><br><span class="line">  p = <span class="keyword">new</span> Test(*rhs.p);</span><br><span class="line">  <span class="keyword">delete</span> porg;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果此时new Test发生异常，那么p可以保持原状.<br>还有一个可以避免异常的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">  Widget tmp(rhs);</span><br><span class="line">  swap(tmp);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码确保异常安全，并且能够解决自我赋值问题。</p>
<h2 id="复制对象时勿忘其每一个成分"><a href="#复制对象时勿忘其每一个成分" class="headerlink" title="复制对象时勿忘其每一个成分"></a>复制对象时勿忘其每一个成分</h2><p><strong>不要尝试以某个copying函数实现另一个copying函数(如拷贝函数实现赋值函数)，应该讲共同机能放入第三个函数中，并且由两个copying函数共同调用。</strong></p>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h2><p>比如使用shared_ptr对象代替传统指针</p>
<h2 id="在资源管理类中小心copying行为"><a href="#在资源管理类中小心copying行为" class="headerlink" title="在资源管理类中小心copying行为"></a>在资源管理类中小心copying行为</h2><p>对于资源管理类的copying行为，可能需要按照以下方面来决定：</p>
<ul>
<li>禁止复制。有的RAII对象复制并不合理，如资源管理类中管理的锁</li>
<li>对底层资源祭出“引用计数法”。有时候，我们希望保持资源，直到它的最后一个使用者被销毁，例如shared_ptr。</li>
<li>复制底层资源。有时候，资源管理需要对某一份资源的任意数量的副本，而你需要资源管理类的唯一理由是，当你不在需要某个副本的时候，就释放它的空间。</li>
<li>转移底部资源的拥有权。确保RAII对象指向一个未加工的资源。即使复制，此时资源的拥有权从被复制物转移到目标物。（备注：这种情况应该比较少见吧）。</li>
</ul>
<h2 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h2><p>对于mutex，我们可以用get_mutex来返回对原始mutex的引用。</p>
<p>有时候可能也会提供隐式转换的接口，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">mutex</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样就会在需要mutex的时候，自动转换。</p>
<h2 id="成对使用new和delete时采取相同形式"><a href="#成对使用new和delete时采取相同形式" class="headerlink" title="成对使用new和delete时采取相同形式"></a>成对使用new和delete时采取相同形式</h2><p>首先，来看new和delete操作符的语义</p>
<ul>
<li>new会先创建对象的内存空间，然后调用其构造函数来初始化</li>
<li>delete会先调用析构函数，然后再释放类的空间</li>
</ul>
<p>然后，new和delete需要采用相同的形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> *str_ptr1 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> *str_ptr2 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> str_ptr1;</span><br><span class="line"><span class="keyword">delete</span>[] str_ptr2;</span><br></pre></td></tr></table></figure>
<p>如果用delete[]来删除str_ptr1，结果是未定义的，delete可能会先解析出数组大小，然后，析构这么多个元素，但是实际上只有一个元素需要释放。同样地，对str_ptr2调用delete，也会出现未定义的行为。</p>
<p>因此，new和delete形式必须要以相同的形式出现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>和<span class="keyword">delete</span></span><br><span class="line"><span class="keyword">new</span>[]和<span class="keyword">delete</span>[]</span><br></pre></td></tr></table></figure>
<h2 id="以独立语句将newed对象置入智能指针"><a href="#以独立语句将newed对象置入智能指针" class="headerlink" title="以独立语句将newed对象置入智能指针"></a>以独立语句将newed对象置入智能指针</h2><p>考虑以下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure>
<p>由于C++中，一条语句里面的函数调用的顺序是不确定的，上面的代码总共有三条语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Widget</span><br><span class="line">priority()</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;();</span><br></pre></td></tr></table></figure>
<p>如果最终编译器以上述顺序执行，并且priority函数中间发生了异常，那么new Widget创建的对象还没加入到shared_ptr中，会造成资源泄漏。</p>
<p>正确的做法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure>
<h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="让接口容易被正确使用，不易被误用"><a href="#让接口容易被正确使用，不易被误用" class="headerlink" title="让接口容易被正确使用，不易被误用"></a>让接口容易被正确使用，不易被误用</h2><ul>
<li>要设计不易被误用的接口</li>
</ul>
<p>例如，要创建一个时间类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Date(<span class="keyword">int</span> month, <span class="keyword">int</span> year, <span class="keyword">int</span> day);</span><br></pre></td></tr></table></figure>
<p>上面的接口就是容易被误用的接口，因为可能把年月日的顺序给搞错了。</p>
<p>可以给年月日分别设计一个类型，构造函数中传入对应的类型才能正确编译。</p>
<ul>
<li><p>限制类型内什么事可做，什么事不能做</p>
<p>比如<code>opeator *</code>的返回值类型为const</p>
</li>
<li><p>让你自己设计类型的表现与内置types一致</p>
</li>
<li><p>任何借口如果要求客户必须记得做某事，就容易出错，最好的方法就是给客户做好</p>
<p>例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Investment *<span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数返回一个指针，需要客户在最后记得释放空间，当客户忘记这件事时，就会造成资源未释放。</p>
<p>比较好的方法，是返回一个shared_ptr智能指针。</p>
</li>
<li><p>shared_ptr支持定制型删除器，可以返回跨模块的new/delete问题，因为shared_ptr会自动调用本模块的delete函数。</p>
</li>
</ul>
<h2 id="设计class犹如设计type"><a href="#设计class犹如设计type" class="headerlink" title="设计class犹如设计type"></a>设计class犹如设计type</h2><ul>
<li><p>新type的对象应该如何被创建和销毁</p>
</li>
<li><p>对象的初始化和对象的赋值该有什么样的差别</p>
</li>
<li><p>新type的对象如果被passed by value，意味着什么？即copy构造函数该如何实现</p>
</li>
<li><p>什么是新type的“合法值”？成员函数必须对菲合法值进行必要的错误检查</p>
</li>
<li><p>你的新type需要配合某个继承图系？</p>
</li>
<li><p>你的新type需要什么样的转换？是否需要隐式或者显式转换成其他类型。</p>
</li>
<li><p>什么样的操作符和函数对此新type而言是合理的?该声明哪些函数，哪些应该是member函数，某些则不是。</p>
</li>
<li><p>什么样的标准含税应该驳回？例如，自动生成的拷贝构造函数，赋值函数和析构函数等等。</p>
</li>
<li><p>谁该取用新type的成员？哪些为public、哪些为protected、哪些为private。</p>
</li>
<li><p>什么是新type的“未声明接口”？这个不太懂</p>
</li>
<li><p>你的新type有多么一般化？或许你其实并非定义一个新type，而是定义一整个</p>
<p>types家族。</p>
</li>
<li><p>你真的需要一个新type吗？如果只是定义新的derived class以便为既有的class添加机能，那么说不定单纯定义一个或多个non-member函数或者template更能达到目标。</p>
</li>
</ul>
<h2 id="宁以pass-by-refrence-to-const替换pass-by-value"><a href="#宁以pass-by-refrence-to-const替换pass-by-value" class="headerlink" title="宁以pass-by-refrence-to-const替换pass-by-value"></a>宁以pass-by-refrence-to-const替换pass-by-value</h2><p>对于自定义的类，往往通过pass by const refrence比较合适，因为这可以省去多次的构造函数的调用开销。对于内置对象，往往以pass-by-value比较合适，因为引用在编译器内部实现往往是指针，对于内置类型，用指针来传递往往会比pass-by-value变慢，多了一次读内存的过程（先读变量的地址，然后在真正读变量的值）。</p>
<p>对于STL迭代器和函数对象，往往习惯上也被设计为pass-by-value。</p>
<h2 id="必须返回对象时，别妄想返回其refrence"><a href="#必须返回对象时，别妄想返回其refrence" class="headerlink" title="必须返回对象时，别妄想返回其refrence"></a>必须返回对象时，别妄想返回其refrence</h2><p>举个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Rational &amp;<span class="title">operator</span><span class="params">(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个要返回refrence，所以，必须在heap上分配一个对象。因为，refrence指向一个函数内的local对象时，在函数退出时，已经被析构了，这时候，函数的返回值就是非法的了。</p>
<p>当你在必须“返回一个refrence和返回一个object”之间进行抉择时，你的工作就是挑出行为正确的那个。</p>
<p>绝不要返回pointer或refrence指向一个local stack对象，或返回refrence指向一个heap-allocated对象（这个需要外部调用delete，而且如果连续赋值可能导致内存空间无法释放），或返回pointer或refrence指向一个local static对象而有可能同时需要对个这样的对象。</p>
<h2 id="将成员变量声明为private"><a href="#将成员变量声明为private" class="headerlink" title="将成员变量声明为private"></a>将成员变量声明为private</h2><ul>
<li>如果将成员变量声明为public，那么，如果对成员变量进行改动，会影响到所有使用该成员变量的客户。</li>
<li>如果将成员变量声明为protected，那么，如果对成员变量进行改动，会影响到所有使用该成员变量的derived classes。</li>
</ul>
<p>所以，为了封装性，把成员变量声明为private。</p>
<h2 id="宁以non-member-non-friend替换member函数"><a href="#宁以non-member-non-friend替换member函数" class="headerlink" title="宁以non-member-non-friend替换member函数"></a>宁以non-member-non-friend替换member函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser &amp;wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  wb.clearCache();</span><br><span class="line">  wb.clearHistory();</span><br><span class="line">  wb.removeCookies();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面代码看出，以non-member-non-friend函数方式形式来实现clear操作会更有封装性，因为它不能访问类里面的数据，更加符合封装的思想。</p>
<h2 id="若所有参数皆需类型转换，请为此采用non-member函数"><a href="#若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数皆需类型转换，请为此采用non-member函数"></a>若所有参数皆需类型转换，请为此采用non-member函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational &amp;rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于上面代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational result = oneHalf * oneEighth;</span><br><span class="line">result = result * oneEighth;</span><br><span class="line">result = oneHalf * <span class="number">2</span>;</span><br><span class="line">result = <span class="number">2</span> * oneHalf; <span class="comment">//有错误</span></span><br></pre></td></tr></table></figure>
<p>为了使得第四个赋值也能支持，可以把<code>operator*</code>实现成以下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs);</span><br></pre></td></tr></table></figure>
<h2 id="考虑写出一个不抛异常的swap函数"><a href="#考虑写出一个不抛异常的swap函数" class="headerlink" title="考虑写出一个不抛异常的swap函数"></a>考虑写出一个不抛异常的swap函数</h2><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>变量的定义最好要出现在其初值能确定的地方。这样可以避免定义了变量，未使用，却带来了构造函数和析构函数的开销。</p>
<p>对于循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法A：定义循环外</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  w = 取决于i的某个值;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法B：定义循环内</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Widget <span class="title">w</span><span class="params">(取决于i的某个值)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>做法A：1个构造函数+1个析构函数+n个赋值函数</li>
<li>做法B：n个构造函数+n个析构函数</li>
</ul>
<p>如果classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效。尤其当n比较大的时候。否则做法B或许比较好。</p>
<p>另外A带的是w的作用域变大，有时候会对程序的可理解性和易维护性造成冲突。</p>
<p>因此：</p>
<ul>
<li>你知道赋值成本比“构造+析构”成本低</li>
<li>你正在处理代码中效率高度敏感的部分，否则你应该使用做法B</li>
</ul>
<h2 id="避免使用转型-cast"><a href="#避免使用转型-cast" class="headerlink" title="避免使用转型(cast)"></a>避免使用转型(cast)</h2><ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免，如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后，客户随后可以调用该函数，而不需将转型放进他们自己的代码内。</li>
<li>宁可使用C++风格转型，不要使用旧式转型前者很容易辨识出来，而且也比较有分别别类的职称。</li>
</ul>
<h2 id="避免返回handles指向对象内部"><a href="#避免返回handles指向对象内部" class="headerlink" title="避免返回handles指向对象内部"></a>避免返回handles指向对象内部</h2><ul>
<li>帮助const成员函数行为像个const</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">const</span> Point &amp;<span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;ulhc;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point &amp;<span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;lrhc;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果这里用非const返回值，会造成Rectangle中的ulhc货lrhc被外部的修改。</p>
<ul>
<li>避免返回handles(包括refrence、指针、迭代器)指向对象内部。遵守这个条款可增加封装性。</li>
</ul>
<p>因为有可能在某个临时对象上，操作这个内部对象，会造成问题：</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GUIObject *pgo;</span><br><span class="line"><span class="keyword">const</span> Point *pUpperLeft = &amp;(boundingBox(*pgo).upperLeft());</span><br></pre></td></tr></table></figure>
<p>这个boundingBox会生成一个临时的Rectangle对象，造成upperLeft的返回的内部对象失效，造成程序不安全。</p>
<h2 id="为“异常安全”而努力是值得的"><a href="#为“异常安全”而努力是值得的" class="headerlink" title="为“异常安全”而努力是值得的"></a>为“异常安全”而努力是值得的</h2><h2 id="透彻了解inlining的内内外外"><a href="#透彻了解inlining的内内外外" class="headerlink" title="透彻了解inlining的内内外外"></a>透彻了解inlining的内内外外</h2><ul>
<li>inline函数如果起作用了，会在每次调用的时候用实现的代码替换它，所以会造成程序体积变大。</li>
<li>inline只是向编译器的一个申请，可以明确用inline关键字，也可以在类体内部定义。</li>
<li>template的实例化和inline无关，如果需要template函数为inline，需要显式地声明它。</li>
<li>inline函数无法随着程序库的升级而升级。换句话说如果f是程序库内的一个inline函数，客户讲“f函数本体”编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序都必须重新编译。</li>
<li>将大多数inline限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
</ul>
<h2 id="将文件间的编译依存关系降到最低"><a href="#将文件间的编译依存关系降到最低" class="headerlink" title="将文件间的编译依存关系降到最低"></a>将文件间的编译依存关系降到最低</h2><ul>
<li>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式，基于此构想的两个手段是Handle classes和Interface Classes。</li>
</ul>
<h1 id="继承和面向对象设计"><a href="#继承和面向对象设计" class="headerlink" title="继承和面向对象设计"></a>继承和面向对象设计</h1><h2 id="确定你的public继承函数塑膜处is-a关系"><a href="#确定你的public继承函数塑膜处is-a关系" class="headerlink" title="确定你的public继承函数塑膜处is-a关系"></a>确定你的public继承函数塑膜处is-a关系</h2><p>“public”继承意味着is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base classes对象。</p>
<h2 id="避免遮掩继承而来的名称"><a href="#避免遮掩继承而来的名称" class="headerlink" title="避免遮掩继承而来的名称"></a>避免遮掩继承而来的名称</h2><p>看以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;；</span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); <span class="comment">//没问题，调用Dervied::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">//错误，因为Derived::mf1遮掩了Base::mf1</span></span><br><span class="line">d.mf2(); <span class="comment">//没问题，调用Base::mf2</span></span><br><span class="line">d.mf3(); <span class="comment">//没问题，调用Dervied::mf3</span></span><br><span class="line">d.mf3(x); <span class="comment">//错误！因为Derived::mf3遮掩了Base::mf3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果你正在使用public继承而又不继承那些重载函数，就是违反Base和derived classes之间的is-a关系，而is-a是public的基石。</p>
</li>
<li><p>为了被遮掩的名称再见天日，可使用using声明式</p>
</li>
</ul>
<h2 id="区分接口继承和实现继承"><a href="#区分接口继承和实现继承" class="headerlink" title="区分接口继承和实现继承"></a>区分接口继承和实现继承</h2><p>我们可以为纯虚函数提供定义，但调用他的唯一途经是使用时明确指出其class名称。</p>
<p>考虑如下一段代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span> :</span> <span class="keyword">public</span> Shape &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于一个pure virtual函数，且不带定义，目的是为了让derived classes只继承函数接口。然后，继承类必须实现它自身的行为。</li>
<li>声明impure virtual函数的目的是，让derived classes继承该函数的接口和缺省实现。也就是，如果某个集成类不想对该功能做特殊处理的时候，可以采用缺省的默认实现，否则，需要自己提供实现。这种方法可能会造成继承类忘记实现自己该实现的功能，这时候编译照样是过的。</li>
<li>声明pure virtual函数且带定义，也是让derived classes继承该函数的接口和缺省实现。这种方法跟上面的区别是，它可以防止集成类忘记实现自己功能的情况，因为是pure virual，采用默认实现也得显式地调用基类的函数。</li>
<li>声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现。</li>
</ul>
<h2 id="考虑virtual函数以外的其他选择"><a href="#考虑virtual函数以外的其他选择" class="headerlink" title="考虑virtual函数以外的其他选择"></a>考虑virtual函数以外的其他选择</h2><p>场景：假如你打算为游戏内的人物设计一个继承体系。你的游戏属于暴力砍杀类型，剧中人物被伤害或因其他因素而降低健康状态的情况并不罕见。因此，你决定提供一个成员函数healthValue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能已不同的方式计算它们的健康指数，将healthValue声明为virtual似乎是再明白不过的做法。</p>
<h3 id="方案1-虚函数方法"><a href="#方案1-虚函数方法" class="headerlink" title="方案1-虚函数方法"></a>方案1-虚函数方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//返回人物的健康指数</span></span><br><span class="line">                                     <span class="comment">//derived classes可重新定义它</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方案2-借由Non-Virtual-Interface手法实现Template-Method模式"><a href="#方案2-借由Non-Virtual-Interface手法实现Template-Method模式" class="headerlink" title="方案2-借由Non-Virtual Interface手法实现Template Method模式"></a>方案2-借由Non-Virtual Interface手法实现Template Method模式</h3><p>这个方案的思路是保留healthValue为public成员函数，但让它成为non-virtual，表调用一个private virtual函数，进行实际工作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  		... <span class="comment">//derived classes不重新定义它</span></span><br><span class="line">        <span class="keyword">int</span> retVal = doHealthValue(); <span class="comment">//做一些事情工作，详下</span></span><br><span class="line">        ... <span class="comment">//做一些事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">//derived classes可重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  		... <span class="comment">//缺省算法，计算健康指数</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>令客户通过public non-virtual成员函数间接调用private virtual函数，称为non-virtual interface手法(NVI)。它是所谓Template Method设计模式的一个独特表现形式。我把这个non-virtual函数称为virtual函数的wrapper。</p>
<p>优点：可以使得virtual函数在调用的时候，之前可以设定好适当场景，并在调用结束后清理场景。事前工作可以是锁定互斥器、制造运转日志记录项目、验证class约束条件。事后工作可以包括互斥器解除锁定，验证函数的时候条件、再次验证class约束条件等等。</p>
<h3 id="方案3-借由Function-Pointers实现Strategy模式"><a href="#方案3-借由Function-Pointers实现Strategy模式" class="headerlink" title="方案3-借由Function Pointers实现Strategy模式"></a>方案3-借由Function Pointers实现Strategy模式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">explict <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span>;</span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">setHealthCalculator</span><span class="params">(HealthCalcFunc hcf)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优点：可以在运行时改变计算血量的方式，比如有的角色开始时计算血量是一种方式，过了某个血量范围后，又是另外一个方式。</p>
<p>缺点：如果计算血量，需要依赖non-public的信息，就无法进行下去。</p>
<h3 id="方案4-借由tr1-function完成strategy模式"><a href="#方案4-借由tr1-function完成strategy模式" class="headerlink" title="方案4-借由tr1::function完成strategy模式"></a>方案4-借由tr1::function完成strategy模式</h3><p>tr1::function对象可以使用任何可调用无，也就是函数指针、函数对象或成员函数指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::tr1::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter &amp;)&gt; HealthCalcFunc;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthCalcFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优点：灵活性，可以使用任何可调用的对象。</p>
<h3 id="方案5-古典的strategy模式"><a href="#方案5-古典的strategy模式" class="headerlink" title="方案5-古典的strategy模式"></a>方案5-古典的strategy模式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">      ---------------             ----------------</span><br><span class="line">      |GameCharacter|/\-----------|HealthCalcFunc|</span><br><span class="line">      ---------------\/            ---------------</span><br><span class="line">            /\                            /\   </span><br><span class="line">            ||                            ||</span><br><span class="line">     -------||----------                  ||------------</span><br><span class="line">     |      ||         |                  ||		   |</span><br><span class="line">------------     --------------     -----------  -----------</span><br><span class="line">|EvilBadGuy|     |EyeCharacter|     |SlowLoser|  |FastLoser|</span><br><span class="line">------------     --------------     -----------  -----------</span><br></pre></td></tr></table></figure>
<h2 id="绝不重新定义继承而来的non-virtual函数"><a href="#绝不重新定义继承而来的non-virtual函数" class="headerlink" title="绝不重新定义继承而来的non-virtual函数"></a>绝不重新定义继承而来的non-virtual函数</h2><p>绝不重新定义继承而来的non-virtual函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">D x;</span><br><span class="line">B *pb = &amp;x;</span><br><span class="line">pb-&gt;mf();<span class="comment">//调用B::mf</span></span><br><span class="line">D *pd = &amp;x;</span><br><span class="line">pd-&gt;mf();<span class="comment">//调用D::mf</span></span><br></pre></td></tr></table></figure>
<p>在D中重载non-virtual的B类对象中的函数，其实已经违反了每个D都是一个B的约束。即对于non-virtual的接口，继承类应该和基类行为是一致的，否则就不应该设计成non-virtual接口。</p>
<h2 id="绝不重新定义继承而来的缺省参数值"><a href="#绝不重新定义继承而来的缺省参数值" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h2><p>virtual函数系动态绑定，而缺省参数值却是静态绑定。</p>
<p>举个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> ShapeColor&#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color=Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color=Green)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有以下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shape *ps;</span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;</span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;</span><br></pre></td></tr></table></figure>
<p>用pc-&gt;draw()的时候，采用的默认参数是Red，是Shape类的默认参数，而不是Derived的类的默认参数，因为默认参数是静态编译期间绑定的。</p>
<p>即使把Base class和Derived class设计成相同的默认参数，如果某一天要修改这个参数，得两个类都需要修改。</p>
<p>这个问题可以通过NVI方法来避免，把函数功能抽象成private的virtual函数，然后把缺省的默认参数移到non-virtual的public函数中。</p>
<h2 id="通过复合塑模出has-a或“根据某物实现出”"><a href="#通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="通过复合塑模出has-a或“根据某物实现出”"></a>通过复合塑模出has-a或“根据某物实现出”</h2><p>复合is-a有两种含义，一种has-a含义，另一种是is-implemented-in-terms-of，根据某物实现出。</p>
<p>例如，我们希望基于std::list来实现一个set，可以，在一个set类里面定义一个std::list作为内部成员，来实现set。</p>
<h2 id="明智而审慎的使用private继承"><a href="#明智而审慎的使用private继承" class="headerlink" title="明智而审慎的使用private继承"></a>明智而审慎的使用private继承</h2><p>private继承意味着is-implemented-in-terms-of（根据某物实现出）。如果你让class D以private形式继承class B，你的用意是为了采用class B内已经备妥的某些特性，不是因为B对象和D对象存在有任何观念上的关系，</p>
<h2 id="明智而审慎的使用多重继承"><a href="#明智而审慎的使用多重继承" class="headerlink" title="明智而审慎的使用多重继承"></a>明智而审慎的使用多重继承</h2>]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Faster-RCNN细节详解</title>
    <url>/2020/03/24/Faster-RCNN%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31426458</a><br><a id="more"></a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Faster RCNN是Ross B. Girshick在2016年提出的。<br>Faster RCNN(Region CNN)可以分为4个主要内容：</p>
<ol>
<li>Conv layers。作为一种CNN网络目标检测方法，Faster RCNN首先使用一组基础的conv+relu+pooling层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。</li>
<li>Region Proposal Networks。RPN网络用于生成region proposals。该层通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals。</li>
<li>Roi Pooling。该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。</li>
<li>Classification。利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</li>
</ol>
<p><img src="1.jpg" alt="Faster RCNN基本结构(原论文)"><br>下图为python版本中的VGG16模型中的faster_rcnn_test.pt的网络结构，可以清晰的看到该网络对于一副任意大小PxQ的图像，首先缩放至固定大小MxN，然后将MxN图像送入网络；而Conv layers中包含了13个conv层+13个relu层+4个pooling层；RPN网络首先经过3x3卷积，再分别生成positive anchors和对应bounding box regression偏移量，然后计算出proposals；而Roi Pooling层则利用proposals从feature maps中提取proposal feature送入后续全连接和softmax网络作classification（即分类proposal到底是什么object）。<br><img src="2.jpg" alt="Faster RCNN网络结构"></p>
<h1 id="1-Conv-Layers"><a href="#1-Conv-Layers" class="headerlink" title="1. Conv Layers"></a>1. Conv Layers</h1><p>Conv layers包含了conv，pooling，relu三种层。以python版本中的VGG16模型中的faster_rcnn_test.pt的网络结构为例，如图2，Conv layers部分共有13个conv层，13个relu层，4个pooling层。这里有一个非常容易被忽略但是又无比重要的信息，在Conv layers中：</p>
<ol>
<li>所有的conv层都是：kernel_size=3，pad=1，stride=1</li>
<li>所有的pooling层都是：kernel_size=3，pad=2，stride=2<br>这意味着conv层的输入和输出都是M*N的大小。pooling层将输出长宽变为输入的1/2.那么，一个MxN大小的矩阵经过Conv layers固定变为(M/16)x(N/16)！这样Conv layers生成的feature map中都可以和原图对应起来。</li>
</ol>
<h1 id="2-Region-Proposal-Networks-RPN"><a href="#2-Region-Proposal-Networks-RPN" class="headerlink" title="2. Region Proposal Networks(RPN)"></a>2. Region Proposal Networks(RPN)</h1><p>Faster RCNN则抛弃了传统的滑动窗口和SS方法，直接使用RPN生成检测框，这也是Faster R-CNN的巨大优势，能极大提升检测框的生成速度。<br>RPN网络实际分为2条线，上面一条通过softmax分类anchors获得positive和negative分类，下面一条用于计算对于anchors的bounding box regression偏移量，以获得精确的proposal。而最后的Proposal层则负责综合positive anchors和对应bounding box regression偏移量获取proposals，同时剔除太小和超出边界的proposals。其实整个网络到了Proposal Layer这里，就完成了相当于目标定位的功能。</p>
<h2 id="2-1-anchors"><a href="#2-1-anchors" class="headerlink" title="2.1 anchors"></a>2.1 anchors</h2><p>所谓anchors，实际上就是一组由rpn/generate_anchors.py生成的矩形。9个矩形共有3种形状，长宽比为大约为{1:2,1:1,2:1}三种。实际上通过anchors就引入了检测中常用到的多尺度方法。<br><img src="3.jpg" alt="anchors示意图"><br>如下图，遍历Conv layers计算获得的feature maps，为每一个点都配备这9种anchors作为初始的检测框。这样做获得检测框很不准确，不用担心，后面还有2次bounding box regression可以修正检测框位置。<br><img src="4.jpg" alt="原文中的anchors"></p>
<blockquote>
<p>上图中的各个数字</p>
<ul>
<li>在原文中使用的是ZF model中，其Conv Layers中最后的conv5层num_output=256，对应生成256张特征图，所以相当于feature map每个点都是256-dimensions</li>
<li>在conv5之后，做了rpn_conv/3x3卷积且num_output=256，相当于每个点又融合了周围3x3的空间信息（猜测这样做也许更鲁棒？反正我没测试），同时256-d不变（如图4和图7中的红框）</li>
<li>假设在conv5 feature map中每个点上有k个anchor（默认k=9），而每个anhcor要分positive和negative，所以每个点由256d feature转化为cls=2k scores；而每个anchor都有(x, y, w, h)对应4个偏移量，所以reg=4k coordinates</li>
<li>补充一点，全部anchors拿去训练太多了，训练程序会在合适的anchors中随机选取128个postive anchors+128个negative anchors进行训练（什么是合适的anchors下文5.1有解释）</li>
</ul>
</blockquote>
<p><strong>其实RPN最终就是在原图尺度上，设置了密密麻麻的候选Anchor。然后用cnn去判断哪些Anchor是里面有目标的positive anchor，哪些是没目标的negative anchor。所以，仅仅是个二分类而已！</strong></p>
<p>Anchor一共有多少个？原图800x600，VGG下采样16倍，feature map每个点设置9个Anchor，所以：<br>$ceil(800/16)\times ceil(600/16)\times 9=50\times 38 \times 9 = 17100$</p>
<h2 id="2-2-bounding-box-regression原理"><a href="#2-2-bounding-box-regression原理" class="headerlink" title="2.2 bounding box regression原理"></a>2.2 bounding box regression原理</h2><p>对于窗口一般使用四维向量$(x,y,w,h)$表示，分别表示窗口的中心点坐标和宽高。对于图 11，红色的框A代表原始的positive Anchors，绿色的框G代表目标的GT，我们的目标是寻找一种关系，使得输入原始的anchor A经过映射得到一个跟真实窗口G更接近的回归窗口G’.即：</p>
<ul>
<li>给定anchor $A=(A_x,A_y,A_w,A_h)$和$GT=[G_x,G_y,G_w,G_h]$</li>
<li>寻找一种变换F使得:$F(A_x,A_y,A_w,A_h)=(G_x^{‘},G_y^{‘},G_w{‘},G_h^{‘})$</li>
</ul>
<p>一种简单的思路就是平移后缩放：<br>平移：$G_x^{‘}=A_w·d_x(A)+A_x$<br>$G_y^{‘}=A_w·d_y(A)+A_y$<br>缩放：$G_w^{‘}=A_w·exp(d_w(A))$<br>$G_h^{‘}=A_h·exp(d_h(A))$</p>
<p>A_x等为系数，需要学习的参数有$d_x(A),d_y{A},d_w(A),d_h(A)$。</p>
<p>对于训练bouding box regression网络回归分支，输入是cnn feature Φ，监督信号是Anchor与GT的差距，即训练目标是：输入 Φ的情况下使网络输出与监督信号尽可能接近。</p>
<h2 id="2-3-proposal-layer"><a href="#2-3-proposal-layer" class="headerlink" title="2.3 proposal layer"></a>2.3 proposal layer</h2><p>Proposal Layer负责综合所有anchors的变换量和positive anchors，计算出精准的proposal，送入后续RoI Pooling Layer。</p>
<p>Proposal Layer有3个输入：positive vs negative anchors分类器结果rpn_cls_prob_reshape，对应的bbox reg的变换量rpn_bbox_pred，以及im_info；另外还有参数feat_stride=16，这和图4是对应的。</p>
<p><strong>im_info</strong> 对于一副任意大小PxQ图像，传入Faster RCNN前首先reshape到固定MxN，im_info=[M, N, scale_factor]则保存了此次缩放的所有信息。然后经过Conv Layers，经过4次pooling变为WxH=(M/16)x(N/16)大小，其中feature_stride=16则保存了该信息，用于计算anchor偏移量。</p>
<blockquote>
<p>这里的输出是[x1,y1,x2,y2]是对应M*N输入图像尺度的。</p>
</blockquote>
<h1 id="3-ROI-pooling"><a href="#3-ROI-pooling" class="headerlink" title="3. ROI pooling"></a>3. ROI pooling</h1><p>Rol pooling层有2个输入：</p>
<ul>
<li>原始的feature maps</li>
<li>RPN输出的proposal boxes（大小各不相同）</li>
</ul>
<blockquote>
<p>RoI Pooling layer forward过程：</p>
<ul>
<li>由于proposal是对应MXN尺度的，所以首先使用spatial_scale参数将其映射回(M/16)X(N/16)大小的feature map尺度；</li>
<li>再将每个proposal对应的feature map区域水平分为<code>pooled_w * pooled_h</code>的网格；</li>
<li>对网格的每一份都进行max pooling处理。<br>这样处理后，即使大小不同的proposal输出结果都是固定大小，实现了固定长度输出。</li>
</ul>
</blockquote>
<h1 id="4-Faster-RCNN的训练"><a href="#4-Faster-RCNN的训练" class="headerlink" title="4. Faster RCNN的训练"></a>4. Faster RCNN的训练</h1><p>6个步骤</p>
<ul>
<li>在已经训练好的model上，训练RPN网络，对应stage1_rpn_train.pt</li>
<li>利用步骤1中训练好的RPN网络，收集proposals，对应rpn_test.pt</li>
<li>第一次训练Fast RCNN网络，对应stage1_fast_rcnn_train.pt</li>
<li>第二训练RPN网络，对应stage2_rpn_train.pt</li>
<li>再次利用步骤4中训练好的RPN网络，收集proposals，对应rpn_test.pt</li>
<li>第二次训练Fast RCNN网络，对应stage2_fast_rcnn_train.pt</li>
</ul>
<h1 id="5-QA"><a href="#5-QA" class="headerlink" title="5 QA"></a>5 QA</h1><p><strong>为何有ROI Pooling还要把输入图片resize到固定大小的MxN</strong><br>由于引入ROI Pooling，从原理上说Faster R-CNN确实能够检测任意大小的图片。但是由于在训练的时候需要使用大batch训练网络，而不同大小输入拼batch在实现的时候代码较为复杂，而且当时以Caffe为代表的第一代深度学习框架也不如Tensorflow和PyTorch灵活，所以作者选择了把输入图片resize到固定大小的800x600。这应该算是历史遗留问题。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>Effective_Modern_C++笔记</title>
    <url>/2020/01/12/Effective-Modern-C-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="型别推导"><a href="#型别推导" class="headerlink" title="型别推导"></a>型别推导</h1><a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;  <span class="comment">//型别是int，值是27</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>; <span class="comment">//型别是int，值是27</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;; <span class="comment">//型别是std::initializer_list&lt;int&gt;,值是27</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;; <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">auto</span> x5 =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>&#125;;  推导不出<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;中的T</span><br></pre></td></tr></table></figure>
<p>当用于auto声明变量的初始化表达式是用大括号扩起时，推导所得的型别就属于std::initializer_list.</p>
<p>带有auto返回值的函数若要返回一个大括号括起来的初始化表达式是通不过编译的。<br>用auto来制定c++14中的lambda式的星灿类被是，也不能使用大括号括起来的初始化表达式。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++11 返回值型别尾序语法：</span></span><br><span class="line"><span class="comment">// 尾序返回值的好处在于，在指定返回值型别时，可以使用函数形参。</span></span><br><span class="line">auto authAndAccess(Container &amp;c, Index i)-&gt;decltype(c[i])&#123;return c[i]&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">const</span> Widget&amp; cw = w;</span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw;  <span class="comment">//Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw;  <span class="comment">//const Widget &amp;</span></span><br></pre></td></tr></table></figure>
<h1 id="转向现代c"><a href="#转向现代c" class="headerlink" title="转向现代c++"></a>转向现代c++</h1><ul>
<li>优先选用nullptr，而非0或NULL</li>
<li>优先选用using别名声明，而非typedef</li>
<li>优先选用限定作用域的枚举类别<ul>
<li>限定作用域的枚举类别可以进行前置声明<br><code>enum class Color; //正确</code><br><code>enum Color; //错误</code></li>
<li>默认型别<br><code>enum class Status: std::uint32_t;</code></li>
</ul>
</li>
<li>优先选用删除函数，而非private未定义函数</li>
<li>为意在改写的函数添加override声明</li>
<li>优先选用const_iterator,而非iterator</li>
<li>只要函数不会发射异常，就为其加上noexcept声明</li>
<li>只要有可能使用constexpr，就使用他，</li>
</ul>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul>
<li>使用unique_ptr管理具备专属所有权的资源</li>
<li>使用shared_ptr管理具备共享所有权的资源</li>
<li>对于类似shared_ptr但有可能空悬的指针使用weak_ptr</li>
<li>优先选用make_unique和make_shared，而非直接使用new</li>
</ul>
<h1 id="右值引用、移动语义和完美转发"><a href="#右值引用、移动语义和完美转发" class="headerlink" title="右值引用、移动语义和完美转发"></a>右值引用、移动语义和完美转发</h1><p><strong>形参总是左值，即使其型别是右值引用</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; w)</span></span>;</span><br><span class="line"><span class="comment">//w 是左值</span></span><br></pre></td></tr></table></figure></p>
<h2 id="std-move-和-std-forward"><a href="#std-move-和-std-forward" class="headerlink" title="std::move 和 std::forward"></a>std::move 和 std::forward</h2><p>std::move无条件的将实参强制转换成右值，而std::forward则仅在某个特定条件满足时才执行同一个强制转换。</p>
<p>如果想要取得某个对象执行移动操作的能力，不要将其声明为常量，因为针对常量对象执行的移动操作将一声不响的变换成复制操作；其次，std::move不仅不实际移动任何东西，甚至不保证经过其强制型别转换后的对象具备可移动能力。std::move的结果唯一可以确定的是，该结果是个右值。</p>
<p>std::forward是有条件的强制型别转换，仅当其实参是使用右值完成初始化时，他才会执行向右值型别的强制型别转换。</p>
<h2 id="区分万能引用和右值引用"><a href="#区分万能引用和右值引用" class="headerlink" title="区分万能引用和右值引用"></a>区分万能引用和右值引用</h2><p>如果看到了<code>T&amp;&amp;</code>，却没有其涉及的型别推导，则其为右值引用<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">//右值引用</span></span><br><span class="line">Widget&amp;&amp; var1 = Widget(); <span class="comment">//右值引用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>;  <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;  <span class="comment">//万能引用</span></span><br><span class="line"><span class="keyword">template</span>&lt;typername T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>; <span class="comment">//万能引用</span></span><br></pre></td></tr></table></figure><br>万能引用的初始化物会决定他代表的是一个左值还是右值引用：如果初始化物是右值，万能应用就会对应到一个右值引用；如果初始化物是一个左值，则万能引用就会对应到一个右值引用</p>
<h2 id="针对右值引用实施std-move-针对万能指针实施std-forward"><a href="#针对右值引用实施std-move-针对万能指针实施std-forward" class="headerlink" title="针对右值引用实施std::move,针对万能指针实施std::forward"></a>针对右值引用实施std::move,针对万能指针实施std::forward</h2><h2 id="避免依万能引用型别进行重载"><a href="#避免依万能引用型别进行重载" class="headerlink" title="避免依万能引用型别进行重载"></a>避免依万能引用型别进行重载</h2><p>把重载和万能引用这两者结合起来几乎总是一个馊主意：一旦万能引用成为重载候选，他就会吸引走大批的实参型别，远比撰写重载代码的程序员期望的要多。</p>
<h2 id="假定移动操作不存在，成本高，未使用"><a href="#假定移动操作不存在，成本高，未使用" class="headerlink" title="假定移动操作不存在，成本高，未使用"></a>假定移动操作不存在，成本高，未使用</h2><p>std::array的复制和移动有相同的时间复杂度</p>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>c++14标准中，捕获成员变量的一种较好的方法是使用广义lambda捕获：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Widget::addFilter() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	filter.emplace_back(</span><br><span class="line">	[divisor = divisor](<span class="keyword">int</span> value)&#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;) <span class="comment">//将divisor复制入闭包，使用副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="优先使用lambda表达式而不是std-bind"><a href="#优先使用lambda表达式而不是std-bind" class="headerlink" title="优先使用lambda表达式而不是std::bind"></a>优先使用lambda表达式而不是std::bind</h2>]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>FasterRCNN目标检测</title>
    <url>/2020/02/25/FasterRCNN%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_44791964/article/details/104451667" target="_blank" rel="noopener">CSDN</a></p>
<h1 id="FasterRCNN"><a href="#FasterRCNN" class="headerlink" title="FasterRCNN"></a>FasterRCNN</h1><a id="more"></a>
<p><img src="9.png" alt=""><br>Faster-RCNN是一个非常有效的目标检测算法，虽然是一个比较早的论文， 但它至今仍是许多目标检测算法的基础。</p>
<p>Faster-RCNN作为一种two-stage的算法，与one-stage的算法相比，two-stage的算法更加复杂且速度较慢，但是检测精度会更高。</p>
<p>事实上也确实是这样，Faster-RCNN的检测效果非常不错，但是检测速度与训练速度有待提高。<br><img src="1.png" alt=""><br>Feature map通过主干提取网络获得<br>9通道是9个先验框，36是9个先验框的调整参数（cx,cy,dw,dh）。<br>proposal中的先验框在Feature map中进行截取。<br>ROIPooling将截取到的信息resize到一个相同的大小<br><img src="2.png" alt=""><br><img src="3.png" alt=""><br>Faster-RCNN可以采用多种的主干特征提取网络，常用的有VGG，Resnet，Xception等等.<br>Faster-RCNN的主干特征提取网络部分只包含了长宽压缩了四次的内容，第五次压缩后的内容在ROI中使用。即Faster-RCNN在主干特征提取网络所用的网络层如图所示。</p>
<h1 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h1><p>如果采用resnet网络，resnet网络的输出为（x//16，y//16，1024）<br>在实际应用中：</p>
<ul>
<li>分类损失=正负样本的binary_crossentropy之和（正样本为检测出来的目标，副样本为背景）</li>
<li>回归损失=正样本的smooth_l1_loss之和</li>
</ul>
<p>RPN网络的输出为anchor的置信度和尺寸修正参数。这些参数的结果通过decode后就是预测框。这些预测框类似于fastRCNN中的预测框的信息。<br>最终结果的输出为每个class的置信度和框的尺寸修正参数。</p>
<h1 id="ROI-pooling-layer"><a href="#ROI-pooling-layer" class="headerlink" title="ROI pooling layer"></a>ROI pooling layer</h1><p>　　　感兴趣区域池（也称为RoI　pooling）是使用卷积神经网络在对象检测任务中广泛使用的操作。例如，在单个图像中检测多个汽车和行人。其目的是对非均匀尺寸的输入执行最大池化以获得固定尺寸的特征图（例如7×7）。</p>
<p>ROI pooling作用有两点：<br>（1）根据输入image，将ROI映射到feature map对应位置，映射是根据image缩小的尺寸来的；<br>（2）将得到的RoI映射在feature map上得到的RoI feature region输出统一大小的特征区域（由于区域提议得到的RoI大小和尺度比例不尽相同，无法输入FC层进行一维化操作）</p>
<h2 id="ROI-pooling-layer的具体操作"><a href="#ROI-pooling-layer的具体操作" class="headerlink" title="ROI pooling layer的具体操作"></a>ROI pooling layer的具体操作</h2><p><img src="4.png" alt=""></p>
<pre><code>1.  根据输入image，将ROI映射到feature map对应位置
2.  将映射后的区域划分为相同大小的sections（sections数量与输出的维度相同）
</code></pre><p>具体过程：假设我们输入的RoI的尺寸大小为H x W，而我们经过RoI pooling layer操作后需要得到的统一尺寸大小为h x w，则有以下几步过程：<br>         1） 输入的H x W需要被划分成h x w个网格块，然后对每个块进行max pooling操作；<br>         2） 那么重要的是每个块需要被划分为多大的像素呢？采用平均分块得到每个块的像素尺寸大小为，但此时又存在问题，如果除不整呢？解决方法是除不整舍去小数保留整数，而最后一个行块或列块包含剩余没有包括在内的元素值。具体看下面的例子。</p>
<pre><code>3.  对每个sections进行max pooling操作
这样我们就可以从不同大小的方框得到固定大小的feature maps
</code></pre><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>考虑一个8<em>8大小的feature map，一个ROI，以及输出大小为2</em>2.<br>（1）输入的固定大小的feature map<br><img src="5.jpg" alt=""><br>（2）region proposal 投影之后位置（左上角，右下角坐标）：（0，3），（7，8）。<br><img src="6.jpg" alt=""><br>（3）将其划分为（2<em>2）个sections（因为输出大小为2</em>2），我们可以得到：<br><img src="7.jpg" alt=""><br>（4）对每个section做max pooling，可以得到：<br><img src="8.jpg" alt=""></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>Embedding层</title>
    <url>/2020/02/17/Embedding%E5%B1%82/</url>
    <content><![CDATA[<p>word2vec到item2vec：  <a href="https://zhuanlan.zhihu.com/p/53194407" target="_blank" rel="noopener">链接</a></p>
<a id="more"></a>
<h1 id="Embedding层"><a href="#Embedding层" class="headerlink" title="Embedding层"></a>Embedding层</h1><blockquote>
<p>近年来，从计算机视觉到自然语言处理再到时间序列预测，神经网络、深度学习的应用越来越广泛。在深度学习的应用过程中，Embedding 这样一种将离散变量转变为连续向量的方式为神经网络在各方面的应用带来了极大的扩展。该技术目前主要有两种应用，NLP 中常用的 word embedding 以及用于类别数据的 entity embedding。</p>
</blockquote>
<p>此篇文章内容主要源自于 <a href="https://link.zhihu.com/?target=https%3A//towardsdatascience.com/neural-network-embeddings-explained-4d028e6f0526">Neural Network Embeddings Explained</a> ，起初未在文章开头标明，谢谢 </p>
<p><a href="https://www.zhihu.com/people/36f5a055cdf4d8abdbe17d725eedc065" target="_blank" rel="noopener">@Michael Tan</a></p>
<p> 的提醒 。</p>
<p>本篇文章主要介绍以下内容：</p>
<ul>
<li>什么是 neural network embedding ？</li>
<li>我们为什么需要使用 neural network embedding？</li>
<li>以及 embedding 是如何自学习的？</li>
</ul>
<p>本文中，将谈到这样一个例子，使用 neural network embedding 来表示所有维基百科上的书籍，可以通过<a href="https://link.zhihu.com/?target=https%3A//github.com/WillKoehrsen/wikipedia-data-science/blob/master/notebooks/Book%20Recommendation%20System.ipynb">这里</a>访问到原作者的推荐系统项目。</p>
<p><img src="image/v2-91311fccee1d318bdebe4166b8640b2f_hd.jpg" alt="img"></p>
<p>Figure 1: Neural Network Embedding of all books on Wikipedia.</p>
<h2 id="Embedding-和-One-Hot-编码"><a href="#Embedding-和-One-Hot-编码" class="headerlink" title="Embedding 和 One Hot 编码"></a><strong>Embedding 和 One Hot 编码</strong></h2><p>上面说了，Embedding 是一个将离散变量转为连续向量表示的一个方式。在神经网络中，embedding 是非常有用的，因为它不光可以减少离散变量的空间维数，同时还可以有意义的表示该变量。</p>
<p>我们可以总结一下，embedding 有以下 3 个主要目的：</p>
<ol>
<li>在 embedding 空间中查找最近邻，这可以很好的用于根据用户的兴趣来进行推荐。</li>
<li>作为监督性学习任务的输入。</li>
<li>用于可视化不同离散变量之间的关系。</li>
</ol>
<p>这也就意味对于上面我们所说的维基百科书籍表示而言，使用 Neural Network Embedding，我们可以在维基百科上获取到的所有 37,000 本书，对于每一篇，仅仅用一个包含 50 个数字的向量即可表示。此外，因为 embedding 是可学习的，因此在不断的训练过程中，更相似的书籍的表示在 embedding space 中将彼此更接近。</p>
<p>要了解 embedding 的优点，我们可以对应 One-hot 编码来观察。One-hot 编码是一种最普通常见的表示离散数据的表示，首先我们计算出需要表示的离散或类别变量的总个数 N，然后对于每个变量，我们就可以用 N-1 个 0 和单个 1 组成的 vector 来表示每个类别。这样做有两个很明显的缺点：</p>
<ol>
<li>对于具有非常多类型的类别变量，变换后的向量维数过于巨大，且过于稀疏。</li>
<li>映射之间完全独立，并不能表示出不同类别之间的关系。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># One Hot Encoding Categoricals</span><br><span class="line">books &#x3D; [&quot;War and Peace&quot;, &quot;Anna Karenina&quot;, </span><br><span class="line">          &quot;The Hitchhiker&#39;s Guide to the Galaxy&quot;]</span><br><span class="line">books_encoded &#x3D; [[1, 0, 0],</span><br><span class="line">                 [0, 1, 0],</span><br><span class="line">                 [0, 0, 1]]</span><br><span class="line">Similarity (dot product) between First and Second &#x3D; 0</span><br><span class="line">Similarity (dot product) between Second and Third &#x3D; 0</span><br><span class="line">Similarity (dot product) between First and Third &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>因此，考虑到这两个问题，表示类别变量的理想解决方案则是我们是否可以通过较少的维度表示出每个类别，并且还可以一定的表现出不同类别变量之间的关系，这也就是 embedding 出现的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Idealized Representation of Embedding</span><br><span class="line">books &#x3D; [&quot;War and Peace&quot;, &quot;Anna Karenina&quot;, </span><br><span class="line">          &quot;The Hitchhiker&#39;s Guide to the Galaxy&quot;]</span><br><span class="line">books_encoded_ideal &#x3D; [[0.53,  0.85],</span><br><span class="line">                       [0.60,  0.80],</span><br><span class="line">                       [-0.78, -0.62]]</span><br><span class="line">Similarity (dot product) between First and Second &#x3D; 0.99</span><br><span class="line">Similarity (dot product) between Second and Third &#x3D; -0.94</span><br><span class="line">Similarity (dot product) between First and Third &#x3D; -0.97</span><br></pre></td></tr></table></figure>
<p>而为了更好的表示类别实体，我们还可以是用一个 embedding neural network 和 supervised 任务来进行学习训练，以找到最适合的表示以及挖掘其内在联系。</p>
<p>One-hot 编码的最大问题在于其转换不依赖于任何的内在关系，而通过一个监督性学习任务的网络，我们可以通过优化网络的参数和权重来减少 loss 以改善我们的 embedding 表示，loss 越小，则表示最终的向量表示中，越相关的类别，它们的表示越相近。</p>
<p>上面给出维基百科的例子中，可能有这样的一个 supervised 任务，“预测这本书是否是 Leo Tolstoy 写的”，而我们最终产生的 embedding 则会让 Tolstory 写的书之间的表示更接近。因此弄清楚如何创建监督学习任务和产生相关表示是 embedding 表示的关键。</p>
<h2 id="Embedding-可视化"><a href="#Embedding-可视化" class="headerlink" title="Embedding 可视化"></a><strong>Embedding 可视化</strong></h2><p>Embedding 最酷的一个地方在于它们可以用来可视化出表示的数据的相关性，当然要我们能够观察，需要通过降维技术来达到 2 维或 3 维。最流行的降维技术是：t-Distributed Stochastic Neighbor Embedding (TSNE)。</p>
<p>我们可以定义维基百科上所有书籍为原始 37,000 维，使用 neural network embedding 将它们映射到 50 维，然后使用 TSNE 将它们映射到 2 维，其结果如下：</p>
<p><img src="image/v2-a93dd8f6e15034811ae6bc253c6b08d8_hd.jpg" alt="img"></p>
<p>Figure 2: Embedding of all 37,000 books on Wikipedia</p>
<p>这样看好像并不能看出什么，但是如果我们根据不同书籍的特征着色，我们将可以很明显的看出结果。</p>
<p><img src="image/v2-e1c5fcd4234d9a6ef64daa9108309ed7_hd.jpg" alt="img"></p>
<p>Figure 3: Embeddings Colored by Genre</p>
<p>我们可以清楚地看到属于同一类型的书籍的分组。虽然它并不完美，但惊奇的是，我们只用 2 个数字就代表维基百科上的所有书籍，而在这些数字中仍能捕捉到不同类型之间的差异。这代表着 embedding 的价值。</p>
<p>静态图的问题在于我们无法真正探索数据并调查变量之间的分组或关系。 为了解决这个问题，TensorFlow开发了 <a href="https://link.zhihu.com/?target=https%3A//projector.tensorflow.org/">projector</a>，这是一个在线应用程序，可以让我们可视化并与 embedding 交互。 结果如下：</p>
<p><img src="image/v2-d4d476abc1d10c2ceadead06441d11fd_b.jpg" alt="img"></p>
<p>Figure 4: Interactive Exploration of Book Embeddings using projector</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Embedding 的基本内容如前面介绍所示，然而我想说的是它的价值并不仅仅在于 word embedding 或者 entity embedding，这种将类别数据用低维表示且可自学习的思想更存在价值。通过这种方式，我们可以将神经网络，深度学习用于更广泛的领域，Embedding 可以表示更多的东西，而这其中的关键在于要想清楚我们需要解决的问题和应用 Embedding 表示我们得到的是什么。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>Focal loss原理与实现</title>
    <url>/2020/02/22/Focal-loss%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="什么是Focal-loss"><a href="#什么是Focal-loss" class="headerlink" title="什么是Focal loss"></a>什么是Focal loss</h1><a id="more"></a>
<p>Focal loss是何恺明大神提出的一种新的loss计算方案。<br>其具有两个重要的特点。</p>
<p>1、控制正负样本的权重<br>2、控制容易分类和难分类样本的权重</p>
<p>正负样本的概念如下：<br>一张图像可能生成成千上万的候选框，但是其中只有很少一部分是包含目标的的，有目标的就是正样本，没有目标的就是负样本。</p>
<p>容易分类和难分类样本的概念如下：<br>假设存在一个二分类，样本1属于类别1的pt=0.9，样本2属于类别1的pt=0.6，显然前者更可能是类别1，其就是容易分类的样本；后者有可能是类别1，所以其为难分类样本。</p>
<p>如何实现权重控制呢，请往下看：</p>
<h1 id="控制正负样本的权重"><a href="#控制正负样本的权重" class="headerlink" title="控制正负样本的权重"></a>控制正负样本的权重</h1><p>如下是常用的交叉熵loss，以二分类为例：<br><img src="1.png" alt=""><br>我们可以利用如下Pt简化交叉熵loss。<br><img src="2.png" alt=""><br>此时：<br><img src="3.png" alt=""><br>想要降低负样本的影响，可以在常规的损失函数前增加一个系数αt。与Pt类似，当label=1的时候，αt=α；当label=otherwise的时候，αt=1 - α，a的范围也是0到1。此时我们便可以通过设置α实现控制正负样本对loss的贡献。<br><img src="4.png" alt=""><br>其中：<br><img src="5.png" alt=""><br>分解开就是：<br><img src="6.jpg" alt=""></p>
<h1 id="控制容易分类和难分类样本的权重"><a href="#控制容易分类和难分类样本的权重" class="headerlink" title="控制容易分类和难分类样本的权重"></a>控制容易分类和难分类样本的权重</h1><p>按照刚才的思路，一个二分类，样本1属于类别1的pt=0.9，样本2属于类别1的pt=0.6，也就是 是某个类的概率越大，其越容易分类 所以利用1-Pt就可以计算出其属于容易分类或者难分类。<br>具体实现方式如下。<br><img src="7.png" alt=""><br>其中<script type="math/tex">(1-p_t)^{\gamma}</script>称为调制系数<br>1、当pt趋于0的时候，调制系数趋于1，对于总的loss的贡献很大。当pt趋于1的时候，调制系数趋于0，也就是对于总的loss的贡献很小。<br>2、当γ=0的时候，focal loss就是传统的交叉熵损失，可以通过调整γ实现调制系数的改变。</p>
<h1 id="两种权重控制方法合并"><a href="#两种权重控制方法合并" class="headerlink" title="两种权重控制方法合并"></a>两种权重控制方法合并</h1><p>通过如下公式就可以实现控制正负样本的权重和控制容易分类和难分类样本的权重。<br><img src="8.png" alt=""></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>GAN生成式对抗网络</title>
    <url>/2020/02/23/GAN%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="什么是GAN"><a href="#什么是GAN" class="headerlink" title="什么是GAN"></a>什么是GAN</h1><p>CSDN: <a href="https://blog.csdn.net/weixin_44791964/article/details/103729797" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103729797</a><br><a id="more"></a><br>生成式对抗网络（GAN, Generative Adversarial Networks ）是一种深度学习模型，是近年来复杂分布上无监督学习最具前景的方法之一。<br>模型通过框架中（至少）两个模块：生成模型（Generative Model）和判别模型（Discriminative Model）的互相博弈学习产生相当好的输出。<br>原始 GAN 理论中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。<br>一个优秀的GAN应用需要有良好的训练方法，否则可能由于神经网络模型的自由性而导致输出不理想。</p>
<p>其实简单来讲，一般情况下，GAN就是创建两个神经网络，一个是生成模型，一个是判别模型。</p>
<p>生成模型输入一行正态分布随机数生成相应的输出。<br>判别模型对生成模型的输出进行判别，判断它是不是真的。</p>
<p>生成模型的目的是<strong>生成让判别模型无法判断真伪的输出</strong>。<br>判别模型的目的是<strong>判断出真伪</strong>。</p>
<p><img src="5.png" alt=""></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA使用</title>
    <url>/2021/02/03/IDEA%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>IDEA快捷键等的使用<br><a id="more"></a></p>
<h2 id="IDEA使用"><a href="#IDEA使用" class="headerlink" title="IDEA使用"></a>IDEA使用</h2><p><strong>帮助文档</strong>：</p>
<p><a href="https://www.jetbrains.com/help/idea/discover-intellij-idea.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/discover-intellij-idea.html</a></p>
<p><strong>安装目录</strong>：</p>
<p><code>可执行文件目录</code>+<code>用户目录/.IntelliJIdea/</code></p>
<p><strong>参数设置</strong></p>
<p>安装目录下的bin文件夹中的<code>idea64.exe.vmoptions</code>文件用于设置虚拟机的相关参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms128m   &#x2F;&#x2F;初始内存数，可以改为500，</span><br><span class="line">-Xmx750m   &#x2F;&#x2F;最大内存数，可以改为1500，可以降低垃圾回收频率</span><br><span class="line">-XX:ReservedCodeCacheSize&#x3D;512m &#x2F;&#x2F;提高可以降低代码回收率</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB&#x3D;50</span><br><span class="line">-XX:CICompilerCount&#x3D;2</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-ea</span><br><span class="line">-Dsun.io.useCanonCaches&#x3D;false</span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes&#x3D;&quot;&quot;</span><br><span class="line">-Djdk.attach.allowAttachSelf&#x3D;true</span><br><span class="line">-Djdk.module.illegalAccess.silent&#x3D;true</span><br><span class="line">-Dkotlinx.coroutines.debug&#x3D;off</span><br></pre></td></tr></table></figure>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="1-Ctrl"><a href="#1-Ctrl" class="headerlink" title="1.Ctrl"></a>1.Ctrl</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + F</td>
<td>在当前文件进行文本查找 （必备）</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>在当前文件进行文本替换 （必备）</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>撤销 （必备）</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>删除光标所在行 或 删除选中的行 （必备）</td>
</tr>
<tr>
<td>Ctrl + X</td>
<td>剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>显示最近打开的文件记录列表 （必备）</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>根据输入的 <strong>类名</strong> 查找类文件 （必备）</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>在当前文件跳转到指定行处</td>
</tr>
<tr>
<td>Ctrl + J</td>
<td>插入自定义动态代码模板 （必备）</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>方法参数提示显示 （必备）</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>前往当前光标所在的方法的父类的方法 / 接口定义 （必备）</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备）</td>
</tr>
<tr>
<td>Ctrl + K</td>
<td>版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>显示当前类的层次结构</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>选择可重写的方法</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>选择可继承的方法</td>
</tr>
<tr>
<td>Ctrl + +</td>
<td>展开代码</td>
</tr>
<tr>
<td>Ctrl + -</td>
<td>折叠代码</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</td>
</tr>
<tr>
<td>Ctrl + [</td>
<td>移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td>Ctrl + ]</td>
<td>移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td>Ctrl + F1</td>
<td>在光标所在的错误代码处显示错误信息 （必备）</td>
</tr>
<tr>
<td>Ctrl + F3</td>
<td>调转到所选中的词的下一个引用位置 （必备）</td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭当前编辑文件</td>
</tr>
<tr>
<td>Ctrl + F8</td>
<td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td>Ctrl + F9</td>
<td>执行 Make Project 操作</td>
</tr>
<tr>
<td>Ctrl + F11</td>
<td>选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备）</td>
</tr>
<tr>
<td>Ctrl + F12</td>
<td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td>Ctrl + End</td>
<td>跳到文件尾</td>
</tr>
<tr>
<td>Ctrl + Home</td>
<td>跳到文件头</td>
</tr>
<tr>
<td>Ctrl + Space</td>
<td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除光标后面的单词或是中文句 （必备）</td>
</tr>
<tr>
<td>Ctrl + BackSpace</td>
<td>删除光标前面的单词或是中文句 （必备）</td>
</tr>
<tr>
<td>Ctrl + 1,2,3…9</td>
<td>定位到对应数值的书签位置 （必备）</td>
</tr>
<tr>
<td>Ctrl + 左键单击</td>
<td>在打开的文件标题上，弹出该文件路径 （必备）</td>
</tr>
<tr>
<td>Ctrl + 光标定位</td>
<td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td>Ctrl + 左方向键</td>
<td>光标跳转到当前单词 / 中文句的左侧开头位置 （必备）</td>
</tr>
<tr>
<td>Ctrl + 右方向键</td>
<td>光标跳转到当前单词 / 中文句的右侧开头位置 （必备）</td>
</tr>
<tr>
<td>Ctrl + 前方向键</td>
<td>等效于鼠标滚轮向前效果 （必备）</td>
</tr>
<tr>
<td>Ctrl + 后方向键</td>
<td>等效于鼠标滚轮向后效果 （必备）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-Alt"><a href="#2-Alt" class="headerlink" title="2.Alt"></a>2.Alt</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt + `\</td>
<td>显示版本控制常用操作菜单弹出层 （必备）</td>
<td></td>
</tr>
<tr>
<td>Alt + Q</td>
<td>弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td>Alt + F1</td>
<td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备）</td>
</tr>
<tr>
<td>Alt + F2</td>
<td>对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td>Alt + F3</td>
<td>选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td>Alt + F7</td>
<td>查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td>Alt + F8</td>
<td>在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td>Alt + Home</td>
<td>定位 / 显示到当前文件的 Navigation Bar</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</td>
</tr>
<tr>
<td>Alt + Insert</td>
<td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备）</td>
</tr>
<tr>
<td>Alt + 左方向键</td>
<td>切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）</td>
</tr>
<tr>
<td>Alt + 右方向键</td>
<td>按切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）</td>
</tr>
<tr>
<td>Alt + 前方向键</td>
<td>当前光标跳转到当前文件的前一个方法名位置 （必备）</td>
</tr>
<tr>
<td>Alt + 后方向键</td>
<td>当前光标跳转到当前文件的后一个方法名位置 （必备）</td>
</tr>
<tr>
<td>Alt + 1,2,3…9</td>
<td>显示对应数值的选项卡，其中 1 是 Project 用得最多 （必备）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-Shift"><a href="#3-Shift" class="headerlink" title="3.Shift"></a>3.Shift</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Shift + F1</td>
<td>如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td>Shift + F2</td>
<td>跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td>Shift + F3</td>
<td>在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td>Shift + F4</td>
<td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td>Shift + F7</td>
<td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td>
</tr>
<tr>
<td>Shift + F9</td>
<td>等效于点击工具栏的 Debug 按钮</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>等效于点击工具栏的 Run 按钮</td>
</tr>
<tr>
<td>Shift + F11</td>
<td>弹出书签显示层 （必备）</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>取消缩进 （必备）</td>
</tr>
<tr>
<td>Shift + ESC</td>
<td>隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td>Shift + End</td>
<td>选中光标到当前行尾位置</td>
</tr>
<tr>
<td>Shift + Home</td>
<td>选中光标到当前行头位置</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备）</td>
</tr>
<tr>
<td>Shift + 左键单击</td>
<td>在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备）</td>
</tr>
<tr>
<td>Shift + 滚轮前后滚动</td>
<td>当前文件的横向滚动轴滚动 （必备）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-Ctrl-Alt"><a href="#4-Ctrl-Alt" class="headerlink" title="4.Ctrl + Alt"></a>4.Ctrl + Alt</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + Alt + L</td>
<td>格式化代码，可以对当前文件和整个包目录使用 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + O</td>
<td>优化导入的类，可以对当前文件和整个包目录使用 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + I</td>
<td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td>Ctrl + Alt + T</td>
<td>对选中的代码弹出环绕选项弹出层 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + J</td>
<td>弹出模板选择窗口，将选定的代码加入动态模板中</td>
</tr>
<tr>
<td>Ctrl + Alt + H</td>
<td>调用层次</td>
</tr>
<tr>
<td>Ctrl + Alt + B</td>
<td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td>Ctrl + Alt + C</td>
<td>重构-快速提取常量</td>
</tr>
<tr>
<td>Ctrl + Alt + F</td>
<td>重构-快速提取成员变量</td>
</tr>
<tr>
<td>Ctrl + Alt + V</td>
<td>重构-快速提取变量</td>
</tr>
<tr>
<td>Ctrl + Alt + Y</td>
<td>同步、刷新</td>
</tr>
<tr>
<td>Ctrl + Alt + S</td>
<td>打开 IntelliJ IDEA 系统设置 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + F7</td>
<td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td>Ctrl + Alt + F11</td>
<td>切换全屏模式</td>
</tr>
<tr>
<td>Ctrl + Alt + Enter</td>
<td>光标所在行上空出一行，光标定位到新行 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + Home</td>
<td>弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td>Ctrl + Alt + Space</td>
<td>类名自动完成</td>
</tr>
<tr>
<td>Ctrl + Alt + 左方向键</td>
<td>退回到上一个操作的地方 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + 右方向键</td>
<td>前进到上一个操作的地方 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + 前方向键</td>
<td>在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td>Ctrl + Alt + 后方向键</td>
<td>在查找模式下，跳到下个查找的文件</td>
</tr>
<tr>
<td>Ctrl + Alt + 右括号（]）</td>
<td>在打开多个项目的情况下，切换下一个项目窗口</td>
</tr>
<tr>
<td>Ctrl + Alt + 左括号（[）</td>
<td>在打开多个项目的情况下，切换上一个项目窗口</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-Ctrl-Shift"><a href="#5-Ctrl-Shift" class="headerlink" title="5.Ctrl + Shift"></a>5.Ctrl + Shift</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + Shift + F</td>
<td>根据输入内容查找整个项目 或 指定目录内文件 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + R</td>
<td>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + J</td>
<td>自动将下一行合并到当前行末尾 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + Z</td>
<td>取消撤销 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + U</td>
<td>对选中的代码进行大 / 小写轮流转换 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + T</td>
<td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + C</td>
<td>复制当前文件磁盘路径到剪贴板 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + V</td>
<td>弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td>Ctrl + Shift + H</td>
<td>显示方法层次结构</td>
</tr>
<tr>
<td>Ctrl + Shift + B</td>
<td>跳转到类型声明处 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + I</td>
<td>快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td>Ctrl + Shift + A</td>
<td>查找动作 / 设置</td>
</tr>
<tr>
<td>Ctrl + Shift + /</td>
<td>代码块注释 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + [</td>
<td>选中从光标所在位置到它的顶部中括号位置 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + ]</td>
<td>选中从光标所在位置到它的底部中括号位置 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + +</td>
<td>展开所有代码 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + -</td>
<td>折叠所有代码 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>高亮显示所有该选中文本，按Esc高亮消失 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + F8</td>
<td>在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td>Ctrl + Shift + F9</td>
<td>编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td>Ctrl + Shift + F12</td>
<td>编辑器最大化 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + Space</td>
<td>智能代码提示</td>
</tr>
<tr>
<td>Ctrl + Shift + Enter</td>
<td>自动结束代码，行末自动添加分号 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + Backspace</td>
<td>退回到上次修改的地方 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + 1,2,3…9</td>
<td>快速添加指定数值的书签 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + 左键单击</td>
<td>把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + 左方向键</td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + 右方向键</td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + 前方向键</td>
<td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + 后方向键</td>
<td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="6-Alt-Shift"><a href="#6-Alt-Shift" class="headerlink" title="6.Alt + Shift"></a>6.Alt + Shift</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt + Shift + N</td>
<td>选择 / 添加 task （必备）</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>显示添加到收藏夹弹出层 / 添加到收藏夹</td>
</tr>
<tr>
<td>Alt + Shift + C</td>
<td>查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td>Alt + Shift + I</td>
<td>查看项目当前文件</td>
</tr>
<tr>
<td>Alt + Shift + F7</td>
<td>在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td>Alt + Shift + F9</td>
<td>弹出 Debug 的可选择菜单</td>
</tr>
<tr>
<td>Alt + Shift + F10</td>
<td>弹出 Run 的可选择菜单</td>
</tr>
<tr>
<td>Alt + Shift + 左键双击</td>
<td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备）</td>
</tr>
<tr>
<td>Alt + Shift + 前方向键</td>
<td>移动光标所在行向上移动 （必备）</td>
</tr>
<tr>
<td>Alt + Shift + 后方向键</td>
<td>移动光标所在行向下移动 （必备）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="7-Ctrl-Shift-Alt"><a href="#7-Ctrl-Shift-Alt" class="headerlink" title="7.Ctrl + Shift + Alt"></a>7.Ctrl + Shift + Alt</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + Shift + Alt + V</td>
<td>无格式黏贴 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + N</td>
<td>前往指定的变量 / 方法</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + S</td>
<td>打开当前项目设置 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + C</td>
<td>复制参考信息</td>
</tr>
</tbody>
</table>
</div>
<h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>F2</td>
<td>跳转到下一个高亮错误 或 警告位置 （必备）</td>
</tr>
<tr>
<td>F3</td>
<td>在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td>F4</td>
<td>编辑源 （必备）</td>
</tr>
<tr>
<td>F7</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td>F8</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td>F9</td>
<td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td>F11</td>
<td>添加书签 （必备）</td>
</tr>
<tr>
<td>F12</td>
<td>回到前一个工具窗口 （必备）</td>
</tr>
<tr>
<td>Tab</td>
<td>缩进 （必备）</td>
</tr>
<tr>
<td>ESC</td>
<td>从工具窗口进入代码文件窗口 （必备）</td>
</tr>
<tr>
<td>连按两次Shift</td>
<td>弹出 Search Everywhere 弹出层</td>
</tr>
</tbody>
</table>
</div>
<h2 id="常用模板"><a href="#常用模板" class="headerlink" title="常用模板"></a>常用模板</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//sout</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//soutp/soutp/soutv/xxx.sout</span></span><br><span class="line">        System.out.println(<span class="string">"args = "</span> + Arrays.deepToString(args));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// soutv,就近</span></span><br><span class="line">        System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">        <span class="comment">// xxx.sout</span></span><br><span class="line">        System.out.println(num1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fori</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//iter</span></span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//itar</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            String arg = args[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//list.for</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">12</span>);</span><br><span class="line">        list.add(<span class="number">12</span>);</span><br><span class="line">        list.add(<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// list.fori</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// list.forr</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ifn \ xxx.null</span></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inn \ xxx.nn</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// prsf</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> xxx =;</span><br><span class="line">    <span class="comment">// psf</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>;</span><br><span class="line">    <span class="comment">// psfi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="comment">// psfs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String $VAR1$;</span><br><span class="line">$END$</span><br></pre></td></tr></table></figure>
<h2 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h2><p>Tools-&gt;Generate JavaDoc</p>
<p>设置：</p>
<p>Locale: <code>zh_CN</code></p>
<p>command arguments: <code>-encoding UTF-8-charset UTF-8</code></p>
<h2 id="缓存和索引文件的清理"><a href="#缓存和索引文件的清理" class="headerlink" title="缓存和索引文件的清理"></a>缓存和索引文件的清理</h2><p>File-&gt;Invalidate Caches/Restart</p>
<h2 id="取消更新"><a href="#取消更新" class="headerlink" title="取消更新"></a>取消更新</h2><p>设置-》Apperance/behaviors-&gt;system settings-&gt;updates</p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA使用JUnit5编写测试</title>
    <url>/2020/12/30/IDEA%E4%BD%BF%E7%94%A8JUnit5%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>廖雪峰的JAVA教程使用Eclipse进行JUnit的使用介绍。个人使用IDEA，因此，学习了IDEA+JUnit5的使用。<br><a id="more"></a></p>
<p>使用步骤：</p>
<ul>
<li>File-&gt;Project Structure-&gt;Project Settings-&gt;Sources-&gt;将测试文件目录进行标注</li>
<li>右键代码区，选择Generate-&gt;Test..</li>
<li>确定</li>
<li>写测试代码</li>
<li>点击测试方法左侧的执行按钮进行测试</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA_SE笔记1</title>
    <url>/2020/12/28/JAVA-SE%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>学习廖雪峰的JAVA入门教程的笔记第一部分。</p>
<p>准备工作、JAVA面向对象编程、JAVA核心类、异常处理<br><a id="more"></a></p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="第一个JAVA程序"><a href="#第一个JAVA程序" class="headerlink" title="第一个JAVA程序"></a>第一个JAVA程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 编译</span><br><span class="line">javac Hello.java</span><br><span class="line">&#x2F;&#x2F; 执行</span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure>
<h2 id="JAVA程序基础"><a href="#JAVA程序基础" class="headerlink" title="JAVA程序基础"></a>JAVA程序基础</h2><h3 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  基本类型及字节数：</span></span><br><span class="line"><span class="comment">  整数类型: byte(1),short(2),int(4),long(8)</span></span><br><span class="line"><span class="comment">  浮点数类型：float(4)，double(8)</span></span><br><span class="line"><span class="comment">  字符类型:char(2)</span></span><br><span class="line"><span class="comment">  布尔类型：boolean(没有明确规定，通常JVM会将其处理为4字节的整数)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">3.14e38f</span>; <span class="comment">// 科学计数法表示的3.14x10^38</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.79e308</span>;</span><br><span class="line"><span class="keyword">double</span> d2 = -<span class="number">1.79e308</span>;</span><br><span class="line"><span class="keyword">double</span> d3 = <span class="number">4.9e-324</span>; <span class="comment">// 科学计数法表示的4.9x10^-324</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> isGreater = <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// 计算结果为true</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">boolean</span> isAdult = age &gt;= <span class="number">18</span>; <span class="comment">// 计算结果为false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> zh = <span class="string">'中'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  引用类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>定义变量的时候，如果加上<code>final</code>修饰符，这个变量就变成了常量：<br><code>final double PI = 3.14; // PI是一个常量</code></p>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">12345</span> / <span class="number">67</span>; <span class="comment">// 184,商</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">12345</span> % <span class="number">67</span>; <span class="comment">// 12345÷67的余数是17</span></span><br><span class="line"></span><br><span class="line">n += <span class="number">100</span>; <span class="comment">// 3409, 相当于 n = n + 100;</span></span><br><span class="line">n -= <span class="number">100</span>; <span class="comment">// 3309, 相当于 n = n - 100;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">3300</span>;</span><br><span class="line">n++; <span class="comment">// 3301, 相当于 n = n + 1;</span></span><br><span class="line">n--; <span class="comment">// 3300, 相当于 n = n - 1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>;       <span class="comment">// 00000000 00000000 00000000 00000111 = 7</span></span><br><span class="line"><span class="keyword">int</span> a = n &lt;&lt; <span class="number">1</span>;  <span class="comment">// 00000000 00000000 00000000 00001110 = 14</span></span><br><span class="line"><span class="keyword">int</span> b = n &lt;&lt; <span class="number">2</span>;  <span class="comment">// 00000000 00000000 00000000 00011100 = 28</span></span><br><span class="line"><span class="keyword">int</span> c = n &lt;&lt; <span class="number">28</span>; <span class="comment">// 01110000 00000000 00000000 00000000 = 1879048192</span></span><br><span class="line"><span class="keyword">int</span> d = n &lt;&lt; <span class="number">29</span>; <span class="comment">// 11100000 00000000 00000000 00000000 = -536870912</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：</span></span><br><span class="line"><span class="keyword">int</span> n = -<span class="number">536870912</span>;</span><br><span class="line"><span class="keyword">int</span> a = n &gt;&gt; <span class="number">1</span>;  <span class="comment">// 11110000 00000000 00000000 00000000 = -268435456</span></span><br><span class="line"><span class="keyword">int</span> b = n &gt;&gt; <span class="number">2</span>;  <span class="comment">// 11111000 00000000 00000000 00000000 = -134217728</span></span><br><span class="line"><span class="keyword">int</span> c = n &gt;&gt; <span class="number">28</span>; <span class="comment">// 11111111 11111111 11111111 11111110 = -2</span></span><br><span class="line"><span class="keyword">int</span> d = n &gt;&gt; <span class="number">29</span>; <span class="comment">// 11111111 11111111 11111111 11111111 = -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号的右移运算</span></span><br><span class="line"><span class="keyword">int</span> n = -<span class="number">536870912</span>;</span><br><span class="line"><span class="keyword">int</span> a = n &gt;&gt;&gt; <span class="number">1</span>;  <span class="comment">// 01110000 00000000 00000000 00000000 = 1879048192</span></span><br><span class="line"><span class="keyword">int</span> b = n &gt;&gt;&gt; <span class="number">2</span>;  <span class="comment">// 00111000 00000000 00000000 00000000 = 939524096</span></span><br><span class="line"><span class="keyword">int</span> c = n &gt;&gt;&gt; <span class="number">29</span>; <span class="comment">// 00000000 00000000 00000000 00000111 = 7</span></span><br><span class="line"><span class="keyword">int</span> d = n &gt;&gt;&gt; <span class="number">31</span>; <span class="comment">// 00000000 00000000 00000000 00000001 = 1</span></span><br><span class="line"><span class="comment">//对byte和short类型进行移位时，会首先转换为int再进行位移。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位运算</span></span><br><span class="line">n = <span class="number">0</span> &amp; <span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line">n = <span class="number">0</span> | <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">n = ~<span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line">n = <span class="number">0</span> ^ <span class="number">1</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。</p>
</blockquote>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较x和y是否相等，先计算其差的绝对值:</span></span><br><span class="line"><span class="keyword">double</span> r = Math.abs(x - y);</span><br><span class="line"><span class="comment">// 再判断绝对值是否足够小:</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个复杂的四则运算中，两个整数的运算不会出现自动提升</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.2</span> + <span class="number">24</span> / <span class="number">5</span>; <span class="comment">// 5.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制转型</span></span><br><span class="line"><span class="keyword">int</span> n1 = (<span class="keyword">int</span>) <span class="number">12.3</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">int</span> n2 = (<span class="keyword">int</span>) <span class="number">12.7</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">int</span> n2 = (<span class="keyword">int</span>) -<span class="number">12.7</span>; <span class="comment">// -12</span></span><br><span class="line"><span class="keyword">int</span> n3 = (<span class="keyword">int</span>) (<span class="number">12.7</span> + <span class="number">0.5</span>); <span class="comment">// 13</span></span><br><span class="line"><span class="keyword">int</span> n4 = (<span class="keyword">int</span>) <span class="number">1.2e20</span>; <span class="comment">// 2147483647</span></span><br></pre></td></tr></table></figure>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p>布尔运算是一种关系运算，包括以下几类：</p>
<ul>
<li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code></li>
<li>与运算 <code>&amp;&amp;</code></li>
<li>或运算 <code>||</code></li>
<li>非运算 <code>!</code></li>
</ul>
<p><strong>三元运算符</strong></p>
<p>三元运算符<code>b ? x : y</code></p>
<h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">'中'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n1 = <span class="string">'A'</span>; <span class="comment">// 字母“A”的Unicodde编码是65</span></span><br><span class="line"><span class="keyword">int</span> n2 = <span class="string">'中'</span>; <span class="comment">// 汉字“中”的Unicode编码是20013</span></span><br><span class="line"><span class="comment">// 注意是十六进制:</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">'\u0041'</span>; <span class="comment">// 'A'，因为十六进制0041 = 十进制65</span></span><br><span class="line"><span class="keyword">char</span> c4 = <span class="string">'\u4e2d'</span>; <span class="comment">// '中'，因为十六进制4e2d = 十进制20013</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">""</span>; <span class="comment">// 空字符串，包含0个字符</span></span><br><span class="line">String s1 = <span class="string">"A"</span>; <span class="comment">// 包含一个字符</span></span><br><span class="line">String s2 = <span class="string">"ABC"</span>; <span class="comment">// 包含3个字符</span></span><br><span class="line">String s3 = <span class="string">"中文 ABC"</span>; <span class="comment">// 包含6个字符，其中有一个空格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s = <span class="string">"abc\"xyz"</span>; <span class="comment">// 包含7个字符: a, b, c, ", x, y, z</span></span><br></pre></td></tr></table></figure>
<p>常见的转义字符包括：</p>
<ul>
<li><code>\&quot;</code> 表示字符<code>&quot;</code></li>
<li><code>\&#39;</code> 表示字符<code>&#39;</code></li>
<li><code>\\</code> 表示字符<code>\</code></li>
<li><code>\n</code> 表示换行符</li>
<li><code>\r</code> 表示回车符</li>
<li><code>\t</code> 表示Tab</li>
<li><code>\u####</code> 表示一个Unicode编码的字符</li>
</ul>
<p>Java的编译器对字符串做了特殊照顾，可以使用<code>+</code>连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。</p>
<p>从Java 13开始，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks），多行字符串前面共同的空格会被去掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    SELECT * FROM</span></span><br><span class="line"><span class="string">    users</span></span><br><span class="line"><span class="string">    WHERE id &gt; 100</span></span><br><span class="line"><span class="string">    ORDER BY name DESC</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span>;</span><br></pre></td></tr></table></figure>
<p><strong>字符串不可变</strong></p>
<p>引用类型的变量可以指向一个空值<code>null</code>，它表示不存在，即该变量不指向任何对象。</p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">ns[<span class="number">0</span>] = <span class="number">68</span>;</span><br><span class="line">ns[<span class="number">1</span>] = <span class="number">79</span>;</span><br><span class="line">ns[<span class="number">2</span>] = <span class="number">91</span>;</span><br><span class="line">ns[<span class="number">3</span>] = <span class="number">85</span>;</span><br><span class="line">ns[<span class="number">4</span>] = <span class="number">62</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span>[] ns = &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">System.out.println(ns.length); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">"ABC"</span>, <span class="string">"XYZ"</span>, <span class="string">"zoo"</span>&#125;;</span><br><span class="line">        String s = names[<span class="number">1</span>];</span><br><span class="line">        names[<span class="number">1</span>] = <span class="string">"cat"</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// s是"XYZ"还是"cat"?: XYZ</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><strong>格式化输出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">System.out.printf(<span class="string">"%.2f\n"</span>, d); <span class="comment">// 显示两位小数3.14</span></span><br><span class="line">System.out.printf(<span class="string">"%.4f\n"</span>, d); <span class="comment">// 显示4位小数3.1416</span></span><br></pre></td></tr></table></figure>
<p>java中的占位符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">占位符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%d</td>
<td style="text-align:left">格式化输出整数</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:left">格式化输出十六进制整数</td>
</tr>
<tr>
<td style="text-align:left">%f</td>
<td style="text-align:left">格式化输出浮点数</td>
</tr>
<tr>
<td style="text-align:left">%e</td>
<td style="text-align:left">格式化输出科学计数法表示的浮点数</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">格式化字符串</td>
</tr>
</tbody>
</table>
</div>
<p>连续两个%%表示一个%字符本身。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">12345000</span>;</span><br><span class="line">System.out.printf(<span class="string">"n=%d, hex=%08x"</span>, n, n); <span class="comment">// 注意，两个%占位符必须传入两个数</span></span><br></pre></td></tr></table></figure>
<p><strong>输入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">"Input your name: "</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        String name = scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">"Input your age: "</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="keyword">int</span> age = scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">"Hi, %s, you are %d\n"</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//scanner.nextLine() / nextInt() / nextDouble() / ...</span></span><br></pre></td></tr></table></figure>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">90</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>判断引用类型是否相等</strong></p>
<p>判断引用类型的变量是否相等时，<code>==</code>表示“引用是否相等”，或者说，是否指向同一个对象。</p>
<p>判断引用类型的值是否相等必须使用equals函数。(s1.equals(s2))</p>
</blockquote>
<h3 id="switch多重选择"><a href="#switch多重选择" class="headerlink" title="switch多重选择"></a>switch多重选择</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> option = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (option) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">"Selected 1"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">"Selected 2"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="string">"Selected 3"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"No fruit selected"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java12的新语法</span></span><br><span class="line"><span class="comment">//不需要break</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fruit = <span class="string">"apple"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"apple"</span> -&gt; System.out.println(<span class="string">"Selected apple"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"pear"</span> -&gt; System.out.println(<span class="string">"Selected pear"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mango"</span> -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Selected mango"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Good choice!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> -&gt; System.out.println(<span class="string">"No fruit selected"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新语法可以直接返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fruit = <span class="string">"apple"</span>;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"apple"</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"pear"</span>, <span class="string">"mango"</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="number">0</span>;</span><br><span class="line">        &#125;; <span class="comment">// 注意赋值语句要以;结束</span></span><br><span class="line">        System.out.println(<span class="string">"opt = "</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yield</span></span><br><span class="line"><span class="comment">// 大多数时候，在switch表达式内部，我们会返回简单的值。</span></span><br><span class="line"><span class="comment">// 但是，如果需要复杂的语句，我们也可以写很多语句，放到&#123;...&#125;里，然后，用yield返回一个值作为switch语句的返回值：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fruit = <span class="string">"orange"</span>;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"apple"</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"pear"</span>, <span class="string">"mango"</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> code = fruit.hashCode();</span><br><span class="line">                yield code; <span class="comment">// switch语句返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">"opt = "</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>编译检查</strong></p>
<p>使用IDE时，可以自动检查是否漏写了<code>break</code>语句和<code>default</code>语句，方法是打开IDE的编译检查。</p>
<p>在Eclipse中，选择<code>Preferences</code> - <code>Java</code> - <code>Compiler</code> - <code>Errors/Warnings</code> - <code>Potential programming problems</code>，将以下检查标记为Warning：</p>
<ul>
<li>‘switch’ is missing ‘default’ case</li>
<li>‘switch’ case fall-through</li>
</ul>
<p>在Idea中，选择<code>Preferences</code> - <code>Editor</code> - <code>Inspections</code> - <code>Java</code> - <code>Control flow issues</code>，将以下检查标记为Warning：</p>
<ul>
<li>Fallthrough in ‘switch’ statement</li>
<li>‘switch’ statement without ‘default’ branch</li>
</ul>
<p>当<code>switch</code>语句存在问题时，即可在IDE中获得警告提示。</p>
</blockquote>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">while</span> (条件表达式) &#123;</span><br><span class="line">    循环语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    执行循环语句</span><br><span class="line">&#125; <span class="keyword">while</span> (条件表达式);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">for</span> (初始条件; 循环检测条件; 循环后更新计数器) &#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for each</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环过程中，可以使用<code>break</code>语句跳出当前循环。</p>
<p><code>continue</code>则是提前结束本次循环，直接继续执行下次循环。</p>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ns.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = ns[i];</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(ns));</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">Arrays.sort(ns);</span><br></pre></td></tr></table></figure>
<p><strong>对数组排序实际上修改了数组本身。</strong></p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.deepToString(ns)); <span class="comment">//多维数组打印</span></span><br></pre></td></tr></table></figure>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"-version"</span>.equals(arg)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"v 1.0"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JAVA面向对象编程"><a href="#JAVA面向对象编程" class="headerlink" title="JAVA面向对象编程"></a>JAVA面向对象编程</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line">Person ming = <span class="keyword">new</span> Person();</span><br><span class="line">ming.name = <span class="string">"小明"</span>;</span><br><span class="line">ming.age = <span class="number">12</span>; <span class="comment">//对字段赋值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一个class可以包含多个field（字段）</li>
</ul>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果自定义了构造方法，编译器不会生成默认构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用其他构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name,<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="comment">// 可变参数用类型...定义，可变参数相当于数组类型：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Group g = <span class="keyword">new</span> Group();</span><br><span class="line">g.setNames(<span class="string">"Xiao Ming"</span>, <span class="string">"Xiao Hong"</span>, <span class="string">"Xiao Jun"</span>); <span class="comment">// 传入3个String</span></span><br><span class="line">g.setNames(<span class="string">"Xiao Ming"</span>, <span class="string">"Xiao Hong"</span>); <span class="comment">// 传入2个String</span></span><br><span class="line">g.setNames(<span class="string">"Xiao Ming"</span>); <span class="comment">// 传入1个String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造方法的初始化顺序：</strong></p>
<ol>
<li>初始化字段</li>
<li>没有赋值的字段初始化为默认值：基本类型=0；默认类型=null；</li>
<li>再执行构造方法的代码</li>
</ol>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p><strong>JAVA只允许class继承自一个类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//person类定义的private字段无法被子类访问；</span></span><br><span class="line">    <span class="comment">//protected字段可以被子类访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一行必须调用父类的构造方法，如果不写，默认生成不带参数的super();</span></span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//覆写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//非必须，让编译器帮忙检查</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用父类被Override的方法</span></span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">Person ps = <span class="keyword">new</span> student(); <span class="comment">//upcasting</span></span><br><span class="line">Object o1 = p; <span class="comment">//upcasting</span></span><br><span class="line">Object o2 = s; <span class="comment">//upcasting</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Student s = (Student) p; <span class="comment">// ClassCastException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//instanceof操作符判断对象的类型</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Student n = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<div id="flowchart-0" class="flow-chart"></div>

<p><strong>多态</strong></p>
<ul>
<li>多态是指针对某个类型的方法调用，其真正执行的方法取决于运行时实际类型的方法</li>
<li>对某个类型调用方法，执行的方法可能是某个子类的方法</li>
<li>利用多态，允许添加更多类型的子类实现功能扩展</li>
</ul>
<p><strong>Object类定义的几个重要方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Overrride</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//把instance输出为String</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;&#125; <span class="comment">//判断两个instance是否逻辑相等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//计算一个instance的哈希值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>final</strong></p>
<ul>
<li>用final修饰的方法不能被Override</li>
<li>用final修饰的类不能被继承</li>
<li>用final修饰的字段在初始化后不能被修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><strong>抽象类</strong></p>
<p>抽象方法所在的类必须声明为抽象类。</p>
<p>抽象类可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口</strong></p>
<p>如果一个类没有字段，所有方法全部是抽象方法，就可以把该抽象类改写为接口</p>
<p>因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Hello</span> </span>&#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口继承</strong></p>
<p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Hello &#123;</span><br><span class="line">    void hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person extends Hello &#123;</span><br><span class="line">    void run();</span><br><span class="line">    String getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>default方法</strong></p>
<p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><p><code>static field</code>类的所有实例共享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 定义静态字段number:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态方法使用类名就可以调用。在静态方法中无法访问this变量，也无法访问实例字段，只能访问静态字段。</p>
<p><strong>接口的静态字段</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口的字段必须是public static final，所以可以省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包和作用域"><a href="#包和作用域" class="headerlink" title="包和作用域"></a>包和作用域</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.java  1</span></span><br><span class="line"><span class="keyword">package</span> ming; <span class="comment">// 申明包名ming</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person.java  2</span></span><br><span class="line"><span class="keyword">package</span> mr.jun; <span class="comment">// 申明包名mr.jun</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>包没有父子关系。<code>java.util</code>和<code>java.util.zip</code>是不同的包，两者没有任何继承关系。</p>
</blockquote>
<p><strong>包作用域</strong></p>
<p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 包作用域:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.hello(); <span class="comment">// 可以调用，因为Main和Person在同一个包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>import</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1：写出完整的类名</span></span><br><span class="line">mr.jun.Arrays arrays = <span class="keyword">new</span> mr.jun.Arrays();</span><br><span class="line"><span class="comment">//2：import</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line">Arrays arrays = <span class="keyword">new</span> Arrays();</span><br><span class="line"><span class="comment">//3：import static导入类的静态字段和静态方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br></pre></td></tr></table></figure>
<p><strong>作用域</strong></p>
<ul>
<li>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问</li>
<li><code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。</li>
<li><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</li>
<li>Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限</li>
<li>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</li>
</ul>
<p><strong>final</strong></p>
<ul>
<li><p>用<code>final</code>修饰<code>class</code>可以阻止被继承</p>
</li>
<li><p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写</p>
</li>
<li><p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值</p>
</li>
<li><p>用<code>final</code>修饰局部变量可以阻止被重新赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    t = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p>
<p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p>
<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p>
</blockquote>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote>
<p>定义在另一个类内部的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">"Nested"</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner(); <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello, "</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匿名类（Anonymous class）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名类和Inner Class一样，可以访问Outer Class的private字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</span></span><br><span class="line"><span class="comment">// Outer.this访问外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">"Nested"</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asyncHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Hello, "</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名类也可以继承自普通类</span></span><br><span class="line"><span class="comment">//&lt;classname&gt; &lt;name&gt; = new &lt;classname&gt;()&#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#125;; <span class="comment">// 匿名类! HashMap&lt;String,String&gt;为父类名</span></span><br><span class="line">        HashMap&lt;String, String&gt; map3 = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">"A"</span>, <span class="string">"1"</span>);</span><br><span class="line">                put(<span class="string">"B"</span>, <span class="string">"2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(map3.get(<span class="string">"A"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态内部类</strong></p>
<p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String NAME = <span class="string">"OUTER"</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello, "</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h3><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p>
<p>启动JVM时设定：<code>java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</code></p>
<p>jar包的使用：<code>java -cp ./hello.jar abc.xyz.Hello</code></p>
<blockquote>
<p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p>
</blockquote>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><blockquote>
<p>java9开始，JDK中引入了模块（Module）。来解决不同jar包之间的依赖问题。</p>
<p>个人理解，模块主要用于减小JRE发布的体积。</p>
</blockquote>
<p>模块之间的依赖项写入单独的文件（module-info.java）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  ./src/module-info.java</span></span><br><span class="line"><span class="keyword">module</span> hello.world&#123;</span><br><span class="line">    <span class="comment">//依赖包</span></span><br><span class="line">    <span class="keyword">requires</span> java.base; <span class="comment">//可不写</span></span><br><span class="line">    <span class="keyword">requires</span> java.xml;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 对外开放的接口</span></span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建模块的步骤</strong></p>
<ul>
<li>编译字节码<code>javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</code></li>
<li>创建jar包：<code>jar --create --file test.jar --main-class com.mmm.Main -C bin .</code></li>
<li>创建模块：<code>jmod create --class-path test.jar test.jmod</code>(必要时创建环境变量)</li>
<li>运行模块：<code>java --module-path test.jar --module test</code></li>
</ul>
<p><strong>打包JRE</strong></p>
<ul>
<li><code>jlink --module-path test.jmod --add-modules java.base,java.xml,test --output jre/</code></li>
</ul>
<h2 id="JAVA核心类"><a href="#JAVA核心类" class="headerlink" title="JAVA核心类"></a>JAVA核心类</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>两个字符串比较，必须总是使用<code>equals()</code>方法。</p>
<p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>
<p><code>String</code>类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="string">"Hello"</span>.contains(<span class="string">"ll"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">"Hello"</span>.indexOf(<span class="string">"l"</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">"Hello"</span>.lastIndexOf(<span class="string">"l"</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">"Hello"</span>.startsWith(<span class="string">"He"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">"Hello"</span>.endsWith(<span class="string">"lo"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>); <span class="comment">// "llo"</span></span><br><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">"ll"</span></span><br><span class="line">sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">//掐头去尾</span></span><br><span class="line"><span class="string">"  \tHello\r\n "</span>.trim(); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="string">"\u3000Hello\u3000"</span>.strip(); <span class="comment">// "Hello" // 和trim()不同的是，类似中文的空格字符\u3000也会被移除</span></span><br><span class="line"><span class="string">" Hello "</span>.stripLeading(); <span class="comment">// "Hello "</span></span><br><span class="line"><span class="string">" Hello "</span>.stripTrailing(); <span class="comment">// " Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空</span></span><br><span class="line"><span class="string">""</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">"  "</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">"  \n"</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">" Hello "</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">s.replace(<span class="string">'l'</span>, <span class="string">'w'</span>); <span class="comment">// "hewwo"，所有字符'l'被替换为'w'</span></span><br><span class="line">s.replace(<span class="string">"ll"</span>, <span class="string">"~~"</span>); <span class="comment">// "he~~o"，所有子串"ll"被替换为"~~"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式替换</span></span><br><span class="line">String s = <span class="string">"A,,B;C ,D"</span>;</span><br><span class="line">s.replaceAll(<span class="string">"[\\,\\;\\s]+"</span>, <span class="string">","</span>); <span class="comment">// "A,B,C,D"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分割</span></span><br><span class="line">String s = <span class="string">"A,B,C,D"</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">"\\,"</span>); <span class="comment">// &#123;"A", "B", "C", "D"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接</span></span><br><span class="line">String[] arr = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">String s = String.join(<span class="string">"***"</span>, arr); <span class="comment">// "A***B***C"</span></span><br><span class="line"></span><br><span class="line">String[] names = &#123;<span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"Grace"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">", "</span>);</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">  sj.add(name);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sj.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化字符串</span></span><br><span class="line"><span class="comment">//%s：显示字符串；</span></span><br><span class="line"><span class="comment">//%d：显示整数；</span></span><br><span class="line"><span class="comment">//%x：显示十六进制整数；</span></span><br><span class="line"><span class="comment">//%f：显示浮点数。</span></span><br><span class="line">String s = <span class="string">"Hi %s, your score is %d!"</span>;</span><br><span class="line">System.out.println(s.formatted(<span class="string">"Alice"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型转换</span></span><br><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// "123"</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// "45.67"</span></span><br><span class="line">String.valueOf(<span class="keyword">true</span>); <span class="comment">// "true"</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> Object()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(<span class="string">"123"</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">int</span> n2 = Integer.parseInt(<span class="string">"ff"</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = Boolean.parseBoolean(<span class="string">"true"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = Boolean.parseBoolean(<span class="string">"FALSE"</span>); <span class="comment">// false</span></span><br><span class="line">Integer.getInteger(<span class="string">"java.version"</span>); <span class="comment">// 版本号，11  把该字符串对应的系统变量转换为Integer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string和char[]的转换</span></span><br><span class="line"><span class="keyword">char</span>[] cs = <span class="string">"Hello"</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line">String s = <span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b1 = <span class="string">"Hello"</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"GBK"</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b3 = <span class="string">"Hello"</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] b = ...</span><br><span class="line">String s1 = <span class="keyword">new</span> String(b, <span class="string">"GBK"</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">','</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">    <span class="comment">//进行链式操作的关键是，定义的append()方法会返回this</span></span><br><span class="line">    sb.append(<span class="string">"Mr "</span>)</span><br><span class="line">      .append(<span class="string">"Bob"</span>)</span><br><span class="line">      .append(<span class="string">"!"</span>)</span><br><span class="line">      .insert(<span class="number">0</span>, <span class="string">"Hello, "</span>);</span><br><span class="line">&#125;</span><br><span class="line">String s = sb.toString();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p>
</blockquote>
<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code></p>
<p>java核心库中为每种基本类型都提供了对应的包装类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">基本类型</th>
<th style="text-align:left">对应的引用类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">java.lang.Boolean</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">java.lang.Byte</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">java.lang.Short</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">java.lang.Integer</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">java.lang.Long</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">java.lang.Float</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">java.lang.Double</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">java.lang.Character</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">Integer n1 = <span class="keyword">new</span> Integer(i);</span><br><span class="line"><span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">Integer n2 = Integer.valueOf(i);</span><br><span class="line"><span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">Integer n3 = Integer.valueOf(<span class="string">"100"</span>);</span><br><span class="line">System.out.println(n3.intValue());</span><br></pre></td></tr></table></figure>
<p><strong>Auto Boxing</strong></p>
<p>自动拆包和解包只发生在编译阶段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="keyword">int</span> x = n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure>
<p><strong>不变性</strong></p>
<p>所有的包装类型都是不变类。<code>private final class Integer{private final int value;}</code></p>
<p><strong>进制转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x1 = Integer.parseInt(<span class="string">"100"</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">int</span> x2 = Integer.parseInt(<span class="string">"100"</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br><span class="line">Integer.toString(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// "100",表示为10进制</span></span><br><span class="line">System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// "2s",表示为36进制</span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// "64",表示为16进制</span></span><br><span class="line">System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// "144",表示为8进制</span></span><br><span class="line">System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// "1100100",表示为2进制</span></span><br></pre></td></tr></table></figure>
<p><strong>包装类型中的静态变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class="line">Boolean t = Boolean.TRUE;</span><br><span class="line">Boolean f = Boolean.FALSE;</span><br><span class="line"><span class="comment">// int可表示的最大/最小值:</span></span><br><span class="line"><span class="keyword">int</span> max = Integer.MAX_VALUE; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="keyword">int</span> min = Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// long类型占用的bit和byte数量:</span></span><br><span class="line"><span class="keyword">int</span> sizeOfLong = Long.SIZE; <span class="comment">// 64 (bits)</span></span><br><span class="line"><span class="keyword">int</span> bytesOfLong = Long.BYTES; <span class="comment">// 8 (bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上转型为Number:</span></span><br><span class="line">Number num = <span class="keyword">new</span> Integer(<span class="number">999</span>);</span><br><span class="line"><span class="comment">// 获取byte, int, long, float, double:</span></span><br><span class="line"><span class="keyword">byte</span> b = num.byteValue();</span><br><span class="line"><span class="keyword">int</span> n = num.intValue();</span><br><span class="line"><span class="keyword">long</span> ln = num.longValue();</span><br><span class="line"><span class="keyword">float</span> f = num.floatValue();</span><br><span class="line"><span class="keyword">double</span> d = num.doubleValue();</span><br></pre></td></tr></table></figure>
<p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>都是带符号整型，最高位是符号位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> x = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> y = <span class="number">127</span>;</span><br><span class="line">System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br></pre></td></tr></table></figure>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>如果读写方法符合以下这种命名规范：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 读方法:</span><br><span class="line">public Type getXyz()</span><br><span class="line">&#x2F;&#x2F; 写方法:</span><br><span class="line">public void setXyz(Type value)</span><br></pre></td></tr></table></figure>
<p>那么这种<code>class</code>被称为<code>JavaBean</code>.<code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举JavaBean属性</span></span><br><span class="line"><span class="keyword">import</span> java.beans.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo info = Introspector.getBeanInfo(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">"  "</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">"  "</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Weekday day = Weekday.SUN;</span><br><span class="line"><span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">  System.out.println(<span class="string">"Work at home!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">"Work at office!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回index</span></span><br><span class="line"><span class="keyword">int</span> n = Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">"星期一"</span>), TUE(<span class="number">2</span>, <span class="string">"星期二"</span>), WED(<span class="number">3</span>, <span class="string">"星期三"</span>), THU(<span class="number">4</span>, <span class="string">"星期四"</span>), FRI(<span class="number">5</span>, <span class="string">"星期五"</span>), SAT(<span class="number">6</span>, <span class="string">"星期六"</span>), SUN(<span class="number">0</span>, <span class="string">"星期日"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue, String chinese)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="keyword">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="记录类"><a href="#记录类" class="headerlink" title="记录类"></a>记录类</h3><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p>
<ol>
<li>定义class时使用<code>final</code>，无法派生子类；</li>
<li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li>
</ol>
<p>从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等效的类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Point[x=%s, y=%s]"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果构造类需要检查参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> z = Point.of();</span><br><span class="line"><span class="keyword">var</span> p = Point.of(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>
<h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p><code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">"123456789000"</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p><code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.4500"</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//scale()表示小数位数</span></span><br><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.4500"</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">"1234500"</span>);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</span></span><br><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456789"</span>);</span><br><span class="line">BigDecimal d2 = d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">BigDecimal d3 = d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//除法需要截断</span></span><br><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456"</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">"23.456789"</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line">BigDecimal d4 = d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p>
</blockquote>
<h3 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.389...</span></span><br><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure>
<h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪随机</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random(<span class="number">098</span>);</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure>
<h4 id="SecureRandom-真随机"><a href="#SecureRandom-真随机" class="headerlink" title="SecureRandom(真随机)"></a>SecureRandom(真随机)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！</p>
</blockquote>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h2><p><code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>
<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>
</ul>
<p><code>Exception</code>又分为两大类：</p>
<ol>
<li><code>RuntimeException</code>以及它的子类；</li>
<li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>
</ol>
<p>Java规定：</p>
<ul>
<li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li>
<li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li>
</ul>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">"中文"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 多catch语句</span></span><br><span class="line">        <span class="comment">// catch的顺序非常重要：子类必须写在前面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">            process2();</span><br><span class="line">            process3();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">            System.out.println(<span class="string">"Bad input"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Unknown error"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"END"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// throw</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// try catch</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>printStackTrace()</code>可以打印出方法的调用栈。</p>
<p><strong>抛出异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="comment">//转换异常</span></span><br><span class="line">        <span class="comment">//为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去，新的Exception就可以持有原始Exception信息。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>catch</code>中抛出异常，不会影响<code>finally</code>的执行。JVM会先执行<code>finally</code>，然后抛出异常。</p>
<p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用<code>origin</code>变量保存原始异常，然后调用<code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在<code>finally</code>抛出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Exception origin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Integer.parseInt(<span class="string">"abc"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            origin = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (origin != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(origin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>Java标准库定义的常用异常包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure>
<p>自定义异常通常从<code>RuntimeException</code>派生：<code>public class BaseException extends RuntimeException {}</code></p>
<p>自定义的<code>BaseException</code>应该提供多个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h2><p><code>NullPointerException</code>是一种代码逻辑错误，遇到<code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用<code>catch</code>来隐藏这种编码错误.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员变量在定义时初始化：</span></span><br><span class="line"><span class="comment">//使用空字符串""而不是默认的null可避免很多NullPointerException，编写业务逻辑时，用空字符串""表示未填写比null安全得多。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回空字符串""、空数组而不是null</span></span><br></pre></td></tr></table></figure>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用assert语句时，还可以添加一个可选的断言消息：</span></span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">"x must &gt;= 0"</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p>
<p>对于可恢复的程序错误，不应该使用断言。</p>
<blockquote>
<p>idea中开启断言的方法</p>
<p>在VM optons中 加入 -ea或-enableassertions</p>
<p>实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解<code>JUnit</code>的使用。</p>
</blockquote>
<h2 id="JDK-Logging"><a href="#JDK-Logging" class="headerlink" title="JDK Logging"></a>JDK Logging</h2><p><code>java.util.logging</code>需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p>
<blockquote>
<p>Java标准库内置的Logging使用并不是非常广泛。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logging</span></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">"start process..."</span>);</span><br><span class="line">        logger.warning(<span class="string">"memory is running out..."</span>);</span><br><span class="line">        logger.fine(<span class="string">"ignored."</span>);</span><br><span class="line">        logger.severe(<span class="string">"process will be terminated..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK的Logging定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<h2 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h2><p>Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p>
<p>Commons Logging可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());<span class="comment">//相比下面的方法，这种方法子类也可以使用该log实例</span></span><br><span class="line">		<span class="comment">//protected final Log log = LogFactory.getLog(Person.class);</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Commons Logging的日志方法，例如<code>info()</code>，除了标准的<code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">"got exception!"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><p>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// log4j2.xml</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"log.pattern"</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"file.err.filename"</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"file.err.pattern"</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;log.pattern&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"err"</span> <span class="attr">bufferedIO</span>=<span class="string">"true"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;file.err.filename&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;file.err.pattern&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;log.pattern&#125;"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"1 MB"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"console"</span> <span class="attr">level</span>=<span class="string">"info"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"err"</span> <span class="attr">level</span>=<span class="string">"error"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="SLF4J和Logback"><a href="#SLF4J和Logback" class="headerlink" title="SLF4J和Logback"></a>SLF4J和Logback</h2><p>SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p>
<p>在Commons Logging中，我们要打印日志，有时候得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">"Set score "</span> + score + <span class="string">" for Person "</span> + p.getName() + <span class="string">" ok."</span>);</span><br></pre></td></tr></table></figure>
<p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">"Set score &#123;&#125; for Person &#123;&#125; ok."</span>, score, p.getName());</span><br></pre></td></tr></table></figure>
<p>如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// logback.xml</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span>log/output.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">ob=>operation: Object
person=>operation: Person
student=>operation: Student

student->person->ob</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-SE笔记5（Web）</title>
    <url>/2021/02/03/JAVA-SE%E7%AC%94%E8%AE%B05%EF%BC%88Web%EF%BC%89/</url>
    <content><![CDATA[<p>JAVA WEB部分<br><a id="more"></a></p>
<h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><ul>
<li>不同的进程有不同的端口号，用来区分不同的软件</li>
<li>范围：0~65535</li>
<li>TCP，UDP分别由65536个端口号，两个协议的端口不冲突</li>
<li>端口分类：<ul>
<li>公有端口0~1023：<ul>
<li>http：80</li>
<li>https：443</li>
<li>ftp：21</li>
<li>telent：23</li>
</ul>
</li>
<li>程序注册端口：1024~49151<ul>
<li>Tomcat：8080</li>
<li>MySQL：3306</li>
<li>Oracle：1521</li>
</ul>
</li>
<li>动态、私有：49152~65535</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ano # 查看所有端口</span><br><span class="line">netstat -ano|findstr "5900" #查看指定端口</span><br><span class="line">tasklist|findstr "8696" #查看指定端口的进程</span><br></pre></td></tr></table></figure>
<h2 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h2><p>对于Browser来说，请求页面的流程如下：</p>
<ol>
<li>与服务器建立TCP连接；</li>
<li>发送HTTP请求；</li>
<li>收取HTTP响应，然后把网页在浏览器中显示出来。</li>
</ol>
<p>浏览器发送的HTTP请求如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.sina.com.cn</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 xxx</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8</span><br></pre></td></tr></table></figure>
<p>其中，第一行表示使用<code>GET</code>请求获取路径为<code>/</code>的资源，并使用<code>HTTP/1.1</code>协议，从第二行开始，每行都是以<code>Header: Value</code>形式表示的HTTP头，比较常用的HTTP Header包括：</p>
<ul>
<li>Host: 表示请求的主机名，因为一个服务器上可能运行着多个网站，因此，Host表示浏览器正在请求的域名；</li>
<li>User-Agent: 标识客户端本身，例如Chrome浏览器的标识类似<code>Mozilla/5.0 ... Chrome/79</code>，IE浏览器的标识类似<code>Mozilla/5.0 (Windows NT ...) like Gecko</code>；</li>
<li>Accept：表示浏览器能接收的资源类型，如<code>text/*</code>，<code>image/*</code>或者<code>*/*</code>表示所有；</li>
<li>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</li>
<li>Accept-Encoding：表示浏览器可以支持的压缩类型，例如<code>gzip, deflate, br</code>。</li>
</ul>
<blockquote>
<p>HTTP目前有多个版本，<code>1.0</code>是早期版本，浏览器每次建立TCP连接后，只发送一个HTTP请求并接收一个HTTP响应，然后就关闭TCP连接。由于创建TCP连接本身就需要消耗一定的时间，因此，<strong>HTTP 1.1允许浏览器和服务器在同一个TCP连接上反复发送、接收多个HTTP请求和响应</strong>，这样就大大提高了传输效率。</p>
<p>我们注意到HTTP协议是一个请求-响应协议，它总是发送一个请求，然后接收一个响应。能不能一次性发送多个请求，然后再接收多个响应呢？<strong>HTTP 2.0可以支持浏览器同时发出多个请求</strong>，但每个请求需要唯一标识，服务器可以不按请求的顺序返回多个响应，由浏览器自己把收到的响应和请求对应起来。可见，HTTP 2.0进一步提高了传输效率，因为浏览器发出一个请求后，不必等待响应，就可以继续发下一个请求。</p>
<p>HTTP 3.0为了进一步提高速度，将抛弃TCP协议，<strong>改为使用无需创建连接的UDP协议</strong>，目前HTTP 3.0仍然处于实验阶段。</p>
</blockquote>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">"server is running..."</span>);</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            Socket sock = ss.accept();</span><br><span class="line">            System.out.println(<span class="string">"connected from "</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            Thread t = <span class="keyword">new</span> Handler(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Socket sock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">this</span>.sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStream output = <span class="keyword">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"client disconnected."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Process new http request..."</span>);</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">var</span> writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 读取HTTP请求:</span></span><br><span class="line">        <span class="keyword">boolean</span> requestOk = <span class="keyword">false</span>;</span><br><span class="line">        String first = reader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (first.startsWith(<span class="string">"GET / HTTP/1."</span>)) &#123;</span><br><span class="line">            requestOk = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            String header = reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (header.isEmpty()) &#123; <span class="comment">// 读取到空行时, HTTP Header读取完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(header);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(requestOk ? <span class="string">"Response OK"</span> : <span class="string">"Response Error"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!requestOk) &#123;</span><br><span class="line">            <span class="comment">// 发送错误响应:</span></span><br><span class="line">            writer.write(<span class="string">"HTTP/1.0 404 Not Found\r\n"</span>);</span><br><span class="line">            writer.write(<span class="string">"Content-Length: 0\r\n"</span>);</span><br><span class="line">            writer.write(<span class="string">"\r\n"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送成功响应:</span></span><br><span class="line">            String data = <span class="string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line">            <span class="keyword">int</span> length = data.getBytes(StandardCharsets.UTF_8).length;</span><br><span class="line">            writer.write(<span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">            writer.write(<span class="string">"Connection: close\r\n"</span>);</span><br><span class="line">            writer.write(<span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">            writer.write(<span class="string">"Content-Length: "</span> + length + <span class="string">"\r\n"</span>);</span><br><span class="line">            writer.write(<span class="string">"\r\n"</span>); <span class="comment">// 空行标识Header和Body的分隔</span></span><br><span class="line">            writer.write(data);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="聊天应用"><a href="#聊天应用" class="headerlink" title="聊天应用"></a>聊天应用</h4><p>Server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> (Socket socket = serverSocket.accept()) &#123;</span><br><span class="line">                <span class="keyword">try</span> (InputStream inputStream = socket.getInputStream()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> (ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();) &#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">int</span> len;</span><br><span class="line">                        <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            byteArrayOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        String s = byteArrayOutputStream.toString();</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress iadress = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">            <span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">            Socket socket = <span class="keyword">new</span> Socket(iadress, port);</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">"欢迎你"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传文件"><a href="#传文件" class="headerlink" title="传文件"></a>传文件</h4><p>server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mmm.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FilterOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span>(Socket socket = serverSocket.accept())&#123;</span><br><span class="line">                <span class="keyword">try</span>(InputStream inputStream = socket.getInputStream())&#123;</span><br><span class="line">                    <span class="keyword">try</span>(FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.iml"</span>))&#123;</span><br><span class="line">                        inputStream.transferTo(fileOutputStream);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mmm.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9999</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStream outputStream = socket.getOutputStream()) &#123;</span><br><span class="line">                <span class="keyword">try</span> (FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"kuangDemo.iml"</span>)) &#123;</span><br><span class="line">                    fileInputStream.transferTo(outputStream);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket()) &#123;</span><br><span class="line">            String msg = <span class="string">"你好啊"</span>;</span><br><span class="line">            InetAddress inetAddress = InetAddress.getByName(<span class="string">"localhost"</span>);</span><br><span class="line">            <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(msg.getBytes(StandardCharsets.UTF_8), <span class="number">0</span>, msg.getBytes(StandardCharsets.UTF_8).length, inetAddress, port);</span><br><span class="line">            datagramSocket.send(packet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>))&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            datagramSocket.receive(datagramPacket);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(datagramPacket.getData(),<span class="number">0</span>,datagramPacket.getLength()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><p>TalkReiver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkReceiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String msgFrom;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkReceiver</span><span class="params">(<span class="keyword">int</span> port,String msgFrom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.msgFrom = msgFrom;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="keyword">this</span>.port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">                datagramSocket.receive(datagramPacket);</span><br><span class="line">                System.out.println(msgFrom+<span class="string">":"</span>+<span class="keyword">new</span> String(datagramPacket.getData()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TalkSender</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkSender</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> fromPort;</span><br><span class="line">    <span class="keyword">int</span> toPort;</span><br><span class="line">    String toIp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkSender</span><span class="params">(<span class="keyword">int</span> fromPort, String toIp, <span class="keyword">int</span> toPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fromPort = fromPort;</span><br><span class="line">        <span class="keyword">this</span>.toPort = toPort;</span><br><span class="line">        <span class="keyword">this</span>.toIp = toIp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="keyword">this</span>.fromPort);</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String data = bufferedReader.readLine();</span><br><span class="line">                <span class="keyword">byte</span>[] datas = data.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length, InetAddress.getByName(<span class="keyword">this</span>.toIp), <span class="keyword">this</span>.toPort);</span><br><span class="line">                datagramSocket.send(datagramPacket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSender(<span class="number">4444</span>,<span class="string">"localhost"</span>,<span class="number">6666</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceiver(<span class="number">8888</span>,<span class="string">"老师"</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Teacher</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSender(<span class="number">9999</span>,<span class="string">"localhost"</span>,<span class="number">8888</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceiver(<span class="number">6666</span>,<span class="string">"老师"</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlDown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://xuexuan.site/images/avatar.png"</span>);</span><br><span class="line">        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = urlConnection.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span>(FileOutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"avatar.png"</span>))&#123;</span><br><span class="line">                inputStream.transferTo(os);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        urlConnection.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>1.Maven:注意打包方式为war，dependencies中的scope为<code>provided</code>，确保只在编译时使用，不会打包到war文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>web-servlet-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.最简单的Servlet：类必须继承自HttpServlet，然后通过覆写doGet或doPost来实现请求处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WebServlet注解表示这是一个Servlet，并映射到地址/:</span></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置响应类型:</span></span><br><span class="line">        resp.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        <span class="comment">// 获取输出流:</span></span><br><span class="line">        PrintWriter pw = resp.getWriter();</span><br><span class="line">        <span class="comment">// 写入响应:</span></span><br><span class="line">        pw.write(<span class="string">"&lt;h1&gt;Hello, world!&lt;/h1&gt;"</span>);</span><br><span class="line">        <span class="comment">// 最后不要忘记flush强制输出:</span></span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.之后，需要在工程目录下<code>src/main/webapp/WEB-INF</code>目录下，创建一个<code>web.xml</code>描述文件。文件内容可以固定如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"> <span class="string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"> <span class="string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span>&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<p>4.需要先启动web服务器，然后运行war，让服务器加载Servlet来处理请求。</p>
<p>常用的支持Servlet API的Web服务器有：Tomcat，Jetty，GlassFish</p>
<p>下载<a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">Tomcat</a>后，解压，将打包好的<code>hello.war</code>复制到webapps目录下，然后进入bin目录，执行startup文件。</p>
<p>通过<code>localhost:8080/hello</code>便可以进行网站的访问。</p>
<h3 id="环境快速搭建"><a href="#环境快速搭建" class="headerlink" title="环境快速搭建"></a>环境快速搭建</h3><blockquote>
<p>Idea 可以直接在Configuration中进行配置</p>
</blockquote>
<p>Tomcat实际也是Java程序，启动流程如下：</p>
<ol>
<li>启动JVM并执行Tomcat的<code>main()</code>方法；</li>
<li>加载war并初始化Servlet；</li>
<li>正常服务。</li>
</ol>
<p>可以将Tomcat的jar包全部引进来，然后自己编写一个<code>main</code>方法，先启动Tomcat，然后加载webapp</p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>web-servlet-embedded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tomcat.version</span>&gt;</span>9.0.26<span class="tag">&lt;/<span class="name">tomcat.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tomcat中包含了Servlet API引用</p>
</blockquote>
<p>main方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 启动Tomcat:</span></span><br><span class="line">        Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">        tomcat.setPort(Integer.getInteger(<span class="string">"port"</span>, <span class="number">8080</span>));</span><br><span class="line">        tomcat.getConnector();</span><br><span class="line">        <span class="comment">// 创建webapp:</span></span><br><span class="line">        Context ctx = tomcat.addWebapp(<span class="string">""</span>, <span class="keyword">new</span> File(<span class="string">"src/main/webapp"</span>).getAbsolutePath());</span><br><span class="line">        WebResourceRoot resources = <span class="keyword">new</span> StandardRoot(ctx);</span><br><span class="line">        resources.addPreResources(</span><br><span class="line">                <span class="keyword">new</span> DirResourceSet(resources, <span class="string">"/WEB-INF/classes"</span>, <span class="keyword">new</span> File(<span class="string">"target/classes"</span>).getAbsolutePath(), <span class="string">"/"</span>));</span><br><span class="line">        ctx.setResources(resources);</span><br><span class="line">        tomcat.start();</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h4><p><code>HttpServletRequest</code>封装了一个HTTP请求，它实际上是从<code>ServletRequest</code>继承而来。最早设计Servlet时，设计者希望Servlet不仅能处理HTTP，也能处理类似SMTP等其他协议，因此，单独抽出了<code>ServletRequest</code>接口，但实际上除了HTTP外，并没有其他协议会用Servlet处理，所以这是一个过度设计。</p>
<p>我们通过<code>HttpServletRequest</code>提供的接口方法可以拿到HTTP请求的几乎全部信息，常用的方法有：</p>
<ul>
<li>getMethod()：返回请求方法，例如，<code>&quot;GET&quot;</code>，<code>&quot;POST&quot;</code>；</li>
<li>getRequestURI()：返回请求路径，但不包括请求参数，例如，<code>&quot;/hello&quot;</code>；</li>
<li>getQueryString()：返回请求参数，例如，<code>&quot;name=Bob&amp;a=1&amp;b=2&quot;</code>；</li>
<li>getParameter(name)：返回请求参数，GET请求从URL读取参数，POST请求从Body中读取参数；</li>
<li>getContentType()：获取请求Body的类型，例如，<code>&quot;application/x-www-form-urlencoded&quot;</code>；</li>
<li>getContextPath()：获取当前Webapp挂载的路径，对于ROOT来说，总是返回空字符串<code>&quot;&quot;</code>；</li>
<li>getCookies()：返回请求携带的所有Cookie；</li>
<li>getHeader(name)：获取指定的Header，对Header名称不区分大小写；</li>
<li>getHeaderNames()：返回所有Header名称；</li>
<li>getInputStream()：如果该请求带有HTTP Body，该方法将打开一个输入流用于读取Body；</li>
<li>getReader()：和getInputStream()类似，但打开的是Reader；</li>
<li>getRemoteAddr()：返回客户端的IP地址；</li>
<li>getScheme()：返回协议类型，例如，<code>&quot;http&quot;</code>，<code>&quot;https&quot;</code>；</li>
</ul>
<h4 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h4><p><code>HttpServletResponse</code>封装了一个HTTP响应。由于HTTP响应必须先发送Header，再发送Body，所以，操作<code>HttpServletResponse</code>对象时，必须先调用设置Header的方法，最后调用发送Body的方法。</p>
<p>常用的设置Header的方法有：</p>
<ul>
<li>setStatus(sc)：设置响应代码，默认是<code>200</code>；</li>
<li>setContentType(type)：设置Body的类型，例如，<code>&quot;text/html&quot;</code>；</li>
<li>setCharacterEncoding(charset)：设置字符编码，例如，<code>&quot;UTF-8&quot;</code>；</li>
<li>setHeader(name, value)：设置一个Header的值；</li>
<li>addCookie(cookie)：给响应添加一个Cookie；</li>
<li>addHeader(name, value)：给响应添加一个Header，因为HTTP协议允许有多个相同的Header；</li>
</ul>
<blockquote>
<p>写入完毕后调用flush是必须的，因为大部分Web服务器都基于HTTP/1.1协议，会复用TCP连接。</p>
<p>写入完毕后不要调用close</p>
</blockquote>
<h4 id="重定向与转发"><a href="#重定向与转发" class="headerlink" title="重定向与转发"></a>重定向与转发</h4><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/hi"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedirectServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 构造重定向的路径:</span></span><br><span class="line">        String name = req.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        String redirectToUrl = <span class="string">"/hello"</span> + (name == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">"?name="</span> + name);</span><br><span class="line">        <span class="comment">// 发送重定向响应:</span></span><br><span class="line">        resp.sendRedirect(redirectToUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重定向有两种：一种是302响应，称为临时重定向，一种是301响应，称为永久重定向。两者的区别是，如果服务器发送301永久重定向响应，浏览器会缓存<code>/hi</code>到<code>/hello</code>这个重定向的关联，下次请求<code>/hi</code>的时候，浏览器就直接发送<code>/hello</code>请求了。</p>
<p><code>redirect()</code>方法用于实现302重定向。</p>
<p>301重定向的实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);</span><br><span class="line">resp.setHeader(<span class="string">"Location"</span>,<span class="string">"/hello"</span>);</span><br></pre></td></tr></table></figure>
<h5 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h5><p>Forward指内部转发。一个Servlet将请求转发给另一个Servlet。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns=<span class="string">"/morning"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">"/hello"</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Session和Cookie"><a href="#使用Session和Cookie" class="headerlink" title="使用Session和Cookie"></a>使用Session和Cookie</h4><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns=<span class="string">"/signin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignInServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个数据库:</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; users = Map.of(<span class="string">"bob"</span>, <span class="string">"bob123"</span>, <span class="string">"alice"</span>, <span class="string">"alice123"</span>, <span class="string">"tom"</span>, <span class="string">"tomcat"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GET请求时显示登录页:</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        PrintWriter pw = resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">"&lt;h1&gt;Sign In&lt;/h1&gt;"</span>);</span><br><span class="line">        pw.write(<span class="string">"&lt;form action=\"/signin\" method=\"post\"&gt;"</span>);</span><br><span class="line">        pw.write(<span class="string">"&lt;p&gt;Username: &lt;input name=\"username\"&gt;&lt;/p&gt;"</span>);</span><br><span class="line">        pw.write(<span class="string">"&lt;p&gt;Password: &lt;input name=\"password\" type=\"password\"&gt;&lt;/p&gt;"</span>);</span><br><span class="line">        pw.write(<span class="string">"&lt;p&gt;&lt;button type=\"submit\"&gt;Sign In&lt;/button&gt; &lt;a href=\"/\"&gt;Cancel&lt;/a&gt;&lt;/p&gt;"</span>);</span><br><span class="line">        pw.write(<span class="string">"&lt;/form&gt;"</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// POST请求时处理用户登录:</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String name = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = req.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        String expectedPassword = users.get(name.toLowerCase());</span><br><span class="line">        <span class="keyword">if</span> (expectedPassword != <span class="keyword">null</span> &amp;&amp; expectedPassword.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 登录成功:</span></span><br><span class="line">            req.getSession().setAttribute(<span class="string">"user"</span>, name);</span><br><span class="line">            resp.sendRedirect(<span class="string">"/"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 从HttpSession获取当前用户名:</span></span><br><span class="line">        String user = (String) req.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        resp.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        resp.setHeader(<span class="string">"X-Powered-By"</span>, <span class="string">"JavaEE Servlet"</span>);</span><br><span class="line">        PrintWriter pw = resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">"&lt;h1&gt;Welcome, "</span> + (user != <span class="keyword">null</span> ? user : <span class="string">"Guest"</span>) + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 未登录，显示登录链接:</span></span><br><span class="line">            pw.write(<span class="string">"&lt;p&gt;&lt;a href=\"/signin\"&gt;Sign In&lt;/a&gt;&lt;/p&gt;"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已登录，显示登出链接:</span></span><br><span class="line">            pw.write(<span class="string">"&lt;p&gt;&lt;a href=\"/signout\"&gt;Sign Out&lt;/a&gt;&lt;/p&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/signout"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignOutServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 从HttpSession移除用户名:</span></span><br><span class="line">        req.getSession().removeAttribute(<span class="string">"user"</span>);</span><br><span class="line">        resp.sendRedirect(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JSP开发"><a href="#JSP开发" class="headerlink" title="JSP开发"></a>JSP开发</h2><p>JSP（Java Server Pages），文件必须放到<code>/src/main/webapp</code>下，文件名必须以<code>.jsp</code>结尾，文件与HTML的差别不大，但是需要插入变量，或者动态输出的地方，使用特殊指令<code>&lt;%...%&gt;</code></p>
<p>示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hello World - JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%-- JSP Comment --%&gt;</span><br><span class="line">    &lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">         out.println(<span class="string">"Your IP address is "</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;span style=<span class="string">"color:red"</span>&gt;</span><br><span class="line">        &lt;%= request.getRemoteAddr() %&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>整个JSP的内容实际上是一个HTML，但是稍有不同：</p>
<ul>
<li>包含在<code>&lt;%--</code>和<code>--%&gt;</code>之间的是JSP的注释，它们会被完全忽略；</li>
<li>包含在<code>&lt;%</code>和<code>%&gt;</code>之间的是Java代码，可以编写任意Java代码；</li>
<li>如果使用<code>&lt;%= xxx %&gt;</code>则可以快捷输出一个变量的值。</li>
</ul>
<p>JSP页面内置的几个变量：</p>
<ul>
<li>out：表示HttpServletResponse的PrintWriter</li>
<li>session：表示当前的HttpSession对象。</li>
<li>request：表示HttpSevletRequest对象。</li>
</ul>
<p>JSP可以通过<code>page</code>指令</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.*"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.*"</span> %&gt;</span><br></pre></td></tr></table></figure>
<p>这样后续的Java代码才能引用简单类名而不是完整类名。</p>
<p>使用<code>include</code>指令可以引入另一个JSP文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%@ include file=<span class="string">"header.jsp"</span>%&gt;</span><br><span class="line">    &lt;h1&gt;Index Page&lt;/h1&gt;</span><br><span class="line">    &lt;%@ include file=<span class="string">"footer.jsp"</span>%&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="MVC开发"><a href="#MVC开发" class="headerlink" title="MVC开发"></a>MVC开发</h2><ul>
<li>Servlet适合编写Java代码，实现各种复杂的业务逻辑，但不适合输出复杂的HTML；</li>
<li>JSP适合编写HTML，并在其中插入动态内容，但不适合编写复杂的Java代码。</li>
</ul>
<p>将两者结合起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> School school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 假装从数据库读取:</span></span><br><span class="line">        School school = <span class="keyword">new</span> School(<span class="string">"No.1 Middle School"</span>, <span class="string">"101 South Street"</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">123</span>, <span class="string">"Bob"</span>, school);</span><br><span class="line">        <span class="comment">// 放入Request中:</span></span><br><span class="line">        req.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="comment">// forward给user.jsp:</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">"/WEB-INF/user.jsp"</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"com.itranswarp.learnjava.bean.*"</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    User user = (User) request.getAttribute(<span class="string">"user"</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hello World - JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello &lt;%= user.name %&gt;!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;School Name:</span><br><span class="line">    &lt;span style=<span class="string">"color:red"</span>&gt;</span><br><span class="line">        &lt;%= user.school.name %&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;School Address:</span><br><span class="line">    &lt;span style=<span class="string">"color:red"</span>&gt;</span><br><span class="line">        &lt;%= user.school.address %&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>把<code>user.jsp</code>放到<code>/WEB-INF/</code>目录下，是因为<code>WEB-INF</code>是一个特殊目录，Web Server会阻止浏览器对<code>WEB-INF</code>目录下任何资源的访问，这样就防止用户通过<code>/user.jsp</code>路径直接访问到JSP页面；</li>
</ul>
<p>我们把<code>UserServlet</code>看作业务逻辑处理，把<code>User</code>看作模型，把<code>user.jsp</code>看作渲染，这种设计模式通常被称为MVC：Model-View-Controller，即<code>UserServlet</code>作为控制器（Controller），<code>User</code>作为模型（Model），<code>user.jsp</code>作为视图（View），整个MVC架构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                   ┌───────────────────────┐</span><br><span class="line">             ┌────&gt;│Controller: UserServlet│</span><br><span class="line">             │     └───────────────────────┘</span><br><span class="line">             │                 │</span><br><span class="line">┌───────┐    │           ┌─────┴─────┐</span><br><span class="line">│Browser│────┘           │Model: User│</span><br><span class="line">│       │&lt;───┐           └─────┬─────┘</span><br><span class="line">└───────┘    │                 │</span><br><span class="line">             │                 ▼</span><br><span class="line">             │     ┌───────────────────────┐</span><br><span class="line">             └─────│    View: user.jsp     │</span><br><span class="line">                   └───────────────────────┘</span><br></pre></td></tr></table></figure>
<p>使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。</p>
<p>MVC模式广泛地应用在Web页面和传统的桌面程序中，我们在这里通过Servlet和JSP实现了一个简单的MVC模型，但它还不够简洁和灵活，后续我们会介绍更简单的Spring MVC开发。</p>
<h3 id="MVC高级开发"><a href="#MVC高级开发" class="headerlink" title="MVC高级开发"></a>MVC高级开发</h3><blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009</a></p>
</blockquote>
<p>直接把MVC搭在Servlet和JSP之上还是不太好，原因如下：</p>
<ul>
<li>Servlet提供的接口仍然偏底层，需要实现Servlet调用相关接口；</li>
<li>JSP对页面开发不友好，更好的替代品是模板引擎；</li>
<li>业务逻辑最好由纯粹的Java类实现，而不是强迫继承自Servlet。</li>
</ul>
<p>通过普通的Java类实现MVC的Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/signin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">signin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/signin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">doSignin</span><span class="params">(SignInBean bean)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/signout"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">signout</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要进一步的深入研究</p>
</blockquote>
<h3 id="使用Filter"><a href="#使用Filter" class="headerlink" title="使用Filter"></a>使用Filter</h3>]]></content>
      <categories>
        <category>JAVA</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Jupyter服务器搭建（windows）</title>
    <url>/2020/02/04/Jupyter%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88windows%EF%BC%89/</url>
    <content><![CDATA[<ol>
<li>创建配置文件：<code>jupyter-notebook --generate-config</code><a id="more"></a>
配置文件位于<code>/User/当前用户/.jupyter/*.py</code></li>
<li>修改登陆访问密码<br><code>jupyter-notebook password</code></li>
<li>修改远程访问配置<br>修改可访问ip：<br>在配置文件中添加<code>c.NotebookApp.ip = &#39;*&#39;</code><br>修改工作目录：<br>在配置文件中添加<code>c.NotebookApp.notebook_dir = &#39;workdir&#39;</code></li>
<li>在其他电脑上通过访问<code>ip:port</code>进行连接</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>MPI</title>
    <url>/2020/09/07/MPI/</url>
    <content><![CDATA[<p>MPI（Message-Passing-Interface 消息传递接口）实现并行是进程级别的，通过通信在进程之间进行消息传递。MPI并不是一种新的开发语言，它是一个定义了可以被C、C++和Fortran程序调用的函数库。这些函数库里面主要涉及的是两个进程之间通信的函数。MPI可以在Windows和linux环境中都有相应的库，本篇以Windows10作为演示开发环境。<br><a id="more"></a><br><a href="https://mpitutorial.com/tutorials/" target="_blank" rel="noopener">https://mpitutorial.com/tutorials/</a></p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>MPI：跨语言的通信协议。是一个信息传递应用程序接口，包括协议和语义说明。</p>
<p>OpenMP(Open Multi-Processing)：共享存储并行编程。用于共享内存并行系统的对处理程序设计的一套指导性编译处理方案。(一般单主机)</p>
<p>OpenMPI：一种高性能消息传递库，它是MPI-2标准的一个开源实现，有一些科研机构和企业一起开发和维护。OpenMPI来创建最好的MPI库。易于使用，并运行本身在各种各样的操作系统。</p>
<h2 id="windows与MPI"><a href="#windows与MPI" class="headerlink" title="windows与MPI"></a>windows与MPI</h2><p>Windows为了兼容MPI，自己做了一套基于一般个人电脑的MPI实现。如果要安装正真意义上的MPI的话，请直接去www.mpich.org下载，里面根据对应的系统下载相应的版本。</p>
<h2 id="一个简单的MPI程序"><a href="#一个简单的MPI程序" class="headerlink" title="一个简单的MPI程序"></a>一个简单的MPI程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rank, numproces;</span><br><span class="line">    <span class="keyword">int</span> namelen;</span><br><span class="line">    <span class="keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];</span><br><span class="line"></span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<span class="comment">//获得进程号</span></span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;numproces);<span class="comment">//返回通信子的进程数</span></span><br><span class="line"></span><br><span class="line">    MPI_Get_processor_name(processor_name, &amp;namelen);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"hello world! process %d of %d on %s\n"</span>, rank, numproces, processor_name);</span><br><span class="line">    MPI_Finalize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MPI的使用"><a href="#MPI的使用" class="headerlink" title="MPI的使用"></a>MPI的使用</h2><p><b>MPI_Init</b>：告知MPI系统进行所有必要的初始化设置。它是写在启动MPI并行计算的最前面的。具体的语法结构为:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MPI_Init(</span><br><span class="line">     <span class="keyword">int</span>* argc_p,</span><br><span class="line">     <span class="keyword">char</span>*** argv_p</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>   参数argc_p和argv_p分别指向main函数中的指针参数，为了弄明白这部分，还得从main函数的参数说起：Ｃ语言规定main函数的参数只能有两个，习惯上这两个参数写为argc和argv。因此，main函数的函数头可写为： main (argc,argv)。Ｃ语言还规定argc(第一个形参)必须是整型变量,argv( 第二个形参)必须是指向字符串的指针数组。其中argc参数表示了命令行中参数的个数(注意：文件名本身也 算一个参数)，argc的值是在输入命令行时由系统按实际参数的个数自动赋予的。例如有命令行为： C:”&gt;E6 24 BASIC dbase FORTRAN由于文件名E6 24本身也算一个参数，所以共有4个参数，因此argc取得的值为4。argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处 理)的首地址。</p>
<p>然而在MPI_Init函数中，并不一定都需要设置argc_p和argv_p这两个参数的，不需要的时候，将它们设置为NULL即可。</p>
<p>通讯子（communicator）：MPI_COMM_WORLD表示一组可以互相发送消息的进程集合。</p>
<p>MPI_Comm_rank:用来获取正在调用进程的通信子中的进程号的函数。</p>
<p>MPI_Comm_size:用来得到通信子的进程数的函数。</p>
<p>这两个函数的具体结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> MPIAPI <span class="title">MPI_Comm_rank</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    __in MPI_Comm comm,</span></span></span><br><span class="line"><span class="function"><span class="params">    __out <span class="keyword">int</span>* rank</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> MPIAPI <span class="title">MPI_Comm_size</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    __in MPI_Comm comm,</span></span></span><br><span class="line"><span class="function"><span class="params">    __out <span class="keyword">int</span>* <span class="built_in">size</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br></pre></td></tr></table></figure>
<p>MPI_Finalize：告知MPI系统MPI已经使用完毕。它总是放到做并行计算的功能块的最后面，在此函数之后就不能再出现任何有关MPI相关的东西了。</p>
<p>以上只是表达了作为一个MPI并行计算的基本结构，并没有真正涉及进程之间的通信，为了更好的进行并行，必然需要进程间的通信，下面介绍两个进程间通信的函数，它们就是MPI_Send和MPI_Recv，分别用于消息的发送和接收。</p>
<p>MPI_Send：阻塞型消息发送。</p>
<p>MPI_Recv：阻塞型消息接收。</p>
<p>MPI_Status：返回消息传递的完成情况。</p>
]]></content>
      <categories>
        <category>高性能计算</category>
      </categories>
  </entry>
  <entry>
    <title>Mask R-CNN实例分割算法</title>
    <url>/2020/03/07/Mask-R-CNN%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>基于Fast RCNN的实例分割算法<br>CSDN：<a href="https://blog.csdn.net/weixin_44791964/article/details/104629135" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/104629135</a></p>
<a id="more"></a>
<h1 id="Mask-R-CNN实现思路"><a href="#Mask-R-CNN实现思路" class="headerlink" title="Mask R-CNN实现思路"></a>Mask R-CNN实现思路</h1><h2 id="一、预测部分"><a href="#一、预测部分" class="headerlink" title="一、预测部分"></a>一、预测部分</h2><h3 id="1、主干网络介绍"><a href="#1、主干网络介绍" class="headerlink" title="1、主干网络介绍"></a>1、主干网络介绍</h3><p><img src="1.png" alt=""><br>Mask-RCNN使用Resnet101作为主干特征提取网络，对应着图像中的CNN部分，其对输入进来的图片有尺寸要求，需要可以整除2的6次方。在进行特征提取后，利用长宽压缩了两次、三次、四次、五次的特征层来进行特征金字塔结构的构造。</p>
<p>ResNet101有两个基本的块，分别名为Conv Block和Identity Block，其中Conv Block输入和输出的维度是不一样的，所以不能连续串联，它的作用是改变网络的维度；Identity Block输入维度和输出维度相同，可以串联，用于加深网络的。<br>Conv Block的结构如下：<br><img src="2.png" alt=""><br>Identity Block的结构如下：<br><img src="3.png" alt=""><br>这两个都是残差网络结构。</p>
<p>以官方使用的coco数据集输入的shape为例，输入的shape为1024x1024，shape变化如下：<br><img src="4.png" alt=""><br>我们取出长宽压缩了两次、三次、四次、五次的结果来进行特征金字塔结构的构造。</p>
<h1 id="2、特征金字塔的构建"><a href="#2、特征金字塔的构建" class="headerlink" title="2、特征金字塔的构建"></a>2、特征金字塔的构建</h1><p><img src="5.png" alt=""><br>特征金字塔FPN的构建是为了实现特征多尺度的融合，在Mask R-CNN当中，我们取出在主干特征提取网络中长宽压缩了两次C2、三次C3、四次C4、五次C5的结果来进行特征金字塔结构的构造。<br><img src="6.png" alt=""><br>提取到的P2、P3、P4、P5、P6可以作为RPN网络的有效特征层，利用RPN建议框网络对有效特征层进行下一步的操作，对先验框进行解码获得建议框。</p>
<p>提取到的P2、P3、P4、P5可以作为Classifier和Mask网络的有效特征层，利用Classifier预测框网络对有效特征层进行下一步的操作，对建议框解码获得最终预测框；利用Mask语义分割网络对有效特征层进行下一步的操作，获得每一个预测框内部的语义分割结果。</p>
<h3 id="3、获得proposal建议框"><a href="#3、获得proposal建议框" class="headerlink" title="3、获得proposal建议框"></a>3、获得proposal建议框</h3><p>由上一步获得的有效特征层在图像中就是Feature Map，其有两个应用，一个是和ROIAsign结合使用、另一个是进入到Region Proposal Network进行建议框的获取。</p>
<p>在进行建议框获取的时候，我们使用的有效特征层是P2、P3、P4、P5、P6，它们使用同一个RPN建议框网络获取先验框调整参数，还有先验框内部是否包含物体。</p>
<p>在Mask R-cnn中，RPN建议框网络的结构和Faster RCNN中的RPN建议框网络类似。</p>
<p>首先进行一次3x3的通道数为512的卷积。</p>
<p>然后再分别进行一次anchors_per_location x 4的卷积 和一次anchors_per_location x 2的卷积。</p>
<p>anchors_per_location x 4的卷积 用于预测 公用特征层上 每一个网格点上 每一个先验框的变化情况。（为什么说是变化情况呢，这是因为Faster-RCNN的预测结果需要结合先验框获得预测框，预测结果就是先验框的变化情况。）</p>
<p>anchors_per_location x 2的卷积 用于预测 公用特征层上 每一个网格点上 每一个预测框内部是否包含了物体。</p>
<p>当我们输入的图片的shape是1024x1024x3的时候，公用特征层的shape就是256x256x256、128x128x256、64x64x256、32x32x256、16x16x256，相当于把输入进来的图像分割成不同大小的网格，然后每个网格默认存在3（anchors_per_location ）个先验框，这些先验框有不同的大小，在图像上密密麻麻。</p>
<p>anchors_per_location x 4的卷积的结果会对这些先验框进行调整，获得一个新的框。<br>anchors_per_location x 2的卷积会判断上述获得的新框是否包含物体。</p>
<p>到这里我们可以获得了一些有用的框，这些框会利用anchors_per_location x 2的卷积判断是否存在物体。</p>
<p>到此位置还只是粗略的一个框的获取，也就是一个建议框。然后我们会在建议框里面继续找东西。</p>
<h3 id="4、Proposal建议框的解码"><a href="#4、Proposal建议框的解码" class="headerlink" title="4、Proposal建议框的解码"></a>4、Proposal建议框的解码</h3><p>通过第二步我们获得了许多个先验框的预测结果。预测结果包含两部分。</p>
<p>anchors_per_location x 4的卷积 用于预测 有效特征层上 每一个网格点上 每一个先验框的变化情况。</p>
<p>anchors_per_location x 1的卷积 用于预测 有效特征层上 每一个网格点上 每一个预测框内部是否包含了物体。</p>
<p>相当于就是将整个图像分成若干个网格；然后从每个网格中心建立3个先验框，当输入的图像是1024,1024,3的时候，总共先验框数量为196608+49152+12288+3072+768 = 261,888‬</p>
<p>当输入图像shape不同时，先验框的数量也会发生改变。</p>
<h3 id="5、对Proposal建议框加以利用（Roi-Align）"><a href="#5、对Proposal建议框加以利用（Roi-Align）" class="headerlink" title="5、对Proposal建议框加以利用（Roi Align）"></a>5、对Proposal建议框加以利用（Roi Align）</h3><p>让我们对建议框有一个整体的理解：<br>事实上建议框就是对图片哪一个区域有物体存在进行初步筛选。</p>
<p>实际上，Mask R-CNN到这里的操作是，通过主干特征提取网络，我们可以获得多个公用特征层，然后建议框会对这些公用特征层进行截取。</p>
<p>其实公用特征层里的每一个点相当于原图片上某个区域内部所有特征的浓缩。</p>
<p>建议框会对其对应的公用特征层进行截取，然后将截取的结果进行resize，在classifier模型里，截取后的内容会resize到7x7x256的大小。在mask模型里，截取后的内容会resize到14x14x256的大小。<br><img src="7.png" alt=""><br>在利用建议框对公用特征层进行截取的时候要注意，要找到建议框属于那个特征层，这个要从建议框的大小进行判断。</p>
<p>在classifier模型里，其会利用一次通道数为1024的7x7的卷积和一次通道数为1024的1x1的卷积对ROIAlign获得的7x7x256的区域进行卷积，两次通道数为1024卷积用于模拟两次1024的全连接，然后再分别全连接到num_classes和num_classes * 4上，分别代表这个建议框内的物体，以及这个建议框的调整参数。</p>
<p>在mask模型里，其首先会对resize后的局部特征层进行四次3x3的256通道的卷积，再进行一次反卷积，再进行一次通道数为num_classes的卷积，最终结果代表每一个像素点分的类。最终的shape为28x28xnum_classes，代表每个像素点的类别。</p>
<h3 id="6、预测框的解码"><a href="#6、预测框的解码" class="headerlink" title="6、预测框的解码"></a>6、预测框的解码</h3><p>在第四部分获得的建议框也代表了图片上的某一些区域，它在后面的在classifier模型里也起到了先验框的作用。</p>
<p>也就是classifier模型的预测结果，代表了建议框内部物体的种类和调整参数。</p>
<p>建议框调整后的结果，也就是最终的预测结果，这个预测结果就可以在图片上进行绘制了。</p>
<p>预测框的解码过程包括了如下几个步骤：<br>1、取出不属于背景，并且得分大于config.DETECTION_MIN_CONFIDENCE的建议框。<br>2、然后利用建议框和classifier模型的预测结果进行解码，获得最终预测框的位置。<br>3、利用得分和最终预测框的位置进行非极大抑制，防止重复检测。</p>
<h3 id="7、mask语义分割信息的获取"><a href="#7、mask语义分割信息的获取" class="headerlink" title="7、mask语义分割信息的获取"></a>7、mask语义分割信息的获取</h3><p>在第六步中，我们获得了最终的预测框，这个预测框相比于之前获得的建议框更加准确，因此我们把这个预测框作为mask模型的区域截取部分，利用这个预测框对mask模型中用到的公用特征层进行截取。</p>
<p>截取后，利用mask模型再对像素点进行分类，获得语义分割结果。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实例分割</category>
      </categories>
      <tags>
        <tag>实例分割</tag>
      </tags>
  </entry>
  <entry>
    <title>MaskRCNN细节详解</title>
    <url>/2020/03/24/MaskRCNN%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/37998710" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37998710</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><a id="more"></a>
<p>mask rcnn是ICCV2017的best paper。<br>Mask RCNN沿用了Faster RCNN的思想，特征提取采用ResNet-FPN的架构，另外多加了一个Mask预测分支。<br>ResNet-FPN+Fast RCNN+Mask，实际上就是Mask RCNN。</p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><h2 id="ResNet-FPN（Feature-Pyramid-Networks）"><a href="#ResNet-FPN（Feature-Pyramid-Networks）" class="headerlink" title="ResNet-FPN（Feature Pyramid Networks）"></a>ResNet-FPN（Feature Pyramid Networks）</h2><p>多尺度检测在目标检测中变得越来越重要，对小目标的检测尤其如此。现在主流的目标检测方法很多都用到了多尺度的方法，包括最新的yolo v3。Feature Pyramid Network (FPN)则是一种精心设计的多尺度检测方法，下面就开始简要介绍FPN。</p>
<p>FPN结构中包括自下而上，自上而下和横向连接三个部分，如下图所示。这种结构可以将各个层级的特征进行融合，使其同时具有强语义信息和强空间信息，在特征学习中算是一把利器了。<br><img src="1.jpg" alt=""><br>FPN实际上是一种通用架构，可以结合各种骨架网络使用，比如VGG，ResNet等。Mask RCNN文章中使用了ResNNet-FPN网络结构。如下图：<br><img src="2.jpg" alt=""><br><img src="7.jpg" alt="头部结构"><br><strong>自下而上</strong><br>从下到上路径。可以明显看出，其实就是简单的特征提取过程，和传统的没有区别。具体就是将ResNet作为骨架网络，根据feature map的大小分为5个stage。stage2，stage3，stage4和stage5各自最后一层输出conv2，conv3，conv4和conv5分别定义为C2，C3，C4，C5，他们相对于原始图片的stride是{4,8,16,32}。需要注意的是，考虑到内存原因，stage1的conv1并没有使用。<br><strong>自上而下和横向连接</strong><br>自上而下是从最高层开始进行上采样，这里的上采样直接使用的是最近邻上采样，而不是使用反卷积操作，一方面简单，另外一方面可以减少训练参数。横向连接则是将上采样的结果和自底向上生成的相同大小的feature map进行融合。具体就是对C2，C3，C4，C5中的每一层经过一个conv 1x1操作（1x1卷积用于降低通道数），无激活函数操作，输出通道全部设置为相同的256通道，然后和上采样的feature map进行加和操作。在融合之后还会再采用3*3的卷积核对已经融合的特征进行处理，目的是消除上采样的混叠效应（aliasing effect）。</p>
<blockquote>
<p>实际上，上图少绘制了一个分支：M5经过步长为2的max pooling下采样得到 P6，作者指出使用P6是想得到更大的anchor尺度512×512。但P6是只用在 RPN中用来得到region proposal的，并不会作为后续Fast RCNN的输入。</p>
<p>总结一下，ResNet-FPN作为RPN输入的feature map是 [公式] ，而作为后续Fast RCNN的输入则是 [公式] 。</p>
</blockquote>
<h2 id="ResNet-FPN-Fast-RCNN"><a href="#ResNet-FPN-Fast-RCNN" class="headerlink" title="ResNet-FPN+Fast RCNN"></a>ResNet-FPN+Fast RCNN</h2><p><img src="3.jpg" alt=""><br>将ResNet-FPN和Fast RCNN进行结合，实际上就是Faster RCNN的了，但与最初的Faster RCNN不同的是，FPN产生了特征金字塔[P2,P3,P4,P5,P6]，而不只是一个featrue map。金字塔经过RPN之后会产生很多region proposal。这些region proposal是分别由[P2,P3,P4,P5,P6]经过RPN产生的，但用于输入到Fast RCNN中的是 [P2,P3,P4,P5]，也就是说要在[P2,P3,P4,P5]中根据region proposal切出ROI进行后续的分类和回归预测。问题来了，我们要选择哪个feature map来切出这些ROI区域呢？实际上，我们会选择最合适的尺度的feature map来切ROI。具体来说，我们通过一个公式来决定宽w和高h的ROI到底要从哪个Pk来切：</p>
<script type="math/tex; mode=display">k=\left\lfloor{k_0+log_2(\sqrt{wh}/224)}\right\rfloor</script><p>这里224表示用于预训练的ImageNet图片的大小。$k_0$表示面积为$w\times h=224\times 224$的ROI所应该在的层级。作者将$k_0$设置为4，也就是说$w\times h=224\times 224$的ROI应该从P4中切出来。假设ROI的scale小于224（比如说是112 * 112），$k=k_0-1=4-1=3$，就意味着要从更高分辨率的P3中产生。另外，k值会做取整处理，防止结果不是整数。</p>
<p>这种做法很合理，大尺度的ROI要从低分辨率的feature map上切，有利于检测大目标，小尺度的ROI要从高分辨率的feature map上切，有利于检测小目标。</p>
<h1 id="ResNet-FPN-Fast-RCNN-mask"><a href="#ResNet-FPN-Fast-RCNN-mask" class="headerlink" title="ResNet-FPN+Fast RCNN+mask"></a>ResNet-FPN+Fast RCNN+mask</h1><p>将ResNet-FPN+Fast RCNN+mask，则得到了最终的Mask RCNN</p>
<h1 id="ROI-Align"><a href="#ROI-Align" class="headerlink" title="ROI Align"></a>ROI Align</h1><p>Faster R-CNN存在的问题是：特征图与原始图像是不对准的（mis-alignment），所以会影响检测精度。而Mask R-CNN提出了RoIAlign的方法来取代ROI pooling，RoIAlign可以保留大致的空间位置。</p>
<p>在Faster RCNN中，有两次整数化的过程：</p>
<ul>
<li>region proposal的xywh通常是小数，但是为了方便操作会把它整数化。</li>
<li>将整数化后的边界区域平均分割成 k x k 个单元，对每一个单元的边界进行整数化。</li>
</ul>
<p><img src="4.jpg" alt=""><br>事实上，经过上述两次整数化，此时的候选框已经和最开始回归出来的位置有一定的偏差，这个偏差会影响检测或者分割的准确度。在论文里，作者把它总结为“不匹配问题”（misalignment）。</p>
<p>为了解决这个问题，ROI Align方法取消整数化操作，保留了小数，使用双线性插值的方法获得坐标为浮点数的像素点上的图像数值。但在实际操作中，ROI Align并不是简单地补充出候选区域边界上的坐标点，然后进行池化，而是重新进行设计。</p>
<p>下面通过一个例子来讲解ROI Align操作。如下图所示，虚线部分表示feature map，实线表示ROI，这里将ROI切分成2x2的单元格。如果采样点数是4，那我们首先将每个单元格子均分成四个小方格（如红色线所示），每个小方格中心就是采样点。这些采样点的坐标通常是浮点数，所以需要对采样点像素进行双线性插值（如四个箭头所示），就可以得到该像素点的值了。然后对每个单元格内的四个采样点进行maxpooling，就可以得到最终的ROIAlign的结果。<br><img src="5.jpg" alt=""></p>
<h1 id="损失"><a href="#损失" class="headerlink" title="损失"></a>损失</h1><p>Mask RCNN定义多任务损失：</p>
<script type="math/tex; mode=display">L=L_{cls}+L_{box}+L_{mask}</script><p>$L<em>{cls}$和$L</em>{box}$与faster rcnn的定义没有区别。需要具体说明的是，假设一共有K个类别，则mask分割分支的输出维度是$K<em>m</em>m$, 对于$m*m$中的每个点，都会输出K个二值Mask（每个类别使用sigmoid输出）。需要注意的是，计算loss的时候，并不是每个类别的sigmoid输出都计算二值交叉熵损失，而是该像素属于哪个类，哪个类的sigmoid输出才要计算损失(如图红色方形所示)。并且在测试的时候，我们是通过分类分支预测的类别来选择相应的mask预测。这样，mask预测和分类预测就彻底解耦了。(nll)</p>
<p>这与FCN方法是不同，FCN是对每个像素进行多类别softmax分类，然后计算交叉熵损失，很明显，这种做法是会造成类间竞争的，而每个类别使用sigmoid输出并计算二值损失，可以避免类间竞争。实验表明，通过这种方法，可以较好地提升性能。<br><img src="6.jpg" alt=""></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>Matplotlib绘图案例</title>
    <url>/2019/11/27/Matplotlib%E7%BB%98%E5%9B%BE%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="绘图数据处理"><a href="#绘图数据处理" class="headerlink" title="绘图数据处理"></a>绘图数据处理</h1><h2 id="绘图时对数据进行三次样条插值："><a href="#绘图时对数据进行三次样条插值：" class="headerlink" title="绘图时对数据进行三次样条插值："></a>绘图时对数据进行三次样条插值：</h2><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.interpolate <span class="keyword">import</span> BSpline,make_interp_spline</span><br><span class="line"></span><br><span class="line"><span class="comment">#....省略数据读取</span></span><br><span class="line">xnew = np.linspace(np.min(x_data), np.max(x_data), <span class="number">300</span>)</span><br><span class="line">spl = make_interp_spline(x_data, y_data, k=<span class="number">3</span>)  <span class="comment"># type: BSpline</span></span><br><span class="line">ynew = spl(xnew)</span><br><span class="line"></span><br><span class="line">plt.plot(xnew,ynew)</span><br></pre></td></tr></table></figure>
<h1 id="中文字体支持"><a href="#中文字体支持" class="headerlink" title="中文字体支持"></a>中文字体支持</h1><p>windows：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置新罗马字体</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>]  <span class="comment">#中文</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="literal">False</span>  <span class="comment">#负号</span></span><br></pre></td></tr></table></figure><br>mac:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 使用mac自带的中文字体，不推荐</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'Arial Unicode MS'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 使用simhei</span></span><br><span class="line"><span class="comment"># 1. 安装simhei  https://www.fontpalace.com/font-details/SimHei/</span></span><br><span class="line"><span class="comment"># 2. 执行rebuild </span></span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> _rebuild</span><br><span class="line">_rebuild() <span class="comment">#reload一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>]  <span class="comment">#中文</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="literal">False</span>  <span class="comment">#负号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可用字体</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontManager</span><br><span class="line">fm = FontManager()</span><br><span class="line">mat_fonts = set(f.name <span class="keyword">for</span> f <span class="keyword">in</span> fm.ttflist)</span><br><span class="line"><span class="keyword">print</span> mat_fonts</span><br></pre></td></tr></table></figure></p>
<h1 id="一般折线图的绘制"><a href="#一般折线图的绘制" class="headerlink" title="一般折线图的绘制"></a>一般折线图的绘制</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>] <span class="comment"># 指定默认字体</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span> <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置新罗马字体</span></span><br><span class="line">plt.rc(<span class="string">'font'</span>,family=<span class="string">'Times New Roman'</span>)</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>]  <span class="comment">#中文</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="literal">False</span>  <span class="comment">#负号</span></span><br><span class="line"><span class="comment"># 省略读取部分</span></span><br><span class="line">fig,ax = plt.subplots()</span><br><span class="line">ax.plot(x_data,y_data,label=<span class="string">"线标签"</span>)  <span class="comment">#添加标签</span></span><br><span class="line">ax.set_title(<span class="string">r"$\sigma-\epsilon$"</span>)   <span class="comment">#设置图表名称  latex设置在r‘’中</span></span><br><span class="line">ax.set_xlabel(<span class="string">r"$\varepsilon$/%"</span>)   <span class="comment">#设置x轴标签</span></span><br><span class="line">ax.set_ylabel(<span class="string">r"$\sigma$/MPa"</span>)    <span class="comment">#设置y轴标签</span></span><br><span class="line">ax.set_xlim(<span class="number">0</span>,<span class="number">8</span>)   <span class="comment">#设置x轴范围</span></span><br><span class="line">ax.set_xticks([])  <span class="comment">#关闭x坐标tick</span></span><br><span class="line">ax.tick_params(direction=<span class="string">'in'</span>,colors=<span class="string">'black'</span>)   <span class="comment">#设置tick的参数  </span></span><br><span class="line">plt.legend()   <span class="comment">#显示标签（绘图时的label）</span></span><br><span class="line"><span class="comment"># plt.legend(frameon=False,fontsize=8) #取消边框，设置大小</span></span><br><span class="line">plt.xticks(x,labels,rotation=<span class="number">70</span>)   <span class="comment">#tick显示</span></span><br><span class="line"><span class="comment"># plt.xticks([])  #关闭tick</span></span><br><span class="line">plt.axis(<span class="string">"off"</span>)  <span class="comment">#关闭坐标轴</span></span><br><span class="line">plt.savefig(result_name,dpi=<span class="number">600</span>,bbox_inches=<span class="string">'tight'</span>,format=<span class="string">"png"</span>)  <span class="comment">#保存图片</span></span><br><span class="line"><span class="comment"># 保存tiff时防止文件大小过大</span></span><br><span class="line"><span class="comment"># plt.savefig在保存tiff文件时，调用的是pil中的函数，但是并没有提供对应的参数接口</span></span><br><span class="line"><span class="comment"># 在mpl 3.1.0版本新加入了设置pil.image参数的功能</span></span><br><span class="line">plt.savefig(<span class="string">"color_grain.tiff"</span>, dpi=<span class="number">1200</span>, bbox_inches=<span class="string">'tight'</span>, format=<span class="string">"tiff"</span>, transparent=<span class="literal">True</span>,pil_kwargs=&#123;<span class="string">"compression"</span>: <span class="string">"tiff_lzw"</span>&#125;) <span class="comment"># 当参数错误时会被自动忽略 # 其他压缩算法 https://imageio.readthedocs.io/en/stable/format_tiff-pil.html</span></span><br><span class="line">plt.show()  <span class="comment">#显示图片</span></span><br><span class="line"></span><br><span class="line">plt.cla()   <span class="comment"># Clear axis</span></span><br><span class="line">plt.clf()   <span class="comment"># Clear figure</span></span><br><span class="line">plt.close() <span class="comment"># Close a figure window</span></span><br></pre></td></tr></table></figure>
<h1 id="直方图的绘制"><a href="#直方图的绘制" class="headerlink" title="直方图的绘制"></a>直方图的绘制</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于dataframe中的数据，直接使用下面的代码</span></span><br><span class="line">df[<span class="string">"column_name"</span>].hist(bins=<span class="number">20</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于pyplot，使用时存在nan值可能会报错</span></span><br><span class="line"><span class="comment"># 方法1,选择非nan</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data = [<span class="number">1</span>,<span class="number">23</span>,<span class="number">4214</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">124</span>,<span class="number">1</span>,<span class="number">24</span>,np.nan]</span><br><span class="line">plt.hist(data[data <span class="keyword">is</span> <span class="keyword">not</span> np.nan])</span><br><span class="line"><span class="comment"># 方法2，删除nan</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data = pd.Series([<span class="number">1</span>,<span class="number">23</span>,<span class="number">4214</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">124</span>,<span class="number">1</span>,<span class="number">24</span>,np.nan])</span><br><span class="line">plt.hist(data.dropna())</span><br></pre></td></tr></table></figure>
<h1 id="双y轴图片的绘制"><a href="#双y轴图片的绘制" class="headerlink" title="双y轴图片的绘制"></a>双y轴图片的绘制</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> rc</span><br><span class="line">rc(<span class="string">'mathtext'</span>, default=<span class="string">'regular'</span>)</span><br><span class="line"></span><br><span class="line">time = np.arange(<span class="number">10</span>)</span><br><span class="line">temp = np.random.random(<span class="number">10</span>)*<span class="number">30</span></span><br><span class="line">Swdown = np.random.random(<span class="number">10</span>)*<span class="number">100</span><span class="number">-10</span></span><br><span class="line">Rn = np.random.random(<span class="number">10</span>)*<span class="number">100</span><span class="number">-10</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.plot(time, Swdown, <span class="string">'-'</span>, label = <span class="string">'Swdown'</span>)</span><br><span class="line">ax.plot(time, Rn, <span class="string">'-'</span>, label = <span class="string">'Rn'</span>)</span><br><span class="line">ax2 = ax.twinx()</span><br><span class="line">ax2.plot(time, temp, <span class="string">'-r'</span>, label = <span class="string">'temp'</span>)</span><br><span class="line">ax.legend(loc=<span class="number">0</span>)</span><br><span class="line">ax.grid()</span><br><span class="line">ax.set_xlabel(<span class="string">"Time (h)"</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">r"Radiation ($MJ\,m^&#123;-2&#125;\,d^&#123;-1&#125;$)"</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">r"Temperature ($^\circ$C)"</span>)</span><br><span class="line">ax2.set_ylim(<span class="number">0</span>, <span class="number">35</span>)</span><br><span class="line">ax.set_ylim(<span class="number">-20</span>,<span class="number">100</span>)</span><br><span class="line">ax2.legend(loc=<span class="number">0</span>)</span><br><span class="line">plt.savefig(<span class="string">'0.png'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调整legend框的位置<br><code>fig.legend(loc=1, bbox_to_anchor=(1,1), bbox_transform=ax.transAxes) # 调整legend框的位置</code><br>多个axes中legend的添加<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot1 = ax1.plot() <span class="comment"># list</span></span><br><span class="line">plot2 = ax2.plot() <span class="comment"># list</span></span><br><span class="line">lines = plot1+plot2</span><br><span class="line">ax1.legend(lines,[l.get_label() <span class="keyword">for</span> l <span class="keyword">in</span> lines])</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>结果：<br><img src="double_y.png" alt=""></p>
<h1 id="给两色图片添加legend"><a href="#给两色图片添加legend" class="headerlink" title="给两色图片添加legend"></a>给两色图片添加legend</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> plot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置legend的label大小以及handle宽度</span></span><br><span class="line">params = &#123;<span class="string">'legend.fontsize'</span>: <span class="number">12</span>,</span><br><span class="line">          <span class="string">'legend.handlelength'</span>: <span class="number">2</span>&#125;</span><br><span class="line">plot.rcParams.update(params)</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Rectangle</span><br><span class="line"></span><br><span class="line">RESULT_DIR = <span class="string">"./result"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(RESULT_DIR):</span><br><span class="line">    os.makedirs(RESULT_DIR, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> png_name <span class="keyword">in</span> os.listdir(<span class="string">"./data"</span>):</span><br><span class="line">    <span class="comment"># 建立两个subplot，第二个来绘制legend</span></span><br><span class="line">    no_color_img = plt.imread(os.path.join(<span class="string">"./data"</span>, png_name))</span><br><span class="line">    unique_value = np.unique(no_color_img, return_counts=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">"total_color_count:"</span>, len(unique_value))</span><br><span class="line">    value_list = sorted(unique_value.tolist())</span><br><span class="line">    new_color_img = np.zeros_like(no_color_img)</span><br><span class="line">    <span class="keyword">for</span> index, pvalue <span class="keyword">in</span> enumerate(value_list):</span><br><span class="line">        new_color_img[no_color_img == pvalue] = index</span><br><span class="line">    print(value_list)</span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    img_ax = ax[<span class="number">0</span>]</span><br><span class="line">    imgs = img_ax.imshow(new_color_img, cmap=plt.get_cmap(<span class="string">"winter"</span>, len(value_list)))</span><br><span class="line">    img_ax.axis(<span class="string">"off"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># handle的rgb颜色可以通过mac取色器获得</span></span><br><span class="line">    legend_ax = ax[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> len(value_list) == <span class="number">2</span>:</span><br><span class="line">        legend_data = [[<span class="number">0</span>, [<span class="number">16</span>, <span class="number">255</span>, <span class="number">127</span>], <span class="string">"Ferrite"</span>], [<span class="number">1</span>, [<span class="number">0</span>, <span class="number">5</span>, <span class="number">255</span>], <span class="string">"Martensite"</span>]]</span><br><span class="line">    <span class="keyword">elif</span> len(value_list) == <span class="number">3</span>:</span><br><span class="line">        legend_data = [[<span class="number">0</span>, [<span class="number">16</span>, <span class="number">255</span>, <span class="number">127</span>], <span class="string">"Ferrite"</span>], [<span class="number">1</span>, [<span class="number">0</span>, <span class="number">5</span>, <span class="number">255</span>], <span class="string">"Martensite"</span>],[<span class="number">2</span>, [<span class="number">0</span>, <span class="number">5</span>, <span class="number">255</span>], <span class="string">"Martensite"</span>]]</span><br><span class="line"></span><br><span class="line">    handles = [</span><br><span class="line">        Rectangle((<span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>, <span class="number">1</span>, color=[v / <span class="number">255</span> <span class="keyword">for</span> v <span class="keyword">in</span> c]) <span class="keyword">for</span> k, c, n <span class="keyword">in</span> legend_data</span><br><span class="line">    ]</span><br><span class="line">    legend_ax.legend(handles, [n <span class="keyword">for</span> k, c, n <span class="keyword">in</span> legend_data], mode=<span class="string">"expand"</span>, ncol=<span class="number">1</span>, frameon=<span class="literal">False</span>,</span><br><span class="line">                     loc=<span class="string">"center"</span>)</span><br><span class="line">    legend_ax.axis(<span class="string">"off"</span>)</span><br><span class="line">    plt.subplots_adjust(hspace=<span class="number">0</span>, wspace=<span class="number">0</span>)  <span class="comment"># plt.tight_layout()</span></span><br><span class="line">    plt.savefig(os.path.join(RESULT_DIR, <span class="string">"&#123;&#125;-color.tiff"</span>.format(png_name)), dpi=<span class="number">1200</span>, bbox_inches=<span class="string">'tight'</span>,</span><br><span class="line">                format=<span class="string">"tiff"</span>, transparent=<span class="literal">True</span>, pil_kwargs=&#123;<span class="string">"compression"</span>: <span class="string">"tiff_deflate"</span>&#125;)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="内置的colorbar"><a href="#内置的colorbar" class="headerlink" title="内置的colorbar"></a>内置的colorbar</h1><p><a href="https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html" target="_blank" rel="noopener">官方网站</a><br>内置颜色<br><img src="color.png" alt="colorname"></p>
<h1 id="绘制网格图"><a href="#绘制网格图" class="headerlink" title="绘制网格图"></a>绘制网格图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LinearSegmentedColormap</span><br><span class="line"></span><br><span class="line">image_array = np.eye(<span class="number">4</span>) </span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.gca()  <span class="comment"># Get the current axes, creating one if necessary.</span></span><br><span class="line"><span class="comment"># 自定义colorbar</span></span><br><span class="line">cmap = LinearSegmentedColormap.from_list(<span class="string">'mycmap'</span>, [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>])  <span class="comment"># colorbar为过渡渐变</span></span><br><span class="line">im = ax.imshow(image_array, cmap=cmap, vmin=<span class="number">0</span>, vmax=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.setp(ax.spines.values(), linewidth=<span class="number">2</span>)  <span class="comment"># 设置上下左右边框的宽度</span></span><br><span class="line">plt.grid(<span class="literal">True</span>, color=<span class="string">'black'</span>, linestyle=<span class="string">'-'</span>, linewidth=<span class="number">2</span>, axis=<span class="string">"both"</span>)  <span class="comment">#设置网格的属性（颜色和宽度等）</span></span><br><span class="line">plt.tick_params(direction=<span class="string">'in'</span>) <span class="comment"># 将tick朝内，隐藏</span></span><br><span class="line">plt.xticks([i + <span class="number">0.5</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)], visible=<span class="literal">False</span>)  <span class="comment">#设置网格线的位置</span></span><br><span class="line">plt.yticks([i + <span class="number">0.5</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)], visible=<span class="literal">False</span>)</span><br><span class="line">plt.savefig(<span class="string">"grid1.png"</span>, bbox_inches=<span class="string">"tight"</span>, dpi=<span class="number">600</span>, transparent=<span class="literal">True</span>, format=<span class="string">"png"</span>) <span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="grid1.png" alt="网格图"></p>
<h1 id="曲线间的填充"><a href="#曲线间的填充" class="headerlink" title="曲线间的填充"></a>曲线间的填充</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对函数和坐标轴之间的区域进行填充</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">100</span>,<span class="number">1000</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.fill(x,y,color=<span class="string">"g"</span>,alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对函数之间的区域进行填充</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">100</span>,<span class="number">1000</span>)</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line"></span><br><span class="line">plt.fill_between(x,y1,y2,facecolor=<span class="string">"g"</span>)</span><br><span class="line">plt.fill_between(x,y1,y2,where= y2&gt;=y1,facecolor=<span class="string">"g"</span>,interpolate=<span class="literal">True</span>) <span class="comment">#interpolate将可能的空白区域进行填充</span></span><br></pre></td></tr></table></figure>
<h1 id="核密度估计图"><a href="#核密度估计图" class="headerlink" title="核密度估计图"></a>核密度估计图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> *</span><br><span class="line">sns.kdeplot(x)  <span class="comment">#只有1D核密度估计图</span></span><br><span class="line">sns.kedplot(x,y)  <span class="comment">#2D核密度估计图</span></span><br><span class="line">sns.distplot(x,y) <span class="comment">#核密度估计图+直方图</span></span><br><span class="line">sns.distplot(x,y,kde=<span class="literal">False</span>)</span><br><span class="line">sns.distplot(x,y,hist=<span class="literal">False</span>)</span><br><span class="line">sns.distplot(x,y,fit=norm) <span class="comment">#正态分布</span></span><br></pre></td></tr></table></figure>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">"11.csv"</span>,index_col=<span class="number">0</span>)</span><br><span class="line">plt.clf()</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">fig.patch.set_visible(<span class="literal">False</span>)</span><br><span class="line">ax.axis(<span class="string">'off'</span>)</span><br><span class="line">ax.axis(<span class="string">'tight'</span>)</span><br><span class="line">ax.table(cellText=data.values, colLabels=data.columns,rowLabels=data.index, loc=<span class="string">'center'</span>)</span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">"1.png"</span>,dpi=<span class="number">600</span>,bbox_inches=<span class="string">"tight"</span>,pad_inches=<span class="number">1</span>) <span class="comment">#防止保存时超出图片边界</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>latex</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>OmniGraffle公式的插入</title>
    <url>/2020/04/03/OmniGraffle%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<p>Windows上的visio在mac上用不了，omnigraffle是一个比较好的替代工具，但是，最近使用过程中发现omnigraffle中无法进行latex公式的编辑。<br><a id="more"></a><br>在网上翻找了各种工具解决，但是都无法避免在mac上安装新的软件。<br>最后，在一个角落里发现了一种新的解决办法，利用mac自带的grapher。使用了之后发现简直是神器。</p>
<p>进入grapher后，任意选择一项，随便输入公式，右键便可保存（保存为pdf格式防止失真）。<br><img src="1.png" alt=""></p>
]]></content>
      <categories>
        <category>其他工具</category>
      </categories>
  </entry>
  <entry>
    <title>OpenCV人脸检测</title>
    <url>/2020/02/16/OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p><a href="https://www.jiqizhixin.com/articles/2019-05-30-3" target="_blank" rel="noopener">转载链接</a><br><a id="more"></a><br>本教程将介绍如何使用 OpenCV 和 Dlib 在 Python 中创建和运行人脸检测算法。同时还将添加一些功能，以同时检测多个面部的眼睛和嘴巴。本文介绍了人脸检测的最基本实现，包括级联分类器、HOG 窗口和深度学习 CNN。</p>
<p>我们将通过以下方法实现人脸检测：</p>
<ul>
<li>使用 OpenCV 的 Haar 级联分类器</li>
<li>使用 Dlib 的方向梯度直方图</li>
<li>使用 Dlib 的卷积神经网络</li>
</ul>
<p>本文代码的 Github 库（以及作者其他博客的代码）链接：</p>
<p><a href="https://github.com/maelfabien/Machine_Learning_Tutorials" target="_blank" rel="noopener">https://github.com/maelfabien/Machine_Learning_Tutorials</a> </p>
<p>我们将使用用于计算机视觉的开源库 OpenCV，它用 C/C++编写，有 C++、Python 和 Java 接口。同时支持 Windows、Linux、MacOS、iOS 和 Android 系统。同时我们还需要工具包 Dlib，它是一个包含机器学习算法和创建复杂软件的 C++工具包。</p>
<p><strong>步骤</strong></p>
<p>第一步是安装 OpenCV 和 Dlib。运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br><span class="line">pip install dlib</span><br></pre></td></tr></table></figure>
<p>文件生成的路径如下（版本不同，路径会稍有差别）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2</span><br></pre></td></tr></table></figure>
<p>如果在使用 Dlib 时出现问题，请参见文章：<a href="https://www.pyimagesearch.com/2018/01/22/install-dlib-easy-complete-guide/" target="_blank" rel="noopener">https://www.pyimagesearch.com/2018/01/22/install-dlib-easy-complete-guide/</a></p>
<p><strong>导入工具包和模型路径</strong></p>
<p>创建一个新的 Jupyter notebook/Python 文件，从以下代码开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import dlib</span><br><span class="line">from imutils import face_utils</span><br><span class="line">font &#x3D; cv2.FONT_HERSHEY_SIMPLEX</span><br></pre></td></tr></table></figure>
<p><strong>级联分类器</strong></p>
<p>首先研究级联分类器。</p>
<p><strong>理论</strong></p>
<p>级联分类器，即使用类 Haar 特征工作的级联增强分类器，是集成学习的一种特殊情况，称为 boost。它通常依赖于 Adaboost 分类器（以及其他模型，如 Real Adaboost、Gentle Adaboost 或 Logitboost）。</p>
<p>级联分类器在包含检测目标的几百个样本图像以及不包含检测目标的其他图像上进行训练。</p>
<p>我们如何检测图上是否有人脸呢？有一种名为 Viola-Jones 的<a href="https://mp.weixin.qq.com/cgi-bin/appmsg?t=media/appmsg_edit&amp;action=edit&amp;type=10&amp;appmsgid=503279302&amp;isMul=1&amp;token=815003832&amp;lang=zh_CN" target="_blank" rel="noopener">目标检测</a>框架的算法，包括了实时人脸检测所需的所有步骤：</p>
<ul>
<li>提取 Haar 特征，特征来自 Haar 小波</li>
<li>创建图像</li>
<li>Adaboost 训练</li>
<li>级联分类器</li>
</ul>
<p><strong>Haar 特征选择</strong></p>
<p>人脸上最常见的一些共同特征如下：</p>
<ul>
<li>与脸颊相比，眼部颜色较深</li>
<li>与眼睛相比，鼻梁区域较为明亮</li>
<li>眼睛、嘴巴、鼻子的位置较为固定……</li>
</ul>
<p>这些特征称为 Haar 特征。<a href="https://mp.weixin.qq.com/cgi-bin/appmsg?t=media/appmsg_edit&amp;action=edit&amp;type=10&amp;appmsgid=503279302&amp;isMul=1&amp;token=815003832&amp;lang=zh_CN" target="_blank" rel="noopener">特征提取</a>过程如下所示：</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/7245f5c9-5da5-4edf-bff6-186719d5fef6/640.jpeg" alt="img"></p>
<p><em>Haar 特征</em></p>
<p>在上图中，第一个特征测量眼部和上脸颊之间的强度差异。特征值计算的方法很简单，对黑色区域中的像素求和再减去白色区域中的像素即可。</p>
<p>然后，将这个矩形作为卷积核作用到整个图像。为了不产生遗漏，我们需要用到每个卷积核的所有的维度和位置。简单的 24 * 24 的图像可能会产生超过 160000 个特征，每个特征由像素值的和/差组成。这样在计算上无法实现实时人脸检测。那么，该如何加快这个过程呢？</p>
<p>一旦通过矩形框识别到有用区域，则在与之完全不同的区域上就无需再做计算了。这一点可以通过 Adaboost 实现。</p>
<p>使用积分图像原理计算矩形框特征的方法更快。我们将在下一节介绍这一点。</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/53407211-6e2b-4c88-8cfb-ad9af35e04d4/640.jpeg" alt="img"></p>
<p>原始论文中提到几种可用于 Haar 特征提取的矩形框：</p>
<ul>
<li>双矩形特征计算的是两个矩形区域内像素和的差，主要用于检测边缘 (a,b)</li>
<li>三矩形特征计算的是中心矩形和减去两个外部矩形和的差，主要用于检测线 (c,d)</li>
<li>四矩形特征计算的是矩形对角线对之间的差 (e)</li>
</ul>
<p><img src="https://image.jiqizhixin.com/uploads/editor/887c30d9-bceb-479b-b57e-4b3be0a24a90/640.png" alt="img"></p>
<p><em>Haar 矩形</em></p>
<p>特征提取完成后，使用 Adaboost 分类器将它们应用于训练集，该分类器结合了一组弱分类器来创建准确的集成模型。只需 200 个特征（最初是 16 万个），实现了 95％的准确率。该论文的作者提取了 6000 个特征。</p>
<p><strong>积分图像</strong></p>
<p>以卷积核的形式计算特征需要花费很长时间。出于这个原因，作者 Viola 和 Jones 提出了图像的中间表示：积分图像。积分图像的作用是仅使用四个值简单地计算矩形和。我们来看看它是如何工作的！</p>
<p>假设我们想要确定一个坐标为 (x,y) 的给定像素的矩形特征。然后，像素的积分图像是给定像素的上方和左侧的像素之和。</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/2a219eb2-16c0-4342-a28e-48a18401baca/640.png" alt="img"></p>
<p>其中 ii(x,y) 是积分图像，i(x,y) 是原始图像。</p>
<p>当计算整个积分图像时，有一种只需要遍历一次原始图像的递归方法。实际上，我们可以定义以下一对递归形式：</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/957c420e-6646-4dcc-ba55-c16eec2b0c80/640.png" alt="img"></p>
<p>其中 s(x,y) 是累积行和，而 s(x−1)=0, ii(−1,y)=0。</p>
<p>这是怎么实现的呢？假设我们想要估算区域 D 的像素总和。我们已经定义了 3 个其他区域：A，B 和 C。</p>
<ul>
<li>点 1 处的积分图像的值是矩形 A 中的像素的总和。</li>
<li>点 2 处的值为 A + B。</li>
<li>点 3 处的值为 A + C。</li>
<li>点 4 处的值是 A + B + C + D。</li>
</ul>
<p>因此，区域 D 中的像素之和可以简单地计算为： 4+1−(2+3)。</p>
<p>这样我们仅使用 4 个数组值就计算出了矩形 D 的值。</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/05ac2da5-0df3-4e6c-9613-9dbfc2fe15b3/640.jpeg" alt="img"></p>
<p>人们应该知道矩形在实际中是非常简单的特征，但对于人脸检测已经足够了。当涉及复杂问题时，可调滤波器往往更灵活多变。</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/e92412f5-225a-4c1f-bba4-63b93194bc5d/640.png" alt="img"></p>
<p><em>可调滤波器</em></p>
<p><strong>使用 Adaboost 学习分类函数</strong></p>
<p>给定一组带标签的训练图像（正负样本均有），Adaboost 用于：</p>
<ul>
<li>提取一小部分特征</li>
<li>训练分类器</li>
</ul>
<p>由于 16 万个特征中的大多数特征与之极不相关，因此我们设计一个增强模型的弱学习算法，用来提取单个矩形特征，将最好的正负样本区分开。</p>
<p><strong>级联分类器</strong></p>
<p>虽然上述过程非常有效，但仍存在一个重大问题。在图像中，大部分图像为非面部区域。对图像的每个区域给予等同的注意力是没有意义的，因为我们应该主要关注最有可能包含人脸的区域。Viola 和 Jone 使用级联分类器在减少了计算时间的同时，实现了更高的检测率。</p>
<p>关键思想是在识别人脸区域时排除不含人脸的子窗口。由于任务是正确识别人脸，我们希望假阴率最小，即包含人脸却未被识别的子窗口最少。</p>
<p>每个子窗口都使用一系列分类器。这些分类器是简单的决策树：</p>
<ul>
<li>如果第一个分类器检测为正样本，继续用第二个</li>
<li>如果第二个分类器检测是正样本，继续用第三个</li>
<li>以此类推</li>
</ul>
<p>虽然有时可能包含人脸的图被认成负样本被子窗口漏检。但初级分类器以较低的计算成本筛除了大多数负样本，下图的分类器可额外消除更多的负样本，但需要更多的计算量。</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/c014f487-359d-4f0e-9f9a-c9bf6720073f/640.jpeg" alt="img"></p>
<p>使用 Adaboost 训练分类器，并调整阈值使错误率降到最低。在训练该模型时，变量如下：</p>
<ul>
<li>每个阶段分类器数量</li>
<li>每个阶段的特征数量</li>
<li>每个阶段的阈值</li>
</ul>
<p>幸运的是，在 OpenCV 中，整个模型已经经过预训练，可直接用于人脸检测。</p>
<p>如果想了解有关 Boosting 技术的更多信息，欢迎查看作者关于 Adaboost 的文章：</p>
<p><a href="https://maelfabien.github.io/machinelearning/adaboost" target="_blank" rel="noopener">https://maelfabien.github.io/machinelearning/adaboost</a></p>
<p><strong>输入</strong></p>
<p>下一步是找到预训练的权重。我们将使用默认的预训练模型来检测人脸、眼睛和嘴巴。文件应位于此路径（python 版本不同，路径略有不同）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data</span><br></pre></td></tr></table></figure>
<p>确定路径后，以此方式声明级联分类器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cascPath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_frontalface_default.xml&quot;</span><br><span class="line">eyePath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_eye.xml&quot;</span><br><span class="line">smilePath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_smile.xml&quot;</span><br><span class="line">faceCascade &#x3D; cv2.CascadeClassifier(cascPath)</span><br><span class="line">eyeCascade &#x3D; cv2.CascadeClassifier(eyePath)</span><br><span class="line">smileCascade &#x3D; cv2.CascadeClassifier(smilePath)</span><br></pre></td></tr></table></figure>
<p><strong>检测图像中的人脸</strong></p>
<p>在实现实时人脸检测算法之前，让我们先尝试在图像上简单检测一下。从加载测试图像开始:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Load the image</span><br><span class="line">gray &#x3D; cv2.imread(&#39;face_detect_test.jpeg&#39;, 0)</span><br><span class="line">plt.figure(figsize&#x3D;(12,8))</span><br><span class="line">plt.imshow(gray, cmap&#x3D;&#39;gray&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.jiqizhixin.com/uploads/editor/ee639060-e22b-43cc-8914-9fcd5ada0869/640.jpeg" alt="img"></p>
<p><em>测试图像</em></p>
<p>然后开始检测人脸，并将检测到的人脸框起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Detect faces</span><br><span class="line">faces &#x3D; faceCascade.detectMultiScale(</span><br><span class="line">gray,</span><br><span class="line">scaleFactor&#x3D;1.1,</span><br><span class="line">minNeighbors&#x3D;5,</span><br><span class="line">flags&#x3D;cv2.CASCADE_SCALE_IMAGE</span><br><span class="line">)</span><br><span class="line"># For each face</span><br><span class="line">for (x, y, w, h) in faces: </span><br><span class="line">    # Draw rectangle around the face</span><br><span class="line">    cv2.rectangle(gray, (x, y), (x+w, y+h), (255, 255, 255), 3)</span><br></pre></td></tr></table></figure>
<p>以下是 detectMultiScale 函数常见的参数列表：</p>
<ul>
<li>scaleFactor：确定每个图像缩放比例大小。</li>
<li>minNeighbors：确定每个候选矩形应保留多少个相邻框。</li>
<li>minSize：最小目标的大小。小于该值的目标将被忽略。</li>
<li>maxSize：最大目标的大小。大于该值的目标将被忽略。</li>
</ul>
<p>最后，显示结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize&#x3D;(12,8))</span><br><span class="line">plt.imshow(gray, cmap&#x3D;&#39;gray&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.jiqizhixin.com/uploads/editor/3bd5ead0-5197-4aa4-8151-52a2c1c11f52/640.jpeg" alt="img"></p>
<p>在测试图像上成功检测到人脸。现在开始实时检测！</p>
<p><strong>实时人脸检测</strong></p>
<p>下面继续进行实时人脸检测的 Python 实现。第一步是启动摄像头，并拍摄视频。然后，将图像转换为灰度图。这用于减小输入图像的维数。实际上，我们应用了一个简单的线性变换，而不是每个像素用三个点来描述红、绿、蓝。</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/9d27ae45-4222-4f77-9fcc-58d70cf832e4/640.png" alt="img"></p>
<p>这在 OpenCV 中是默认实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">video_capture &#x3D; cv2.VideoCapture(0)</span><br><span class="line">while True:</span><br><span class="line">    # Capture frame-by-frame</span><br><span class="line">    ret, frame &#x3D; video_capture.read()</span><br><span class="line">    gray &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure>
<p>现在我们使用上述定义的 faceCascade 变量，它包含一个预训练算法，现在将其用于灰度图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">faces &#x3D; faceCascade.detectMultiScale(</span><br><span class="line">        gray,</span><br><span class="line">        scaleFactor&#x3D;1.1,</span><br><span class="line">        minNeighbors&#x3D;5,</span><br><span class="line">        minSize&#x3D;(30, 30),</span><br><span class="line">        flags&#x3D;cv2.CASCADE_SCALE_IMAGE</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>对于检测到的每个人脸，都加上一个矩形框：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (x, y, w, h) in faces:</span><br><span class="line">        if w &gt; 250 :</span><br><span class="line">            cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 3)</span><br><span class="line">            roi_gray &#x3D; gray[y:y+h, x:x+w]</span><br><span class="line">            roi_color &#x3D; frame[y:y+h, x:x+w]</span><br></pre></td></tr></table></figure>
<p>对于检测到的每张嘴，都加上一个矩形框：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smile &#x3D; smileCascade.detectMultiScale(</span><br><span class="line">        roi_gray,</span><br><span class="line">        scaleFactor&#x3D; 1.16,</span><br><span class="line">        minNeighbors&#x3D;35,</span><br><span class="line">        minSize&#x3D;(25, 25),</span><br><span class="line">        flags&#x3D;cv2.CASCADE_SCALE_IMAGE</span><br><span class="line">    )</span><br><span class="line">    for (sx, sy, sw, sh) in smile:</span><br><span class="line">        cv2.rectangle(roi_color, (sh, sy), (sx+sw, sy+sh), (255, 0, 0), 2)</span><br><span class="line">        cv2.putText(frame,&#39;Smile&#39;,(x + sx,y + sy), 1, 1, (0, 255, 0), 1)</span><br></pre></td></tr></table></figure>
<p>对于检测到的每双眼睛，都加上一个矩形框：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyes &#x3D; eyeCascade.detectMultiScale(roi_gray)</span><br><span class="line">    for (ex,ey,ew,eh) in eyes:</span><br><span class="line">        cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2)</span><br><span class="line">        cv2.putText(frame,&#39;Eye&#39;,(x + ex,y + ey), 1, 1, (0, 255, 0), 1)</span><br></pre></td></tr></table></figure>
<p>然后计算人脸总数，显示整体图像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cv2.putText(frame,&#39;Number of Faces : &#39; + str(len(faces)),(40, 40), font, 1,(255,0,0),2)      </span><br><span class="line">    # Display the resulting frame</span><br><span class="line">    cv2.imshow(&#39;Video&#39;, frame)</span><br></pre></td></tr></table></figure>
<p>当按下 q 键时，执行退出选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if cv2.waitKey(1) &amp; 0xFF &#x3D;&#x3D; ord(&#39;q&#39;):</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<p>最后当所有操作完成后，关闭所有窗口。在 Mac 上关闭窗口存在一些问题，可能需要通过活动管理器退出 Python。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">video_capture.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><strong>封装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">cascPath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_frontalface_default.xml&quot;</span><br><span class="line">eyePath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_eye.xml&quot;</span><br><span class="line">smilePath &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;cv2&#x2F;data&#x2F;haarcascade_smile.xml&quot;</span><br><span class="line"></span><br><span class="line">faceCascade &#x3D; cv2.CascadeClassifier(cascPath)</span><br><span class="line">eyeCascade &#x3D; cv2.CascadeClassifier(eyePath)</span><br><span class="line">smileCascade &#x3D; cv2.CascadeClassifier(smilePath)</span><br><span class="line"></span><br><span class="line">font &#x3D; cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line">video_capture &#x3D; cv2.VideoCapture(0)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # Capture frame-by-frame</span><br><span class="line">    ret, frame &#x3D; video_capture.read()</span><br><span class="line"></span><br><span class="line">    gray &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    faces &#x3D; faceCascade.detectMultiScale(</span><br><span class="line">        gray,</span><br><span class="line">        scaleFactor&#x3D;1.1,</span><br><span class="line">        minNeighbors&#x3D;5,</span><br><span class="line">        minSize&#x3D;(200, 200),</span><br><span class="line">        flags&#x3D;cv2.CASCADE_SCALE_IMAGE</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # Draw a rectangle around the faces</span><br><span class="line">    for (x, y, w, h) in faces:</span><br><span class="line">        cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 3)</span><br><span class="line">            roi_gray &#x3D; gray[y:y+h, x:x+w]</span><br><span class="line">            roi_color &#x3D; frame[y:y+h, x:x+w]</span><br><span class="line">            cv2.putText(frame,&#39;Face&#39;,(x, y), font, 2,(255,0,0),5)</span><br><span class="line"></span><br><span class="line">    smile &#x3D; smileCascade.detectMultiScale(</span><br><span class="line">        roi_gray,</span><br><span class="line">        scaleFactor&#x3D; 1.16,</span><br><span class="line">        minNeighbors&#x3D;35,</span><br><span class="line">        minSize&#x3D;(25, 25),</span><br><span class="line">        flags&#x3D;cv2.CASCADE_SCALE_IMAGE</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    for (sx, sy, sw, sh) in smile:</span><br><span class="line">        cv2.rectangle(roi_color, (sh, sy), (sx+sw, sy+sh), (255, 0, 0), 2)</span><br><span class="line">        cv2.putText(frame,&#39;Smile&#39;,(x + sx,y + sy), 1, 1, (0, 255, 0), 1)</span><br><span class="line"></span><br><span class="line">    eyes &#x3D; eyeCascade.detectMultiScale(roi_gray)</span><br><span class="line">    for (ex,ey,ew,eh) in eyes:</span><br><span class="line">        cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2)</span><br><span class="line">        cv2.putText(frame,&#39;Eye&#39;,(x + ex,y + ey), 1, 1, (0, 255, 0), 1)</span><br><span class="line"></span><br><span class="line">    cv2.putText(frame,&#39;Number of Faces : &#39; + str(len(faces)),(40, 40), font, 1,(255,0,0),2)      </span><br><span class="line">    # Display the resulting frame</span><br><span class="line">    cv2.imshow(&#39;Video&#39;, frame)</span><br><span class="line"></span><br><span class="line">    if cv2.waitKey(1) &amp; 0xFF &#x3D;&#x3D; ord(&#39;q&#39;):</span><br><span class="line">      break</span><br><span class="line"></span><br><span class="line"># When everything is done, release the capture</span><br><span class="line">video_capture.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<p>我已经制作了人脸检测算法的 YouTube 视频演示：</p>
<p><strong>Dlib 的方向梯度直方图（HOG）</strong></p>
<p>第二种常用的人脸检测工具由 Dlib 提供，它使用了方向梯度直方图（HOG）的概念。论文《Histograms of Oriented Gradients for Human Detection》实现这一方案。</p>
<p><strong>理论</strong></p>
<p>HOG 背后的想法是将特征提取到一个向量中，并将其输入到分类算法中，例如支持向量机，它将评估人脸（或实际想识别的任何对象）是否存在于某个区域中。</p>
<p>提取的特征是图像梯度（方向梯度）方向的分布（直方图）。梯度通常在边缘和角落周围较大，并允许我们检测这些区域。</p>
<p>在原始论文中，该算法用于人体检测，检测过程如下：</p>
<p><strong>预处理</strong></p>
<p>首先，输入图像必须尺寸相同（可通过裁剪和缩放）。图像长宽比要求为 1:2，因此输入图像的尺寸可能为 64x128 或 100x200。</p>
<p><strong>计算梯度图像</strong></p>
<p>第一步是通过以下卷积核计算图像的水平梯度和垂直梯度：</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/629050c3-86c7-4b27-9903-bf953f27895c/640.png" alt="img"></p>
<p><em>计算梯度的卷积核</em></p>
<p>图像的梯度通常会消除非必要信息。</p>
<p>上面图像的梯度可以通过下面的 python 语句找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gray &#x3D; cv2.imread(&#39;images&#x2F;face_detect_test.jpeg&#39;, 0)</span><br><span class="line">im &#x3D; np.float32(gray) &#x2F; 255.0</span><br><span class="line"># Calculate gradient </span><br><span class="line">gx &#x3D; cv2.Sobel(im, cv2.CV_32F, 1, 0, ksize&#x3D;1)</span><br><span class="line">gy &#x3D; cv2.Sobel(im, cv2.CV_32F, 0, 1, ksize&#x3D;1)</span><br><span class="line">mag, angle &#x3D; cv2.cartToPolar(gx, gy, angleInDegrees&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>绘制图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize&#x3D;(12,8))</span><br><span class="line">plt.imshow(mag)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.jiqizhixin.com/uploads/editor/b7b2438b-1f98-4992-bdf8-7b94e4dbde7f/640.jpeg" alt="img"></p>
<p>我们之前没有预处理图像。</p>
<p><strong>计算 HOG</strong></p>
<p>首先将图像分成 8x8 个单元来提供紧凑表示，使 HOG 对噪声更鲁棒。然后，计算每个单元的 HOG。</p>
<p>为了估计区域内的梯度方向，我们只需在每个区域内的 64 个梯度方向值（8x8）及其大小（另外 64 个值）之间构建直方图。直方图的类别对应梯度的角度，从 0 到 180°。总共 9 类：0°，20°，40°…… 160°。</p>
<p>上面的代码给了我们 2 个信息：</p>
<ul>
<li>梯度方向</li>
<li>梯度大小</li>
</ul>
<p>当我们构建 HOG 时，有 3 种情况：</p>
<ul>
<li>角度小于 160°，且不介于两类之间。在这种情况下，角度将添加到 HOG 的正确类中。</li>
<li>角度小于 160°，恰好在两类之间。在这种情况下，像素被均分到左右两侧类中。</li>
<li>角度大于 160°。在这种情况下，我们认为像素与 160°和 0°成比例。</li>
</ul>
<p><img src="https://image.jiqizhixin.com/uploads/editor/d944bc9f-9bdf-4a60-ba76-e5f53ba6af5b/640.jpeg" alt="img"></p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/841dab46-ac57-43e1-9656-40c3b3738003/640.jpeg" alt="img"></p>
<p>每个 8x8 单元的 HOG 如下所示：</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/8b5ba4f7-a2f8-48a3-8b3c-ab03ce87366d/640.jpeg" alt="img"></p>
<p><em>HOG</em></p>
<p><strong>模块归一化</strong></p>
<p>最后，可以用 16×16 的模块对图像进行归一化，并使其对光照不变。这可以通过将大小为 8x8 的 HOG 的每个值除以包含它的 16x16 模块的 HOG 的 L2 范数来实现，这个模块实际上是长度为 9*4 = 36 的简单向量。</p>
<p><strong>模块归一化</strong></p>
<p>最后，将所有 36x1 向量连接成一个大向量。OK！现在有了特征向量，我们可以在上面训练一个软 SVM 分类器（C=0.01）。</p>
<p><strong>检测图像上的人脸</strong></p>
<p>实现非常简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">face_detect &#x3D; dlib.get_frontal_face_detector()</span><br><span class="line">rects &#x3D; face_detect(gray, 1)</span><br><span class="line">for (i, rect) in enumerate(rects):</span><br><span class="line">(x, y, w, h) &#x3D; face_utils.rect_to_bb(rect)</span><br><span class="line">    cv2.rectangle(gray, (x, y), (x + w, y + h), (255, 255, 255), 3)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize&#x3D;(12,8))</span><br><span class="line">plt.imshow(gray, cmap&#x3D;&#39;gray&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.jiqizhixin.com/uploads/editor/0f5b21c6-a073-44e8-9fac-06ddbc85b0b5/640.jpeg" alt="img"></p>
<p><strong>实时人脸检测</strong></p>
<p>如前所述，该算法非常容易实现。我们还实现了一个更轻量的版本，只用来识别人脸。Dlib 让人脸关键点的检测更加容易，但这是另一个话题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">video_capture &#x3D; cv2.VideoCapture(0)</span><br><span class="line">flag &#x3D; 0</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line"></span><br><span class="line">    ret, frame &#x3D; video_capture.read()</span><br><span class="line"></span><br><span class="line">    gray &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    rects &#x3D; face_detect(gray, 1)</span><br><span class="line"></span><br><span class="line">    for (i, rect) in enumerate(rects):</span><br><span class="line"></span><br><span class="line">        (x, y, w, h) &#x3D; face_utils.rect_to_bb(rect)</span><br><span class="line"></span><br><span class="line">        cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)</span><br><span class="line"></span><br><span class="line">        cv2.imshow(&#39;Video&#39;, frame)</span><br><span class="line"></span><br><span class="line">    if cv2.waitKey(1) &amp; 0xFF &#x3D;&#x3D; ord(&#39;q&#39;):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">video_capture.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><strong>Dlib 中的卷积神经网络</strong></p>
<p>最后一种方法基于卷积神经网络。为了增强结果，它还实现了最大边缘目标检测（MMOD）。</p>
<p><strong>理论</strong></p>
<p>卷积神经网络是主要用于计算机视觉的前馈神经网络。它们提供自动图像预处理以及密集的神经网络部分。CNN 还是用来处理带有网格状拓扑的数据的特殊神经网络。它的架构灵感来自动物视觉皮层。</p>
<p>以前的方法中，很大一部分工作是选择滤波器来创建特征，以便尽从图像中可能多地提取信息。随着深度学习和计算能力的提高，这项工作现在可以实现自动化。CNN 的名称就来自我们用一组滤波器卷积初始图像输入的事实。需要选择的参数仍是需要应用的滤波器数量以及尺寸。滤波器的尺寸称为步幅。一般步幅设置在 2 到 5 之间。</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/b2ddc028-d6a9-4d24-91aa-82a4bdf216c7/640.jpeg" alt="img"></p>
<p>在这种特定情况下，CNN 的输出是二分类，如果有人脸，则取值 1，否则取 0。</p>
<p><strong>检测图像上的人脸</strong></p>
<p>一些元素在实现中会发生变化。</p>
<p>第一步是下载预训练模型：<a href="https://github.com/davisking/dlib-models/blob/master/mmod_human_face_detector.dat.bz2" target="_blank" rel="noopener">https://github.com/davisking/dlib-models/blob/master/mmod_human_face_detector.dat.bz2</a></p>
<p> 将下载后的权重放到文件夹中，并定义 dnnDaceDetector：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnnFaceDetector &#x3D; dlib.cnn_face_detection_model_v1（&quot;mmod_human_face_detector.dat&quot;）</span><br></pre></td></tr></table></figure>
<p>然后，与之前做的相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rects &#x3D; dnnFaceDetector(gray, 1)</span><br><span class="line">for (i, rect) in enumerate(rects):</span><br><span class="line">    x1 &#x3D; rect.rect.left()</span><br><span class="line">    y1 &#x3D; rect.rect.top()</span><br><span class="line">    x2 &#x3D; rect.rect.right()</span><br><span class="line">    y2 &#x3D; rect.rect.bottom()</span><br><span class="line">    # Rectangle around the face</span><br><span class="line">    cv2.rectangle(gray, (x1, y1), (x2, y2), (255, 255, 255), 3)</span><br><span class="line">plt.figure(figsize&#x3D;(12,8))</span><br><span class="line">plt.imshow(gray, cmap&#x3D;&#39;gray&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://image.jiqizhixin.com/uploads/editor/4f7f86e8-d304-466f-a130-16e04efc1d06/640.jpeg" alt="img"></p>
<p><strong>实时人脸检测</strong></p>
<p>最后，实现实时 CNN 人脸检测：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">video_capture &#x3D; cv2.VideoCapture(0)</span><br><span class="line">flag &#x3D; 0</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # Capture frame-by-frame</span><br><span class="line">    ret, frame &#x3D; video_capture.read()</span><br><span class="line"></span><br><span class="line">    gray &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    rects &#x3D; dnnFaceDetector(gray, 1)</span><br><span class="line"></span><br><span class="line">    for (i, rect) in enumerate(rects):</span><br><span class="line"></span><br><span class="line">        x1 &#x3D; rect.rect.left()</span><br><span class="line">        y1 &#x3D; rect.rect.top()</span><br><span class="line">        x2 &#x3D; rect.rect.right()</span><br><span class="line">        y2 &#x3D; rect.rect.bottom()</span><br><span class="line"></span><br><span class="line">        # Rectangle around the face</span><br><span class="line">        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)</span><br><span class="line"></span><br><span class="line">    # Display the video output</span><br><span class="line">    cv2.imshow(&#39;Video&#39;, frame)</span><br><span class="line"></span><br><span class="line">    # Quit video by typing Q</span><br><span class="line">    if cv2.waitKey(1) &amp; 0xFF &#x3D;&#x3D; ord(&#39;q&#39;):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">video_capture.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><strong>如何选择模型</strong></p>
<p>这是一个很难回答的问题，但我们只讨论两个重要指标：</p>
<ul>
<li>计算时间</li>
<li>准确率</li>
</ul>
<p>在速度方面，HOG 是最快的算法，其次是 Haar 级联分类器和 CNN。</p>
<p>但是，Dlib 中的 CNN 是准确率最高的算法。HOG 表现也很好，但在识别较小的人脸时会有一些问题。Haar 级联分类器的整体表现与 HOG 相似。</p>
<p>考虑到实时人脸检测的速度，我在个人项目中使用了 HOG。</p>
<p>希望这个关于 OpenCV 和 Dlib 的人脸检测的快速教程能对你有所帮助。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>人脸检测</tag>
      </tags>
  </entry>
  <entry>
    <title>QT学习笔记（C++）</title>
    <url>/2020/01/12/QT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88C-%EF%BC%89/</url>
    <content><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><a id="more"></a>
<h2 id="makefile-的编写"><a href="#makefile-的编写" class="headerlink" title="makefile 的编写"></a>makefile 的编写</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Makefile for building: hellorect</span></span><br><span class="line">CC          = gcc</span><br><span class="line">CXX         = g++</span><br><span class="line">LINKER      = g++</span><br><span class="line">LFLAGS      = -lm -static</span><br><span class="line"></span><br><span class="line">OBJECTS     = rect.o hellorect.o</span><br><span class="line">DSTTARGET   = hellorect</span><br><span class="line"><span class="comment"># Default rule</span></span><br><span class="line"><span class="section">all: <span class="variable">$(DSTTARGET)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DSTTARGET)</span>: <span class="variable">$(OBJECTS)</span></span><br><span class="line">	<span class="variable">$(LINKER)</span>  <span class="variable">$(LFLAGS)</span>  -o <span class="variable">$@</span>  <span class="variable">$(OBJECTS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">hellorect.o: hellorect.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c  -o  <span class="variable">$@</span>  <span class="variable">$&lt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="section">rect.o: rect.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c  -o  <span class="variable">$@</span>  <span class="variable">$&lt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm  <span class="variable">$(OBJECTS)</span>  hellorect.exe</span><br></pre></td></tr></table></figure>
<p>这里解释一下上面脚本意思（# 打头的是注释，忽略掉）：<br>中间带有等于号的都是定义变量，引用变量的方式就是 $(变量名) , 脚本里 CC 是 C 语言编译器，CXX 是 C++ 编译器，LINKER 是链接器， LFLAGS 是链接器的参数。OBJECTS 是编译得到的目标文件，DSTTARGET 是可执行的目标程序。<br>接下来是 Makefile 的生成规则，Makefile 的基本规则是：</p>
<p>生成目标: 依赖文件<br>[tab字符] 系统命令</p>
<p> 示例的 Makefile 中</p>
<p>all: $(DSTTARGET)</p>
<p>是默认生成规则，依赖文件 $(DSTTARGET) ，它的下一行没有命令。 而如何生成 $(DSTTARGET) 呢，继续往下找</p>
<p>$(DSTTARGET): $(OBJECTS)</p>
<p>生成 $(DSTTARGET) 需要 $(OBJECTS)，有了目标文件之后执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(LINKER)  $(LFLAGS)  -o $@  $(OBJECTS)</span><br></pre></td></tr></table></figure>
<p>即调用链接器 $(LINKER)，根据链接器参数 $(LFLAGS) 和 $(OBJECTS)，生成 $@ 。 $@ 就是上一行冒号左边的要生成的目标。注意系统命令 $(LINKER) 之前一定要有制表符 tab 字符， 不能用 4 个空格代替，否则 make 时会出现没有分隔符（separator）的错误。<br>接下来的四句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hellorect.o: hellorect.cpp      </span><br><span class="line">	$(CXX) -c  -o  $@  $&lt;  </span><br><span class="line"></span><br><span class="line">rect.o: rect.cpp</span><br><span class="line">	$(CXX) -c  -o  $@  $&lt;</span><br></pre></td></tr></table></figure>
<p>是使用编译器生成目标文件 hellorect.o 和 rect.o ，$@ 是上一行冒号左边的目标，$&lt; 是上一行冒号右边第一个依赖文件。 hellorect.o 和 rect.o就是链接器需要的 $(OBJECTS) 。<br>最后的两句是清除规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">	rm  $(OBJECTS)  hellorect.exe</span><br></pre></td></tr></table></figure>
<p>rm 是删除命令，如果 Windows 系统里没有 rm 命令，请安装一个 msysgit 工具（ <a href="http://msysgit.github.io/），" target="_blank" rel="noopener">http://msysgit.github.io/），</a> 然后系统环境变量里面会有 msysgit 工具路径，里面有 rm 工具。 clean 做的事情就是删除项目生成的 .o 和 .exe 文件。（注：Linux 系统里可执行程序没有 .exe 后缀，需要去掉 .exe 后缀。）</p>
<h2 id="自定义QWidget"><a href="#自定义QWidget" class="headerlink" title="自定义QWidget"></a>自定义QWidget</h2><p>在自定义的类继承QWidget的同时，要包含Q_OBJECT宏。但是，第一次使用会报错</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/23595961/qt-a-missing-vtable-usually-means-the-first-non-inline-virtual-member-function" target="_blank" rel="noopener">https://stackoverflow.com/questions/23595961/qt-a-missing-vtable-usually-means-the-first-non-inline-virtual-member-function</a><br>Q_OBJECT是必要的<br>Q_OBJECT是信号，插槽，可调用项,qobject_cast翻译，属性，枚举和方法自省等的前提。</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定c++标准的版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动调用moc，uic，rcc处理qt的扩展部分</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Qt5的cmake模块所在目录，如果不设置将使用系统提供的版本</span></span><br><span class="line"><span class="comment"># QT_DIR和QT_VERSION是指定了qt安装目录和版本的环境变量</span></span><br><span class="line"><span class="comment"># 如果你使用了系统的cmake，那么会优先使用系统提供模块，因为cmake会优先搜索CMAKE_SYSTEM_PREFIX_PATH</span></span><br><span class="line"><span class="comment"># 如果你不想让cmake优先搜索系统目录（会导致编译使用系统安装的qt而不是我们配置的），需要提示find_package命令</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH <span class="variable">$&#123;CMAKE_PREFIX_PATH&#125;</span> $ENV&#123;QT_DIR&#125;/$ENV&#123;QT_VERSION&#125;/gcc_64/lib/cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到对应的qt模块，名字为qmake中QT += &lt;name&gt;中的name首字母大写后加上Qt5前缀</span></span><br><span class="line"><span class="comment"># 例如core为QtCore，你也可以去$&#123;CMAKE_PREFIX_PATH&#125;的目录中找到正确的模块名</span></span><br><span class="line"><span class="comment"># 如果不想使用系统qt，这样写（注意NO_DEFAULT_PATH参数，它会让find_package跳过系统目录的查找）：</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt5Widgets REQUIRED NO_DEFAULT_PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你想要使用系统自带的qt，这样写：</span></span><br><span class="line"><span class="comment"># find_package(Qt5Widgets REQUIRED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录的所有源文件添加进变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIRS_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通常这样设置就可以，如果你的项目包含qrc文件，那么需要将它们单独添加进来</span></span><br><span class="line"><span class="comment"># 例如add_executable(test $&#123;DIRS_SRCS&#125; resources.qrc)</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span> <span class="variable">$&#123;DIRS_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把对应Qt模块的库链接进程序</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">test</span> Qt5::Widgets)</span><br></pre></td></tr></table></figure>
<p>资源文件格式<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RCC</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qresource</span> <span class="attr">prefix</span>=<span class="string">"/icon"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>icon/icon_THP.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="信号与槽的连接"><a href="#信号与槽的连接" class="headerlink" title="信号与槽的连接"></a>信号与槽的连接</h2><p>①connect()绑定函数，如果放到主窗口的构造函数中，此时，子窗口的类还没新建对象，没有分配内存地址，如果new一个对象，程序不会报错（搜一下，有好新手跟我一样有这个疑问），但是新建的子窗口对象与通过主窗口的点击按钮后，新建的子窗口对象是两码事，在内存中是两个不同的地址，我们要绑定的应该是后者与主窗口的信号槽绑定，所以，connect函数应该放到主窗口点击子窗口按钮代码里面。<br>②connect()绑定函数，如果放到子窗口的构造函数中，发送用this，接收用主窗口指针，原理一样，如果此处新建主窗口对象，然后建立连接，其实内存中有两个主窗口对象了，绑定的并不是我想显示日志信息的主窗口对象，此处可以直接调用出窗口已新建好对象的指针。<br>③connect()，在子窗口和主窗口交互的过程中，其实放到哪里不重要，重要的是发送和接收的指针一定要是已新建好的主窗口/子窗口对象的指针，并且确保是新建好后再执行该connect()绑定函数。</p>
<h2 id="复杂多窗口设计"><a href="#复杂多窗口设计" class="headerlink" title="复杂多窗口设计"></a>复杂多窗口设计</h2><p>在多窗口设计过程中：</p>
<ol>
<li>涉及到控件之间的信号连接，需要在控件被建立后再创建。</li>
<li>对于可能被重建（在deleterlater之后new对象）的控件，将其控件的相关连接单独写入一个函数。删除对象时，注意需要先删除对象相关的图标（Actions对应的toolbar和menubar中的item），然后通过deleterLater（）方法删除对象。</li>
</ol>
<h2 id="删除机制"><a href="#删除机制" class="headerlink" title="删除机制"></a>删除机制</h2><p>在qt中如果对象继承自一个QObject对象，则QT会自动对对象进行管理。</p>
<h1 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h1><h2 id="窗口中添加分割线"><a href="#窗口中添加分割线" class="headerlink" title="窗口中添加分割线"></a>窗口中添加分割线</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    QFrame *<span class="built_in">line</span>;</span><br><span class="line">    <span class="built_in">line</span> = <span class="keyword">new</span> QFrame();</span><br><span class="line">    <span class="built_in">line</span>-&gt;setFrameShape(QFrame::VLine);</span><br><span class="line"><span class="comment">//    line-&gt;setFrameShadow(QFrame::Sunken);</span></span><br><span class="line">    <span class="built_in">line</span>-&gt;setLineWidth(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>PCB电路板制作流程</title>
    <url>/2020/09/02/PCB%E7%94%B5%E8%B7%AF%E6%9D%BF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>印制电路板{PCB线路板}，又称印刷电路板，是电子元器件电气连接的提供者。<br>参考链接：<a href="http://mouser.eetrend.com/content/2018/100015548.html" target="_blank" rel="noopener">http://mouser.eetrend.com/content/2018/100015548.html</a><br><a href="http://www.360doc.com/content/16/0529/15/33072037_563261798.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/16/0529/15/33072037_563261798.shtml</a><br><a href="https://wenku.baidu.com/view/e809f110cc7931b765ce1577.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/e809f110cc7931b765ce1577.html</a><br><a id="more"></a></p>
<h1 id="PCB电路板的组成"><a href="#PCB电路板的组成" class="headerlink" title="PCB电路板的组成"></a>PCB电路板的组成</h1><p>1、线路与图面（Pattern）：线路是做为原件之间导通的工具，在设计上会另外设计大铜面作为接地及电源层。线路与图面是同时做出的。</p>
<p>2、介电层（Dielectric）：用来保持线路及各层之间的绝缘性，俗称为基材。</p>
<p>3、孔（Through hole / via）：导通孔可使两层次以上的线路彼此导通，较大的导通孔则做为零件插件用，另外有非导通孔（nPTH）通常用来作为表面贴装定位，组装时固定螺丝用。</p>
<p>4、防焊油墨（Solder resistant /Solder Mask） ：并非全部的铜面都要吃锡上零件，因此非吃锡的区域，会印一层隔绝铜面吃锡的物质（通常为环氧树脂），避免非吃锡的线路间短路。根据不同的工艺，分为绿油、红油、蓝油。</p>
<p>5、丝印（Legend /Marking/Silk screen）：此为非必要之构成，主要的功能是在电路板上标注各零件的名称、位置框，方便组装后维修及辨识用。</p>
<p>6、表面处理（Surface Finish）：由于铜面在一般环境中，很容易氧化，导致无法上锡（焊锡性不良），因此会在要吃锡的铜面上进行保护。保护的方式有喷锡（HASL），化金（ENIG），化银（Immersion Silver），化锡（Immersion TIn），有机保焊剂（OSP），方法各有优缺点，统称为表面处理。</p>
<h2 id="PCB制作工艺"><a href="#PCB制作工艺" class="headerlink" title="PCB制作工艺"></a>PCB制作工艺</h2><p>1.化学清洗—【Chemical Clean】<br><img src="1.jpeg" alt="img"><br>为得到良好质量的蚀刻图形，就要确保抗蚀层与基板表面牢固的结合，要求基板表面无氧化层、油污、灰尘、指印以及其他的污物。因此在涂布抗蚀层前首先要对板进行表面清洗并使铜箔表面达到一定的粗化层度。<br>内层板材：开始做四层板，内层（第二层和第三层）是必须先做的。内层板材是由玻璃纤维和环氧树脂基复合在上下表面的铜薄板。</p>
<p>2.裁板 压膜—【Cut Sheet Dry Film Lamination】<br><img src="2.jpeg" alt="img"><br>涂光刻胶：为了在内层板材作出我们需要的形状，我们首先在内层板材上贴上干膜（光刻胶，光致抗蚀剂）。干膜是由聚酯簿膜，光致抗蚀膜及聚乙烯保护膜三部分组成的。贴膜时，先从干膜上剥下聚乙烯保护膜，然后在加热加压的条件下将干膜粘贴在铜面上。</p>
<p>3.曝光和显影-【Image Expose】 【Image Develop】<br><img src="3.jpeg" alt="img"><br>曝光：在紫外光的照射下，光引发剂吸收了光能分解成游离基，游离基再引发光聚合单体产生聚合交联反应，反应后形成不溶于稀碱溶液的高分子结构。聚合反应还要持续一段时间，为保证工艺的稳定性，曝光后不要立即撕去聚酯膜，应停留15分钟以上，以时聚合反应继续进行，显影前撕去聚酯膜。<br>显影：感光膜中未曝光部分的活性基团与稀碱溶液反应生产可溶性物质而溶解下来，留下已感光交联固化的图形部分。</p>
<p>4.蚀刻-【Copper Etch】<br><img src="4.jpeg" alt="img"><br>在挠性印制板或印制板的生产过程中，以化学反应方法将不要部分的铜箔予以去除，使之形成所需的回路图形，光刻胶下方的铜是被保留下来不受蚀刻的影响的。</p>
<p>5.去膜，蚀后冲孔，AOI检查，氧化<br>Strip Resist】 【Post Etch Punch】 【AOI Inspection】 【Oxide】<br><img src="5.jpeg" alt="img"><br>去膜的目的是清除蚀刻后板面留存的抗蚀层使下面的铜箔暴露出来。“膜渣”过滤以及废液回收则须妥善处理。如果去膜后的水洗能完全清洗干净，则可以考虑不做酸洗。板面清洗后最后要完全干燥，避免水份残留。</p>
<p>6.叠板-保护膜胶片【Layup with prepreg】<br><img src="6.jpeg" alt="img"><br>进压合机之前,需将各多层板使用原料准备好,以便叠板(Lay-up)作业.除已氧化处理之内层外,尚需保护膜胶片(Prepreg)-环氧树脂浸渍玻璃纤维。叠片的作用是按一定的次序将覆有保护膜的板子叠放以来并置于二层钢板之间。</p>
<p>7.叠板-铜箔 和真空层压<br>【Layup with copper foil】【Vacuum Lamination Press】<br><img src="7.jpeg" alt="img"><br>铜箔-给目前的内层板材再在两侧都覆盖一层铜箔，然后进行多层加压（在固定的时间内需要测量温度和压力的挤压）完成后冷却到室温，剩下的就是一个多层合在一起的板材了。</p>
<p>8.CNC钻孔【CNC Drill】<br><img src="8.jpeg" alt="img"><br>在内层精确的条件下，数控钻孔根据模式钻孔。钻孔精度要求很高，以确保孔是在正确位置。</p>
<p>9.电镀-通孔【Electroless Copper】<br><img src="9.jpeg" alt="img"><br>为了使通孔能在各层之间导通（使孔壁上之非导体部份之树脂及玻纤束进行金属化），在孔中必须填充铜。第一步是在孔中镀薄薄一层铜，这个过程完全是化学反应。最终镀的铜厚为50英寸的百万分之一。</p>
<p>10.裁板 压膜【Cut Sheet】 【Dry Film Lamination】<br><img src="10.jpeg" alt="img"><br>涂光刻胶：我们有一次在外层涂光刻胶。</p>
<p>11.曝光和显影-【Image Expose】 【Image Develop】<br><img src="11.jpeg" alt="img"><br>外层曝光和显影</p>
<p>12.线路电镀：【Copper Pattern Electro Plating】<br><img src="12.jpeg" alt="img"><br>此次也成为二次镀铜，主要目的是加厚线路铜和通孔铜厚。</p>
<p>13.电镀锡【Tin Pattern Electro Plating】</p>
<p>其主要目的是蚀刻阻剂, 保护其所覆盖的铜导体不会在碱性蚀铜时受到攻击（保护所有铜线路和通孔内部）。</p>
<p>14.去膜【Strip Resist】<br><img src="13.jpeg" alt="img"><br>我们已经知道了目的，只需要用化学方法，表面的铜被暴露出来。</p>
<p>15.蚀刻【Copper Etch】<br><img src="14.jpeg" alt="img"><br>我们知道了蚀刻的目的，镀锡部分保护了下面的铜箔。</p>
<p>16.预硬化 曝光 显影 上阻焊<br><img src="15.jpeg" alt="img"><br>【LPI coating side 1】 【Tack Dry】 【LPI coating side 2】【Tack Dry】<br>【Image Expose】【Image Develop】 【Thermal Cure Soldermask】<br>阻焊层,是为了把焊盘露出来用的,也就是通常说的绿油层,实际上就是在绿油层上挖孔,把焊盘等不需要绿油盖住的地方露出来。适当清洗可以得到合适的表面特征。</p>
<p>17.表面处理<br><img src="16.jpeg" alt="img"><br>【Surface finish】<br> > HASL, Silver, OSP, ENIG 热风整平，沉银，有机保焊剂，化学镍金<br> > Tab Gold if any 金手指<br>热风整平焊料涂覆ＨＡＬ(俗称喷锡)过程是先把印制板上浸上助焊剂，随后在熔融焊料里浸涂，然后从两片风刀之间通过，用风刀中的热压缩空气把印制板上的多余焊料吹掉，同时排除金属孔内的多余焊料，从而得到一个光亮、平整、均匀的焊料涂层。<br>金手指(Gold Finger,或称 Edge Connector)设计的目的,在于藉由connector连接器的插接作为板对外连络的出口,因此须要金手指制程.之所以选择金是因为它优越的导电度及抗氧化性.但因为金的成本极高所以只应用于金手指,局部镀或化学金</p>
<p>最后总结一下所有的过程：<br>1) Inner Layer 内层<br> > Chemical Clean 化学清洗<br> > Cut Sheet Dry Film Lamination 裁板 压膜<br> > Image Expose 曝光<br> > Image Develop 显影<br> > Copper Etch 蚀铜<br> > Strip Resist 去膜<br> > Post Etch Punch 蚀后冲孔<br> > AOI Inspection AOI 检查<br> > Oxide 氧化<br> > Layup 叠板<br> > Vacuum Lamination Press 压合</p>
<p>2) CNC Drilling 钻孔<br> > CNC Drilling 钻孔</p>
<p>3) Outer Layer 外层<br> > Deburr 去毛刺<br> > Etch back - Desmear 除胶渣<br> > Electroless Copper 电镀-通孔<br> > Cut Sheet Dry Film Lamination 裁板 压膜<br> > Image Expose 曝光<br> > Image Develop 显影</p>
<p>4) Plating 电镀<br> > Image Develop 显影<br> > Copper Pattern Electro Plating 二次镀铜<br> > Tin Pattern Electro Plating 镀锡<br> > Strip Resist 去膜<br> > Copper Etch 蚀铜<br> > Strip Tin 剥锡</p>
<p>5) Solder Mask 阻焊<br> > Surface prep 前处理<br> > LPI coating side 1 印刷<br> > Tack Dry 预硬化<br> > LPI coating side 2 印刷<br> > Tack Dry 预硬化<br> > Image Expose 曝光<br> > Image Develop 显影<br> > Thermal Cure Soldermask 印阻焊</p>
<p>6) Surface finish 表面处理<br> > HASL, Silver, OSP, ENIG 热风整平，沉银，有机保焊剂，化学镍金<br> > Tab Gold if any 金手指<br> > Legend 图例</p>
<p>7) Profile 成型<br> > NC Routing or punch</p>
<p>8) ET Testing, continuity and isolation</p>
<p>9) QC Inspection<br> > Ionics 离子残余量测试<br> > 100% Visual Inspection 目检<br> > Audit Sample Mechanical Inspection<br> > Pack &amp; Shipping 包装及出货</p>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>Polar Mask分割算法【转载】</title>
    <url>/2020/04/08/Polar-Mask%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>PolarMask的精度并不是很高，而且速度上也没有优势，但是它的思路是非常巧妙的，对后面的研究有着很大的启发意义。<br><a id="more"></a><br>转载自：<a href="https://zhuanlan.zhihu.com/p/84890413" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84890413</a></p>
<p>PolarMask, 一种single shot的实例分割框架，文章在<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1909.13226">https://arxiv.org/abs/1909.13226</a>, 代码已经开源，在<a href="https://link.zhihu.com/?target=https%3A//github.com/xieenze/PolarMask">https://github.com/xieenze/PolarMask</a>。欢迎大家多多指教。</p>
<p>PolarMask基于FCOS，把实例分割统一到了FCN的框架下。在4月份FCOS挂出来之后，我和沈老师就一直在讨论如何进把instance segmentation融合进FCN里。FCOS本质上是一种FCN的dense prediction的检测框架，可以在性能上不输anchor based的目标检测方法，让行业看到了anchor free方法的潜力。接下来要解决的问题是实例分割。</p>
<p>这个工作我个人觉得最大的贡献在于，把更复杂的实例分割问题，转化成在网络设计和计算量复杂度上和物体检测一样复杂的任务，把对实例分割的建模变得简单和高效。</p>
<p>Mask R-CNN<br>首先回顾一下之前最经典的实例分割方法，‘先检测再分割’，在这方面做到极致的算法是Mask RCNN。</p>
<p><img src="image/v2-ba7114dd24d45324477916feda18ba92_1440w.jpg" alt="img"></p>
<p>Mask R-CNN属于基于两阶段的检测算法，在检测框的基础上进行像素级的语义分割，简化了实例分割的难度，同时取得了stoa的性能，在’先检测再分割’ 这一范式上做到了极致。</p>
<hr>
<p>**PolarMask</p>
<p>**我们的PolarMask提出了一种新的instance segmentation建模方式，通过寻找物体的contour建模，提供了一种新的方法供大家选择。</p>
<p>**两种实例分割的建模方式：</p>
<p>**1 像素级建模 类似于图b，在检测框中对每个pixel分类<br>2 轮廓建模 类似于图c和图d，其中，图c是基于直角坐标系建模轮廓，图d是基于极坐标系建模轮廓</p>
<p><img src="image/v2-e1631235db01c2ca6e65c9601bb2b7f2_1440w.jpg" alt="img"></p>
<p>可以看到Mask R-CNN属于第一种建模方式，而我们提出的PolarMask属于图d建模方式。图c也会work，但是相比图d缺乏固定角度先验。换句话说，基于极坐标系的方式已经将固定角度设为先验，网络只需回归固定角度的长度即可，简化了问题的难度。</p>
<p>PolarMask 基于极坐标系建模轮廓，把实例分割问题转化为实例中心点分类(instance center classification)问题和密集距离回归(dense distance regression)问题。同时，我们还提出了两个有效的方法，用来优化high-quality正样本采样和dense distance regression的损失函数优化，分别是Polar CenterNess和 Polar IoU Loss。没有使用任何trick(多尺度训练，延长训练时间等)，PolarMask 在ResNext 101的配置下 在coco test-dev上取得了32.9的mAP。 这是首次，我们证明了更复杂的实例分割问题，可以在网络设计和计算复杂度上，和anchor free物体检测一样简单。我们希望PolarMask可以成为一个简单且强有效的single shot instance segmentation 的baseline。</p>
<p>PolarMask最重要的特点是:<br>(1) anchor free and bbox free，不需要出检测框<br>(2) fully convolutional network, 相比FCOS把4根射线散发到36根射线，将instance segmentation和object detection用同一种建模方式来表达。</p>
<p>我们选取FCOS嵌入我们的方法，主要是为了simple。FCOS是目前state-of-the-art的anchor-free检测器，并且十分simple。我们在FCOS的基础上，几乎不加任何计算量，就可以建模实例分割问题，并取得competitive的性能，证明了实例分割可以简化成和目标检测相同复杂的问题。<br>此外，FCOS可以看成PolarMask的特殊形式，而PolarMask可以看作FCOS的通用形式，因为bbox本质上是最简单的Mask，只有0,90,180,270四个角度回归长度。 我们首次将instance segmentation和object detection用同一种建模方式来表达。</p>
<hr>
<p><strong>网络结构</strong></p>
<p><img src="image/v2-d078fdf98ec216ace64b3f58e29a7b4b_1440w.jpg" alt="img"></p>
<p>整个网络和FCOS一样简单，首先是标准的backbone + fpn模型，其次是head部分，我们把fcos的bbox分支替换为mask分支，仅仅是把channel=4替换为channel=n, 这里n=36，相当于36根射线的长度。同时我们提出了一种新的Polar Centerness 用来替换FCOS的bbox centerness。<br>可以看到，在网络复杂度上，PolarMask和FCOS并无明显差别。</p>
<p><strong>Polar Segmentation建模</strong></p>
<p><img src="image/v2-9f57162d6c22a2f8cedcc551fdc768db_1440w.jpg" alt="img"></p>
<p>首先，输入一张原图，经过网络可以得到中心点的位置和n(n=36 is best in our setting)根射线的距离，其次，根据角度和长度计算出轮廓上的这些点的坐标，从0°开始连接这些点，最后把联通区域内的区域当做实例分割的结果。<br>在实验中，我们以重心为基准，assign到feature map上，会在重心周围采样，作为正样本，别的地方当做负样本，训练方式和FCOS保持一致，采用Focal Loss, 在此，我们提出Polar CenterNess，用来选择出高质量的正样本，给低质量的正样本降低权重。</p>
<hr>
<p><strong>Polar CenterNess</strong></p>
<p>如何在Polar Coordinate下定义高质量的正样本？我们通过如下公式定义</p>
<p><img src="image/v2-1935d8988a501ab1532035a32dc8ab6b_1440w.jpg" alt="img"></p>
<p>其中 d1 d2….dn指的是36根射线的长度，最好的正样本必须具备d<em>min ——&gt;</em> d<em>max.</em></p>
<p>用一张图举例</p>
<p><img src="image/v2-21693594e81a6e2cb03811997f378325_1440w.jpg" alt="img"></p>
<p>以看到中间的图，会出现长度回归差别很大的问题，而右边的图中心点位置就较为合适，到所有轮廓的长度回归就较为接近，36根射线的距离会比较均衡。 Polar Centerness 可以给右边图的点较高的centerness分数，给中间图的点降低centerness分数，这样在infernece的时候右边图的点分数较高。</p>
<p>根据消融实验，Polar Centerness可以有效提高1.4的性能，同时不增加网络复杂度。结果如下图所展示</p>
<p><img src="image/v2-c245decddce93a7088bdd848f7d7099d_1440w.jpg" alt="img"></p>
<hr>
<p><strong>Polar IoU Loss</strong></p>
<p>在PolarMask中，需要回归k(k=36)根射线的距离，这相比目标检测更为复杂，如何监督regression branch是一个问题。我们提出Polar IoU Loss近似计算出predict mask和gt mask的iou，通过Iou Loss 更好的优化mask的回归。通过实验证明，Polar IoU Loss相比Smooth L1loss可以明显提高2.6个点，同时Smooth L1loss还面临和其他loss不均衡的问题，需要精心调整权重，这是十分低效的，Polar IoU loss不需要调整权重就可以使mask分支快速且稳定收敛。<br>那么，Polar IoU Loss如何计算呢？如下图所展示</p>
<p><img src="image/v2-2e74b81da53e7d1794d6d60d4088cdb2_1440w.jpg" alt="img"></p>
<p>可以看到 两个mask的Iou可以简化为在dθ下的三角形面积iou问题并对无数个三角形求和，最终可以推倒到如下形式：</p>
<p><img src="image/v2-afc9b59d8829ed113e9f53999f8955da_1440w.jpg" alt="img"></p>
<p>其实最终的表达形式十分简单，但是相比smooth l1的确可以不用调参并裸涨2.6个点。说明loss func的设计对于深度神经网络呢意义重大。结果如下所展示</p>
<p><img src="image/v2-000f2903d0c2098ad7465391ba4cb444_1440w.jpg" alt="img"></p>
<p>我们在论文中还做了如下消融实验：射线数量的选择，加不加bbox branch, backbone以及尺寸和速度的trade off. 细节在论文中都有，不一一展开。</p>
<hr>
<p><strong>上限分析</strong></p>
<p>看到这里，很多人心里都会有一个疑问，射线这种建模方式，对于凹的物体会有性能损失，上限达不到100mAP，PolarMask怎么处理这个问题？<br>答案是这样，PolarMask相比Mask R-CNN这种pixel建模的方法，对于形状特别奇怪的mask的确建模会失败，但是这并不代表polarmask毫无意义。原因有两个，(1)Mask R-CNN的上限也到不了100 mAP 因为有下采样这类操作使得信息损失。(2)不管Mask R-CNN还是PolarMask，他们的实际性能距离100mAP的上限都特别远。<br>所以我们目前应该关注如何让实际网络性能去更好地趋近于上限。</p>
<p>定量分析分析射线建模的上限：</p>
<p><img src="image/v2-9b1ec4ad61022d706976f7100a43e3df_1440w.jpg" alt="img"></p>
<p>如图所示，当采用mass center做instance中心时，当射线数量不断提高，射线的gt和真实的gt的平均iou高达90%以上，这证明了对于射线建模的性能上限的忧虑还远远不需要担心。现阶段需要操心的问题是如何不断提高基于射线建模的网络性能。</p>
<hr>
<p><strong>实验</strong></p>
<p>最终，配上一图一表展示一下相比sota的结果</p>
<p><img src="image/v2-59ed0e0bac433b0d37a2e8b553610d43_1440w.jpg" alt="img"></p>
<p>可以看到, 没用采用任何trick的情况下，PolarMask在resnext101-fpn的情况下，取得了32.9的配置，虽然不是stoa，但是也比较有竞争力。我们目前并没有采用很多常用的能涨点的trick，比如 ms train和longer training epochs。相比之下，别的one stage方法都不约而同的采用了mstrain和longer training epoches。 我们会进一步改进，争取再提高性能。</p>
<hr>
<p><strong>后记</strong>：</p>
<p>我们会尽快完善并放出带多尺度训练和增长训练时间的代码和模型，以提供给大家并和上述模型公平比较，做instance segmentation非常费卡和时间，希望大家理解。</p>
<hr>
<p><strong>一些调参的碎碎念：</strong></p>
<p>这个工作在今年4月FCOS出来的同时，我和沈春华老师就在讨论如何进行FCOS进行single shot anchor free实例分割，以及在CVPR开会的时候，和文海，彦伟, 宋林等小伙伴就论证过contour regression的可行性，因为大家可以看出，anchor free 物体检测已经是大势所趋，下一个领域必然是anchor free实例分割，预测一下，再下一个领域是全景分割。在和沈老师这么多月的讨论中以及一次又一次实验的失败中，polarmask逐渐成型。最开始mask regression无数次无法收敛，写mask iou loss又复杂效果还不怎么好，直到某一天想出了polar iou loss。发现性能很好，不用调参，一把出结果。感觉平时做研究还是需要多思考，而不是盲目的做实验。同时，polar centerness也是我在旅游的过程中想到的，然后立马找了个咖啡厅写代码调试，裸涨1.4个点。这两个方法在不增加计算量的情况下，充分发挥了polarmask的性能，看起来其实很简单，但是实际上是背后很多次思考和化简的结果。</p>
<p>总得来说，我最喜欢这篇文章就两点，</p>
<p>1 足够简单，不加任何trick, 也没有任何复杂的操作，比如deformable conv和roi align操作，有希望在工业界大规模应用</p>
<p>2 找到了一种表达方式，把bbox detection和mask segmentation统一了起来，和FCOS是一种传承的工作，FCOS理论上可以看成PolarMask的特殊版，而PolarMask是FCOS的泛化版，因为bbox本质上是最简单的Mask。 PolarMask本质上可以看成一个目标检测和实例分割统一的框架。只需要简单修改就可以退化到FCOS。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实例分割</category>
      </categories>
  </entry>
  <entry>
    <title>qt相关</title>
    <url>/2020/05/06/QT%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="clion插件"><a href="#clion插件" class="headerlink" title="clion插件"></a>clion插件</h1><a id="more"></a>
<p>External tools<br>In “File -&gt; Settings -&gt; Tools -&gt; External Tools”, add 4 external tools:</p>
<p>Qt Creator:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Program:   &quot;PATH_TO_QT&#x2F;QT_VERSION&#x2F;QT_ARCH&#x2F;Tools&#x2F;QtCreator&#x2F;bin&#x2F;qtcreator&quot;</span><br><span class="line">Arguments: $FilePath$</span><br></pre></td></tr></table></figure><br>UI Designer:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Program:   &quot;PATH_TO_QT&#x2F;QT_VERSION&#x2F;QT_ARCH&#x2F;lib&#x2F;bin&#x2F;designer&quot;)</span><br><span class="line">Arguments: $FilePath$</span><br></pre></td></tr></table></figure><br>LUpdate:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Program:   &quot;PATH_TO_QT&#x2F;QT_VERSION&#x2F;QT_ARCH&#x2F;lib&#x2F;bin&#x2F;lupdate&quot;)</span><br><span class="line">Arguments: $FilePath$ -ts $FileNameWithoutExtension$.ts</span><br></pre></td></tr></table></figure><br>Linguist:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Program:   &quot;PATH_TO_QT&#x2F;QT_VERSION&#x2F;QT_ARCH&#x2F;lib&#x2F;bin&#x2F;linguist&quot;)</span><br><span class="line">Arguments: $FilePath$</span><br></pre></td></tr></table></figure><br>Now you can right click these file types and under the external tool:<br>For .ui select Qt Creator/Designer and start UI designing<br>For .qml select Qt Creator and design UI in QML editor<br>For .qrc select Qt Creator and use resource editor<br>For .cpp/.ui select LUpdate to create its translation file<br>For .ts select Linguist and start the translating</p>
<h1 id="qt资源文件"><a href="#qt资源文件" class="headerlink" title="qt资源文件"></a>qt资源文件</h1><p>手动修改和编写qrc文件的方法。<br>test.qrc文件：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE RCC&gt;</span><span class="tag">&lt;<span class="name">RCC</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">qresource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/copy.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/cut.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/document.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/icon.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/new.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/open.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/paste.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>images/save.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure><br>.qrc 文件中列出的 资源文件 是程序的源码树的一部分。指定的路径是 .qrc 文件所在目录的相对路径。 注意，列出的资源文件必须位于 .qrc 文件所在目录或者其子目录下。<br>程序中，可以用资源在源码树中的名称加一个  <code>:/</code> 前缀 来访问它。例如，在程序的源码树中是 <code>images/cut.png</code> 的文件可以通过<code>:/images/cut.png</code> 来访问。</p>
<p>但也可以用file标签中的alias属性来指定：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">file</span> <span class="attr">alias</span>=<span class="string">"cut-img.png"</span>&gt;</span>images/cut.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这时该文件可以通过  <code>:/cut-img.png</code>  来访问。</p>
<p>也可以在 .qrc 文件中用 qresource 标签的 prefix 属性：<br>它可以为 .qrc 文件中所有文件指定一个前缀：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">qresource</span> <span class="attr">prefix</span>=<span class="string">"/myresources"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">file</span> <span class="attr">alias</span>=<span class="string">"cut-img.png"</span>&gt;</span>images/cut.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这时该文件可以用  :/myresources/cut-img.png  访问。</p>
<h1 id="QT路径"><a href="#QT路径" class="headerlink" title="QT路径"></a>QT路径</h1><p>比如我们有一个程序在：<code>C:/Qt/examples/tools/regexp/regexp.exe</code></p>
<ol>
<li><p>程序所在目录<br>　　<code>QString QCoreApplication::applicationDirPath()</code><br>　　那么 <code>qApp-&gt;applicationDirPath()</code> 的结果是：<br>　　输出：<code>C:/Qt/examples/tools/regexp</code>　</p>
</li>
<li><p>程序的完整名称。那么可以这么写：<br>　　<code>qApp-&gt;applicationFilePath()</code><br>　　输出：<code>C:/Qt/examples/tools/regexp/regexp.exe</code></p>
</li>
<li><p>当前工作目录<br>　QDir 提供了一个静态函数 <code>currentPath()</code> 可以获取当前工作目录<br>　　如果我们是双击一个程序运行的，那么程序的工作目录就是程序所在目录。<br>　　如果是在命令行下运行一个程序，那么运行程序时在命令行的哪个目录，那个目录就是当前目录。</p>
</li>
<li><p>用户目录路径</p>
</li>
</ol>
<p>　　Qt 5 中引入的方法<br> 　<code>QStandardPaths::writableLocation(QStandardPaths::HomeLocation);</code><br>　　<code>QStandardPaths::standardLocations(QStandardPaths::HomeLocation);</code><br>　　这两个方法的区别是 <code>standardLocations()</code> 返回值是 QStringList。当然对于 HomeLocation 来说这个 QStringList 中只有一个 QString。</p>
<p>　　还有另外一种方法，利用 QDir 类的一个静态函数：<br>　　<code>QDir::homePath();</code></p>
<ol>
<li>我的文档路径</li>
</ol>
<p>　　 Qt 5 中引入的方法。</p>
<p>　　<code>QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);</code></p>
<p>　　<code>QStandardPaths::standardLocations(QStandardPaths::DocumentsLocation);</code></p>
<ol>
<li>桌面路径</li>
</ol>
<p>　　<code>QStandardPaths::writableLocation(QStandardPaths::DesktopLocation);</code></p>
<p>　　<code>QStandardPaths::standardLocations(QStandardPaths::DesktopLocation);</code></p>
<ol>
<li>程序数据存放路径</li>
</ol>
<p>　　通常我们会将程序所需的一些数据存入注册表。但是有时需要存储的数据太多，放在注册表中就不适合了。这时我们就要找个专门的地方来放数据。以前我喜欢将数据直接放到程序所在目录，但是后来发现我的程序运行时经常没有权限对这个目录下的文件进行写操作。后来发现其实 Qt 早就替我们考虑过这些问题了。</p>
<p>　　Qt 5 中引入的方法。</p>
<p>　　<code>QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);</code></p>
<p>　　<code>QStandardPaths::standardLocations(QStandardPaths::AppDataLocation);</code></p>
<p>　　Qt 5.5 中引入了另一种方法：　　</p>
<p>　　<code>QStandardPaths::writableLocation(QStandardPaths::AppConfigLocation);</code></p>
<p>　　<code>QStandardPaths::standardLocations(QStandardPaths::AppConfigLocation);</code></p>
<p>　　这个方法一般来说和上面的方法得到的结果是相同的。按照 Qt 帮助文档的解释，这个方法可以确保返回的路径非空。所以我认为应该优先选用这个方法。</p>
<ol>
<li>临时文件路径</li>
</ol>
<p>　　Qt 5 中引入的方法。</p>
<p>　　<code>QStandardPaths::writableLocation(QStandardPaths::TempLocation);</code></p>
<p>   <code>QStandardPaths::standardLocations(QStandardPaths::TempLocation);</code></p>
<p>　　更传统的方法是利用 QDir 的一个静态函数 <code>tempPath()</code>。</p>
<p>　　<code>QDir::tempPath();</code></p>
<p>　　在这个目录下生成临时文件和临时目录需要用到另外两个类： QTemporaryFile 和 QTemporaryDir。就不展开介绍了，大家可以参考 qt 的帮助文档。</p>
<p>至此，常用的各种特殊路径就介绍的差不多了。剩下还有些不常用的，可以参考 QStandardPaths 类的介绍。</p>
<h1 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h1><p>QT事件模块一个真正强大的特性是可以设置一个QObject的实例去监测另外一个QObject实例的事件,在被监测的实例see之前.<br>返回true告诉Qt我们已经处理了这个事件. 如果我们返回false, Qt会发送这个event到它原来的目的地.</p>
<ol>
<li>安装事件过滤器<br><code>installEventFilter(parent);</code></li>
<li>事件过滤器<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> :</span> <span class="keyword">public</span> QPushButton &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyButton(QWidget *parent) : QPushButton(parent) &#123;</span><br><span class="line">        installEventFilter(parent);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span> :</span> <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyWindow() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;setWindowTitle(<span class="string">"321"</span>);</span><br><span class="line">        button = <span class="keyword">new</span> MyButton(<span class="keyword">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> override </span>&#123;</span><br><span class="line">      # 过滤事件</span><br><span class="line">        <span class="keyword">if</span> (button == obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event-&gt;type() == QEvent::Enter) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;setWindowTitle(<span class="string">"123"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MyButton *button;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="QString-to-string"><a href="#QString-to-string" class="headerlink" title="QString to string"></a>QString to string</h1></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString qs;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> utf8_text = qs.toUtf8().constData();</span><br></pre></td></tr></table></figure>
<h1 id="带参数的信号与槽函数的绑定"><a href="#带参数的信号与槽函数的绑定" class="headerlink" title="带参数的信号与槽函数的绑定"></a>带参数的信号与槽函数的绑定</h1><p>qt5中的用法：<a href="https://www.devbean.net/2012/09/qt-study-road-2-deep-qt5-signals-slots-syntax/" target="_blank" rel="noopener">https://www.devbean.net/2012/09/qt-study-road-2-deep-qt5-signals-slots-syntax/</a></p>
<h2 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(&amp;a, &amp;Counter::valueChanged,</span><br><span class="line">                 &amp;b, &amp;Counter::setValue);</span><br></pre></td></tr></table></figure>
<h2 id="有重载的信号"><a href="#有重载的信号" class="headerlink" title="有重载的信号"></a>有重载的信号</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">void</span> (Newspaper:: *newPaperNameDate)(<span class="keyword">const</span> QString &amp;, <span class="keyword">const</span> QDate &amp;) = &amp;Newspaper::newPaper;</span><br><span class="line">QObject::<span class="built_in">connect</span>(&amp;newspaper, newPaperNameDate,</span><br><span class="line">                 &amp;reader,    &amp;Reader::receiveNewspaper);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 不推荐</span></span><br><span class="line"><span class="comment">// 使用的是 C 风格的强制类型转换。此时，如果你改变了信号的类型，那么你就会有一个潜在的运行时错误。例如，如果我们把(const QString &amp;, const QDate &amp;)两个参数修改成(const QDate &amp;, const QString &amp;)，C 风格的强制类型转换就会失败，并且这个错误只能在运行时发现。</span></span><br><span class="line">QObject::<span class="built_in">connect</span>(&amp;newspaper,</span><br><span class="line">                 (<span class="keyword">void</span> (Newspaper:: *)(<span class="keyword">const</span> QString &amp;, <span class="keyword">const</span> QDate &amp;))&amp;Newspaper::newPaper,</span><br><span class="line">                 &amp;reader,</span><br><span class="line">                 &amp;Reader::receiveNewspaper);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3  C++ 推荐的风格，当参数类型改变时，编译器会检测到这个错误。</span></span><br><span class="line">QObject::<span class="built_in">connect</span>(&amp;newspaper,</span><br><span class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (Newspaper:: *)(<span class="keyword">const</span> QString &amp;, <span class="keyword">const</span> QDate &amp;)&gt;(&amp;Newspaper::newPaper),</span><br><span class="line">                 &amp;reader,</span><br><span class="line">                 &amp;Reader::receiveNewspaper);</span><br></pre></td></tr></table></figure>
<h2 id="参数个数不一致"><a href="#参数个数不一致" class="headerlink" title="参数个数不一致"></a>参数个数不一致</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(&amp;newspaper, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (Newspaper:: *)</span><br><span class="line">(<span class="keyword">const</span> QString &amp;)&gt;(&amp;Newspaper::newPaper),</span><br><span class="line">[=](<span class="keyword">const</span> QString &amp;name) </span><br><span class="line">&#123; <span class="comment">/* Your code here. */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h1><p><a href="https://www.devbean.net/2013/05/qt-study-road-2-dnd/" target="_blank" rel="noopener">https://www.devbean.net/2013/05/qt-study-road-2-dnd/</a><br><a href="https://www.devbean.net/2013/05/qt-study-road-2-dnd-data/" target="_blank" rel="noopener">https://www.devbean.net/2013/05/qt-study-road-2-dnd-data/</a><br><a href="https://openhome.cc/Gossip/Qt4Gossip/DragExecAccept.html" target="_blank" rel="noopener">https://openhome.cc/Gossip/Qt4Gossip/DragExecAccept.html</a></p>
<p>drag方需要重写：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dragMoveEvent</span><span class="params">(QDragMoveEvent *e)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> override</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> CustomListWidget::mousePressEvent(QMouseEvent *event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;button() == Qt::LeftButton) &#123;</span><br><span class="line">        startPoint = event-&gt;pos();</span><br><span class="line">    &#125;</span><br><span class="line">    QListWidget::mousePressEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CustomListWidget::mouseMoveEvent(QMouseEvent *event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;buttons() &amp; Qt::LeftButton) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((event-&gt;pos() - startPoint).manhattanLength() &gt;= QApplication::startDragDistance()) &#123;</span><br><span class="line">            performDrag();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QListWidget::mouseMoveEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CustomListWidget::performDrag() &#123;</span><br><span class="line">    QListWidgetItem *item = currentItem();</span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="keyword">auto</span> mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">        mimeData-&gt;setText(item-&gt;<span class="built_in">text</span>());</span><br><span class="line">        mimeData-&gt;setImageData(item-&gt;icon());</span><br><span class="line">        <span class="keyword">auto</span> drag = <span class="keyword">new</span> QDrag(<span class="keyword">this</span>);</span><br><span class="line">        drag-&gt;setMimeData(mimeData);</span><br><span class="line">        drag-&gt;setPixmap(item-&gt;icon().pixmap(QSize(<span class="number">22</span>, <span class="number">22</span>)));</span><br><span class="line">        drag-&gt;exec(Qt::CopyAction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CustomListWidget::dragMoveEvent(QDragMoveEvent *e) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>drop方需要重写：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dragEnterEvent</span><span class="params">(QDragEnterEvent *e)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dragMoveEvent</span><span class="params">(QDragMoveEvent *e)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dropEvent</span><span class="params">(QDropEvent *e)</span> override</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> CustomTreeWidget::dropEvent(QDropEvent *e) &#123;</span><br><span class="line">    qDebug() &lt;&lt; e-&gt;type();</span><br><span class="line">    qDebug() &lt;&lt; e-&gt;source();</span><br><span class="line">    qDebug() &lt;&lt; e-&gt;mimeData()-&gt;<span class="built_in">text</span>();</span><br><span class="line">    qDebug() &lt;&lt; e-&gt;mimeData()-&gt;imageData();</span><br><span class="line">    qDebug() &lt;&lt; e-&gt;source()-&gt;objectName();</span><br><span class="line"><span class="comment">//    CustomListWidget *source = qobject_cast&lt;CustomListWidget *&gt;(e-&gt;source());</span></span><br><span class="line">    QIcon icon = e-&gt;mimeData()-&gt;imageData().value&lt;QIcon&gt;();</span><br><span class="line">    QString <span class="built_in">text</span> = e-&gt;mimeData()-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">auto</span> item = <span class="keyword">new</span> QTreeWidgetItem();</span><br><span class="line">    item-&gt;setIcon(<span class="number">0</span>, icon);</span><br><span class="line">    item-&gt;setText(<span class="number">1</span>, <span class="built_in">text</span>);</span><br><span class="line">    addTopLevelItem(item);</span><br><span class="line">    e-&gt;accept();</span><br><span class="line">    QTreeWidget::dropEvent(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CustomTreeWidget::dragEnterEvent(QDragEnterEvent *e) &#123;</span><br><span class="line">    e-&gt;setDropAction(Qt::CopyAction);</span><br><span class="line">    e-&gt;accept();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CustomTreeWidget::dragMoveEvent(QDragMoveEvent *event) &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>RAII机制</title>
    <url>/2020/08/02/RAII%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><a id="more"></a>
<p>RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。</p>
<h2 id="为什么要使用RAII？"><a href="#为什么要使用RAII？" class="headerlink" title="为什么要使用RAII？"></a>为什么要使用RAII？</h2><p>上面说到RAII是用来管理资源、避免资源泄漏的方法。那么，用了这么久了，也写了这么多程序了，口头上经常会说资源，那么资源是如何定义的？在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤：<br>1 申请资源；<br>2 使用资源；<br>3 释放资源。<br>第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Retinanet目标检测算法</title>
    <url>/2020/02/23/Retinanet%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Retinanet目标检测算法"><a href="#Retinanet目标检测算法" class="headerlink" title="Retinanet目标检测算法"></a>Retinanet目标检测算法</h1><a id="more"></a>
<p><img src="1.png" alt=""><br>Retinanet是在何凯明大神提出Focal loss同时提出的一种新的目标检测方案，来验证Focal Loss的有效性。</p>
<p>One-Stage目标检测方法常常使用先验框提高预测性能，一张图像可能生成成千上万的候选框，但是其中只有很少一部分是包含目标的的，有目标的就是正样本，没有目标的就是负样本。这种情况造成了One-Stage目标检测方法的正负样本不平衡，也使得One-Stage目标检测方法的检测效果比不上Two-Stage目标检测方法。</p>
<p>Focal Loss是一种新的用于平衡One-Stage目标检测方法正负样本的Loss方案。</p>
<p>Retinane的结构非常简单，但是其存在非常多的先验框，以输入600x600x3的图片为例，就存在着67995个先验框，这些先验框里面大多包含的是背景，存在非常多的负样本。以Focal Loss训练的Retinanet可以有效的平衡正负样本，实现有效的训练。<br><img src="2.png" alt=""></p>
<p>ResNet50有两个基本的块，分别名为Conv Block和Identity Block，其中Conv Block输入和输出的维度是不一样的，所以不能连续串联，它的作用是改变网络的维度；Identity Block输入维度和输出维度相同，可以串联，用于加深网络的。<br>Conv Block的结构如下：<br><img src="3.png" alt=""><br>Identity Block的结构如下：<br><img src="4.png" alt=""><br>通过图像金字塔我们可以获得五个有效的特征层，分别是P3、P4、P5、P6、P7，<br>为了和普通特征层区分，我们称之为有效特征层，将这五个有效的特征层传输过class+box subnets就可以获得预测结果了。</p>
<p>class subnet采用4次256通道的卷积和1次num_priors x num_classes通道的卷积，num_priors指的是该特征层所拥有的先验框数量，num_classes指的是网络一共对多少类的目标进行检测。</p>
<p>box subnet采用4次256通道的卷积和1次num_priors x 4通道的卷积，num_priors指的是该特征层所拥有的先验框数量，4指的是先验框的调整情况。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL经典案例（50题）</title>
    <url>/2020/04/18/SQL%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%EF%BC%8850%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<p>表结构<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student(Sid,Sname,Sage,Ssex)学生表</span><br><span class="line">sid：学号</span><br><span class="line">sname：学生姓名</span><br><span class="line">sbirth：学生年龄</span><br><span class="line">ssex：学生性别</span><br><span class="line"></span><br><span class="line">Course(Cid,Cname,T#)课程表</span><br><span class="line">cid：课程编号</span><br><span class="line">cname：课程名称</span><br><span class="line">tid：教师编号</span><br><span class="line"></span><br><span class="line">Score(Sid,Cid,score)成绩表</span><br><span class="line">sid：学号</span><br><span class="line">cid：课程编号</span><br><span class="line">score：成绩</span><br><span class="line"></span><br><span class="line">Teacher(Tid,Tname)教师表</span><br><span class="line">tid：教师编号：</span><br><span class="line">tname：教师名字</span><br></pre></td></tr></table></figure></p>
<p>数据<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Student`</span>(</span><br><span class="line"><span class="string">`sid`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="string">`sname`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line"><span class="string">`sbirth`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line"><span class="string">`ssex`</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`s_id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Course`</span>(</span><br><span class="line"><span class="string">`cid`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="string">`cname`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line"><span class="string">`tid`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`c_id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Teacher`</span>(</span><br><span class="line"><span class="string">`tid`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="string">`tname`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`t_id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Score`</span>(</span><br><span class="line"><span class="string">`sid`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="string">`cid`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="string">`score`</span> <span class="built_in">INT</span>(<span class="number">3</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`s_id`</span>,<span class="string">`c_id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'赵雷'</span> , <span class="string">'1990-01-01'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'钱电'</span> , <span class="string">'1990-12-21'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'孙风'</span> , <span class="string">'1990-05-20'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'李云'</span> , <span class="string">'1990-08-06'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'05'</span> , <span class="string">'周梅'</span> , <span class="string">'1991-12-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'06'</span> , <span class="string">'吴兰'</span> , <span class="string">'1992-03-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'07'</span> , <span class="string">'郑竹'</span> , <span class="string">'1989-07-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'08'</span> , <span class="string">'王菊'</span> , <span class="string">'1990-01-20'</span> , <span class="string">'女'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'语文'</span> , <span class="string">'02'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'数学'</span> , <span class="string">'01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'英语'</span> , <span class="string">'03'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'李四'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'王五'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'01'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'02'</span> , <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'03'</span> , <span class="number">99</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'01'</span> , <span class="number">70</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'02'</span> , <span class="number">60</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'03'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'01'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'02'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'03'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'01'</span> , <span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'02'</span> , <span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'03'</span> , <span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'05'</span> , <span class="string">'01'</span> , <span class="number">76</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'05'</span> , <span class="string">'02'</span> , <span class="number">87</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'06'</span> , <span class="string">'01'</span> , <span class="number">31</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'06'</span> , <span class="string">'03'</span> , <span class="number">34</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'07'</span> , <span class="string">'02'</span> , <span class="number">89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'07'</span> , <span class="string">'03'</span> , <span class="number">98</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="1、查询“001”课程比“002”课程成绩高的所有学生的学号"><a href="#1、查询“001”课程比“002”课程成绩高的所有学生的学号" class="headerlink" title="1、查询“001”课程比“002”课程成绩高的所有学生的学号"></a>1、查询“001”课程比“002”课程成绩高的所有学生的学号</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询“001”课程比“002”课程成绩高的所有学生的学号</span></span><br><span class="line"><span class="keyword">SELECT</span> a.sid,a.score,b.score <span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">sid</span>,score <span class="keyword">FROM</span> Score <span class="keyword">WHERE</span> cid=<span class="string">'01'</span>) <span class="keyword">as</span> a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">sid</span>,score <span class="keyword">FROM</span> Score <span class="keyword">WHERE</span> cid=<span class="string">'02'</span>) <span class="keyword">as</span> b <span class="keyword">on</span> a.sid=b.sid</span><br><span class="line"> <span class="keyword">WHERE</span> a.score&gt;b.score;</span><br></pre></td></tr></table></figure>
<h1 id="2、查询平均成绩大于60分的同学的学号和平均成绩"><a href="#2、查询平均成绩大于60分的同学的学号和平均成绩" class="headerlink" title="2、查询平均成绩大于60分的同学的学号和平均成绩"></a>2、查询平均成绩大于60分的同学的学号和平均成绩</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>,<span class="keyword">avg</span>(score) <span class="keyword">as</span> avgs</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">HAVING</span> avgs&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>
<h1 id="3、查询所有同学的学号、姓名、选课数、总成绩"><a href="#3、查询所有同学的学号、姓名、选课数、总成绩" class="headerlink" title="3、查询所有同学的学号、姓名、选课数、总成绩"></a>3、查询所有同学的学号、姓名、选课数、总成绩</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid,s.sname,sc.count_class,sc.sum_score</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">sid</span>,<span class="keyword">count</span>(cid) <span class="keyword">as</span> count_class,<span class="keyword">sum</span>(score) <span class="keyword">as</span> sum_score <span class="keyword">FROM</span> Score <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span>) <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">on</span> s.sid=sc.sid</span><br></pre></td></tr></table></figure>
<h1 id="4、查询姓‘李’的老师的个数："><a href="#4、查询姓‘李’的老师的个数：" class="headerlink" title="4、查询姓‘李’的老师的个数："></a>4、查询姓‘李’的老师的个数：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> Teacher</span><br><span class="line"><span class="keyword">WHERE</span> tname <span class="keyword">LIKE</span> <span class="string">"李%"</span></span><br></pre></td></tr></table></figure>
<h1 id="5、查询没有学过“叶平”老师可的同学的学号、姓名："><a href="#5、查询没有学过“叶平”老师可的同学的学号、姓名：" class="headerlink" title="5、查询没有学过“叶平”老师可的同学的学号、姓名："></a>5、查询没有学过“叶平”老师可的同学的学号、姓名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid,s.sname</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">IN</span></span><br><span class="line">		(<span class="keyword">SELECT</span> cid <span class="keyword">FROM</span> Course <span class="keyword">as</span> c</span><br><span class="line">		<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Teacher <span class="keyword">as</span> t</span><br><span class="line">		<span class="keyword">ON</span> t.tid=c.tid</span><br><span class="line">		<span class="keyword">WHERE</span> t.tname=<span class="string">'叶平'</span>))</span><br></pre></td></tr></table></figure>
<h1 id="6、查询学过“叶平”老师所教的所有课的同学的学号、姓名："><a href="#6、查询学过“叶平”老师所教的所有课的同学的学号、姓名：" class="headerlink" title="6、查询学过“叶平”老师所教的所有课的同学的学号、姓名："></a>6、查询学过“叶平”老师所教的所有课的同学的学号、姓名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid,s.sname</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">WHERE</span> s.sid <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Course <span class="keyword">as</span> c <span class="keyword">on</span> sc.cid=c.cid</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Teacher <span class="keyword">as</span> t <span class="keyword">on</span> c.tid=t.tid</span><br><span class="line"><span class="keyword">WHERE</span> t.tname=<span class="string">'叶平'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(sc.cid)=(<span class="keyword">SELECT</span> <span class="keyword">count</span>(cc.cid) <span class="keyword">FROM</span> Teacher <span class="keyword">as</span> tt,Course <span class="keyword">as</span> cc <span class="keyword">WHERE</span> tt.tid=cc.cid <span class="keyword">and</span> tt.tname=<span class="string">'叶平'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="7、查询学过“011”并且也学过编号“002”课程的同学的学号、姓名："><a href="#7、查询学过“011”并且也学过编号“002”课程的同学的学号、姓名：" class="headerlink" title="7、查询学过“011”并且也学过编号“002”课程的同学的学号、姓名："></a>7、查询学过“011”并且也学过编号“002”课程的同学的学号、姓名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>,sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> Score <span class="keyword">WHERE</span> cid=<span class="string">'01'</span>)</span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">sid</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> Score <span class="keyword">WHERE</span> cid=<span class="string">'01'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名："><a href="#8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名：" class="headerlink" title="8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名："></a>8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid,s.sname</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">WHERE</span> s.sid <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> t1.sid <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> cid=<span class="string">'02'</span>) <span class="keyword">as</span> t2,</span><br><span class="line">(<span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> cid=<span class="string">'01'</span>) <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> t1.sid=t2.sid <span class="keyword">AND</span> t1.score&gt;t2.score)</span><br></pre></td></tr></table></figure>
<h1 id="9、查询所有课程成绩小于60的同学的学号、姓名："><a href="#9、查询所有课程成绩小于60的同学的学号、姓名：" class="headerlink" title="9、查询所有课程成绩小于60的同学的学号、姓名："></a>9、查询所有课程成绩小于60的同学的学号、姓名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">60</span>&gt; <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> score <span class="keyword">FROM</span> Score <span class="keyword">as</span> sc2 <span class="keyword">WHERE</span> sc.sid=sc2.sid))</span><br></pre></td></tr></table></figure>
<h1 id="10、查询没有学全所有课的学生的学号、姓名"><a href="#10、查询没有学全所有课的学生的学号、姓名" class="headerlink" title="10、查询没有学全所有课的学生的学号、姓名"></a>10、查询没有学全所有课的学生的学号、姓名</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(cid)=(<span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> Course))</span><br></pre></td></tr></table></figure>
<h1 id="11、查询至少有一门课与学号为“1001”同学所学相同的同学的学号和姓名："><a href="#11、查询至少有一门课与学号为“1001”同学所学相同的同学的学号和姓名：" class="headerlink" title="11、查询至少有一门课与学号为“1001”同学所学相同的同学的学号和姓名："></a>11、查询至少有一门课与学号为“1001”同学所学相同的同学的学号和姓名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sc.sid</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">WHERE</span> sc.cid <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span>=<span class="string">'01'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="12、查询和“01”号同学所学课程完全相同的其他同学的学号"><a href="#12、查询和“01”号同学所学课程完全相同的其他同学的学号" class="headerlink" title="12、查询和“01”号同学所学课程完全相同的其他同学的学号"></a>12、查询和“01”号同学所学课程完全相同的其他同学的学号</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">in</span> (<span class="keyword">SELECT</span> sc.cid <span class="keyword">FROM</span> Score <span class="keyword">as</span> sc <span class="keyword">WHERE</span> sc.sid=<span class="string">'01'</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(cid)=(<span class="keyword">SELECT</span> <span class="keyword">count</span>(sc2.cid) <span class="keyword">FROM</span> Score <span class="keyword">as</span> sc2 <span class="keyword">WHERE</span> sc2.sid=<span class="string">'01'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sc2.sid)</span><br></pre></td></tr></table></figure>
<h1 id="13、把“SCORE”表中“张三”老师教的课的成绩都更改为此课程的平均成绩"><a href="#13、把“SCORE”表中“张三”老师教的课的成绩都更改为此课程的平均成绩" class="headerlink" title="13、把“SCORE”表中“张三”老师教的课的成绩都更改为此课程的平均成绩"></a>13、把“SCORE”表中“张三”老师教的课的成绩都更改为此课程的平均成绩</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误，更新出现在子查询中</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">SET</span> score=(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(b.score) <span class="keyword">FROM</span> Score <span class="keyword">as</span> b <span class="keyword">WHERE</span> sc.cid=b.cid <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.cid)</span><br><span class="line"><span class="keyword">WHERE</span> sc.cid <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> Teacher <span class="keyword">as</span> t,Course <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">WHERE</span> t.tname=<span class="string">'张三'</span> <span class="keyword">and</span> t.tid=c.tid);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>
<h1 id="14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名："><a href="#14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名：" class="headerlink" title="14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名："></a>14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">WHERE</span> sc.cid <span class="keyword">in</span> (<span class="keyword">SELECT</span> cid</span><br><span class="line">		<span class="keyword">FROM</span> Score <span class="keyword">AS</span> sc</span><br><span class="line">		<span class="keyword">WHERE</span> sc.sid=<span class="string">'02'</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(sc.cid)=(<span class="keyword">SELECT</span> <span class="keyword">count</span>(cid)</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">AS</span> sc</span><br><span class="line"><span class="keyword">WHERE</span> sc.sid=<span class="string">'02'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="15、删除学习“张三”老师课的SC表记录"><a href="#15、删除学习“张三”老师课的SC表记录" class="headerlink" title="15、删除学习“张三”老师课的SC表记录"></a>15、删除学习“张三”老师课的SC表记录</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Teacher <span class="keyword">as</span> t <span class="keyword">on</span> c.tid=t.tid</span><br><span class="line"><span class="keyword">WHERE</span> t.tname=<span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Score;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>
<h1 id="16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、002号课的平均成绩："><a href="#16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、002号课的平均成绩：" class="headerlink" title="16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、002号课的平均成绩："></a>16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、002号课的平均成绩：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> Score</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>,<span class="string">'02'</span>,(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sc2.score) <span class="keyword">FROM</span> Score <span class="keyword">as</span> sc2 <span class="keyword">WHERE</span> sc2.cid=<span class="string">'02'</span>)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> Score <span class="keyword">WHERE</span> cid=<span class="string">'03'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>
<h1 id="17、按平均成绩从高到低显示所有学生的“语文”（c-id-’01’）、“数学”（c-id-’02’）、“英语”（c-id-’03’）三门课程成绩-按如下形式显示：学生ID，语文，数学，英语，有效课程数，有效平均分"><a href="#17、按平均成绩从高到低显示所有学生的“语文”（c-id-’01’）、“数学”（c-id-’02’）、“英语”（c-id-’03’）三门课程成绩-按如下形式显示：学生ID，语文，数学，英语，有效课程数，有效平均分" class="headerlink" title="17、按平均成绩从高到低显示所有学生的“语文”（c_id=’01’）、“数学”（c_id=’02’）、“英语”（c_id=’03’）三门课程成绩,按如下形式显示：学生ID，语文，数学，英语，有效课程数，有效平均分"></a>17、按平均成绩从高到低显示所有学生的“语文”（c_id=’01’）、“数学”（c_id=’02’）、“英语”（c_id=’03’）三门课程成绩,按如下形式显示：学生ID，语文，数学，英语，有效课程数，有效平均分</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sc2.sid,</span><br><span class="line">(<span class="keyword">SELECT</span> score <span class="keyword">FROM</span> Score <span class="keyword">as</span> sc <span class="keyword">WHERE</span> sc.cid=<span class="string">'02'</span> <span class="keyword">and</span> sc.sid=sc2.sid) <span class="keyword">as</span> <span class="string">'课程'</span>,</span><br><span class="line"><span class="keyword">count</span>(*),</span><br><span class="line"><span class="keyword">AVG</span>(sc2.score)</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc2</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(sc2.score)</span><br></pre></td></tr></table></figure>
<h1 id="18、查询各科成绩最高和最低的分：以如下的形式显示：课程ID，最高分，最低分"><a href="#18、查询各科成绩最高和最低的分：以如下的形式显示：课程ID，最高分，最低分" class="headerlink" title="18、查询各科成绩最高和最低的分：以如下的形式显示：课程ID，最高分，最低分"></a>18、查询各科成绩最高和最低的分：以如下的形式显示：课程ID，最高分，最低分</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(score) <span class="keyword">FROM</span> Score <span class="keyword">as</span> sc <span class="keyword">WHERE</span> sc.cid=c.cid) <span class="keyword">as</span> 最高分,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(score) <span class="keyword">FROM</span> Score <span class="keyword">as</span> sc <span class="keyword">WHERE</span> sc.cid=c.cid) <span class="keyword">as</span> 最低分</span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">as</span> c</span><br></pre></td></tr></table></figure>
<h1 id="19、按各科平均成绩从低到高和及格率的百分数从高到低顺序："><a href="#19、按各科平均成绩从低到高和及格率的百分数从高到低顺序：" class="headerlink" title="19、按各科平均成绩从低到高和及格率的百分数从高到低顺序："></a>19、按各科平均成绩从低到高和及格率的百分数从高到低顺序：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid,</span><br><span class="line"><span class="keyword">MAX</span>(score) <span class="keyword">as</span> 最高分,</span><br><span class="line"><span class="keyword">MIN</span>(score) <span class="keyword">as</span> 最低分</span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid</span><br></pre></td></tr></table></figure>
<h1 id="20、查询如下课程平均成绩和及格率的百分数-用”1行”显示-企业管理（001），马克思（002），OO-amp-UML-（003），数据库（004）："><a href="#20、查询如下课程平均成绩和及格率的百分数-用”1行”显示-企业管理（001），马克思（002），OO-amp-UML-（003），数据库（004）：" class="headerlink" title="20、查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）："></a>20、查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sc.cid <span class="keyword">as</span> 课程号,c.cname <span class="keyword">as</span> 课程名,<span class="keyword">AVG</span>(sc.score) <span class="keyword">as</span> 平均成绩, </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">sid</span>) <span class="keyword">FROM</span> Score <span class="keyword">as</span> sc2 <span class="keyword">WHERE</span> sc.cid=sc2.cid <span class="keyword">and</span> sc2.score&gt;<span class="number">60</span>)/<span class="keyword">count</span>(<span class="keyword">sid</span>) <span class="keyword">as</span> 及格率</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Course <span class="keyword">as</span> c <span class="keyword">ON</span> sc.cid=c.cid</span><br><span class="line"><span class="keyword">WHERE</span> sc.cid <span class="keyword">in</span> (<span class="string">'01'</span>,<span class="string">'02'</span>,<span class="string">'03'</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.cid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 平均成绩,及格率 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h1 id="21、查询不同老师所教不同课程平均分从高到低显示："><a href="#21、查询不同老师所教不同课程平均分从高到低显示：" class="headerlink" title="21、查询不同老师所教不同课程平均分从高到低显示："></a>21、查询不同老师所教不同课程平均分从高到低显示：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sc.cid,t.tname,c.cname,<span class="keyword">avg</span>(sc.score)</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Course <span class="keyword">as</span> c <span class="keyword">on</span> sc.cid=c.cid</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Teacher <span class="keyword">as</span> t <span class="keyword">on</span> c.tid=t.tid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">avg</span>(sc.score) <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<h1 id="22、查询如下课程成绩第3名到第6名的学生成绩单：企业管理-001-，马克思-002-，UML-003-，数据库-004-："><a href="#22、查询如下课程成绩第3名到第6名的学生成绩单：企业管理-001-，马克思-002-，UML-003-，数据库-004-：" class="headerlink" title="22、查询如下课程成绩第3名到第6名的学生成绩单：企业管理(001)，马克思(002)，UML(003)，数据库(004)："></a>22、查询如下课程成绩第3名到第6名的学生成绩单：企业管理(001)，马克思(002)，UML(003)，数据库(004)：</h1><h1 id="23、统计下列各科成绩，各分数段人数：课程ID，课程名称，-100-85-85-70-70-60-小于60-："><a href="#23、统计下列各科成绩，各分数段人数：课程ID，课程名称，-100-85-85-70-70-60-小于60-：" class="headerlink" title="23、统计下列各科成绩，各分数段人数：课程ID，课程名称，[100-85],[85-70],[70-60],[ 小于60] ："></a>23、统计下列各科成绩，各分数段人数：课程ID，课程名称，[100-85],[85-70],[70-60],[ 小于60] ：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sc.cid,c.cname,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.score&gt;<span class="number">85</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'100-85'</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.score&gt;<span class="number">70</span> <span class="keyword">and</span> sc.score&lt;=<span class="number">85</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'85-70'</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.score&gt;<span class="number">60</span> <span class="keyword">and</span> sc.score&lt;=<span class="number">70</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'70-60'</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.score&lt;<span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> <span class="string">'&lt;60'</span></span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Course <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">ON</span> sc.cid=c.cid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.cid</span><br></pre></td></tr></table></figure>
<h1 id="24、查询学生平均成绩及其名次："><a href="#24、查询学生平均成绩及其名次：" class="headerlink" title="24、查询学生平均成绩及其名次："></a>24、查询学生平均成绩及其名次：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="number">1</span>+<span class="keyword">count</span>(<span class="keyword">DISTINCT</span> avgs)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> sc.sid,<span class="keyword">AVG</span>(sc.score) <span class="keyword">as</span> avgs</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span>) <span class="keyword">as</span> T1</span><br><span class="line"><span class="keyword">WHERE</span> T1.avgs&gt;T2.avgs) <span class="keyword">as</span> 名次</span><br><span class="line">,T2.sid,T2.avgs</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">sid</span>,<span class="keyword">avg</span>(score) <span class="keyword">as</span> avgs</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span>) <span class="keyword">as</span> T2</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avgs <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<h1 id="25、查询各科成绩前三名的记录（不考虑成绩并列情况）："><a href="#25、查询各科成绩前三名的记录（不考虑成绩并列情况）：" class="headerlink" title="25、查询各科成绩前三名的记录（不考虑成绩并列情况）："></a>25、查询各科成绩前三名的记录（不考虑成绩并列情况）：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.cid=b.cid <span class="keyword">and</span> b.score&gt;a.score)&lt;<span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cid,score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<h1 id="26、查询每门课程被选修的学生数："><a href="#26、查询每门课程被选修的学生数：" class="headerlink" title="26、查询每门课程被选修的学生数："></a>26、查询每门课程被选修的学生数：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid,<span class="keyword">count</span>(<span class="keyword">sid</span>)</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid</span><br></pre></td></tr></table></figure>
<h1 id="27、查询出只选修一门课程的全部学生的学号和姓名："><a href="#27、查询出只选修一门课程的全部学生的学号和姓名：" class="headerlink" title="27、查询出只选修一门课程的全部学生的学号和姓名："></a>27、查询出只选修一门课程的全部学生的学号和姓名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> s.sid,s.sname,<span class="keyword">count</span>(sc.cid)</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Score <span class="keyword">as</span> sc <span class="keyword">ON</span> s.sid=sc.sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s.sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(sc.cid)=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="28、查询男生、女生人数："><a href="#28、查询男生、女生人数：" class="headerlink" title="28、查询男生、女生人数："></a>28、查询男生、女生人数：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">WHEN</span> s.ssex=<span class="string">'男'</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> 男,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">WHEN</span> s.ssex=<span class="string">'女'</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">as</span> 女</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br></pre></td></tr></table></figure>
<h1 id="29、查询姓“张”的学生名单："><a href="#29、查询姓“张”的学生名单：" class="headerlink" title="29、查询姓“张”的学生名单："></a>29、查询姓“张”的学生名单：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> sname <span class="keyword">like</span> <span class="string">'张%'</span></span><br></pre></td></tr></table></figure>
<h1 id="30、查询同名同姓的学生名单，并统计同名人数："><a href="#30、查询同名同姓的学生名单，并统计同名人数：" class="headerlink" title="30、查询同名同姓的学生名单，并统计同名人数："></a>30、查询同名同姓的学生名单，并统计同名人数：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> a.sname,<span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> a,Student <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.sid&lt;&gt;b.sid <span class="keyword">and</span> a.sname=b.sname</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> a.sname</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> sname,<span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sname</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="31、1981年出生的学生名单（注：student表中sage列的类型是datetime）"><a href="#31、1981年出生的学生名单（注：student表中sage列的类型是datetime）" class="headerlink" title="31、1981年出生的学生名单（注：student表中sage列的类型是datetime）:"></a>31、1981年出生的学生名单（注：student表中sage列的类型是datetime）:</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(s.sbirth)=<span class="string">'1990'</span></span><br></pre></td></tr></table></figure>
<h1 id="32、查询平均成绩大于85的所有学生的学号、姓名和平均成绩："><a href="#32、查询平均成绩大于85的所有学生的学号、姓名和平均成绩：" class="headerlink" title="32、查询平均成绩大于85的所有学生的学号、姓名和平均成绩："></a>32、查询平均成绩大于85的所有学生的学号、姓名和平均成绩：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sc.sid,s.sname,<span class="keyword">AVG</span>(sc.score)</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Student <span class="keyword">as</span> s <span class="keyword">on</span> s.sid=sc.sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(sc.score)&gt;<span class="number">85</span></span><br></pre></td></tr></table></figure>
<h1 id="33、查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列："><a href="#33、查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列：" class="headerlink" title="33、查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列："></a>33、查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid,<span class="keyword">AVG</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(score),cid <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h1 id="34、查询课程名称为“数据库”，且分数低于60的学生名字和分数："><a href="#34、查询课程名称为“数据库”，且分数低于60的学生名字和分数：" class="headerlink" title="34、查询课程名称为“数据库”，且分数低于60的学生名字和分数："></a>34、查询课程名称为“数据库”，且分数低于60的学生名字和分数：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sname,sc.score</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Course <span class="keyword">as</span> c <span class="keyword">on</span> sc.cid=c.cid</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Student <span class="keyword">as</span> s <span class="keyword">on</span> s.sid=sc.sid</span><br><span class="line"><span class="keyword">WHERE</span> c.cname=<span class="string">'数据库'</span> <span class="keyword">AND</span> sc.score&lt;<span class="number">60</span></span><br></pre></td></tr></table></figure>
<h1 id="35、查询所有学生的选课情况："><a href="#35、查询所有学生的选课情况：" class="headerlink" title="35、查询所有学生的选课情况："></a>35、查询所有学生的选课情况：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sname,sc.sid,c.cid</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Course <span class="keyword">as</span> c <span class="keyword">ON</span> sc.cid=c.cid</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student <span class="keyword">as</span> s <span class="keyword">ON</span> sc.sid=s.sid</span><br></pre></td></tr></table></figure>
<h1 id="36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数："><a href="#36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数：" class="headerlink" title="36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数："></a>36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> s.sname,sc.score,c.cname</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Score <span class="keyword">as</span> sc <span class="keyword">ON</span> s.sid=sc.sid</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Course <span class="keyword">as</span> c <span class="keyword">ON</span> sc.cid=c.cid</span><br><span class="line"><span class="keyword">WHERE</span> sc.score&gt;<span class="number">70</span></span><br></pre></td></tr></table></figure>
<h1 id="37、查询不及格的课程，并按课程号从大到小的排列："><a href="#37、查询不及格的课程，并按课程号从大到小的排列：" class="headerlink" title="37、查询不及格的课程，并按课程号从大到小的排列："></a>37、查询不及格的课程，并按课程号从大到小的排列：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> score&lt;<span class="number">60</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cid</span><br></pre></td></tr></table></figure>
<h1 id="38、查询课程编号为“003”且课程成绩在80分以上的学生的学号和姓名："><a href="#38、查询课程编号为“003”且课程成绩在80分以上的学生的学号和姓名：" class="headerlink" title="38、查询课程编号为“003”且课程成绩在80分以上的学生的学号和姓名："></a>38、查询课程编号为“003”且课程成绩在80分以上的学生的学号和姓名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid,s.sname</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">WHERE</span> s.sid <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> cid=<span class="string">'03'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="39、求选了课程的学生人数："><a href="#39、求选了课程的学生人数：" class="headerlink" title="39、求选了课程的学生人数："></a>39、求选了课程的学生人数：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT sid) </span><br><span class="line">FROM Score</span><br></pre></td></tr></table></figure>
<h1 id="41、查询各个课程及相应的选修人数："><a href="#41、查询各个课程及相应的选修人数：" class="headerlink" title="41、查询各个课程及相应的选修人数："></a>41、查询各个课程及相应的选修人数：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid,<span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid;</span><br></pre></td></tr></table></figure>
<h1 id="42、查询不同课程成绩相同的学生和学号、课程号、学生成绩："><a href="#42、查询不同课程成绩相同的学生和学号、课程号、学生成绩：" class="headerlink" title="42、查询不同课程成绩相同的学生和学号、课程号、学生成绩："></a>42、查询不同课程成绩相同的学生和学号、课程号、学生成绩：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">DISTINCT</span> a.sid,a.cid,a.score</span><br><span class="line"><span class="keyword">from</span> Score <span class="keyword">as</span> a ,Score <span class="keyword">as</span> b </span><br><span class="line"><span class="keyword">where</span> a.score = b.score</span><br><span class="line"><span class="keyword">and</span> a.cid &lt;&gt; b.cid;</span><br></pre></td></tr></table></figure>
<h1 id="43、查询每门课程成绩最好的前两名："><a href="#43、查询每门课程成绩最好的前两名：" class="headerlink" title="43、查询每门课程成绩最好的前两名："></a>43、查询每门课程成绩最好的前两名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> Score <span class="keyword">as</span> b <span class="keyword">WHERE</span> a.cid=b.cid <span class="keyword">and</span> b.score&gt;a.score</span><br><span class="line">)&lt;<span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cid,score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<h1 id="44、统计每门课程的学生选修人数-超过10人的课程才统计-。要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序："><a href="#44、统计每门课程的学生选修人数-超过10人的课程才统计-。要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序：" class="headerlink" title="44、统计每门课程的学生选修人数(超过10人的课程才统计)。要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序："></a>44、统计每门课程的学生选修人数(超过10人的课程才统计)。要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid,<span class="keyword">count</span>(score) <span class="keyword">as</span> cs</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid</span><br><span class="line"><span class="keyword">HAVING</span> cs &gt; <span class="number">10</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cs <span class="keyword">DESC</span>,cid;</span><br></pre></td></tr></table></figure>
<h1 id="45、检索至少选修两门课程的学生学号："><a href="#45、检索至少选修两门课程的学生学号：" class="headerlink" title="45、检索至少选修两门课程的学生学号："></a>45、检索至少选修两门课程的学生学号：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(cid)&gt;=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="46、查询全部学生选修的课程和课程号和课程名："><a href="#46、查询全部学生选修的课程和课程号和课程名：" class="headerlink" title="46、查询全部学生选修的课程和课程号和课程名："></a>46、查询全部学生选修的课程和课程号和课程名：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid,cname</span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> cid <span class="keyword">IN</span>(<span class="keyword">SELECT</span> cid <span class="keyword">FROM</span> Score)</span><br></pre></td></tr></table></figure>
<h1 id="47、查询没学过”叶平”老师讲授的任一门课程的学生姓名"><a href="#47、查询没学过”叶平”老师讲授的任一门课程的学生姓名" class="headerlink" title="47、查询没学过”叶平”老师讲授的任一门课程的学生姓名"></a>47、查询没学过”叶平”老师讲授的任一门课程的学生姓名</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sname</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">WHERE</span> s.sid <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">WHERE</span> sc.cid <span class="keyword">IN</span>(</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> cid</span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Teacher <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">WHERE</span> c.tid=t.tid <span class="keyword">and</span> t.tname=<span class="string">'叶平'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="48、查询两门以上不及格课程的同学的学号以及其平均成绩："><a href="#48、查询两门以上不及格课程的同学的学号以及其平均成绩：" class="headerlink" title="48、查询两门以上不及格课程的同学的学号以及其平均成绩："></a>48、查询两门以上不及格课程的同学的学号以及其平均成绩：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>,<span class="keyword">avg</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> score&lt;<span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="keyword">sid</span>)&gt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">sid</span></span><br></pre></td></tr></table></figure>
<h1 id="49、检索“004”课程分数小于60，按分数降序排列的同学学号："><a href="#49、检索“004”课程分数小于60，按分数降序排列的同学学号：" class="headerlink" title="49、检索“004”课程分数小于60，按分数降序排列的同学学号："></a>49、检索“004”课程分数小于60，按分数降序排列的同学学号：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> cid=<span class="string">'004'</span> <span class="keyword">and</span> score&lt;<span class="number">60</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h1 id="50、删除“002”同学的“001”课程的成绩："><a href="#50、删除“002”同学的“001”课程的成绩：" class="headerlink" title="50、删除“002”同学的“001”课程的成绩："></a>50、删除“002”同学的“001”课程的成绩：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span>=<span class="string">'002'</span> <span class="keyword">and</span> cid=<span class="string">'001'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>TimeDistributed层（keras）</title>
    <url>/2020/03/11/TimeDistributed%E5%B1%82%EF%BC%88keras%EF%BC%89/</url>
    <content><![CDATA[<h1 id="tf-keras-layers-TimeDistributed"><a href="#tf-keras-layers-TimeDistributed" class="headerlink" title="tf.keras.layers.TimeDistributed"></a>tf.keras.layers.TimeDistributed</h1><a id="more"></a>
<p><strong>This wrapper allows to apply a layer to every temporal slice of an input.</strong><br>输入至少应当有3个维度，第一个维度被函数默认为是一个临时的维度。<br>考虑一个具有32个样本的样本集合，每个样品都是由10个16维的向量组成。这个batch的输入shape就应当是(32,10,16),不包括样本个数维度的输入shape是(10,16)。</p>
<p>这个时候就可以使用TimeDistributed来对10个向量每个向量添加一个Dense层。此时输出是（32,10,8）维度的。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(TimeDistributed(Dense(<span class="number">8</span>), input_shape=(<span class="number">10</span>, <span class="number">16</span>)))</span><br><span class="line"><span class="comment"># now model.output_shape == (None, 10, 8)</span></span><br></pre></td></tr></table></figure><br>对于一个子序列层，不需要输入input_shape参数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.add(TimeDistributed(Dense(<span class="number">32</span>)))</span><br><span class="line"><span class="comment"># now model.output_shape == (None, 10, 32)</span></span><br></pre></td></tr></table></figure><br>输出尺寸为(32, 10, 32).</p>
<p>同样TimeDistributed可以用于任何层,比如Conv2D layer:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(TimeDistributed(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">                          input_shape=(<span class="number">10</span>, <span class="number">299</span>, <span class="number">299</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>SSD目标检测</title>
    <url>/2020/02/22/SSD%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>CSDN：<a href="https://blog.csdn.net/weixin_44791964/article/details/104107271" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/104107271</a></p>
<h1 id="SSD目标检测算法"><a href="#SSD目标检测算法" class="headerlink" title="SSD目标检测算法"></a>SSD目标检测算法</h1><a id="more"></a>
<p>SSD是一种非常优秀的one-stage目标检测方法，one-stage算法就是目标检测和分类是同时完成的，其主要思路是利用CNN提取特征后，均匀地在图片的不同位置进行密集抽样，抽样时可以采用不同尺度和长宽比，物体分类与预测框的回归同时进行，整个过程只需要一步，所以其优势是速度快。<br>但是均匀的密集采样的一个重要缺点是训练比较困难，这主要是因为正样本与负样本（背景）极其不均衡（参见Focal Loss），导致模型准确度稍低。<br>SSD的英文全名是Single Shot MultiBox Detector，Single shot说明SSD算法属于one-stage方法，MultiBox说明SSD算法基于多框预测。</p>
<h1 id="SSD目标检测原理"><a href="#SSD目标检测原理" class="headerlink" title="SSD目标检测原理"></a>SSD目标检测原理</h1><p><img src="1.png" alt=""><br>SSD采用的主干网络是VGG网络，VGG网络相比普通的VGG网络有一定的修改，主要修改的地方就是：<br>1、将VGG16的FC6和FC7层转化为卷积层。<br>2、去掉所有的Dropout层和FC8层；<br>3、新增了Conv6、Conv7、Conv8、Conv9。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>TinyXML2的使用（转）</title>
    <url>/2020/05/13/TinyXML2%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
    <content><![CDATA[<h1 id="1-TinyXML2概述"><a href="#1-TinyXML2概述" class="headerlink" title="1.TinyXML2概述"></a>1.TinyXML2概述</h1><a id="more"></a>
<p>TinyXML2是simple、small、efficient开源的C++ XML文件解析库，可以很方便的应用到现有的项目之中。非常适合存储简单数据，配置文件，对象序列化等数据量不是很大的操作。</p>
<p>TinyXML2详细介绍与源码获取方法详见：TinyXML2官网。</p>
<h1 id="2-TinyXML1与TinyXML2对比"><a href="#2-TinyXML1与TinyXML2对比" class="headerlink" title="2. TinyXML1与TinyXML2对比"></a>2. TinyXML1与TinyXML2对比</h1><p>TinyXML1与TinyXML2这两个著名的开源XML文件解析库均出自Lee Thomason之手，向这位满怀开源精神的大家致敬。</p>
<p>TinyXML2适用于大部分的C/C++项目开发，经得住考验，是最好的选择。较TinyXML1而言，TinyXML2化繁为简，使用时只需要包含两个文件，而TinyXML1需要6个文件，一般生成静态链接库供项目的使用。TinyXML1详细介绍与源码见：TinyXML1官网。TinyXML1用法用例可以参考博文：TinyXML快速入门。</p>
<p>TinyXML2使用了与TinyXML1相似都可API，并且拥有丰富的测试案例。但TinyXML2解析器相对TinyXML1在代码上是完全重写，使其更适合于游戏开发中使用。它使用更少的内存，更快，并使用更少的内存分配。</p>
<p>TinyXML2无需STL，也放弃了对STL支持。所有字符串查询均使用C风格字符串“const char *”来表示，省去string类型对象的构造，并使代码更简单。</p>
<p>二者共同点： （1）都使用了简单易用的API。 （2）都是基于DOM（Document Object Model，文档对象模型）的解析器。 （3）都支持UTF-8编码。</p>
<p>TinyXML2的优点： （1）对大部分大部分的C/C++项目具有普适性。 （2）使用较少的内存（约TinyXML1的40%），速度变得更快。 （3）没有C++的STL的要求。 （4）更接近现代C++的特性，如使用了适当的命名空间。 （5）适当有效的处理了的空白字符（空格，TAB和回车）。</p>
<p>TinyXML1的优点： （1）可以报告分析错误的位置。 （2）提供一些C++ STL公约支持：流和字符串。 （3）拥有非常成熟和良好的调试代码库。</p>
<h1 id="3-TinyXML2的用法用例"><a href="#3-TinyXML2的用法用例" class="headerlink" title="3. TinyXML2的用法用例"></a>3. TinyXML2的用法用例</h1><p>TinyXML2的网上教程并不多见，醍醐灌顶，受益匪浅的教程更是凤毛麟角。有的也是蜻蜓点水、参差不齐的泛泛而谈。最终，所能参考的资料也就是官网的文档和示例代码，但却有点晦涩难懂。因此，本文就为了解决这个尴尬的局面，结合官网的资料和网上资源，尽量详细的列出TinyXML2的常见用法用例，不足之处，请留言补充，后续增加修改。</p>
<p>xml文件本质就是小型的数据库，换个角度来说就是，对数据库有什么操作，那么对xml文件就应能实现什么操作。一般而言，对数据库的操作包括以下几种：新建数据库和对数据库增删查改。那么对应xml文件就是新建xml文件、增加xml文件的节点，删除xml文件的指定节点，查询xml文件指定节点的值，修改xml文件中节点的值。</p>
<blockquote>
<p>使用方法：将tinyxml2.cpp和tinyxml2.h拷贝至项目目录，使用时包含#include “tinyxml2.h”和using namespace tinyxml2。</p>
</blockquote>
<p>使用场景：存储用户信息。</p>
<p>用户数据表设计如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变量名	描述	类型	长度（字节）	不为空	主键</span><br><span class="line">UserName	用户名	Vchar	3-20	Y	Y</span><br><span class="line">Password	密码	Char	32	Y	N</span><br><span class="line">Gender	性别	Int	1	N	N</span><br><span class="line">Mobile	电话	Char	11	N	N</span><br><span class="line">Email	电子邮箱	Varchar	1-50	N	N</span><br></pre></td></tr></table></figure></p>
<p>对应XML文件实现如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DBUSER</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">User</span> <span class="attr">Name</span>=<span class="string">”lvlv”</span> <span class="attr">Password</span> =<span class="string">”123456”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Gender</span>&gt;</span><span class="tag">&lt;/<span class="name">Gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Mobile</span> &gt;</span><span class="tag">&lt;/ <span class="attr">Mobile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Email</span> &gt;</span><span class="tag">&lt;/ <span class="attr">Email</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">User</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">DBUSER</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，XML由三大部分组成，分别是声明、根节点和其它节点。其中xml文件的声明包括三方面的内容：Version、Standalone和Encoding。下面将详细列出常见tinyxml2的用法。</p>
<p>注意：以下示例代码针对本人下载使用的TinyXML2，官网的TinyXML2在不断的完善和更新当中，最新的TinyXML2和本人的示例代码可能会有出入。本人使用的TinyXML2是2015.9.23从官网下载的，已上传至CSDN下载，见：TinyXML2。</p>
<h2 id="3-1创建XML文件"><a href="#3-1创建XML文件" class="headerlink" title="3.1创建XML文件"></a>3.1创建XML文件</h2><p>示例代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//function：create a xml file</span></span><br><span class="line"><span class="comment">//param：xmlPath:xml文件路径</span></span><br><span class="line"><span class="comment">//return:0,成功，非0，失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createXML</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* xmlPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* declaration =<span class="string">"&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;"</span>;</span><br><span class="line">    XMLDocument doc;</span><br><span class="line">    doc.Parse(declaration);<span class="comment">//会覆盖xml所有内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加申明可以使用如下两行</span></span><br><span class="line">    <span class="comment">//XMLDeclaration* declaration=doc.NewDeclaration();</span></span><br><span class="line">    <span class="comment">//doc.InsertFirstChild(declaration);</span></span><br><span class="line"></span><br><span class="line">    XMLElement* root=doc.NewElement(<span class="string">"DBUSER"</span>);</span><br><span class="line">    doc.InsertEndChild(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doc.SaveFile(xmlPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建结果：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DBUSER</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-2增加xml文件的节点"><a href="#3-2增加xml文件的节点" class="headerlink" title="3.2增加xml文件的节点"></a>3.2增加xml文件的节点</h2><p>示例代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    User()&#123;</span><br><span class="line">        gender=<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    User(<span class="keyword">const</span> <span class="built_in">string</span>&amp; userName, <span class="keyword">const</span> <span class="built_in">string</span>&amp; password, <span class="keyword">int</span> gender, <span class="keyword">const</span> <span class="built_in">string</span>&amp; mobile, <span class="keyword">const</span> <span class="built_in">string</span>&amp; email)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;userName=userName;</span><br><span class="line">        <span class="keyword">this</span>-&gt;password=password;</span><br><span class="line">        <span class="keyword">this</span>-&gt;gender=gender;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mobile=mobile;</span><br><span class="line">        <span class="keyword">this</span>-&gt;email=email;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> userName;</span><br><span class="line">    <span class="built_in">string</span> password;</span><br><span class="line">    <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="built_in">string</span> mobile;</span><br><span class="line">    <span class="built_in">string</span> email;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function:insert XML node</span></span><br><span class="line"><span class="comment">//param:xmlPath:xml文件路径; user:用户对象</span></span><br><span class="line"><span class="comment">//return:0:成功; 非0:失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertXMLNode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* xmlPath,<span class="keyword">const</span> User&amp; user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XMLDocument doc;</span><br><span class="line">    <span class="keyword">int</span> res=doc.LoadFile(xmlPath);</span><br><span class="line">    <span class="keyword">if</span>(res!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"load xml file failed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    XMLElement* root=doc.RootElement();</span><br><span class="line"></span><br><span class="line">    XMLElement* userNode = doc.NewElement(<span class="string">"User"</span>);</span><br><span class="line">    userNode-&gt;SetAttribute(<span class="string">"Name"</span>,user.userName.c_str());</span><br><span class="line">    userNode-&gt;SetAttribute(<span class="string">"Password "</span>,user.password.c_str());</span><br><span class="line">    root-&gt;InsertEndChild(userNode);</span><br><span class="line"></span><br><span class="line">    XMLElement* gender = doc.NewElement(<span class="string">"Gender"</span>);</span><br><span class="line">    XMLText* genderText=doc.NewText(itoa(user.gender));</span><br><span class="line">    gender-&gt;InsertEndChild(genderText);</span><br><span class="line">    userNode-&gt;InsertEndChild(gender);</span><br><span class="line"></span><br><span class="line">    XMLElement* mobile = doc.NewElement(<span class="string">"Mobile"</span>);</span><br><span class="line">    mobile-&gt;InsertEndChild(doc.NewText(user.mobile.c_str()));</span><br><span class="line">    userNode-&gt;InsertEndChild(mobile);</span><br><span class="line"></span><br><span class="line">    XMLElement* email = doc.NewElement(<span class="string">"Email"</span>);</span><br><span class="line">    email-&gt;InsertEndChild(doc.NewText(user.email.c_str()));</span><br><span class="line">    userNode-&gt;InsertEndChild(email);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doc.SaveFile(xmlPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建结果：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DBUSER</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">User</span> <span class="attr">Name</span>=<span class="string">"lvlv"</span> <span class="attr">Password</span> =<span class="string">"12346"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Gender</span>&gt;</span>1<span class="tag">&lt;/<span class="name">Gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Mobile</span>&gt;</span>15813354926<span class="tag">&lt;/<span class="name">Mobile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Email</span>&gt;</span>1589276509@qq.com<span class="tag">&lt;/<span class="name">Email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">User</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DBUSER</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-3查询xml文件的指定节点"><a href="#3-3查询xml文件的指定节点" class="headerlink" title="3.3查询xml文件的指定节点"></a>3.3查询xml文件的指定节点</h2><p>Xml文件中，一个用户节点存储一个用户的信息。因此，对用户信息的增删查改，即无论查询节点、删除节点、修改节点和增加节点，都需要获取需要操作的节点。那么先实现一个根据用户名获取节点指针的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//function:根据用户名获取用户节点</span></span><br><span class="line"><span class="comment">//param:root:xml文件根节点；userName：用户名</span></span><br><span class="line"><span class="comment">//return：用户节点</span></span><br><span class="line"><span class="function">XMLElement* <span class="title">queryUserNodeByName</span><span class="params">(XMLElement* root,<span class="keyword">const</span> <span class="built_in">string</span>&amp; userName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    XMLElement* userNode=root-&gt;FirstChildElement(<span class="string">"User"</span>);</span><br><span class="line">    <span class="keyword">while</span>(userNode!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(userNode-&gt;Attribute(<span class="string">"Name"</span>)==userName)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        userNode=userNode-&gt;NextSiblingElement();<span class="comment">//下一个兄弟节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在以上函数的基础上，获取用户信息的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">User* <span class="title">queryUserByName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* xmlPath,<span class="keyword">const</span> <span class="built_in">string</span>&amp; userName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XMLDocument doc;</span><br><span class="line">    <span class="keyword">if</span>(doc.LoadFile(xmlPath)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"load xml file failed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    XMLElement* root=doc.RootElement();</span><br><span class="line">    XMLElement* userNode=queryUserNodeByName(root,userName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(userNode!=<span class="literal">NULL</span>)  <span class="comment">//searched successfully</span></span><br><span class="line">    &#123;</span><br><span class="line">        User* user=<span class="keyword">new</span> User();</span><br><span class="line">        user-&gt;userName=userName;</span><br><span class="line">        user-&gt;password=userNode-&gt;Attribute(<span class="string">"Password"</span>);</span><br><span class="line">        XMLElement* genderNode=userNode-&gt;FirstChildElement(<span class="string">"Gender"</span>);</span><br><span class="line">        user-&gt;gender=atoi(genderNode-&gt;GetText());</span><br><span class="line">        XMLElement* mobileNode=userNode-&gt;FirstChildElement(<span class="string">"Mobile"</span>);</span><br><span class="line">        user-&gt;mobile=mobileNode-&gt;GetText();     </span><br><span class="line">        XMLElement* emailNode=userNode-&gt;FirstChildElement(<span class="string">"Email"</span>);</span><br><span class="line">        user-&gt;email=emailNode-&gt;GetText();           </span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-4修改xml文件的指定节点"><a href="#3-4修改xml文件的指定节点" class="headerlink" title="3.4修改xml文件的指定节点"></a>3.4修改xml文件的指定节点</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//function:修改指定节点内容</span></span><br><span class="line"><span class="comment">//param:xmlPath:xml文件路径；user：用户对象</span></span><br><span class="line"><span class="comment">//return：bool</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">updateUser</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* xmlPath,User* user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XMLDocument doc;</span><br><span class="line">    <span class="keyword">if</span>(doc.LoadFile(xmlPath)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"load xml file failed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    XMLElement* root=doc.RootElement();</span><br><span class="line">    XMLElement* userNode=queryUserNodeByName(root,user-&gt;userName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(userNode!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(user-&gt;password!=userNode-&gt;Attribute(<span class="string">"Password"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            userNode-&gt;SetAttribute(<span class="string">"Password"</span>,user-&gt;password.c_str());  <span class="comment">//修改属性</span></span><br><span class="line">        &#125;</span><br><span class="line">        XMLElement* genderNode=userNode-&gt;FirstChildElement(<span class="string">"Gender"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user-&gt;gender!=atoi(genderNode-&gt;GetText()))  </span><br><span class="line">        &#123;</span><br><span class="line">            genderNode-&gt;SetText(itoa(user-&gt;gender).c_str());   <span class="comment">//修改节点内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        XMLElement* mobileNode=userNode-&gt;FirstChildElement(<span class="string">"Mobile"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user-&gt;mobile!=mobileNode-&gt;GetText())</span><br><span class="line">        &#123;</span><br><span class="line">            mobileNode-&gt;SetText(user-&gt;mobile.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        XMLElement* emailNode=userNode-&gt;FirstChildElement(<span class="string">"Email"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user-&gt;email!=emailNode-&gt;GetText())</span><br><span class="line">        &#123;</span><br><span class="line">            emailNode-&gt;SetText(user-&gt;email.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(doc.SaveFile(xmlPath)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//修改用户信息</span></span><br><span class="line">    <span class="function">User <span class="title">user</span><span class="params">(<span class="string">"lvlv"</span>,<span class="string">"00001111"</span>,<span class="number">0</span>,<span class="string">"13995648666"</span>,<span class="string">"1586666@qq.com"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(updateUser(<span class="string">"./user.xml"</span>,&amp;user))</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"update successfully"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"update failed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">修改结果：</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> standalone=<span class="string">"no"</span>?&gt;</span><br><span class="line">&lt;DBUSER&gt;</span><br><span class="line">    &lt;User Name=<span class="string">"lvlv"</span> Password=<span class="string">"00001111"</span>&gt;</span><br><span class="line">        &lt;Gender&gt;<span class="number">0</span>&lt;/Gender&gt;</span><br><span class="line">        &lt;Mobile&gt;<span class="number">13995648666</span>&lt;/Mobile&gt;</span><br><span class="line">        &lt;Email&gt;<span class="number">1586666</span>@qq.com&lt;/Email&gt;</span><br><span class="line">&lt;/User&gt;</span><br><span class="line">&lt;/DBUSER&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-5删除xml文件的指定节点的信息"><a href="#3-5删除xml文件的指定节点的信息" class="headerlink" title="3.5删除xml文件的指定节点的信息"></a>3.5删除xml文件的指定节点的信息</h2><p>//function:删除指定节点内容<br>//param:xmlPath:xml文件路径；userName：用户名称<br>//return：bool<br>bool deleteUserByName(const char<em> xmlPath,const string&amp; userName)<br>{<br>    XMLDocument doc;<br>    if(doc.LoadFile(xmlPath)!=0)<br>    {<br>        cout&lt;&lt;”load xml file failed”&lt;&lt;endl;<br>        return false;<br>    }<br>    XMLElement</em> root=doc.RootElement();<br>    //doc.DeleteNode(root);//删除xml所有节点<br>    XMLElement<em> userNode=queryUserNodeByName(root,userName);<br>    if(userNode!=NULL)<br>    {<br>        userNode-&gt;DeleteAttribute(“Password”);//删除属性<br>        XMLElement</em> emailNode=userNode-&gt;FirstChildElement(“Email”);<br>        userNode-&gt;DeleteChild(emailNode); //删除指定节点<br>        //userNode-&gt;DeleteChildren();//删除节点的所有孩子节点<br>        if(doc.SaveFile(xmlPath)==0)<br>            return true;<br>    }<br>    return false;<br>}<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">验证代码：</span><br><span class="line">&#96;&#96;&#96;C++</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;删除用户某些信息</span><br><span class="line">    if(deleteUserByName(&quot;.&#x2F;user.xml&quot;,&quot;lvlv&quot;))</span><br><span class="line">        cout&lt;&lt;&quot;delete successfully&quot;&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;&quot;delete failed&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>删除结果：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DBUSER</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">User</span> <span class="attr">Name</span>=<span class="string">"lvlv"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Gender</span>&gt;</span>10<span class="tag">&lt;/<span class="name">Gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Mobile</span>&gt;</span>13995648666<span class="tag">&lt;/<span class="name">Mobile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">User</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DBUSER</span>&gt;</span></span><br></pre></td></tr></table></figure><br>4.其它常见用例<br>4.1获取xml文件申明<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//function:获取xml文件申明</span></span><br><span class="line"><span class="comment">//param:xmlPath:xml文件路径；strDecl：xml申明</span></span><br><span class="line"><span class="comment">//return：bool</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getXMLDeclaration</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* xmlPath,<span class="built_in">string</span>&amp; strDecl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XMLDocument doc;</span><br><span class="line">    <span class="keyword">if</span>(doc.LoadFile(xmlPath)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"load xml file failed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    XMLNode* decl=doc.FirstChild();  </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>!=decl)  </span><br><span class="line">    &#123;  </span><br><span class="line">        XMLDeclaration* declaration =decl-&gt;ToDeclaration();  </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span>!=declaration)  </span><br><span class="line">        &#123;  </span><br><span class="line">              strDecl = declaration-&gt;Value();</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>验证代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取xml文件申明</span></span><br><span class="line">    <span class="built_in">string</span> strDecl;</span><br><span class="line">    <span class="keyword">if</span>(getXMLDeclaration(<span class="string">"./user.xml"</span>,strDecl))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"declaration:"</span>&lt;&lt;strDecl&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>验证结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declaration:xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;no&quot;</span><br></pre></td></tr></table></figure></p>
<p>4.2打印xml文件至标准输出<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//function:将xml文件内容输出到标准输出</span></span><br><span class="line"><span class="comment">//param:xmlPath:xml文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* xmlPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XMLDocument doc;</span><br><span class="line">    <span class="keyword">if</span>(doc.LoadFile(<span class="string">"./user.xml"</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"load xml file failed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doc.Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>4.3 xml文件内容输出至内存<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">XMLPrinter printer;</span><br><span class="line">doc.Print( &amp;printer );</span><br><span class="line"><span class="comment">// printer.CStr() has a const char* to the XML</span></span><br></pre></td></tr></table></figure><br>4.4如何解析xml格式的字符串信息,不是文件中的<br>采用tinyXML中的TiXmlDocument类的Parse方法即可。例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * xmlString = <span class="string">"&lt;?xml version=\"1.0\" standalone=no&gt;\n&lt;!– Our to do list data –&gt;\n&lt;ToDo&gt;\n&lt;Item priority=\"1\"&gt; &lt;bold&gt;Toy store!&lt;/bold&gt;\n&lt;/Item&gt;\n&lt;Item priority=\"2\"&gt; Do bills&lt;/Item&gt;\n&lt;/ToDo&gt; "</span>;</span><br><span class="line">XMLDocument *doc = <span class="keyword">new</span> XMLDocument();</span><br><span class="line">doc-&gt;Parse(xmlString);</span><br><span class="line"> </span><br><span class="line">XMLElement * rootElement = doc-&gt;RootElement();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * rootName = rootElement-&gt;Value();</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>VS的使用</title>
    <url>/2020/07/22/VS%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="VS的使用"><a href="#VS的使用" class="headerlink" title="VS的使用"></a>VS的使用</h2><a id="more"></a>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Ctrl + F5  <span class="comment">//编译执行</span></span><br><span class="line">F9         <span class="comment">//加断点</span></span><br><span class="line">F10        <span class="comment">//单步执行</span></span><br><span class="line">F11        <span class="comment">//单步执行（进入函数）</span></span><br><span class="line">shift + F9 <span class="comment">//查看变量地址</span></span><br></pre></td></tr></table></figure>
<h3 id="指定目录"><a href="#指定目录" class="headerlink" title="指定目录"></a>指定目录</h3><p>可以指定下列目录类型。<br><strong>可执行目录</strong><br>搜索可执行文件的目录。对应于 PATH 环境变量。<br><strong>包含目录（*.h）</strong><br>搜索在源代码中引用的包含文件的目录。对应于 INCLUDE 环境变量。<br><strong>引用目录</strong><br>搜索通过 #using 指令在源代码中引用的程序集和模块（元数据）文件的目录。对应于 LIBPATH 环境变量。<br><strong>库目录（*.lib）</strong><br>搜索库（包括运行时库）的目录。对应于 LIB 环境变量。<br><strong>源目录</strong><br>搜索用于 IntelliSense 的源文件的目录。<br><strong>排除目录</strong><br>检查生成依赖项时，不会搜索目录。</p>
<p><strong>调试-&gt;环境(*.dll)</strong></p>
<p><code>PATH=&lt;dll文件目录&gt;</code></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>bss段、data段、text段、堆栈</title>
    <url>/2020/07/21/bss%E6%AE%B5%E3%80%81data%E6%AE%B5%E3%80%81text%E6%AE%B5%E3%80%81%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>每个线程都有一个栈，但一个应用程序通常只有一个堆<br><a id="more"></a></p>
<h2 id="bss段："><a href="#bss段：" class="headerlink" title="bss段："></a>bss段：</h2><p>　　bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。</p>
<p>　　bss是英文Block Started by Symbol的简称。</p>
<p>　　bss段属于静态内存分配。 </p>
<h2 id="data段："><a href="#data段：" class="headerlink" title="data段："></a>data段：</h2><p>　　数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。</p>
<p>　　数据段属于静态内存分配。 </p>
<h2 id="text段："><a href="#text段：" class="headerlink" title="text段："></a>text段：</h2><p>　　代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。</p>
<p>　　这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。</p>
<p>　　在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 </p>
<h2 id="堆（heap）："><a href="#堆（heap）：" class="headerlink" title="堆（heap）："></a>堆（heap）：</h2><p>　　堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。</p>
<p>　　当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；</p>
<p>　　当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p>
<h2 id="栈-stack-："><a href="#栈-stack-：" class="headerlink" title="栈(stack)："></a>栈(stack)：</h2><p>　　 栈又称堆栈，是用户存放程序临时创建的局部变量，</p>
<p>　　也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。</p>
<p>　　除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>c++内联函数</title>
    <url>/2019/11/19/c-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>参考链接：<a href="https://blog.csdn.net/BjarneCpp/article/details/76044493" target="_blank" rel="noopener">https://blog.csdn.net/BjarneCpp/article/details/76044493</a></p>
<h1 id="1-内联函数"><a href="#1-内联函数" class="headerlink" title="1.内联函数"></a>1.内联函数</h1><p>在C++中我们通常定义以下函数来求两个整数的最大值：<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;<span class="number">1234</span></span><br></pre></td></tr></table></figure></p>
<p>为这么一个小的操作定义一个函数的好处有：</p>
<p><strong>① 阅读和理解函数 max 的调用，要比读一条等价的条件表达式并解释它的含义要容易得多</strong></p>
<p><strong>② 如果需要做任何修改，修改函数要比找出并修改每一处等价表达式容易得多</strong></p>
<p><strong>③ 使用函数可以确保统一的行为，每个测试都保证以相同的方式实现</strong></p>
<p><strong>④ 函数可以重用，不必为其他应用程序重写代码</strong></p>
<p>虽然有这么多好处，但是写成函数有一个潜在的缺点：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行</p>
<p>C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;<span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>则调用：<code>cout &lt;&lt; max(a, b) &lt;&lt; endl;</code></p>
<p>在编译时展开为：<code>cout &lt;&lt; (a &gt; b ? a : b) &lt;&lt; endl;</code> 从而消除了把 max写成函数的额外执行开销。</p>
<h1 id="2-内联函数和宏"><a href="#2-内联函数和宏" class="headerlink" title="2. 内联函数和宏"></a>2. 内联函数和宏</h1><p>无论是《Effective C++》中的 “Prefer consts，enums，and inlines to #defines” 条款，还是《高质量程序设计指南——C++/C语言》中的“用函数内联取代宏”，宏在C++中基本是被废了，在书《<a href="http://download.csdn.net/detail/bjarnecpp/9909375" target="_blank" rel="noopener">高质量程序设计指南——C++/c语言</a>》中这样解释到：</p>
<p><img src="image/SouthEast-20191117103611325.jpeg" alt="这里写图片描述"></p>
<h1 id="3-将内联函数放入头文件"><a href="#3-将内联函数放入头文件" class="headerlink" title="3. 将内联函数放入头文件"></a>3. 将内联函数放入头文件</h1><p>关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。</p>
<p>如下风格的函数 Foo 不能成为内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;   <span class="comment">// inline 仅与函数声明放在一起   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>而如下风格的函数 Foo 则成为内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>   <span class="comment">// inline 与函数定义体放在一起</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但我认为 inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p>
<p>定义在类声明之中的成员函数将自动地成为内联函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ... &#125;   <span class="comment">// 自动地成为内联函数  </span></span><br><span class="line">&#125; <span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>但是编译器是否将它真正内联则要看 Foo函数如何定义</p>
<p>内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。</p>
<p>当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。</p>
<p>但是你会很奇怪，重复定义那么多次，不会产生链接错误？</p>
<p>我们来看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件A.h 代码如下:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : a(a),b(b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;<span class="number">1234567891011</span></span><br><span class="line"><span class="comment">// 文件A.cpp 代码如下:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"A.h"</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::max()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"><span class="comment">// 文件Main.cpp 代码如下:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"A.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::max()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.max() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<p>一切正常编译，<code>输出结果：5</code></p>
<p>倘若你在Main.cpp中没有定义max内联函数，那么会出现链接错误：<br><code>error LNK2001: unresolved external symbol &quot;public: int __thiscall A::max(void)&quot; (?max@A@@QAEHXZ)main.obj</code><br>找不到函数的定义，所以内联函数可以在程序中定义不止一次，只要 inline 函数的定义在某个源文件中只出现一次，而且在所有源文件中，其定义必须是完全相同的就可以。</p>
<p>在头文件中加入或修改 inline 函数时，使用了该头文件的所有源文件都必须重新编译。</p>
<h1 id="4-慎用内联"><a href="#4-慎用内联" class="headerlink" title="4. 慎用内联"></a>4. 慎用内联</h1><p>内联虽有它的好处，但是也要慎用，以下摘自<em><a href="http://download.csdn.net/detail/bjarnecpp/9909375" target="_blank" rel="noopener">《高质量程序设计指南——C++/C语言》</a></em>：</p>
<p><img src="image/SouthEast.jpeg" alt="这里写图片描述"></p>
<p>而在Google C++编码规范中则规定得更加明确和详细：</p>
<blockquote>
<h2 id="内联函数："><a href="#内联函数：" class="headerlink" title="内联函数："></a>内联函数：</h2><h2 id="Tip：-只有当函数只有-10-行甚至更少时才将其定义为内联函数"><a href="#Tip：-只有当函数只有-10-行甚至更少时才将其定义为内联函数" class="headerlink" title="Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数."></a>Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.</h2><p>定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.<br>优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.<br>缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。<br>结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!<br>另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).<br>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p>
<p>-inl.h文件：</p>
<h2 id="Tip：-复杂的内联函数的定义-应放在后缀名为-inl-h-的头文件中"><a href="#Tip：-复杂的内联函数的定义-应放在后缀名为-inl-h-的头文件中" class="headerlink" title="Tip： 复杂的内联函数的定义, 应放在后缀名为 -inl.h 的头文件中."></a>Tip： 复杂的内联函数的定义, 应放在后缀名为 -inl.h 的头文件中.</h2><p>内联函数的定义必须放在头文件中, 编译器才能在调用点内联展开定义. 然而, 实现代码理论上应该放在 .cc 文件中, 我们不希望 .h 文件中有太多实现代码, 除非在可读性和性能上有明显优势.</p>
<p>如果内联函数的定义比较短小, 逻辑比较简单, 实现代码放在 .h 文件里没有任何问题. 比如, 存取函数的实现理所当然都应该放在类定义内. 出于编写者和调用者的方便, 较复杂的内联函数也可以放到 .h 文件中, 如果你觉得这样会使头文件显得笨重, 也可以把它萃取到单独的 -inl.h 中. 这样把实现和类定义分离开来, 当需要时包含对应的 -inl.h 即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++头文件和源文件</title>
    <url>/2019/11/19/c-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="头文件-h-："><a href="#头文件-h-：" class="headerlink" title="头文件(.h)："></a>头文件(.h)：</h2><p>​    写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。</p>
<p>.h文件中能包含：<br><a id="more"></a></p>
<ul>
<li>类成员数据的声明，但不能赋值</li>
<li>类静态数据成员的定义和赋值，但不建议，只是个声明就好。</li>
<li>类的成员函数的声明</li>
<li>非类成员函数的声明</li>
<li>常数的定义：如：const int a=5;</li>
<li>静态函数的定义</li>
<li>类的内联函数的定义</li>
</ul>
<p>不能包含：</p>
<ul>
<li>1． 所有非静态变量（不是类的数据成员）的声明</li>
<li>2。 默认命名空间声明不要放在头文件，using namespace std;等应放在.cpp中，在 .h 文件中使用 std::string</li>
</ul>
<p>特别注意</p>
<ul>
<li>一，<strong>头文件中可以写 const 对象的定义</strong>。因为全局的 const 对象默认是没有 extern 的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个 .cpp 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同时，因为这些 .cpp 文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些 .cpp 文件中的这个 const 对象的值是相同的，可谓一举两得。同理，static 对象的定义也可以放进头文件。</li>
<li>二，<strong>头文件中可以写内联函数（inline）的定义</strong>。因为inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义；但是，如果我在其他的文件中还使用到了这个函数那怎么办呢？这几乎没什么太好的解决办法，因此 C++ 规定，内联函数可以在程序中定义多次，只要内联函数在一个 .cpp 文件中只出现一次，并且在所有的 .cpp 文件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。</li>
<li>三，<strong>头文件中可以写类（class）的定义。</strong>因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的。所以把类的定义放进头文件，在使用到这个类的 .cpp 文件中去包含这个头文件，是一个很好的做法。在这里，值得一提的是，类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。一般，我们的做法是，<strong>把类的定义放在头文件中，而把函数成员的实现代码放在一个 .cpp 文件中</strong>。这是可以的，也是很好的办法。不过，还有另一种办法。那就是<strong>直接把函数成员的实现代码也写进类定义里面。在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。</strong>因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。注意一下，<strong>如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。</strong>一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被重定义了。</li>
</ul>
<h2 id="源文件（-cpp）："><a href="#源文件（-cpp）：" class="headerlink" title="源文件（.cpp）："></a>源文件（.cpp）：</h2><p>源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。那么当你需要用到自己写的头文件中的类时，只需要#include进来就行了。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake基础（搬运）</title>
    <url>/2019/11/26/cmake%E5%9F%BA%E7%A1%80%EF%BC%88%E6%90%AC%E8%BF%90%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/8df5b2aba316" target="_blank" rel="noopener">原链接 ref</a></p>
<h1 id="1-编译单目录工程"><a href="#1-编译单目录工程" class="headerlink" title="1. 编译单目录工程"></a>1. 编译单目录工程</h1><p>1.创建工程文件夹</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> hello #工程目录</span><br><span class="line">cd hello</span><br><span class="line"><span class="built_in">mkdir</span> src   # 存放源代码的目录</span><br><span class="line"><span class="built_in">mkdir</span> build # 存放编译中间代码和目标代码的目录</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2.进入<code>src</code>目录，编写一个<code>main.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.编写工程顶层目录的<code>CMakeLists.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minumum_required(VERSION 2.6)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定项目名</span></span><br><span class="line">project(hello)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定子目录</span></span><br><span class="line">add_subdirectory(src)</span><br></pre></td></tr></table></figure>
<p>4.编写子目录<code>src</code>的<code>CMakeLists.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST)</span><br><span class="line"></span><br><span class="line">add_executable(hello <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>5.编译工程</p>
<blockquote>
<p>1.进入<code>build</code> 目录<br> 2.执行命令<code>cmake ..</code>创建Makefile<br> 3.执行命令<code>make</code>编译工程<br> 4.在<code>build</code>的子目录<code>src</code>生成了执行文件</p>
</blockquote>
<h1 id="2-编译多目录工程"><a href="#2-编译多目录工程" class="headerlink" title="2. 编译多目录工程"></a>2. 编译多目录工程</h1><p>1.创建工程目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir hello <span class="comment"># 工程目录</span></span><br><span class="line"><span class="built_in">cd</span> hello</span><br><span class="line">mkdir src   <span class="comment"># 存放源码目录</span></span><br><span class="line">mkdir build <span class="comment"># 存放编译产生的中间文件</span></span><br><span class="line"><span class="built_in">cd</span> src      </span><br><span class="line">mkdir hello <span class="comment"># 存放hello 模块</span></span><br><span class="line">mkdir world <span class="comment"># 存放world 模块</span></span><br></pre></td></tr></table></figure>
<p>2.编写<code>hello</code>模块</p>
<ul>
<li>进入<code>hello</code>目录</li>
<li>编写<code>hello.h</code>文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  HELLO_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_Print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写<code>hello.c</code>文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_Print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写<code>CMakeLists.txt</code> 文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aux_source_directory(. DIR_HELLO_SRC)</span><br><span class="line"></span><br><span class="line">add_library(hello_lib <span class="variable">$&#123;DIR_HELLO_SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>3.编写<code>world</code>模块</p>
<ul>
<li>进入<code>world</code>目录</li>
<li>编写<code>world.h</code>文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  WORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  WORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">World_Print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写<code>world.c</code>文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"world.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">World_Print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写<code>CMakeLists.txt</code> 文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aux_source_directory(. DIR_WORLD_SRC)</span><br><span class="line"></span><br><span class="line">add_library(world_lib <span class="variable">$&#123;DIR_WORLD_SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>4.编写主模块</p>
<ul>
<li>进入<code>src</code>目录</li>
<li>编写<code>main.c</code> 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello/hello.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"world/world.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Hello_Print();</span><br><span class="line">    World_Print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写<code>CMakeLists.txt</code> 文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_source_directory(. DIR_SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line">add_subdirectory(hello)</span><br><span class="line">add_subdirectory(world)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行文件</span></span><br><span class="line">add_executable(hello_prj <span class="variable">$&#123;DIR_SRC&#125;</span>)</span><br><span class="line">target_link_libraries(hello_prj ello_lib world_lib)</span><br></pre></td></tr></table></figure>
<p>5.编写顶层目录的<code>CMakeLists.txt</code>文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cmake_minumum_required</span>(<span class="selector-tag">VERSION</span> 2<span class="selector-class">.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">project</span>(<span class="selector-tag">hello_prj</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">add_subdirectory</span>(<span class="selector-tag">src</span>)</span><br></pre></td></tr></table></figure>
<h1 id="3-动态库和静态库的构建和使用"><a href="#3-动态库和静态库的构建和使用" class="headerlink" title="3. 动态库和静态库的构建和使用"></a>3. 动态库和静态库的构建和使用</h1><p>1.使用一个<code>hello world</code>工程来展开说明<br> <strong>项目结构</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="params">|-- CMakeLists.txt</span></span><br><span class="line"><span class="params">|</span>-- build</span><br><span class="line"><span class="params">|-- <span class="keyword">include</span></span></span><br><span class="line"><span class="params">|</span>   <span class="params">|-- hello</span></span><br><span class="line"><span class="params">|</span>   <span class="params">|   `-- hello.h</span></span><br><span class="line"><span class="params">|</span>   <span class="string">`-- world</span></span><br><span class="line"><span class="string">|       `</span>-- world.h</span><br><span class="line"><span class="params">|-- src</span></span><br><span class="line"><span class="params">|</span>   <span class="params">|-- CMakeLists.txt</span></span><br><span class="line"><span class="params">|</span>   <span class="params">|-- hello</span></span><br><span class="line"><span class="params">|</span>   <span class="params">|   `-- hello.c</span></span><br><span class="line"><span class="params">|</span>   <span class="string">`-- world</span></span><br><span class="line"><span class="string">|       `</span>-- world.c</span><br><span class="line"><span class="string">`-- test</span></span><br><span class="line"><span class="string">    |-- CMakeLists.txt</span></span><br><span class="line"><span class="string">        `</span>-- mytest.c</span><br></pre></td></tr></table></figure>
<p>2.顶层目录<code>CMakeLists.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.6)</span><br><span class="line"></span><br><span class="line">project(helloworld)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置库文件存放路径</span></span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置执行文件存放路径</span></span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前目录及子目录(递归获取),添加到头文件搜索路径</span></span><br><span class="line"><span class="keyword">function</span>(include_sub_directories_recursively root_dir)</span><br><span class="line">    <span class="keyword">if</span> (IS_DIRECTORY <span class="variable">$&#123;root_dir&#125;</span>)               <span class="comment"># 当前路径是一个目录吗，是的话就加入到包含目录</span></span><br><span class="line">        message(<span class="string">"include dir: "</span> <span class="variable">$&#123;root_dir&#125;</span>)</span><br><span class="line">        include_directories(<span class="variable">$&#123;root_dir&#125;</span>)</span><br><span class="line">    endif()</span><br><span class="line"></span><br><span class="line">    file(GLOB ALL_SUB RELATIVE <span class="variable">$&#123;root_dir&#125;</span> <span class="variable">$&#123;root_dir&#125;</span>/*) <span class="comment"># 获得当前目录下的所有文件，让如ALL_SUB列表中</span></span><br><span class="line">    foreach(sub <span class="variable">$&#123;ALL_SUB&#125;</span>)</span><br><span class="line">        <span class="keyword">if</span> (IS_DIRECTORY <span class="variable">$&#123;root_dir&#125;</span>/<span class="variable">$&#123;sub&#125;</span>)</span><br><span class="line">            include_sub_directories_recursively(<span class="variable">$&#123;root_dir&#125;</span>/<span class="variable">$&#123;sub&#125;</span>) <span class="comment"># 对子目录递归调用，包含</span></span><br><span class="line">        endif()</span><br><span class="line">    endforeach()</span><br><span class="line">endfunction()</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目的所有目录都为头文件搜索路径</span></span><br><span class="line">include_sub_directories_recursively(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加库文件搜索路径</span></span><br><span class="line">link_directories(</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build/lib</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加子目录</span></span><br><span class="line">add_subdirectory(src)</span><br><span class="line">add_subdirectory(<span class="built_in">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置安装目录</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_INSTALL_PREFIX <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/install)</span><br></pre></td></tr></table></figure>
<p>3.<code>helloworld</code>库的源代码<br> <strong>hello.h文件</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  HELLO_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_Print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>hello.c文件</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello/hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_Print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>world.h文件</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  WORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  WORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">World_Print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>world.c文件</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"world/world.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">World_Print</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.子目录<code>src</code>下的<code>CMakeLists.txt</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#递归获取当前目录及子目录下的所有c文件</span></span><br><span class="line">file(GLOB_RECURSE c_files <span class="string">"*.c"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成动态库和静态库</span></span><br><span class="line">add_library(helloworld_lib_shared  SHARED $&#123;c_files&#125;)</span><br><span class="line">add_library(helloworld_lib_static STATIC $&#123;c_files&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将动态库和静态库的名字设置为一致</span></span><br><span class="line">set_target_properties(helloworld_lib_shared PROPERTIES OUTPUT_NAME <span class="string">"helloworld"</span>)</span><br><span class="line">set_target_properties(helloworld_lib_static PROPERTIES OUTPUT_NAME <span class="string">"helloworld"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置动态库版本</span></span><br><span class="line">set_target_properties(helloworld_lib_shared PROPERTIES VERSION <span class="number">1.2</span> SOVERSION <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装动态库和静态库</span></span><br><span class="line">INSTALL(TARGETS helloworld_lib_shared helloworld_lib_static</span><br><span class="line">    LIBRARY DESTINATION lib</span><br><span class="line">    ARCHIVE DESTINATION lib)</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装头文件</span></span><br><span class="line">INSTALL(DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/<span class="keyword">include</span>/ DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>5.<code>mytest.c</code>文件测试生成的库文件<br> <strong>mytest.c文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello/hello.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"world/world.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Hello_Print();</span><br><span class="line">    World_Print();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CMakeLists.txt文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#递归获取所有当前目录及子目录下的C文件</span></span><br><span class="line">file(GLOB_RECURSE c_files ./*.c)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#生成执行文件</span></span><br><span class="line">add_executable(mytest <span class="variable">$&#123;c_files&#125;</span>)</span><br><span class="line">     </span><br><span class="line"><span class="comment">#链接外部库</span></span><br><span class="line">target_link_libraries(mytest libhelloworld.so)</span><br></pre></td></tr></table></figure>
<p>6.构建工程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>进入目录build</span><br><span class="line"><span class="number">2.</span>执行命令: cmake ..</span><br><span class="line"><span class="number">3.</span>执行命令: <span class="built_in">make</span></span><br><span class="line"><span class="number">4.</span>执行命令: <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure>
<h1 id="4-指定编译器和编译选项"><a href="#4-指定编译器和编译选项" class="headerlink" title="4. 指定编译器和编译选项"></a>4. 指定编译器和编译选项</h1><p>1.<code>CMAKE_C_COMPILER</code>: 指定C编译器<br> 2.<code>CMAKE_CXX_COMPILTER</code>:指定C++编译器<br> 3.<code>CMAKE_C_FLAGS</code>: 指定C编译选项<br> 4.<code>CMAKE_CXX_FLAGS</code>:指定C++编译选项<br> 5.<code>EXECUTABLE_OUTPUT_PATH</code>: 指定执行文件存放目录<br> 6.<code>LIBRARY_OUTPUT_PATH</code>: 指定库文件存放目录<br> 7.<code>CMAKE_BUILD_TYPE</code>:指定build类型[Debug|Release]<br> 8.<code>BUILD_SHARED_LIBS</code>: 指定默认库编译方式[OFF|ON]</p>
<p><strong>上述内部变量使用说明</strong>:<br> 1.<code>CMakeLists.txt</code>文件上使用<code>set</code>命令<br> 2.cmake 命令中指定，如: <code>cmake -DCMAKE_C_COMPILER=gcc</code></p>
<p><code>add_definitions</code>:添加编译参数</p>
<h1 id="5-配置编译模块"><a href="#5-配置编译模块" class="headerlink" title="5. 配置编译模块"></a>5. 配置编译模块</h1><h1 id="6-CMake-常用变量和语句"><a href="#6-CMake-常用变量和语句" class="headerlink" title="6. CMake 常用变量和语句"></a>6. CMake 常用变量和语句</h1><p>1.<code>include_directories</code>:指定头文件搜索路径<br> 2.<code>link_directories</code>:指定库文件搜索路径<br> 3.<code>add_subdirectory</code>:添加子目录<br> 4.<code>target_link_libraries</code>:指定文件链接库文件</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake官方教程（搬运）</title>
    <url>/2019/11/26/cmake%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%EF%BC%88%E6%90%AC%E8%BF%90%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/6df3857462cd" target="_blank" rel="noopener">原链接 ref</a></p>
<h1 id="起点（Step-1）"><a href="#起点（Step-1）" class="headerlink" title="起点（Step 1）"></a>起点（Step 1）</h1><p>参看下面的CMakeLists.txt文件，最简单的一个工程需要有一个这样的cmake文件，一共就这么两行</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cmake_minimum_required</span> (<span class="selector-tag">VERSION</span> 2<span class="selector-class">.6</span>)</span><br><span class="line"><span class="selector-tag">project</span> (<span class="selector-tag">Tutorial</span>) </span><br><span class="line"><span class="selector-tag">add_executable</span> (<span class="selector-tag">Tutorial</span> <span class="selector-tag">tutorial</span><span class="selector-class">.cxx</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>注意到这里都是用的小写的命令，在cmake文件里面大小写不严格区分，都可以用。<br> add_executable添加一个可编译的目标到工程里面</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">add_executable</span>(&lt;<span class="selector-tag">name</span>&gt; <span class="selector-attr">[WIN32]</span> <span class="selector-attr">[MACOSX_BUNDLE]</span></span><br><span class="line">               <span class="selector-attr">[EXCLUDE_FROM_ALL]</span></span><br><span class="line">               <span class="selector-tag">source1</span> <span class="selector-attr">[source2 ...]</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>name: 工程所要构建的目标名称</li>
<li>WIN32/..: 目标app运行的平台</li>
<li>source1：构建目标App的源文件</li>
</ul>
<p>tutorial.cxx的源代码计算一个数的平方根。第一版的代码很简单，参看如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple program that computes the square root of a number</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Uage: %s number\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">double</span> inputValue = atof(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"The square root of %g is %g\n"</span>,</span><br><span class="line">            inputValue, outputValue);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写完上面两个文件以后，在根目录下新建一个build目录<br> .<br> ├── build<br> ├── CMakeLists.txt<br> └── tutorial.cxx<br> 然后运行如下命令</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$ cd buld</span><br><span class="line">$ CMake ..</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
<ul>
<li>CMake会自动加载上级目录里面的CMakeLists.txt文件，编译所需的文件都会生成在build目录下</li>
<li>make之后会生成可执行文件Tutorial</li>
</ul>
<h2 id="添加一个版本号和配置的头文件"><a href="#添加一个版本号和配置的头文件" class="headerlink" title="添加一个版本号和配置的头文件"></a>添加一个版本号和配置的头文件</h2><p>修改CMakeList.txt来添加version number：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.6)</span><br><span class="line">project (Tutorial)</span><br><span class="line"><span class="comment"># 版本号.</span></span><br><span class="line"><span class="built_in">set</span> (Tutorial_VERSION_MAJOR 1)</span><br><span class="line"><span class="built_in">set</span> (Tutorial_VERSION_MINOR 0)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 配置一个头文件来传递一些CMake设置到源代码</span></span><br><span class="line">configure_file (</span><br><span class="line">  <span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/TutorialConfig.h.in"</span></span><br><span class="line">  <span class="string">"<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/TutorialConfig.h"</span></span><br><span class="line">  )</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 添加TutorialConfig.h的路径到头文件的搜索路径</span></span><br><span class="line">include_directories(<span class="string">"<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 添加目标可执行文件</span></span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br></pre></td></tr></table></figure>
<p>configure_file会拷贝一个文件到另一个目录并修改文件内容:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">configure_file</span>(&lt;<span class="selector-tag">input</span>&gt; &lt;<span class="selector-tag">output</span>&gt;</span><br><span class="line">               <span class="selector-attr">[COPYONLY]</span> <span class="selector-attr">[ESCAPE_QUOTES]</span> <span class="selector-attr">[@ONLY]</span></span><br><span class="line">               <span class="selector-attr">[NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF]</span> ])</span><br></pre></td></tr></table></figure>
<p>cmake会自动定义两个变量</p>
<ul>
<li>${PROJECT_SOURCE_DIR}：  当前工程最上层的目录</li>
<li>${PROJECT_BINARY_DIR}：　当前工程的构建目录（本例中新建的build目录）</li>
</ul>
<p>在这个例子里，configure_file命令的源文件是TutorialConfig.h.in，手动创建这个文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tutorial工程的配置选项和设置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br></pre></td></tr></table></figure>
<p>调用CMake的时候会在build目录下新的头文件，并且使用CMakeList.txt中定义的值来替换@Tutorial_VERSION_MAJOR@和@Tutorial_VERSION_MINOR@这两个变量。<br> 下一步要在源文件tutorial.cxx中包含这个配置的头文件，就能使用这些版本信息了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple program that computes the square root of a number</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TutorialConfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"%s Version %d.%d\n"</span>, </span><br><span class="line">              argv[<span class="number">0</span>],</span><br><span class="line">              Tutorial_VERSION_MAJOR,</span><br><span class="line">              Tutorial_VERSION_MINOR)</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Uage: %s number\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">double</span> inputValue = atof(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"The square root of %g is %g\n"</span>,</span><br><span class="line">            inputValue, outputValue);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行如下命令查看结果</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br><span class="line">$ ./Tutorial</span><br></pre></td></tr></table></figure>
<p>这个时候控制台会打印出来版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;Tutorial Version 1.0</span><br><span class="line">Uage: .&#x2F;Tutorial number</span><br></pre></td></tr></table></figure>
<h1 id="添加Library（Step-2）"><a href="#添加Library（Step-2）" class="headerlink" title="添加Library（Step 2）"></a>添加Library（Step 2）</h1><p>现在我们尝试添加一个library到我们的工程。这个lib提供一个自定义的计算平方根的函数，用来替换编译器提供的函数。<br> lib的源文件放到一个叫MathFunctions的子目录中，在目录下新建CMakeList.txt文件，添加如下的一行</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">add_library</span>(<span class="selector-tag">MathFunctions</span> <span class="selector-tag">mysqrt</span><span class="selector-class">.cxx</span>)</span><br></pre></td></tr></table></figure>
<p>源文件mysqrt.cxx包含一个函数mysqrt用于计算平方根。代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFunctions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a hack square root calculation using simple operations</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> result;</span><br><span class="line">  <span class="keyword">double</span> delta;</span><br><span class="line">  result = x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do ten iterations</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      result = <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delta = x - (result * result);</span><br><span class="line">    result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Computing sqrt of %g to be %g\n"</span>, x, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要添加一个头文件MathFunctions.h以提供接口给main函数调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在的目录结构<br> .<br> ├── build<br> ├── CMakeLists.txt<br> ├── MathFunctions<br> │   ├── CMakeLists.txt<br> │   ├── MathFunctions.h<br> │   └── mysqrt.cxx<br> ├── TutorialConfig.h.in<br> └── tutorial.cxx</p>
<p>CMakeLists.txt文件需要相应做如下改动</p>
<ul>
<li>添加一行add_subdirectory来保证新加的library在工程构建过程中被编译。</li>
<li>添加新的头文件搜索路径MathFunction/MathFunctions.h。</li>
<li>添加新的library到executable。</li>
</ul>
<p>CMakeList.txt的最后几行变成了这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include_directories (<span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions"</span>)</span><br><span class="line">add_subdirectory (MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加executable</span></span><br><span class="line">add_executable (Tutorial tutorial.cxx)</span><br><span class="line">target_link_libraries (Turorial MathFunctions)</span><br></pre></td></tr></table></figure>
<p>最后要修改tutorial.cxx文件来调用自定义的mysqrt函数<br> 最后编译一下试试</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br><span class="line">$ ./Tutorial</span><br></pre></td></tr></table></figure>
<p>看一下编译的log</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Scanning dependencies of target MathFunctions</span><br><span class="line">[<span class="meta"> 50%</span>] Building CXX <span class="keyword">object</span> MathFunctions/CMakeFiles/MathFunctions.dir/mysqrt.cxx.o</span><br><span class="line">Linking CXX <span class="keyword">static</span> library libMathFunctions.a</span><br><span class="line">[<span class="meta"> 50%</span>] Built target MathFunctions</span><br><span class="line">Scanning dependencies of target Tutorial</span><br><span class="line">[<span class="meta">100%</span>] Building CXX <span class="keyword">object</span> CMakeFiles/Tutorial.dir/tutorial.cxx.o</span><br><span class="line">Linking CXX executable Tutorial</span><br><span class="line">[<span class="meta">100%</span>] Built target Tutorial</span><br></pre></td></tr></table></figure>
<p>这里编译生成了新的库libMathFunctions.a</p>
<h2 id="现在我们考虑把MathFunctions库配置成可选的"><a href="#现在我们考虑把MathFunctions库配置成可选的" class="headerlink" title="现在我们考虑把MathFunctions库配置成可选的"></a>现在我们考虑把MathFunctions库配置成可选的</h2><p>首先在最顶层的CMakeList.txt文件添加一个option</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#需要用自定义的数学函数么？</span></span><br><span class="line">option (USE_MYMATH</span><br><span class="line">            <span class="string">"Use tutorial provided math implementation"</span> ON)</span><br></pre></td></tr></table></figure>
<p>运行ccmake ..会跳出来配置的GUI，在GUi中会看到新添加的这个选项，用户可以根据需要进行修改。<br> 下一个改变是依据配置来判断是否编译和链接MathFunctions库。按照如下所示的修改CMakeList.txt的末尾几行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the MathFunctions library?</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">  include_directories (<span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions"</span>)</span><br><span class="line">  add_subdirectory (MathFunctions)</span><br><span class="line">  SET (EXTRA_LIBS <span class="variable">$&#123;EXTRA_LIBS&#125;</span> MathFunctions)</span><br><span class="line">endif (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add executable</span></span><br><span class="line">add_executable (Tutorial tutorial.cxx)</span><br><span class="line">target_link_libraries (Turorial <span class="variable">$&#123;EXTRA_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子里还是用了变量（EXTRA_LIBS）来收集后面link进可执行文件的时候任意可选的库。这是一个常用的方法，在工程非常大有很多optional的组件的时候，可以让这个编译文件保持干净。<br> 代码的修改就更直接了(用宏定义隔离开)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple program that computes the square root of a number</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TutorialConfig.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFunctions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"%s Version %d.%d\n"</span>, argv[<span class="number">0</span>],</span><br><span class="line">            Tutorial_VERSION_MAJOR,</span><br><span class="line">            Tutorial_VERSION_MINOR);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Usage: %s number\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">double</span> inputValue = atof(argv[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">  <span class="keyword">double</span> outputValue = mysqrt(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"The square root of %g is %g\n"</span>,</span><br><span class="line">          inputValue, outputValue);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源代码里面同样可以使用USE_MYMATH，只要在TutorialConfig.h.in里面添加一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cmakedefine USE_MYMATH</span></span><br></pre></td></tr></table></figure>
<h1 id="安装测试-Step-3"><a href="#安装测试-Step-3" class="headerlink" title="安装测试 (Step 3)"></a>安装测试 (Step 3)</h1><p>下一步我们会添加install规则和testing到工程。install规则非常直接。对于MathFunctions库，我们通过在MathFunctions的CMakeList文件中添加如下两行来安装库和头文件。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">install</span> (<span class="selector-tag">TARGETS</span> <span class="selector-tag">MathFunctions</span> <span class="selector-tag">DESTINATION</span> <span class="selector-tag">bin</span>)</span><br><span class="line"><span class="selector-tag">install</span>(<span class="selector-tag">FILES</span> <span class="selector-tag">MathFunctions</span><span class="selector-class">.h</span> <span class="selector-tag">DESTINATION</span> <span class="selector-tag">include</span>)</span><br></pre></td></tr></table></figure>
<p>对于应用程序，为了安装executable和配置头文件，需要在最上层的CMakeList.txt文件中添加下面几行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the install targets</span></span><br><span class="line">install (TARGETS Tutorial DESTINATION bin)</span><br><span class="line">install (FILES <span class="string">"<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/TutorialConfig.h"</span> DESTINATION include)</span><br></pre></td></tr></table></figure>
<p>到了这里你就可以构建整个tutorial了，通过命令make install，系统会自动安装对应的头文件，库以及可执行文件。CMake变量CMAKE_INSTALL_PREFIX用来指定这些文件需要安装到哪个根目录。<br> 添加测试用例也很直接，只要在最上层的CMakeList.txt文件添加一系列的基础测试来验证应用程序是否正常工作。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(CTest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the application run</span></span><br><span class="line">add_test (TutorialRuns Tutorial <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does it sqrt of 25</span></span><br><span class="line">add_test (TutorialComp25 Tutorial <span class="number">25</span>)</span><br><span class="line">set_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">"25 is 5"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does it handle negative numbers</span></span><br><span class="line">add_test (TutorialNegative Tutorial <span class="number">-25</span>)</span><br><span class="line">set_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">"-25 is 0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does it handle small numbers</span></span><br><span class="line">add_test (TutorialSmall Tutorial <span class="number">0.0001</span>)</span><br><span class="line">set_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">"0.0001 is 0.01"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the usage message work?</span></span><br><span class="line">add_test (TutorialUsage Tutorial)</span><br><span class="line">set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">"Usage:.*number"</span>)</span><br></pre></td></tr></table></figure>
<p>编译完成后可以通过在命令行运行ctest来执行这些测试用例。如果你希望添加很多测试用例来测试不同的输入值，这个时候推荐你创建一个宏，这样添加新的case会更轻松：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define a macro to simplify adding tests, then use it</span></span><br><span class="line">macro (do_test arg result)</span><br><span class="line">  add_test (TutorialComp<span class="variable">$&#123;arg&#125;</span> Tutorial <span class="variable">$&#123;arg&#125;</span>)</span><br><span class="line">  set_tests_properties (TutorialComp<span class="variable">$&#123;arg&#125;</span></span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span>)</span><br><span class="line">endmacro (do_test)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># do a bunch of result based tests</span></span><br><span class="line">do_test (25 <span class="string">"25 is 5"</span>)</span><br><span class="line">do_test (-25 <span class="string">"-25 is 0"</span>)</span><br></pre></td></tr></table></figure>
<p>每次调用do_test，都会添加一个新的test case到工程。</p>
<h1 id="添加系统回顾-Step-4"><a href="#添加系统回顾-Step-4" class="headerlink" title="添加系统回顾 (Step 4)"></a>添加系统回顾 (Step 4)</h1><p>下一步我们考虑在工程中添加一些代码，这些代码会依赖的某些特性在运行的目标平台上可能没有。比如说，我们添加了一些代码，这些代码需要用到log和exp函数，但某些目标平台上可能没有这些库函数。如果平台有log函数那么我们就是用log来计算平方根，我们首先通过CheckFunctionExists.cmake来测试一下是否有这些函数，在最上层的CMakeList文件中添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># does this system provide the log and exp functions?</span><br><span class="line">include (CheckFunctionExists)</span><br><span class="line">check_function_exists (log HAVE_LOG)</span><br><span class="line">check_function_exists (exp HAVE_EXP)</span><br></pre></td></tr></table></figure>
<p>Next we modify the TutorialConfig.h.in to define those values if CMake found them on the platform as follows:<br> 下一步，如果CMake发现平台有我们需要的这些函数，则需要修改TutorialConfig.h.in来定义这些值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// does the platform provide exp and <span class="built_in">log</span> <span class="built_in">functions</span>?</span><br><span class="line"><span class="comment">#cmakedefine HAVE_LOG</span></span><br><span class="line"><span class="comment">#cmakedefine HAVE_EXP</span></span><br></pre></td></tr></table></figure>
<p>有一点很重要，就是log和exp的测试工作需要在配置TutorialConfig.h前完成。最后在mysqrt函数中我们可以提供一个可选的实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if we have both log and exp then use them</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (HAVE_LOG) &amp;&amp; defined (HAVE_EXP)</span></span><br><span class="line">  result = <span class="built_in">exp</span>(<span class="built_in">log</span>(x)*<span class="number">0.5</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// otherwise use an iterative approach</span></span></span><br><span class="line">  . . .</span><br></pre></td></tr></table></figure>
<h1 id="添加生成文件和生成器-Step-5"><a href="#添加生成文件和生成器-Step-5" class="headerlink" title="添加生成文件和生成器 (Step 5)"></a>添加生成文件和生成器 (Step 5)</h1><p>这一节中我们会演示一下怎么添加一个生成的源文件到引用程序的构建过程中。例如说，我们希望在构建过程中创建一个预先计算好的平方根表，然后把这个表格编译进我们的应用程序。首先我们需要一个能生成这张表的程序。在MathFunctions子目录中，定义一个新的源文件MakeTable.cxx:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple program that builds a sqrt table </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">double</span> result;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// make sure we have enough arguments</span></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// open the output file</span></span><br><span class="line">  FILE *fout = fopen(argv[<span class="number">1</span>],<span class="string">"w"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!fout)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// create a source file with a table of square roots</span></span><br><span class="line">  <span class="built_in">fprintf</span>(fout,<span class="string">"double sqrtTable[] = &#123;\n"</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">    result = <span class="built_in">sqrt</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i));</span><br><span class="line">    <span class="built_in">fprintf</span>(fout,<span class="string">"%g,\n"</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// close the table with a zero</span></span><br><span class="line">  <span class="built_in">fprintf</span>(fout,<span class="string">"0&#125;;\n"</span>);</span><br><span class="line">  fclose(fout);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这里的需要传递正确的输出文件给app，然后才会生成table。下一步是在MathFunctions的CMakeList.txt添加相应的命令来编译生成可执行文件MakeTable，然后在编译过程中运行这个程序。如下所示的添加一些命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># first we add the executable that generates the table</span></span><br><span class="line">add_executable(MakeTable MakeTable.cxx)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># add the command to generate the source code</span></span><br><span class="line">add_custom_command (</span><br><span class="line">  OUTPUT <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">  COMMAND MakeTable <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">  DEPENDS MakeTable</span><br><span class="line">  )</span><br><span class="line"> </span><br><span class="line"><span class="comment"># add the binary tree directory to the search path for </span></span><br><span class="line"><span class="comment"># include files</span></span><br><span class="line">include_directories( <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span> )</span><br><span class="line"> </span><br><span class="line"><span class="comment"># add the main library</span></span><br><span class="line">add_library(MathFunctions mysqrt.cxx <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h  )</span><br></pre></td></tr></table></figure>
<ul>
<li>首先添加可执行的MakeTable。</li>
<li>然后我们添加一个用户命令指定怎么通过允许MakeTable来生成Table.h。</li>
<li>下一步需要让CMAKE知道mysqrt.cxx依赖生成的Table.h。把生成的Table.h添加到MathFunctions库的资源列表中。</li>
<li>还需要添加当前的bin的目录添加到include的list中，这样mysqrt.cxx编译时候可以找到Table.h。</li>
<li>最后编译包含Table.h的mysqrt.cxx来生成MathFunctions库<br> 到这儿最上层的CMakeList.txt文件就如下面所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.6)</span><br><span class="line">project (Tutorial)</span><br><span class="line"></span><br><span class="line">include(CTest) </span><br><span class="line"><span class="comment"># The version number.</span></span><br><span class="line"><span class="built_in">set</span> (Tutorial_VERSION_MAJOR 1)</span><br><span class="line"><span class="built_in">set</span> (Tutorial_VERSION_MINOR 0) </span><br><span class="line"></span><br><span class="line"><span class="comment"># does this system provide the log and exp functions?</span></span><br><span class="line">include (<span class="variable">$&#123;CMAKE_ROOT&#125;</span>/Modules/CheckFunctionExists.cmake) check_function_exists (<span class="built_in">log</span> HAVE_LOG)</span><br><span class="line">check_function_exists (exp HAVE_EXP) </span><br><span class="line"></span><br><span class="line"><span class="comment"># should we use our own math functions</span></span><br><span class="line">option(USE_MYMATH <span class="string">"Use tutorial provided math implementation"</span> ON) </span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line">configure_file ( <span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/TutorialConfig.h.in"</span> <span class="string">"<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/TutorialConfig.h"</span> ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line">include_directories (<span class="string">"<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the MathFunctions library?</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH) </span><br><span class="line">  include_directories (<span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions"</span>)</span><br><span class="line">  add_subdirectory (MathFunctions) </span><br><span class="line">  <span class="built_in">set</span> (EXTRA_LIBS <span class="variable">$&#123;EXTRA_LIBS&#125;</span> MathFunctions)</span><br><span class="line">endif (USE_MYMATH) </span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line">add_executable (Tutorial tutorial.cxx)</span><br><span class="line">target_link_libraries (Tutorial <span class="variable">$&#123;EXTRA_LIBS&#125;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># add the install targets</span></span><br><span class="line">install (TARGETS Tutorial DESTINATION bin)</span><br><span class="line">install (FILES <span class="string">"<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/TutorialConfig.h"</span> DESTINATION include) </span><br><span class="line"></span><br><span class="line"><span class="comment"># does the application run</span></span><br><span class="line">add_test (TutorialRuns Tutorial 25) </span><br><span class="line"><span class="comment"># does the usage message work?</span></span><br><span class="line">add_test (TutorialUsage Tutorial)</span><br><span class="line">set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">"Usage:.*number"</span> ) </span><br><span class="line"><span class="comment">#define a macro to simplify adding tests</span></span><br><span class="line">macro (do_test arg result) </span><br><span class="line">  add_test (TutorialComp<span class="variable">$&#123;arg&#125;</span> Tutorial <span class="variable">$&#123;arg&#125;</span>) </span><br><span class="line">  set_tests_properties (TutorialComp<span class="variable">$&#123;arg&#125;</span> PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span> )</span><br><span class="line">endmacro (do_test) </span><br><span class="line"></span><br><span class="line"><span class="comment"># do a bunch of result based tests</span></span><br><span class="line">do_test (4 <span class="string">"4 is 2"</span>)</span><br><span class="line">do_test (9 <span class="string">"9 is 3"</span>)</span><br><span class="line">do_test (5 <span class="string">"5 is 2.236"</span>)</span><br><span class="line">do_test (7 <span class="string">"7 is 2.645"</span>)</span><br><span class="line">do_test (25 <span class="string">"25 is 5"</span>)</span><br><span class="line">do_test (-25 <span class="string">"-25 is 0"</span>)</span><br><span class="line">do_test (0.0001 <span class="string">"0.0001 is 0.01"</span>)</span><br></pre></td></tr></table></figure>
<p>TutorialConfig.h.in 文件如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the configured options and settings for Tutorial</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br><span class="line"><span class="meta">#cmakedefine USE_MYMATH </span></span><br><span class="line"><span class="comment">// does the platform provide exp and log functions?</span></span><br><span class="line"><span class="meta">#cmakedefine HAVE_LOG</span></span><br><span class="line"><span class="meta">#cmakedefine HAVE_EXP</span></span><br></pre></td></tr></table></figure>
<p>MathFunctions的文件CMakeLists.txt如下:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># first we add the executable that generates the table</span></span><br><span class="line">add_executable(MakeTable MakeTable.cxx)</span><br><span class="line"><span class="comment"># add the command to generate the source code</span></span><br><span class="line">add_custom_command ( OUTPUT $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h DEPENDS MakeTable COMMAND MakeTable $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h )</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree directory to the search path </span></span><br><span class="line"><span class="comment"># for include files</span></span><br><span class="line">include_directories( $&#123;CMAKE_CURRENT_BINARY_DIR&#125; ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># add the main library</span></span><br><span class="line">add_library(MathFunctions mysqrt.cxx $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h) </span><br><span class="line">install (TARGETS MathFunctions DESTINATION bin)</span><br><span class="line">install (FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2019/12/28/docker/</url>
    <content><![CDATA[<p><a href="Docker.html">思维导图</a></p>
<h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><a id="more"></a>
<p>几个重要的概念，镜像（image），容器（container），仓库（repository）<br> Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。<br>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。<br>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器<br>至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</p>
<h1 id="docker的安装"><a href="#docker的安装" class="headerlink" title="docker的安装"></a>docker的安装</h1><h2 id="mac下docker的安装"><a href="#mac下docker的安装" class="headerlink" title="mac下docker的安装"></a>mac下docker的安装</h2><p>直接在<code>www.docker.com</code>下载dmg安装包进行安装<br>新版本需要账号（用户名xiaobais）<br>速度过慢可以在下一节中的阿里云镜像加速器中获取</p>
<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h1><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><ol>
<li>dev.aliyun.com进行登录</li>
<li>在服务中搜索-》容器镜像服务</li>
<li>镜像中心-》镜像加速器</li>
<li>按照对应的教程进行</li>
</ol>
<h2 id="docker为什么比虚拟机快"><a href="#docker为什么比虚拟机快" class="headerlink" title="docker为什么比虚拟机快"></a>docker为什么比虚拟机快</h2><p>(1)docker有着比虚拟机更少的抽象层。<br>(2)docker利用的是宿主机的内核,而不需要Guest OS。<br><img src="docker_vm.png" alt=""></p>
<h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><h2 id="docker帮助命令"><a href="#docker帮助命令" class="headerlink" title="docker帮助命令"></a>docker帮助命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>
<h2 id="docker镜像命令"><a href="#docker镜像命令" class="headerlink" title="docker镜像命令"></a>docker镜像命令</h2><ol>
<li><p><code>docker images</code><br>列出本地的镜像模板</p>
<blockquote>
<p>Options<br>-a 列出本地的所有镜像<br>-q 只显示对象的ID<br>—digests: 显示对象的摘要信息<br>—no-trunc: 显示完整的信息</p>
</blockquote>
</li>
<li><p><code>docker search</code></p>
<blockquote>
<p>Options<br>-s 列出点赞数不小于指定值的镜像<br>-no-trunc</p>
</blockquote>
</li>
<li><p><code>docker pull 《镜像名》</code></p>
<blockquote>
<p>Options<br>docker pull 镜像名 等价于 docker pull 镜像名:lastest<br>docker pull 镜像名[:TAG]</p>
</blockquote>
</li>
<li><p><code>docker rmi</code></p>
<blockquote>
<p>Options<br>删除单个镜像 docker rmi -f 镜像名<br>删除多个镜像 docker rmi -f 镜像名:TAG 镜像名2:TAG<br>删除全部  dockr rmi -f $(docker images -qa)</p>
</blockquote>
</li>
</ol>
<h2 id="docker容器命令"><a href="#docker容器命令" class="headerlink" title="docker容器命令"></a>docker容器命令</h2><ol>
<li>新建并启动容器<br><code>docker run [OPTIONS] IMAGE [COMMAND][ARG...]</code><br><code>docker run -it IMAGE</code> 启用交互式容器</li>
</ol>
<blockquote>
<p>OPTIONS<br>—name=”容器的新名字”：为容器制定一个名称<br> -i：以交互模式运行容器，通常与 -t 同时使用；<br>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>-d: 后台运行容器，并返回容器ID，也即启动守护式容器；<br>-P: 随机端口映射；<br>-p: 指定端口映射，有以下四种格式<br>    ip:hostPort:containerPort<br>    ip::containerPort<br>    hostPort:containerPort<br>    containerPort </p>
</blockquote>
<ol>
<li><p>列出所有正在运行的容器<br><code>docker ps</code></p>
<blockquote>
<p>OPTIONS说明（常用）：<br>-a :列出当前所有正在运行的容器+历史上运行过的<br>-l :显示最近创建的容器。<br>-n：显示最近n个创建的容器。<br>-q :静默模式，只显示容器编号。<br>—no-trunc :不截断输出。</p>
</blockquote>
</li>
<li><p>启动容器<br><code>docker start</code></p>
</li>
<li><p>重启容器<br><code>docker restart</code></p>
</li>
<li><p>停止容器<br><code>docker stop</code></p>
</li>
<li><p>强制停止容器<br><code>docker kill</code></p>
</li>
<li><p>删除已停止容器<br><code>docker rm</code><br>删除多个容器</p>
</li>
</ol>
<ul>
<li><code>docker rm -f $(docker ps -a -q)</code></li>
<li><code>docker ps -a -q |xargs docker rm</code></li>
</ul>
<h3 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h3><ol>
<li>启用守护式容器 <code>docker run -d IMAGE</code>  后台运行就会自动退出<br><code>docker run -d mycentos /bin/sh -c &quot;while true;do echo hello xx;sleep 2;done&quot;</code></li>
<li>查看容器日志 <code>docker logs -f -t --tail 容器id</code></li>
<li>查看容器内进程 <code>docker top</code></li>
<li>查看容器内部细节 <code>docker inspect</code></li>
<li>进入正在运行的容器并以命令行交互<ul>
<li>进入容器 <code>docker attach 容器id</code></li>
<li>在容器中执行命令<code>docker exec -it 容器id COMMAND</code></li>
<li>在容器中执行命令并以命令行交互 <code>docker exec -it 容器id /bin/bash</code> 此时使用exit退出容器并不会关闭容器</li>
</ul>
</li>
<li>将容器内数据拷贝到主机上<ul>
<li><code>docker cp 容器id:地址 本地地址</code></li>
</ul>
</li>
<li>提交容器副本，使之成为新的镜像<br><code>docker commit</code><br><code>docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 要创建的镜像的名称:[标签名]</code></li>
</ol>
<h3 id="docker命令总结"><a href="#docker命令总结" class="headerlink" title="docker命令总结"></a>docker命令总结</h3><p><img src="docker_command.png" alt=""></p>
<blockquote>
<p>attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</p>
<p>build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</p>
<p>commit    Create a new image from a container changes   # 提交当前容器为新的镜像</p>
<p>cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</p>
<p>create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</p>
<p>diff      Inspect changes on a container’s filesystem   # 查看 docker 容器变化</p>
<p>events    Get real time events from the server          # 从 docker 服务获取容器实时事件</p>
<p>exec      Run a command in an existing container        # 在已存在的容器上运行命令</p>
<p>export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</p>
<p>history   Show the history of an image                  # 展示一个镜像形成历史</p>
<p>images    List images                                   # 列出系统当前镜像</p>
<p>import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</p>
<p>info      Display system-wide information               # 显示系统相关信息</p>
<p>inspect   Return low-level information on a container   # 查看容器详细信息</p>
<p>kill      Kill a running container                      # kill 指定 docker 容器</p>
<p>load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</p>
<p>login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</p>
<p>logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</p>
<p>logs      Fetch the logs of a container                 # 输出当前容器日志信息</p>
<p>port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</p>
<p>pause     Pause all processes within a container        # 暂停容器</p>
<p>ps        List containers                               # 列出容器列表</p>
<p>pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</p>
<p>push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</p>
<p>restart   Restart a running container                   # 重启运行的容器</p>
<p>rm        Remove one or more containers                 # 移除一个或者多个容器</p>
<p>rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</p>
<p>run       Run a command in a new container              # 创建一个新的容器并运行一个命令</p>
<p>save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</p>
<p>search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</p>
<p>start     Start a stopped containers                    # 启动容器</p>
<p>stop      Stop a running containers                     # 停止容器</p>
<p>tag       Tag an image into a repository                # 给源中镜像打标签</p>
<p>top       Lookup the running processes of a container   # 查看容器中运行的进程信息</p>
<p>unpause   Unpause a paused container                    # 取消暂停容器</p>
<p>version   Show the docker version information           # 查看 docker 版本号</p>
<p>wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</p>
</blockquote>
<h1 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h1><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。<br><strong>UnionFS(联合文件系统)</strong><br>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br><strong>docker镜像加载</strong><br>  docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。<br>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 </p>
<h1 id="docker容器数据卷"><a href="#docker容器数据卷" class="headerlink" title="docker容器数据卷"></a>docker容器数据卷</h1><p>docker容器数据卷目的是将容器产生的数据进行持久化<br>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：<br>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p>
<p><strong>特点</strong>：<br>1：数据卷可在容器之间共享或重用数据<br>2：卷中的更改可以直接生效<br>3：数据卷中的更改不会包含在镜像的更新中<br>4：数据卷的生命周期一直持续到没有容器使用它为止</p>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><ol>
<li>容器内添加<br><code>docker run -it -v /宿主机目录:/容器内目录 镜像名 /bin/bash</code><br><code>docker run -it -v /宿主机目录:/容器内目录:ro 镜像名 /bin/bash</code> 容器内目录只读read only</li>
<li>DockerFile添加<br><code>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># volume test</span><br><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;&#x2F;dataVolumeContainer1&quot;,&quot;&#x2F;dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;finished,--------success1&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<code>docker build -f dockerfile -t newcentos .</code><br>对应的宿主机上的卷地址可以通过<code>docker inspect newcentos</code></li>
</ol>
<p>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied<br>解决办法：在挂载目录后多加一个—privileged=true参数即可</p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器<br>容器见传递共享<code>--volumes-from</code></p>
<p><code>docker run -it --name doc2 --volume-from doc1 centos</code><br>容器之间配置信息传递，数据卷的生命周期一直持续到没有容器使用他为止。</p>
<h1 id="DockerFile解析"><a href="#DockerFile解析" class="headerlink" title="DockerFile解析"></a>DockerFile解析</h1><h2 id="构建三步骤"><a href="#构建三步骤" class="headerlink" title="构建三步骤"></a>构建三步骤</h2><p>编写dockerfile - &gt; docker build - &gt; docker run</p>
<h2 id="内容基础"><a href="#内容基础" class="headerlink" title="内容基础"></a>内容基础</h2><ol>
<li>每条保留字命令都必须为大写字母且后面要跟随至少一个参数</li>
<li><h1 id="表示注释"><a href="#表示注释" class="headerlink" title="表示注释"></a>表示注释</h1></li>
<li>每条指令都会创建一个新的镜像层进行提交</li>
</ol>
<h2 id="docker执行dockerfile的大致流程"><a href="#docker执行dockerfile的大致流程" class="headerlink" title="docker执行dockerfile的大致流程"></a>docker执行dockerfile的大致流程</h2><ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器进行修改</li>
<li>执行类似commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
<h2 id="docker保留字指令"><a href="#docker保留字指令" class="headerlink" title="docker保留字指令"></a>docker保留字指令</h2><ol>
<li>FROM: 基础镜像，当前的新镜像基于哪个镜像</li>
<li>MAINTAINER：镜像维护者姓名和邮箱</li>
<li>RUN：容器构建时需要运行的命令</li>
<li>EXPOSE：当前容器对外暴露出的端口</li>
<li>WORKDIR：指定在创建容器后，终端默认登陆进来的工作目录</li>
<li>ENV：用来在构建镜像过程中设置环境变量</li>
<li>ADD：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</li>
<li>COPY：类似ADD,拷贝文件和目录到镜像中，将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</li>
<li>VOLUME：容器数据卷，用于数据保存与持久化工作</li>
<li>CMD：指定一个容器启动时要执行的命令。dockerfile可以有多个CMD命令，但只有最后一个生效，CMD会被docker run后的参数替换</li>
<li>ENTRYPOINT：指定一个容器启动时要运行的命令。会追加参数</li>
<li>ONBUILD：当构建一个被继承的dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</li>
</ol>
<p><img src="docker_image.png" alt=""></p>
<h2 id="将镜像发布到阿里云"><a href="#将镜像发布到阿里云" class="headerlink" title="将镜像发布到阿里云"></a>将镜像发布到阿里云</h2><p>dev.aliyun.com创建仓库<br>在仓库中的管理按钮中查看帮助文档即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker login --username&#x3D; registry.cn-xxx.aliyuncs.com</span><br><span class="line">sudo docker tag [Imageid] resgistry.cn-xxx.aliyuncs.com&#x2F;xasdf&#x2F;asdff:[镜像版本号]</span><br><span class="line">sudo docker push registry.cn-xxx.aliyuncs.com&#x2F;xasdf&#x2F;asdff:[镜像版本号]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CODE工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>dataclasses数据类</title>
    <url>/2020/07/07/dataclasses%E6%95%B0%E6%8D%AE%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="dataclasses"><a href="#dataclasses" class="headerlink" title="dataclasses"></a>dataclasses</h1><p>官方文档：<a href="https://docs.python.org/zh-cn/3/library/dataclasses.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/dataclasses.html</a><br><a id="more"></a></p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>这个模块提供了一个装饰器和一些函数，用于自动添加生成的 special methods ，例如 <code>__init__()</code> 和 <code>__repr__()</code> 到用户定义的类。 它最初描述于PEP557。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryItem</span>:</span></span><br><span class="line">    <span class="string">'''Class for keeping track of an item in inventory.'''</span></span><br><span class="line">    name: str</span><br><span class="line">    unit_price: float</span><br><span class="line">    quantity_on_hand: int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_cost</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> self.unit_price * self.quantity_on_hand</span><br></pre></td></tr></table></figure>
<p>除其他事情外，将添加<code>__init__()</code>，其看起来像:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, unit_price: float, quantity_on_hand: int=<span class="number">0</span>)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.unit_price = unit_price</span><br><span class="line">    self.quantity_on_hand = quantity_on_hand</span><br></pre></td></tr></table></figure>
<p>请注意，此方法会自动添加到类中：它不会在上面显示的 InventoryItem 定义中直接指定。</p>
<h2 id="模块级装饰器、类和函数"><a href="#模块级装饰器、类和函数" class="headerlink" title="模块级装饰器、类和函数"></a>模块级装饰器、类和函数</h2><ol>
<li><code>@dataclasses.dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)</code><br><strong>dataclass() 的参数有：</strong></li>
</ol>
<ul>
<li><p><code>init</code>: 如果为真值（默认），将生成一个<code>__init__()</code>方法。<br>如果类已定义 <code>__init__()</code> ，则忽略此参数。</p>
</li>
<li><p><code>repr</code>：如果为真值（默认），将生成一个<code>__repr__()</code>方法。 生成的 repr 字符串将具有类名以及每个字段的名称和 repr ，按照它们在类中定义的顺序。不包括标记为从 repr 中排除的字段。 例如：InventoryItem(name=’widget’, unit_price=3.0, quantity_on_hand=10)。</p>
</li>
</ul>
<p>如果类已定义<code>__repr__()</code>，则忽略此参数。</p>
<ul>
<li><code>eq</code>：如果为true（默认值），将生成<code>__eq__()</code>方法。此方法将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。</li>
</ul>
<p>如果类已定义 <code>__eq__()</code> ，则忽略此参数。</p>
<ul>
<li><code>order</code> ：如果为真值（默认为 False ），则 <code>__lt__()</code> 、<code>__le__()</code> 、 <code>__gt__()</code> 和 <code>__ge__()</code> 方法将生成。 这将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。如果 order 为真值并且 eq 为假值 ，则引发 ValueError 。</li>
</ul>
<p>如果类已经定义了 <code>__lt__()</code> 、<code>__le__()</code> 、 <code>__gt__()</code> 或者 <code>__ge__()</code> 中的任意一个，将引发 TypeError 。</p>
<ul>
<li><code>unsafe_hash</code> ：如果为 False （默认值），则根据 eq 和 frozen 的设置方式生成 <code>__hash__()</code> 方法。</li>
</ul>
<p><code>__hash__()</code> 由内置的 hash() 使用，当对象被添加到散列集合（如字典和集合）时。有一个<code>__hash__()</code> 意味着类的实例是不可变的。可变性是一个复杂的属性，取决于程序员的意图， <code>__eq__()</code> 的存在性和行为，以及 dataclass() 装饰器中 eq 和 frozen 标志的值。</p>
<p>默认情况下， dataclass() 不会隐式添加 <code>__hash__()</code> 方法，除非这样做是安全的。 它也不会添加或更改现有的明确定义的 <code>__hash__()</code> 方法。 设置类属性 <code>__hash__ = None</code> 对 Python 具有特定含义，如 <code>__hash__()</code> 文档中所述。</p>
<p>如果 <code>__hash__()</code> 没有显式定义，或者它被设置为 None ，那么 dataclass() 可以 添加一个隐式 <code>__hash__()</code> 方法。虽然不推荐，但你可以强制 dataclass() 用 unsafe<em>hash=True 创建一个 `<em>_hash</em></em>()` 方法。 如果你的类在逻辑上是不可变的但实际仍然可变，则可能就是这种情况。这是一个特殊的用例，应该仔细考虑。</p>
<p>以下是隐式创建 <code>__hash__()</code> 方法的规则。请注意，你不能在数据类中都使用显式的 <code>__hash__()</code> 方法并设置 unsafe_hash=True ；这将导致 TypeError 。</p>
<p>如果 eq 和 frozen 都是 true，默认情况下 dataclass() 将为你生成一个 <code>__hash__()</code> 方法。如果 eq 为 true 且 frozen 为 false ，则 <code>__hash__()</code> 将被设置为 None ，标记它不可用（因为它是可变的）。如果 eq 为 false ，则 <code>__hash__()</code> 将保持不变，这意味着将使用超类的 <code>__hash__()</code> 方法（如果超类是 object ，这意味着它将回到基于id的hash）。</p>
<ul>
<li>frozen: 如为真值 (默认值为 False)，则对字段赋值将会产生异常。 这模拟了只读的冻结实例。 如果在类中定义了 <code>__setattr__()</code> 或<code>__delattr__()</code> 则将会引发 TypeError。 参见下文的讨论。</li>
</ul>
<ol>
<li><code>dataclasses.field(*, default=MISSING, default_factory=MISSING, repr=True, hash=None, init=True, compare=True, metadata=None)</code></li>
</ol>
<p>field() 参数有：</p>
<ul>
<li><p>default ：如果提供，这将是该字段的默认值。这是必需的，因为 field() 调用本身会替换一般的默认值。</p>
</li>
<li><p>default_factory ：如果提供，它必须是一个零参数可调用对象，当该字段需要一个默认值时，它将被调用。除了其他目的之外，这可以用于指定具有可变默认值的字段，如下所述。 同时指定 default 和 default_factory 将产生错误。</p>
</li>
<li><p>init ：如果为true（默认值），则该字段作为参数包含在生成的 <code>__init__()</code> 方法中。</p>
</li>
<li><p>repr ：如果为true（默认值），则该字段包含在生成的 <code>__repr__()</code> 方法返回的字符串中。</p>
</li>
<li><p>compare ：如果为true（默认值），则该字段包含在生成的相等性和比较方法中（ <code>__eq__()</code> ， <code>__gt__()</code> 等等）。</p>
</li>
<li><p>hash ：这可以是布尔值或 None 。如果为true，则此字段包含在生成的 <code>__hash__()</code> 方法中。如果为 None （默认值），请使用 compare 的值，这通常是预期的行为。如果字段用于比较，则应在 hash 中考虑该字段。不鼓励将此值设置为 None 以外的任何值。</p>
</li>
</ul>
<p>设置 hash=False 但 compare=True 的一个可能原因是，如果一个计算 hash 的代价很高的字段是检验等价性需要的，但还有其他字段可以计算类型的 hash 。 即使从 hash 中排除某个字段，它仍将用于比较。</p>
<ul>
<li>metadata ：这可以是映射或 None 。 None 被视为一个空的字典。这个值包含在 MappingProxyType() 中，使其成为只读，并暴露在 Field 对象上。数据类根本不使用它，它是作为第三方扩展机制提供的。多个第三方可以各自拥有自己的键值，以用作元数据中的命名空间。</li>
</ul>
<h2 id="初始化后处理"><a href="#初始化后处理" class="headerlink" title="初始化后处理"></a>初始化后处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    a: float</span><br><span class="line">    b: float</span><br><span class="line">    c: float = field(init=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__post_init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.c = self.a + self.b</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>enum枚举量声明、定义、使用与强类型枚举详解</title>
    <url>/2020/07/22/enum%E6%9E%9A%E4%B8%BE%E9%87%8F%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89%E3%80%81%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>c++中的enum类型<br><a id="more"></a></p>
<h1 id="枚举量的声明"><a href="#枚举量的声明" class="headerlink" title="枚举量的声明"></a>枚举量的声明</h1><h2 id="枚举类型定义"><a href="#枚举类型定义" class="headerlink" title="枚举类型定义"></a>枚举类型定义</h2><p><code>enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};</code></p>
<p>这句话声明了一个enumType类型，声明Monday等为符号常量，默认值为0-6.</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p><code>enumType Weekday</code></p>
<p>也可以在定义枚举类型时定义枚举变量</p>
<p><code>enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday;</code></p>
<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p>在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量。如：<code>Weekday=Sunday</code></p>
<h1 id="自定义枚举量的值"><a href="#自定义枚举量的值" class="headerlink" title="自定义枚举量的值"></a>自定义枚举量的值</h1><p><code>enum enumType {Monday=1, Tuesday=2, Wednesday=3, Thursday=4, Friday=5, Saturday=6, Sunday=7};</code></p>
<p>只定义一部分枚举量的值<code>enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};</code>，这样Monday、Wednesday 均被定义为 1，则 Tuesday=2，Thursday、Friday、Saturday、Sunday 的值默认分别为 2、3、4、5。</p>
<h1 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h1><p>枚举的上限是 大于最大枚举量的 最小的 2 的幂，减去 1。</p>
<p>枚举的下限有两种情况：一、枚举量的最小值不小于 0，则枚举下限取 0；二、枚举量的最小值小于 0，则枚举下限是小于最小枚举量的最大的 2 的幂，加上 1。</p>
<p>如<code>enum enumType1 { First=-5，Second=14，Third=10 };</code>枚举量的上限是16-1=15,枚举的下限是-8+1=-7（-8小于最小枚举量-5，且为2的幂）；</p>
<h1 id="枚举应用"><a href="#枚举应用" class="headerlink" title="枚举应用"></a>枚举应用</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> enumType&#123;Step0, Step1, Step2&#125;Step=Step0; <span class="comment">// 注意这里在声明枚举的时候直接定义了枚举变量 Step,并初始化为 Step0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (Step)x</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> Step0:&#123;...;<span class="keyword">break</span>;&#125;</span><br><span class="line">  <span class="keyword">case</span> Step1:&#123;...;<span class="keyword">break</span>;&#125;</span><br><span class="line">  <span class="keyword">case</span> Step2:&#123;...;<span class="keyword">break</span>;&#125;</span><br><span class="line">  <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外枚举还有一种少见的用法是<code>enum { one ,two ,three};</code>就是不指定一个名字,这样我们自然也没法去定义一些枚举类型了。此时就相当于 <code>static const int one = 0;</code>这样定义三个常量一样。然后用的话就是 <code>int no = one</code>.</p>
<h1 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h1><p>传统C++中枚举常量被暴漏在外层作用域中，这样若是同一作用域下有两个不同的枚举类型，但含有相同的枚举常量也是不可的（如<code>enum Side{Right,Left};enum Thing{Wrong,Right};</code>是不可的）。</p>
<p>强类型枚举使用<code>enum class</code>声明。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumeration</span>&#123;</span></span><br><span class="line">    VAL1,</span><br><span class="line">    VAL2,</span><br><span class="line">    VAL3=<span class="number">100</span>,</span><br><span class="line">    VAL4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样，枚举类型时安全的，枚举值也不会被隐式转换为整数，无法和整数数值比较，比如（Enumeration：：VAL4==10会触发编译错误）。</p>
<p>另外枚举类型所使用的类型默认为int类型，也可指定其他类型，比如：<br><code>enum class Enum:unsigned int{VAL1,VAL2};</code></p>
<p><strong>强类型枚举能解决传统枚举不同枚举类下同枚举值名的问题，使用枚举类型的枚举名时，必须指明所属范围，比如：Enum::VAL1，而单独的VAL1则不再具有意义。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>excel文件读写（python）</title>
    <url>/2020/07/01/excel%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<p>由于后面的项目需要直接处理excel表格（xls，xlsx等），因此，对excel处理的相关工具进行学习。<br><a id="more"></a></p>
<p>对于<strong>csv文件</strong>，由于其本质为文本格式，可以直接进行方便的读写操作</p>
<p>通过python对excel表格文件进行处理有多种方式：pandas，openpyxl，xlrd，xlutils和pyexcel之类的软件包都提供了与excel文件交互的接口。</p>
<h1 id="1-pandas与excel"><a href="#1-pandas与excel" class="headerlink" title="1.pandas与excel"></a>1.pandas与excel</h1><h2 id="pandas读取excel"><a href="#pandas读取excel" class="headerlink" title="pandas读取excel"></a>pandas读取excel</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">file = <span class="string">'example.xlsx'</span></span><br><span class="line">xl = pd.ExcelFile(file)</span><br><span class="line">print(xl.sheet_names)</span><br><span class="line">df1 = xl.parse(<span class="string">'Sheet1'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>pd.ExcelFile vs pd.read_excel</strong><br>pd.ExcelFile是一个类，而read_excel是一个方法<br>在最新版本的pandas中，read_excel确保它具有一个ExcelFile对象（如果没有则创建一个对象），然后_parse_excel直接调用该方法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(io, ExcelFile):</span><br><span class="line">    io = ExcelFile(io, engine=engine)</span><br><span class="line"><span class="keyword">return</span> io._parse_excel(...)</span><br></pre></td></tr></table></figure><br>通过更新的（统一的）参数处理，ExcelFile.parse实际上仅是一条语句：<br><code>return self._parse_excel(...)</code></p>
</blockquote>
<h2 id="pandas写入excel"><a href="#pandas写入excel" class="headerlink" title="pandas写入excel"></a>pandas写入excel</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Install `XlsxWriter`</span></span><br><span class="line">!pip install XlsxWriter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># Specify a writer</span></span><br><span class="line">writer = pd.ExcelWriter(<span class="string">'example.xlsx'</span>, engine=<span class="string">'xlsxwriter'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write your DataFrame to a file   </span></span><br><span class="line"><span class="comment"># yourData is a dataframe that you are interested in writing as an excel file</span></span><br><span class="line">yourData.to_excel(writer, <span class="string">'Sheet1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the result</span></span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>
<h1 id="2-openpyxl与excel"><a href="#2-openpyxl与excel" class="headerlink" title="2.openpyxl与excel"></a>2.openpyxl与excel</h1><p>openpyxl支持.xlsx，xlsm，xltx，和xltm等格式</p>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import `load_workbook` module from `openpyxl`</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># Load in the workbook</span></span><br><span class="line">wb = load_workbook(<span class="string">'test.xlsx'</span>)</span><br><span class="line"><span class="comment"># Get sheet names</span></span><br><span class="line">print(wb.sheetnames)</span><br></pre></td></tr></table></figure>
<h2 id="查看activate-sheet"><a href="#查看activate-sheet" class="headerlink" title="查看activate sheet"></a>查看activate sheet</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get a sheet by name</span></span><br><span class="line">sheet = wb[<span class="string">'Sheet1'</span>]</span><br><span class="line"><span class="comment"># Print the sheet title</span></span><br><span class="line">print(<span class="string">'Sheet Title:'</span>,sheet.title)</span><br><span class="line"><span class="comment"># Get currently active sheet</span></span><br><span class="line">anotherSheet = wb.active</span><br><span class="line"><span class="comment"># Check `anotherSheet`</span></span><br><span class="line">print(anotherSheet)</span><br></pre></td></tr></table></figure>
<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>获取某个单元格的信息<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Retrieve the value of a certain cell</span></span><br><span class="line">print(sheet[<span class="string">'A1'</span>].value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select element 'B3' of your sheet</span></span><br><span class="line">c = sheet[<span class="string">'B3'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve the row number of your element</span></span><br><span class="line">print(<span class="string">'Row No.:'</span>, c.row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve the column number of your element</span></span><br><span class="line">print(<span class="string">'Column Letter:'</span>, c.column)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve the coordinates of the cell</span></span><br><span class="line">print(<span class="string">'Coordinates of cell:'</span>, c.coordinate)</span><br><span class="line"></span><br><span class="line"><span class="comment">###################</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">ID</span><br><span class="line">Row No.: <span class="number">3</span></span><br><span class="line">Column Letter: <span class="number">2</span></span><br><span class="line">Coordinates of cell: B3</span><br></pre></td></tr></table></figure></p>
<p>获取某个位置的单元格<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(sheet.cell(row&#x3D;1, column&#x3D;2).value)</span><br></pre></td></tr></table></figure></p>
<p>openpyxl有一个<code>utility</code>有两个方法<code>get_column_letter</code>和<code>column_index_from_string</code>。顾名思义，前者返回给定字母的数字/整数，后者返回提供字母的数字作为字符串。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import relevant modules from `openpyxl.utils`</span></span><br><span class="line"><span class="keyword">from</span> openpyxl.utils <span class="keyword">import</span> get_column_letter, column_index_from_string</span><br><span class="line"><span class="comment"># Return 'A'</span></span><br><span class="line">print(<span class="string">'Column Letter:'</span>, get_column_letter(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># Return '1'</span></span><br><span class="line">print(<span class="string">'Column Index:'</span>, column_index_from_string(<span class="string">'A'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># return</span></span><br><span class="line">Column Letter: A</span><br><span class="line">Column Index: <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cellObj <span class="keyword">in</span> sheet[<span class="string">'A1'</span>:<span class="string">'C3'</span>]:</span><br><span class="line">      <span class="keyword">for</span> cell <span class="keyword">in</span> cellObj:</span><br><span class="line">              print(cell.coordinate, cell.value)</span><br><span class="line">      print(<span class="string">'--- END ---'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="sheet属性"><a href="#sheet属性" class="headerlink" title="sheet属性"></a>sheet属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Retrieve the maximum amount of rows</span></span><br><span class="line">print(<span class="string">'Max Rows:'</span>, sheet.max_row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve the maximum amount of columns</span></span><br><span class="line">print(<span class="string">'Max Columns:'</span>, sheet.max_column)</span><br></pre></td></tr></table></figure>
<h2 id="与pandas结合使用"><a href="#与pandas结合使用" class="headerlink" title="与pandas结合使用"></a>与pandas结合使用</h2><p>可以使用Pandas包中的函数将工作表的值放入DataFrame中，然后使用DataFrame函数来分析和处理数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import `pandas`</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert Sheet to DataFrame</span></span><br><span class="line">df = pd.DataFrame(sheet.values)</span><br></pre></td></tr></table></figure></p>
<p>如果要指定标头和索引，则可以传递标头参数，其中标头和索引的列表为True，但是，由于转换为数据框的工作表已经包含标头，因此不需要添加标头：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the sheet values in `data`</span></span><br><span class="line">data = sheet.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># Indicate the columns in the sheet values</span></span><br><span class="line">cols = next(data)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert your data to a list</span></span><br><span class="line">data = list(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the data at index 0 for the indices</span></span><br><span class="line">idx = [r[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> data]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Slice the data at index 1</span></span><br><span class="line">data = (islice(r, <span class="number">1</span>, <span class="literal">None</span>) <span class="keyword">for</span> r <span class="keyword">in</span> data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make your DataFrame</span></span><br><span class="line">df = pd.DataFrame(data, index=idx, columns=cols)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></p>
<h2 id="写回excel文件"><a href="#写回excel文件" class="headerlink" title="写回excel文件"></a>写回excel文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import `dataframe_to_rows`</span></span><br><span class="line"><span class="keyword">from</span> openpyxl.utils.dataframe <span class="keyword">import</span> dataframe_to_rows</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a workbook</span></span><br><span class="line">wb = Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the worksheet in the active workbook</span></span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># Append the rows of the DataFrame to your worksheet</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> dataframe_to_rows(df, index=<span class="literal">True</span>, header=<span class="literal">True</span>):</span><br><span class="line">    ws.append(r)</span><br></pre></td></tr></table></figure>
<h1 id="3-xlrd与excel"><a href="#3-xlrd与excel" class="headerlink" title="3.xlrd与excel"></a>3.xlrd与excel</h1><h2 id="读取xls和xlxs格式的文件"><a href="#读取xls和xlxs格式的文件" class="headerlink" title="读取xls和xlxs格式的文件"></a>读取xls和xlxs格式的文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import `xlrd`</span></span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open a workbook</span></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">'test.xlsx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loads only current sheets to memory</span></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">'test.xlsx'</span>, on_demand = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load a specific sheet by name</span></span><br><span class="line">worksheet = workbook.sheet_by_name(<span class="string">'Sheet1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load a specific sheet by index</span></span><br><span class="line">worksheet = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve the value from cell at indices (0,0)</span></span><br><span class="line">sheet.cell(<span class="number">1</span>, <span class="number">1</span>).value</span><br><span class="line">print(sheet1.cell(<span class="number">1</span>,<span class="number">0</span>).value)<span class="comment">#获取表格里的内容，三种方式</span></span><br><span class="line"></span><br><span class="line">print(sheet1.cell_value(<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">print(sheet1.row(<span class="number">1</span>)[<span class="number">0</span>].value)</span><br></pre></td></tr></table></figure>
<h1 id="4-xlwt与excel"><a href="#4-xlwt与excel" class="headerlink" title="4.xlwt与excel"></a>4.xlwt与excel</h1><p>xlwt创建电子表格。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import `xlwt`</span></span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a workbook</span></span><br><span class="line">book = xlwt.Workbook(encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a sheet to the workbook</span></span><br><span class="line">sheet1 = book.add_sheet(<span class="string">"Python Sheet 1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write to the sheet of the workbook</span></span><br><span class="line">sheet1.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"This is the First Cell of the First Sheet"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the workbook</span></span><br><span class="line">book.save(<span class="string">"spreadsheet.xls"</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Initialize a workbook</span></span><br><span class="line">book = xlwt.Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a sheet to the workbook</span></span><br><span class="line">sheet1 = book.add_sheet(<span class="string">"Sheet1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The data</span></span><br><span class="line">cols = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>]</span><br><span class="line">txt = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loop over the rows and columns and fill in the values</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    row = sheet1.row(num)</span><br><span class="line">    <span class="keyword">for</span> index, col <span class="keyword">in</span> enumerate(cols):</span><br><span class="line">        value = txt[index] + num</span><br><span class="line">        row.write(index, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the result</span></span><br><span class="line">book.save(<span class="string">"test.xls"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置表格样式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_style</span><span class="params">(name,height,bold=False)</span>:</span></span><br><span class="line">	style = xlwt.XFStyle()</span><br><span class="line">	font = xlwt.Font()</span><br><span class="line">	font.name = name</span><br><span class="line">	font.bold = bold</span><br><span class="line">	font.color_index = <span class="number">4</span></span><br><span class="line">	font.height = height</span><br><span class="line">	style.font = font</span><br><span class="line">	<span class="keyword">return</span> style</span><br><span class="line"></span><br><span class="line"><span class="comment">#写Excel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_excel</span><span class="params">()</span>:</span></span><br><span class="line">	f = xlwt.Workbook()</span><br><span class="line">	sheet1 = f.add_sheet(<span class="string">'学生'</span>,cell_overwrite_ok=<span class="literal">True</span>)</span><br><span class="line">	row0 = [<span class="string">"姓名"</span>,<span class="string">"年龄"</span>,<span class="string">"出生日期"</span>,<span class="string">"爱好"</span>]</span><br><span class="line">	colum0 = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"恋习Python"</span>,<span class="string">"小明"</span>,<span class="string">"小红"</span>,<span class="string">"无名"</span>]</span><br><span class="line">	<span class="comment">#写第一行</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(row0)):</span><br><span class="line">		sheet1.write(<span class="number">0</span>,i,row0[i],set_style(<span class="string">'Times New Roman'</span>,<span class="number">220</span>,<span class="literal">True</span>))</span><br><span class="line">	<span class="comment">#写第一列</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(colum0)):</span><br><span class="line">		sheet1.write(i+<span class="number">1</span>,<span class="number">0</span>,colum0[i],set_style(<span class="string">'Times New Roman'</span>,<span class="number">220</span>,<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">	sheet1.write(<span class="number">1</span>,<span class="number">3</span>,<span class="string">'2006/12/12'</span>)</span><br><span class="line">	sheet1.write_merge(<span class="number">6</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="string">'未知'</span>)<span class="comment">#合并行单元格</span></span><br><span class="line">	sheet1.write_merge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">'打游戏'</span>)<span class="comment">#合并列单元格</span></span><br><span class="line">	sheet1.write_merge(<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">'打篮球'</span>)</span><br><span class="line"></span><br><span class="line">	f.save(<span class="string">'test.xls'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	write_excel()</span><br></pre></td></tr></table></figure>
<h1 id="5-pyexcel与excel"><a href="#5-pyexcel与excel" class="headerlink" title="5.pyexcel与excel"></a>5.pyexcel与excel</h1><p>pyexcel提供用于读取，操作和在写入数据的单个API接口（.csv，.ods，.xls，.xlsx，和.xlsm文件）。使用pyexcel，可以用最少的代码将excel文件中的数据转换为数组或dict格式。</p>
<h2 id="数组格式"><a href="#数组格式" class="headerlink" title="数组格式"></a>数组格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import `pyexcel`</span></span><br><span class="line"><span class="keyword">import</span> pyexcel</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get an array from the data</span></span><br><span class="line">my_array = pyexcel.get_array(file_name=<span class="string">"test.xls"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="字典格式"><a href="#字典格式" class="headerlink" title="字典格式"></a>字典格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import `OrderedDict` module</span></span><br><span class="line"><span class="keyword">from</span> pyexcel._compact <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get your data in an ordered dictionary of lists</span></span><br><span class="line">my_dict = pyexcel.get_dict(file_name=<span class="string">"test.xls"</span>, name_columns_by_row=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>还可以获得二维数组的字典。简而言之，您可以借助该get_book_dict()功能将所有工作簿表提取到一个字典中。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get your data in a dictionary of 2D arrays</span></span><br><span class="line">book_dict = pyexcel.get_book_dict(file_name=<span class="string">"test.xls"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="写入excel文件"><a href="#写入excel文件" class="headerlink" title="写入excel文件"></a>写入excel文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get the data</span></span><br><span class="line">data = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the array to a file</span></span><br><span class="line">pyexcel.save_as(array=data, dest_file_name=<span class="string">"array_data.xls"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The data</span></span><br><span class="line">d2_array_dictionary = &#123;<span class="string">'Sheet 1'</span>: [</span><br><span class="line">                                   [<span class="string">'ID'</span>, <span class="string">'AGE'</span>, <span class="string">'SCORE'</span>]</span><br><span class="line">                                   [<span class="number">1</span>, <span class="number">22</span>, <span class="number">5</span>],</span><br><span class="line">                                   [<span class="number">2</span>, <span class="number">15</span>, <span class="number">6</span>],</span><br><span class="line">                                   [<span class="number">3</span>, <span class="number">28</span>, <span class="number">9</span>]</span><br><span class="line">                                  ],</span><br><span class="line">                       <span class="string">'Sheet 2'</span>: [</span><br><span class="line">                                    [<span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span>],</span><br><span class="line">                                    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                                    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">                                    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">                                  ],</span><br><span class="line">                       <span class="string">'Sheet 3'</span>: [</span><br><span class="line">                                    [<span class="string">'M'</span>, <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'P'</span>],</span><br><span class="line">                                    [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">                                    [<span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]</span><br><span class="line">                                    [<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>]</span><br><span class="line">                                   ]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the data to a file                        </span></span><br><span class="line">pyexcel.save_book_as(bookdict=d2_array_dictionary, dest_file_name=<span class="string">"2d_array_data.xls"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="6-csv库"><a href="#6-csv库" class="headerlink" title="6. csv库"></a>6. csv库</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import `csv`</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in csv file</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> csv.reader(open(<span class="string">'data.csv'</span>), delimiter=<span class="string">','</span>):</span><br><span class="line">      print(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write csv file</span></span><br><span class="line">data = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">outfile = open(<span class="string">'data.csv'</span>, <span class="string">'w'</span>)</span><br><span class="line">writer = csv.writer(outfile, delimiter=<span class="string">';'</span>, quotechar=<span class="string">'"'</span>)</span><br><span class="line">writer.writerows(data)</span><br><span class="line">outfile.close()</span><br></pre></td></tr></table></figure>
<h1 id="7-xlsxwriter库"><a href="#7-xlsxwriter库" class="headerlink" title="7. xlsxwriter库"></a>7. xlsxwriter库</h1><p><a href="https://xlsxwriter.readthedocs.io/" target="_blank" rel="noopener">官方文档</a></p>
<p>xlsxwriter库可以在excel文件中使用excel自带的绘图进行绘制<br>简单使用：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlsxwriter</span><br><span class="line"></span><br><span class="line">workbook = xlsxwriter.Workbook(<span class="string">'hello.xlsx'</span>)</span><br><span class="line">worksheet = workbook.add_worksheet()</span><br><span class="line"></span><br><span class="line">worksheet.write(<span class="string">'A1'</span>, <span class="string">'Hello world'</span>)</span><br><span class="line"></span><br><span class="line">workbook.close()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在XlsxWriter中，行和列都是零索引。工作表中的第一个单元格A1是(0, 0)。</li>
</ul>
<h2 id="设置行高"><a href="#设置行高" class="headerlink" title="设置行高"></a>设置行高</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sheet_handle.set_default_row(<span class="number">30</span>)</span><br><span class="line">sheet_handle.set_row(cur_row, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<h2 id="设置单元格格式"><a href="#设置单元格格式" class="headerlink" title="设置单元格格式"></a>设置单元格格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title_format = workbook_handle.add_format(&#123;<span class="string">"font_name"</span>: <span class="string">"Arial"</span>, <span class="string">"bold"</span>: <span class="literal">True</span>, <span class="string">"font_size"</span>: <span class="number">20</span>&#125;)</span><br><span class="line">sheet_handle.write(cur_row, <span class="number">0</span>, description_info[<span class="string">"title"</span>], title_format)</span><br></pre></td></tr></table></figure>
<h2 id="添加图表"><a href="#添加图表" class="headerlink" title="添加图表"></a>添加图表</h2><p><a href="https://xlsxwriter.readthedocs.io/chart.html" target="_blank" rel="noopener">https://xlsxwriter.readthedocs.io/chart.html</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chart = workbook.add_chart(&#123;<span class="string">'type'</span>: <span class="string">'column'</span>&#125;)</span><br><span class="line">worksheet.insert_chart(<span class="string">'A7'</span>, chart)</span><br></pre></td></tr></table></figure></p>
<p><strong>type可用类型</strong>：bar、column、doughnut、line、pie、radar、scatter、stock</p>
<h3 id="添加序列"><a href="#添加序列" class="headerlink" title="添加序列"></a>添加序列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chart.add_series(&#123;</span><br><span class="line">    <span class="string">'categories'</span>: <span class="string">'=Sheet1!$A$1:$A$5'</span>,</span><br><span class="line">    <span class="string">'values'</span>:     <span class="string">'=Sheet1!$B$1:$B$5'</span>,</span><br><span class="line">    <span class="string">'line'</span>:       &#123;<span class="string">'color'</span>: <span class="string">'red'</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or using a list of values instead of category/value formulas:</span></span><br><span class="line"><span class="comment">#     [sheetname, first_row, first_col, last_row, last_col]</span></span><br><span class="line">chart.add_series(&#123;</span><br><span class="line">    <span class="string">'categories'</span>: [<span class="string">'Sheet1'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="string">'values'</span>:     [<span class="string">'Sheet1'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">'line'</span>:       &#123;<span class="string">'color'</span>: <span class="string">'red'</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>序列可设置的参数：</p>
<ul>
<li><p>values：这是系列中最重要的属性，并且是每个图表对象的唯一必需选项。此选项将图表与其显示的工作表数据链接起来。可以使用上面第一个示例中所示的公式或使用第二个示例中所示的值列表来设置数据范围。</p>
</li>
<li><p>categories：这将设置图表类别标签。类别与X轴大致相同。在大多数图表类型中，该categories 属性是可选的，图表仅假设的序列为 1..n。</p>
</li>
<li><p>name：设置系列的名称。名称显示在编辑栏中。对于非饼图/甜甜圈图，它也会显示在图例中。name属性是可选的，如果未提供，则默认为 。名称也可以是公式，例如或带有工作表名称，行和列的列表，例如。Series 1..n=Sheet1!$A$1[‘Sheet1’, 0, 0]</p>
</li>
<li><p>line：设置系列线型的属性，例如颜色和宽度。请参阅图表格式：线。</p>
</li>
<li><p>border：设置系列的边框属性，例如颜色和样式。请参阅图表格式：边框。</p>
</li>
<li><p>fill：设置系列的实心填充属性，例如颜色。请参阅 图表格式：实心填充。</p>
</li>
<li><ul>
<li>pattern：设置系列的图案填充属性。请参阅 图表格式：模式填充。</li>
</ul>
</li>
<li><p>gradient：设置系列的渐变填充属性。请参阅 图表格式：“渐变填充”。</p>
</li>
<li><p>marker：设置系列标记的属性，例如样式和颜色。请参阅图表系列选项：标记。</p>
</li>
<li><p>trendline：设置系列趋势线的属性，例如线性，多项式和移动平均线类型。请参阅 图表系列选项：趋势线。</p>
</li>
<li><p>smooth：设置线系列的平滑属性。</p>
</li>
<li><p>y_error_bars：设置图表系列的垂直误差范围。请参阅 图表系列选项：误差线。</p>
</li>
<li><p>x_error_bars：设置图表系列的水平误差范围。请参阅 图表系列选项：误差线。</p>
</li>
<li><p>data_labels：设置系列的数据标签。请参阅 图表系列选项：数据标签。</p>
</li>
<li><p>points：设置系列中各个点的属性。请参阅 图表系列选项：点。</p>
</li>
<li><p>invert_if_negative：将填充颜色反转为负值。通常仅适用于柱状图和条形图。</p>
</li>
<li><p>overlap：在条形图/柱形图中设置系列之间的重叠。范围是+/-100。默认值为0：</p>
</li>
<li><p>gap：在条形图/柱形图中设置系列之间的间隔。范围是0到500。默认值是150：</p>
</li>
</ul>
<h3 id="设置轴属性"><a href="#设置轴属性" class="headerlink" title="设置轴属性"></a>设置轴属性</h3><p><code>chart.set_x_axis()</code></p>
<p>辅助x轴<code>chart.set_x2_axis()</code></p>
<h3 id="合并图表"><a href="#合并图表" class="headerlink" title="合并图表"></a>合并图表</h3><p><code>chart.combine（）</code></p>
<h3 id="设置大小"><a href="#设置大小" class="headerlink" title="设置大小"></a>设置大小</h3><p><code>chart.set_size()</code>可设置的属性：width、height、x_scale、y_scale、x_offset、y_offset</p>
<p><code>offset</code>也可通过<code>worksheet.insert_chart(&#39;E2&#39;, chart, {&#39;x_offset&#39;: 25, &#39;y_offset&#39;: 10})</code>设定</p>
<h3 id="设置标题"><a href="#设置标题" class="headerlink" title="设置标题"></a>设置标题</h3><p><code>chart.set_title({&#39;name&#39;: &#39;Year End Results&#39;})</code></p>
<h3 id="设置图例"><a href="#设置图例" class="headerlink" title="设置图例"></a>设置图例</h3><p><code>chart.set_legend({&#39;none&#39;: True})</code></p>
<h2 id="notation的转换"><a href="#notation的转换" class="headerlink" title="notation的转换"></a>notation的转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xlsxwriter.utility <span class="keyword">import</span> xl_rowcol_to_cell</span><br><span class="line"></span><br><span class="line">cell = xl_rowcol_to_cell(<span class="number">0</span>, <span class="number">0</span>)   <span class="comment"># A1</span></span><br><span class="line">cell = xl_rowcol_to_cell(<span class="number">0</span>, <span class="number">1</span>)   <span class="comment"># B1</span></span><br><span class="line">cell = xl_rowcol_to_cell(<span class="number">1</span>, <span class="number">0</span>)   <span class="comment"># A2</span></span><br><span class="line"></span><br><span class="line">str = xl_rowcol_to_cell(<span class="number">0</span>, <span class="number">0</span>, col_abs=<span class="literal">True</span>)                <span class="comment"># $A1</span></span><br><span class="line">str = xl_rowcol_to_cell(<span class="number">0</span>, <span class="number">0</span>, row_abs=<span class="literal">True</span>)                <span class="comment"># A$1</span></span><br><span class="line">str = xl_rowcol_to_cell(<span class="number">0</span>, <span class="number">0</span>, row_abs=<span class="literal">True</span>, col_abs=<span class="literal">True</span>)  <span class="comment"># $A$1</span></span><br><span class="line"></span><br><span class="line">column = xl_col_to_name(<span class="number">0</span>, <span class="literal">False</span>)  <span class="comment"># A</span></span><br><span class="line">column = xl_col_to_name(<span class="number">0</span>, <span class="literal">True</span>)   <span class="comment"># $A</span></span><br><span class="line">column = xl_col_to_name(<span class="number">1</span>, <span class="literal">True</span>)   <span class="comment"># $B</span></span><br><span class="line"></span><br><span class="line">cell_range = xl_range(<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>)  <span class="comment"># A1:A10</span></span><br><span class="line">cell_range = xl_range(<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>)  <span class="comment"># C2:C9</span></span><br><span class="line">cell_range = xl_range(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># A1:E4</span></span><br><span class="line"></span><br><span class="line">cell_range = xl_range_abs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>)  <span class="comment"># $A$1:$A$10</span></span><br><span class="line">cell_range = xl_range_abs(<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>)  <span class="comment"># $C$2:$C$9</span></span><br><span class="line">cell_range = xl_range_abs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># $A$1:$E$4</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
  </entry>
  <entry>
    <title>github_clone慢</title>
    <url>/2021/02/04/github-clone%E6%85%A2/</url>
    <content><![CDATA[<p>最近在使用github时，发现从服务器clone到本地非常慢，查找了很多解决方案，最终决定使用配置git代理的方式来进行实现。</p>
<a id="more"></a>
<p>git clone慢：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line"></span><br><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:10809</span><br><span class="line">git config --global https.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:10809</span><br><span class="line"></span><br><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:10808</span><br><span class="line">git config --global https.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:10808</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODE工具</category>
      </categories>
  </entry>
  <entry>
    <title>fortran语法</title>
    <url>/2020/04/04/fortran%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>把fortran的语法简单总结一下,方便以后查阅<br><a id="more"></a></p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> program_name</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">! type declaration statements      </span></span><br><span class="line"><span class="comment">! executable statements  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> program_name</span><br></pre></td></tr></table></figure>
<h2 id="加法fortran程序"><a href="#加法fortran程序" class="headerlink" title="加法fortran程序"></a>加法fortran程序</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> addNumbers</span><br><span class="line"></span><br><span class="line"><span class="comment">! This simple program adds two numbers     </span></span><br><span class="line">   <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">! Type declarations</span></span><br><span class="line">   <span class="keyword">real</span> :: a, b, result </span><br><span class="line">   </span><br><span class="line"><span class="comment">! Executable statements </span></span><br><span class="line">   a = <span class="number">12.0</span></span><br><span class="line">   b = <span class="number">15.0</span></span><br><span class="line">   result = a + b</span><br><span class="line">   <span class="built_in">print</span> *, <span class="string">'The total is '</span>, result                   </span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> addNumbers</span><br></pre></td></tr></table></figure>
<ul>
<li>所有Fortran程序start关键字程序和end关键字结束程序，然后是该程序的名称。        </li>
<li>隐无语句允许编译器检查所有的变量类型是正确声明。必须始终使用无隐在每个程序的开始。</li>
<li>在Fortran语言注释开始使用感叹号（！），因为在这之后的所有字符（除字符串）被编译器忽略。</li>
<li>print*命令在屏幕上显示数据。</li>
<li>代码行缩进，是保持一个程序读取一个很好的做法。</li>
<li>Fortran语言允许大写和小写字母。 Fortran语言是区分大小写的，除了字符串常量。</li>
</ul>
<h1 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h1><p>Fortran语言提供了五种内在数据类型：整型(integer),实型(real),复杂类型(complex，储存复数)，逻辑类型(logical)，字符类型(character)<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> testing</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="comment">!4bytes整数</span></span><br><span class="line">    <span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">4</span>)::largeval</span><br><span class="line">    <span class="comment">!输出integer允许的最大值</span></span><br><span class="line">    <span class="built_in">print</span> *,<span class="built_in">huge</span>(largeval)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">real</span>::p,q</span><br><span class="line"></span><br><span class="line">    <span class="comment">!如果不指定长度，默认为1</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">40</span>)::<span class="keyword">name</span></span><br><span class="line">    <span class="keyword">name</span> = <span class="string">"zara ali"</span></span><br><span class="line">    <span class="comment">!name(1:4)得到zara</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> testing</span><br></pre></td></tr></table></figure></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量声明<code>type-specifier :: variable_name</code><br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: total  	</span><br><span class="line"><span class="keyword">real</span> :: average </span><br><span class="line"><span class="keyword">complex</span> :: cx  </span><br><span class="line"><span class="keyword">logical</span> :: done </span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">80</span>) :: message <span class="comment">! a string of 80 characters</span></span><br></pre></td></tr></table></figure></p>
<p>变量赋值<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">total = <span class="number">20000</span>  </span><br><span class="line">average = <span class="number">1666.67</span>   </span><br><span class="line">done = .true.   </span><br><span class="line">message = “A big Hello from Tutorials Point” </span><br><span class="line">cx = (<span class="number">3.0</span>, <span class="number">5.0</span>) <span class="comment">! cx = 3.0 + 5.0i</span></span><br></pre></td></tr></table></figure></p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!parameter 表示常量</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: pi = <span class="number">3.1415927</span></span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!算术运算符</span></span><br><span class="line">+,-,*,/,**</span><br><span class="line"></span><br><span class="line"><span class="comment">!关系运算符</span></span><br><span class="line">== <span class="comment">!等于</span></span><br><span class="line">/= <span class="comment">!不等</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;</span><br><span class="line">&gt;=</span><br><span class="line">&lt;=</span><br><span class="line"></span><br><span class="line"><span class="comment">!逻辑运算符</span></span><br><span class="line">.and.</span><br><span class="line">.or.</span><br><span class="line">.not.</span><br><span class="line">.eqv.</span><br><span class="line">.neqv.</span><br></pre></td></tr></table></figure>
<h1 id="fortran选择决策"><a href="#fortran选择决策" class="headerlink" title="fortran选择决策"></a>fortran选择决策</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>普通if<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">logical</span> expression) <span class="keyword">then</span>      </span><br><span class="line">   statement  </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">logical</span> expression) <span class="keyword">then</span>      </span><br><span class="line">   statement(s)  </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   other_statement(s)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">name</span>:] </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">logical</span> expression <span class="number">1</span>) <span class="keyword">then</span> </span><br><span class="line">   <span class="comment">! block 1   </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">logical</span> expression <span class="number">2</span>) <span class="keyword">then</span>       </span><br><span class="line">   <span class="comment">! block 2   </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">logical</span> expression <span class="number">3</span>) <span class="keyword">then</span>       </span><br><span class="line">   <span class="comment">! block 3  </span></span><br><span class="line"><span class="keyword">else</span>       </span><br><span class="line">   <span class="comment">! block 4   </span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> [<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure></p>
<p>命名if例子：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> markGradeA  </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span>  </span><br><span class="line">   <span class="keyword">real</span> :: marks</span><br><span class="line">   <span class="comment">! assign marks   </span></span><br><span class="line">   marks = <span class="number">90.4</span></span><br><span class="line">   <span class="comment">! use an if statement to give grade</span></span><br><span class="line">  </span><br><span class="line">   gr: <span class="keyword">if</span> (marks &gt; <span class="number">90.0</span>) <span class="keyword">then</span>  </span><br><span class="line">   <span class="built_in">print</span> *, <span class="string">" Grade A"</span></span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">if</span> gr</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> markGradeA</span><br></pre></td></tr></table></figure></p>
<h1 id="select-case结构"><a href="#select-case结构" class="headerlink" title="select case结构"></a>select case结构</h1><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">name</span>:] <span class="keyword">select</span> <span class="keyword">case</span> (expression) </span><br><span class="line">   <span class="keyword">case</span> (selector1)          </span><br><span class="line">   <span class="comment">! some statements          </span></span><br><span class="line">   ... <span class="keyword">case</span> (selector2)           </span><br><span class="line">   <span class="comment">! other statements           </span></span><br><span class="line">   ...       </span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">default</span>          </span><br><span class="line">   <span class="comment">! more statements          </span></span><br><span class="line">   ...   </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">select</span> [<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure>
<p>也可以指定为一个范围<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> selectCaseProg</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">! local variable declaration</span></span><br><span class="line">   <span class="keyword">integer</span> :: marks = <span class="number">78</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">select</span> <span class="keyword">case</span> (marks)</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">case</span> (<span class="number">91</span>:<span class="number">100</span>) </span><br><span class="line">         <span class="built_in">print</span>*, <span class="string">"Excellent!"</span> </span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> (<span class="number">81</span>:<span class="number">90</span>)</span><br><span class="line">         <span class="built_in">print</span>*, <span class="string">"Very good!"</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> (<span class="number">71</span>:<span class="number">80</span>) </span><br><span class="line">         <span class="built_in">print</span>*, <span class="string">"Well done!"</span> </span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> (<span class="number">61</span>:<span class="number">70</span>)</span><br><span class="line">         <span class="built_in">print</span>*, <span class="string">"Not bad!"</span> </span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> (<span class="number">41</span>:<span class="number">60</span>)</span><br><span class="line">         <span class="built_in">print</span>*, <span class="string">"You passed!"</span>  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> (:<span class="number">40</span>)</span><br><span class="line">         <span class="built_in">print</span>*, <span class="string">"Better try again!"</span>  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">         <span class="built_in">print</span>*, <span class="string">"Invalid marks"</span> </span><br><span class="line">         </span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line">   <span class="built_in">print</span>*, <span class="string">"Your marks is "</span>, marks</span><br><span class="line"> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> selectCaseProg</span><br></pre></td></tr></table></figure></p>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!do循环</span></span><br><span class="line"><span class="keyword">do</span> var = start, <span class="keyword">stop</span> [,step]    </span><br><span class="line">   <span class="comment">! statement(s)</span></span><br><span class="line">   …</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!do while</span></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (<span class="keyword">logical</span> expr) </span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<ul>
<li>exit语句终止循环或select case语句。</li>
<li>cycle语句相当于python中的continue</li>
<li>stop终止program</li>
</ul>
<h1 id="fortran字符"><a href="#fortran字符" class="headerlink" title="fortran字符"></a>fortran字符</h1><h2 id="字符串接"><a href="#字符串接" class="headerlink" title="字符串接"></a>字符串接</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> hello</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">character</span>(len=<span class="number">15</span>) :: surname, firstname </span><br><span class="line">   <span class="keyword">character</span>(len=<span class="number">6</span>) :: title </span><br><span class="line">   <span class="keyword">character</span>(len=<span class="number">40</span>):: <span class="keyword">name</span></span><br><span class="line">   <span class="keyword">character</span>(len=<span class="number">25</span>)::greetings</span><br><span class="line">   </span><br><span class="line">   title = <span class="string">'Mr. '</span> </span><br><span class="line">   firstname = <span class="string">'Rowan '</span> </span><br><span class="line">   surname = <span class="string">'Atkinson'</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">name</span> = title//firstname//surname</span><br><span class="line">   greetings = <span class="string">'A big hello from Mr. Beans'</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">print</span> *, <span class="string">'Here is '</span>, <span class="keyword">name</span></span><br><span class="line">   <span class="built_in">print</span> *, greetings</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> hello</span><br><span class="line"></span><br><span class="line"><span class="comment">! 输出</span></span><br><span class="line"><span class="comment">! Here is Mr.Rowan Atkinson       </span></span><br><span class="line"><span class="comment">! A big hello from Mr.Bean</span></span><br></pre></td></tr></table></figure>
<h1 id="fortran数组"><a href="#fortran数组" class="headerlink" title="fortran数组"></a>fortran数组</h1><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!声明</span></span><br><span class="line"><span class="comment">!创建一个5×5的二维矩阵命名的整数数组</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">dimension</span>(<span class="number">5</span>,<span class="number">5</span>)::matrix</span><br><span class="line"><span class="comment">!声明某些明确的下限</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">dimension</span>(<span class="number">2</span>:<span class="number">6</span>) :: numbers</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">dimension</span> (-<span class="number">3</span>:<span class="number">2</span>,<span class="number">0</span>:<span class="number">4</span>) :: matrix</span><br><span class="line"></span><br><span class="line"><span class="comment">!赋值</span></span><br><span class="line">numbers = (/<span class="number">1.5</span>, <span class="number">3.2</span>,<span class="number">4.5</span>,<span class="number">0.9</span>,<span class="number">7.2</span> /)</span><br><span class="line"></span><br><span class="line"><span class="comment">!索引</span></span><br><span class="line">array ([lower]:[upper][:stride], ...)</span><br></pre></td></tr></table></figure>
<h1 id="向量和矩阵乘法"><a href="#向量和矩阵乘法" class="headerlink" title="向量和矩阵乘法"></a>向量和矩阵乘法</h1><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dot_product</span>(vector_a,vector_b)</span><br><span class="line"><span class="built_in">matmul</span>(matrix_a,matrix_b)</span><br></pre></td></tr></table></figure>
<h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><p>动态数组是一种数组，其尺寸在编译时不知道，而是在执行时才已知/确定的。<br>动态数组的属性使用 allocatable 声明。</p>
<p><code>real, dimension (:,:), allocatable :: darray</code></p>
<p>示例<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> dynamic_array </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line"></span><br><span class="line">   <span class="comment">!rank is 2, but size not known   </span></span><br><span class="line">   <span class="keyword">real</span>, <span class="keyword">dimension</span> (:,:), <span class="keyword">allocatable</span> :: darray    </span><br><span class="line">   <span class="keyword">integer</span> :: s1, s2     </span><br><span class="line">   <span class="keyword">integer</span> :: i, j     </span><br><span class="line">   </span><br><span class="line">   <span class="built_in">print</span>*, <span class="string">"Enter the size of the array:"</span>     </span><br><span class="line">   read*, s1, s2      </span><br><span class="line">   </span><br><span class="line">   <span class="comment">! allocate memory      </span></span><br><span class="line">   <span class="built_in">allocate</span> ( darray(s1,s2) )      </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">do</span> i = <span class="number">1</span>, s1           </span><br><span class="line">      <span class="keyword">do</span> j = <span class="number">1</span>, s2                </span><br><span class="line">         darray(i,j) = i*j               </span><br><span class="line">         <span class="built_in">print</span>*, <span class="string">"darray("</span>,i,<span class="string">","</span>,j,<span class="string">") = "</span>, darray(i,j)           </span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">do</span>      </span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">do</span>      </span><br><span class="line">   </span><br><span class="line">   <span class="built_in">deallocate</span> (darray)  </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> dynamic_array</span><br></pre></td></tr></table></figure></p>
<h2 id="data语句"><a href="#data语句" class="headerlink" title="data语句"></a>data语句</h2><p>data 语句可用于初始化多个阵列，或用于阵列部分的初始化。<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> variable / list / ...</span><br></pre></td></tr></table></figure></p>
<p>示例<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> dataStatement</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">integer</span> :: a(<span class="number">5</span>), b(<span class="number">3</span>,<span class="number">3</span>), c(<span class="number">10</span>),i, j</span><br><span class="line">   <span class="keyword">data</span> a /<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>/ </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">data</span> b(<span class="number">1</span>,:) /<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>/ </span><br><span class="line">   <span class="keyword">data</span> b(<span class="number">2</span>,:)/<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>/ </span><br><span class="line">   <span class="keyword">data</span> b(<span class="number">3</span>,:)/<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>/ </span><br><span class="line">   <span class="keyword">data</span> (c(i),i=<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>) /<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>/ </span><br><span class="line">   <span class="keyword">data</span> (c(i),i=<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>)/<span class="number">5</span>*<span class="number">2</span>/</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">'The A array:'</span></span><br><span class="line">   <span class="keyword">do</span> j = <span class="number">1</span>, <span class="number">5</span>                </span><br><span class="line">      <span class="built_in">print</span>*, a(j)           </span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">'The B array:'</span></span><br><span class="line">   <span class="keyword">do</span> i = <span class="built_in">lbound</span>(b,<span class="number">1</span>), <span class="built_in">ubound</span>(b,<span class="number">1</span>)</span><br><span class="line">      <span class="built_in">write</span>(*,*) (b(i,j), j = <span class="built_in">lbound</span>(b,<span class="number">2</span>), <span class="built_in">ubound</span>(b,<span class="number">2</span>))</span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">'The C array:'</span> </span><br><span class="line">   <span class="keyword">do</span> j = <span class="number">1</span>, <span class="number">10</span>                </span><br><span class="line">      <span class="built_in">print</span>*, c(j)           </span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">do</span>      </span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> dataStatement</span><br></pre></td></tr></table></figure></p>
<h2 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h2><p>where与numpy.where类似<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> whereStatement</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">integer</span> :: a(<span class="number">3</span>,<span class="number">5</span>), i , j</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">do</span> i = <span class="number">1</span>,<span class="number">3</span></span><br><span class="line">      <span class="keyword">do</span> j = <span class="number">1</span>, <span class="number">5</span>                </span><br><span class="line">         a(i,j) = j-i          </span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">'The A array:'</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">do</span> i = <span class="built_in">lbound</span>(a,<span class="number">1</span>), <span class="built_in">ubound</span>(a,<span class="number">1</span>)</span><br><span class="line">      <span class="built_in">write</span>(*,*) (a(i,j), j = <span class="built_in">lbound</span>(a,<span class="number">2</span>), <span class="built_in">ubound</span>(a,<span class="number">2</span>))</span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">where</span>( a&lt;<span class="number">0</span> ) </span><br><span class="line">      a = <span class="number">1</span> </span><br><span class="line">   <span class="keyword">elsewhere</span></span><br><span class="line">      a = <span class="number">5</span></span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line">  </span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">'The A array:'</span></span><br><span class="line">   <span class="keyword">do</span> i = <span class="built_in">lbound</span>(a,<span class="number">1</span>), <span class="built_in">ubound</span>(a,<span class="number">1</span>)</span><br><span class="line">      <span class="built_in">write</span>(*,*) (a(i,j), j = <span class="built_in">lbound</span>(a,<span class="number">2</span>), <span class="built_in">ubound</span>(a,<span class="number">2</span>))</span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">do</span>   </span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> whereStatement</span><br></pre></td></tr></table></figure></p>
<h1 id="导出数据类型-结构"><a href="#导出数据类型-结构" class="headerlink" title="导出数据类型(结构)"></a>导出数据类型(结构)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>声明格式<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> type_name      </span><br><span class="line">   declarations</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure><br>示例<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Books</span><br><span class="line">   <span class="keyword">character</span>(len=<span class="number">50</span>) :: title</span><br><span class="line">   <span class="keyword">character</span>(len=<span class="number">50</span>) :: author</span><br><span class="line">   <span class="keyword">character</span>(len=<span class="number">150</span>) :: subject</span><br><span class="line">   <span class="keyword">integer</span> :: book_id</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span> Books</span><br></pre></td></tr></table></figure></p>
<h2 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h2><p><code>type(Books) :: book1</code><br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">book1%title = <span class="string">"C Programming"</span></span><br><span class="line">book1%author = <span class="string">"Nuha Ali"</span></span><br><span class="line">book1%subject = <span class="string">"C Programming Tutorial"</span></span><br><span class="line">book1%book_id = <span class="number">6495407</span></span><br></pre></td></tr></table></figure></p>
<h2 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h2><p><code>type(Books), dimension(2) :: list</code></p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p1 <span class="comment">! pointer to integer  </span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">pointer</span>, <span class="keyword">dimension</span> (:) :: pra <span class="comment">! pointer to 1-dim real array  </span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">pointer</span>, <span class="keyword">dimension</span> (:,:) :: pra2 <span class="comment">! pointer to 2-dim real array</span></span><br></pre></td></tr></table></figure>
<h2 id="分配指针空间"><a href="#分配指针空间" class="headerlink" title="分配指针空间"></a>分配指针空间</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> pointerExample</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p1</span><br><span class="line">   <span class="built_in">allocate</span>(p1)</span><br><span class="line">   </span><br><span class="line">   p1 = <span class="number">1</span></span><br><span class="line">   <span class="built_in">Print</span> *, p1</span><br><span class="line">   </span><br><span class="line">   p1 = p1 + <span class="number">4</span></span><br><span class="line">   <span class="built_in">Print</span> *, p1</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> pointerExample</span><br></pre></td></tr></table></figure>
<p>目标是另一个正态变量，空间预留给它。目标变量必须与目标属性进行声明。<br>一个指针变量使用的关联操作符使目标变量相关联(=&gt;)。<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> pointerExample</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p1</span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">target</span> :: t1 </span><br><span class="line">   </span><br><span class="line">   p1=&gt;t1</span><br><span class="line">   p1 = <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, p1</span><br><span class="line">   <span class="built_in">Print</span> *, t1</span><br><span class="line">   </span><br><span class="line">   p1 = p1 + <span class="number">4</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, p1</span><br><span class="line">   <span class="built_in">Print</span> *, t1</span><br><span class="line">   </span><br><span class="line">   t1 = <span class="number">8</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, p1</span><br><span class="line">   <span class="built_in">Print</span> *, t1</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> pointerExample</span><br></pre></td></tr></table></figure></p>
<h1 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h1><p>我们可以使用打印print<em>语句，以及读取键盘使用read</em>语句，并显示数据输出到屏幕上。这种形式的输入输出是自由格式的I/O，它被称为列表控制的输入输出。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(*,*) item1, item2, item3...</span><br><span class="line"><span class="built_in">print</span> *, item1, item2, item3</span><br><span class="line"><span class="built_in">write</span>(*,*) item1, item2, item3...</span><br></pre></td></tr></table></figure>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read <span class="keyword">fmt</span>, variable_list </span><br><span class="line"><span class="built_in">print</span> <span class="keyword">fmt</span>, variable_list </span><br><span class="line"><span class="built_in">write</span> <span class="keyword">fmt</span>, variable_list</span><br></pre></td></tr></table></figure>
<h1 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h1><p>OPEN, WRITE, READ 和 CLOSE语句可以实现这一目标。</p>
<p><code>open (list-of-specifiers)</code></p>
<p><code>close ([UNIT=]u[,IOSTAT=ios,ERR=err,STATUS=sta])</code></p>
<p><code>read ([UNIT=]u, [FMT=]fmt, IOSTAT=ios, ERR=err, END=s)</code></p>
<p><code>write([UNIT=]u, [FMT=]fmt, IOSTAT=ios, ERR=err, END=s)</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>修辞符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[UNIT=] u</td>
<td>单元数u可以是任何数量范围内9-99，它表明该文件，可以选择任何号码，但在程序中每一个打开的文件必须有一个唯一的数字</td>
</tr>
<tr>
<td>IOSTAT= ios</td>
<td>它是在I/O状态标识符和应为整数的变量。如果打开的语句是成功，则返回IOS值为零，否则为一个非零值。</td>
</tr>
<tr>
<td>ERR = err</td>
<td>它是一个标签到该控制跳以防有错误。</td>
</tr>
<tr>
<td>FILE = fname</td>
<td>文件名，一个字符串。</td>
</tr>
<tr>
<td>STATUS = sta</td>
<td>它示出了该文件的先前状态。一个字符串，可以有三个值NEW, OLD 或 SCRATCH。一个临时文件被创建和删除，当关闭或程序结束。</td>
</tr>
<tr>
<td>ACCESS = acc</td>
<td>它是该文件的访问模式。可以有两个值SEQUENTIAL 或 DIRECT。默认值是SEQUENTIAL。</td>
</tr>
<tr>
<td>FORM= frm</td>
<td>它给该文件的格式的状态。可以有FORMATTED 或UNFORMATTED两个值。默认值是UNFORMATTED</td>
</tr>
<tr>
<td>RECL = rl</td>
<td>它指定的每个记录中的一个直接访问文件的长度。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="fortran过程"><a href="#fortran过程" class="headerlink" title="fortran过程"></a>fortran过程</h1><p>包括函数和子程序</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是返回一个数量的过程。函数不修改其参数。<br>返回数值被称为函数值，并将其表示为函数名。</p>
<p><strong>语法</strong><br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="keyword">name</span>(arg1, arg2, ....)  </span><br><span class="line">   [declarations, including those for the arguments]   </span><br><span class="line">   [executable statements] </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> [<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>示例</strong><br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> calling_func</span><br><span class="line"></span><br><span class="line">   <span class="keyword">real</span> :: a</span><br><span class="line">   a = area_of_circle(<span class="number">2.0</span>) </span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">"The area of a circle with radius 2.0 is"</span></span><br><span class="line">   <span class="built_in">Print</span> *, a</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> calling_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">! this function computes the area of a circle with radius r  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> area_of_circle (r)  </span><br><span class="line"></span><br><span class="line"><span class="comment">! function result     </span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span>      </span><br><span class="line"></span><br><span class="line">   <span class="comment">! dummy arguments        </span></span><br><span class="line">   <span class="keyword">real</span> :: area_of_circle   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">! local variables </span></span><br><span class="line">   <span class="keyword">real</span> :: r     </span><br><span class="line">   <span class="keyword">real</span> :: pi</span><br><span class="line">   </span><br><span class="line">   pi = <span class="number">4</span> * <span class="built_in">atan</span> (<span class="number">1.0</span>)     </span><br><span class="line">   area_of_circle = pi * r**<span class="number">2</span>  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> area_of_circle</span><br></pre></td></tr></table></figure></p>
<h2 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h2><p>子程序没有返回值，可以修改其参数</p>
<p><strong>语法</strong><br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> <span class="keyword">name</span>(arg1, arg2, ....)    </span><br><span class="line">   [declarations, including those for the arguments]    </span><br><span class="line">   [executable statements]  </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> [<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>调用子程序</strong><br>使用call来调用子程序<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> calling_func</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">real</span> :: a, b</span><br><span class="line">   a = <span class="number">2.0</span></span><br><span class="line">   b = <span class="number">3.0</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">"Before calling swap"</span></span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">"a = "</span>, a</span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">"b = "</span>, b</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">call</span> swap(a, b)</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">"After calling swap"</span></span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">"a = "</span>, a</span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">"b = "</span>, b</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> calling_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> swap(x, y) </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">real</span> :: x, y, temp   </span><br><span class="line">   </span><br><span class="line">   temp = x  </span><br><span class="line">   x = y </span><br><span class="line">   y = temp  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> swap</span><br></pre></td></tr></table></figure></p>
<h2 id="指定参数意图"><a href="#指定参数意图" class="headerlink" title="指定参数意图"></a>指定参数意图</h2><p>intent(in) 用作输入<br>intent(out) 用作输出，他们将被覆盖<br>intent(inout) 参数都使用和覆盖<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> calling_func</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">real</span> :: x, y, z, disc</span><br><span class="line">   </span><br><span class="line">   x= <span class="number">1.0</span></span><br><span class="line">   y = <span class="number">5.0</span></span><br><span class="line">   z = <span class="number">2.0</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">call</span> intent_example(x, y, z, disc)</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">"The value of the discriminant is"</span></span><br><span class="line">   <span class="built_in">Print</span> *, disc</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> calling_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> intent_example (a, b, c, d)     </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span>     </span><br><span class="line"></span><br><span class="line">   <span class="comment">! dummy arguments      </span></span><br><span class="line">   <span class="keyword">real</span>, <span class="keyword">intent</span> (<span class="keyword">in</span>) :: a     </span><br><span class="line">   <span class="keyword">real</span>, <span class="keyword">intent</span> (<span class="keyword">in</span>) :: b      </span><br><span class="line">   <span class="keyword">real</span>, <span class="keyword">intent</span> (<span class="keyword">in</span>) :: c    </span><br><span class="line">   <span class="keyword">real</span>, <span class="keyword">intent</span> (<span class="keyword">out</span>) :: d   </span><br><span class="line">   </span><br><span class="line">   d = b * b - <span class="number">4.0</span> * a * c </span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> intent_example</span><br></pre></td></tr></table></figure></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>当一个函数被递归使用，则 result 选项要被使用。<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> calling_func</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">integer</span> :: i, f</span><br><span class="line">   i = <span class="number">15</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Print</span> *, <span class="string">"The value of factorial 15 is"</span></span><br><span class="line">   f = myfactorial(<span class="number">15</span>)</span><br><span class="line">   <span class="built_in">Print</span> *, f</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> calling_func</span><br><span class="line"></span><br><span class="line"><span class="comment">! computes the factorial of n (n!)      </span></span><br><span class="line"><span class="keyword">recursive</span> <span class="function"><span class="keyword">function</span></span> myfactorial (n) result (fac)  </span><br><span class="line"><span class="comment">! function result     </span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span>     </span><br><span class="line"></span><br><span class="line">   <span class="comment">! dummy arguments     </span></span><br><span class="line">   <span class="keyword">integer</span> :: fac     </span><br><span class="line">   <span class="keyword">integer</span>, <span class="keyword">intent</span> (<span class="keyword">in</span>) :: n     </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">select</span> <span class="keyword">case</span> (n)         </span><br><span class="line">      <span class="keyword">case</span> (<span class="number">0</span>:<span class="number">1</span>)         </span><br><span class="line">         fac = <span class="number">1</span>         </span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">default</span>    </span><br><span class="line">         fac = n * myfactorial (n-<span class="number">1</span>)  </span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">select</span> </span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> myfactorial</span><br></pre></td></tr></table></figure></p>
<h2 id="内部过程"><a href="#内部过程" class="headerlink" title="内部过程"></a>内部过程</h2><p>当一个过程被包含在程序中，它被称为程序的内部程序。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program mainprog  </span><br><span class="line">implicit none </span><br><span class="line"></span><br><span class="line">   real :: a, b </span><br><span class="line">   a &#x3D; 2.0</span><br><span class="line">   b &#x3D; 3.0</span><br><span class="line">   </span><br><span class="line">   Print *, &quot;Before calling swap&quot;</span><br><span class="line">   Print *, &quot;a &#x3D; &quot;, a</span><br><span class="line">   Print *, &quot;b &#x3D; &quot;, b</span><br><span class="line">   </span><br><span class="line">   call swap(a, b)</span><br><span class="line">   </span><br><span class="line">   Print *, &quot;After calling swap&quot;</span><br><span class="line">   Print *, &quot;a &#x3D; &quot;, a</span><br><span class="line">   Print *, &quot;b &#x3D; &quot;, b</span><br><span class="line"> </span><br><span class="line">contains   </span><br><span class="line">   subroutine swap(x, y)     </span><br><span class="line">      real :: x, y, temp      </span><br><span class="line">      temp &#x3D; x </span><br><span class="line">      x &#x3D; y  </span><br><span class="line">      y &#x3D; temp   </span><br><span class="line">   end subroutine swap </span><br><span class="line">   </span><br><span class="line">end program mainprog</span><br></pre></td></tr></table></figure></p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块用于：</p>
<ul>
<li>包装子程序，数据和接口块。</li>
<li>定义，可以使用多于一个常规全局数据。</li>
<li>声明可以选择的任何程序内提供的变量。</li>
<li>导入整个模块，可使用在另一个程序或子程序。</li>
</ul>
<p><strong>使用模块</strong><br><code>use name</code></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> constants  </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line"></span><br><span class="line">   <span class="keyword">real</span>, <span class="keyword">parameter</span> :: pi = <span class="number">3.1415926536</span>  </span><br><span class="line">   <span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">2.7182818285</span> </span><br><span class="line">   </span><br><span class="line"><span class="keyword">contains</span>      </span><br><span class="line">   <span class="function"><span class="keyword">subroutine</span></span> show_consts()          </span><br><span class="line">      <span class="built_in">print</span>*, <span class="string">"Pi = "</span>, pi          </span><br><span class="line">      <span class="built_in">print</span>*,  <span class="string">"e = "</span>, e     </span><br><span class="line">   <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> show_consts </span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> constants </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> module_example     </span><br><span class="line"><span class="keyword">use</span> constants      </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span>     </span><br><span class="line"></span><br><span class="line">   <span class="keyword">real</span> :: x, ePowerx, area, radius </span><br><span class="line">   x = <span class="number">2.0</span></span><br><span class="line">   radius = <span class="number">7.0</span></span><br><span class="line">   ePowerx = e ** x</span><br><span class="line">   area = pi * radius**<span class="number">2</span>     </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">call</span> show_consts() </span><br><span class="line">   </span><br><span class="line">   <span class="built_in">print</span>*, <span class="string">"e raised to the power of 2.0 = "</span>, ePowerx</span><br><span class="line">   <span class="built_in">print</span>*, <span class="string">"Area of a circle with radius 7.0 = "</span>, area  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> module_example</span><br></pre></td></tr></table></figure>
<p>缺省情况下，在一个模块中的所有的变量和子程序被提供给正在使用的模块代码，通过 use 语句声明。</p>
<p>但是，可以控制模块代码中使用的private 和 public 属性的访问性。当声明一些变量或子程序为私有，这是不可以用在模块之外使用。</p>
<h1 id="common，module共享数据"><a href="#common，module共享数据" class="headerlink" title="common，module共享数据"></a>common，module共享数据</h1><h2 id="common"><a href="#common" class="headerlink" title="common"></a>common</h2><p>在新书写的代码里，避免使用 COMMON 语句，而使用 Module 语句代替它。<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMON</span> /a/b, /c/d, e, f</span><br><span class="line"><span class="comment">!表示在公用区a中有变量（或者数组）b，在公用区c中有d, e, f 。</span></span><br><span class="line"><span class="keyword">integer</span> b,d,e,f</span><br><span class="line"><span class="comment">!在使用公用区变量前，必须再次说明类型，非常容易发生错误</span></span><br></pre></td></tr></table></figure></p>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>save 属性表明这些变量会被保存起来，以便在不同的程序单元间保持同样的值。<br>（虽然语法未明确指出，但所有的编译器都默许 Module 中的变量具有 save 属性，因此，很多时候 save 也可以忽略不写）<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Module</span> modname</span><br><span class="line">  <span class="keyword">Implicit</span> <span class="keyword">None</span></span><br><span class="line">  <span class="comment">!// 明确变量类型，顺序无关</span></span><br><span class="line">  <span class="keyword">Integer</span> , <span class="keyword">save</span> :: a = <span class="number">1</span> , b = <span class="number">2</span>  </span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Module</span> modname</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> www_fcode_cn</span><br><span class="line">  <span class="keyword">use</span> modname <span class="comment">!// 无需，也不能再定义 a b</span></span><br><span class="line">  <span class="keyword">Implicit</span> <span class="keyword">None</span> </span><br><span class="line">  <span class="built_in">write</span>(*,*) b , a <span class="comment">!// 输出 2，1 正确</span></span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line">  b = <span class="number">4</span></span><br><span class="line">  <span class="comment">!// 按变量名对应，因此倒序输出，其值也倒序</span></span><br><span class="line">  <span class="keyword">call</span> Sub()</span><br><span class="line"><span class="keyword">End</span> <span class="function"><span class="keyword">Program</span></span> www_fcode_cn</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Subroutine</span></span> Sub()</span><br><span class="line">  <span class="keyword">use</span> modname <span class="comment">!// 无需，也不能再定义 a b</span></span><br><span class="line">  <span class="keyword">Implicit</span> <span class="keyword">None</span></span><br><span class="line">  <span class="built_in">write</span>(*,*) a , b <span class="comment">!// 输出 3，4 正确</span></span><br><span class="line"><span class="keyword">End</span> <span class="function"><span class="keyword">Subroutine</span></span> Sub</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Fortran</category>
      </categories>
  </entry>
  <entry>
    <title>github中的快速查找</title>
    <url>/2019/11/26/github%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>根据CodeSheep的视频进行总结：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:name example  &#x2F;&#x2F;名字中有“example”</span><br><span class="line">in:readme example  &#x2F;&#x2F;readme中有“example”</span><br><span class="line">in:description example &#x2F;&#x2F;描述中有“example”</span><br><span class="line"></span><br><span class="line">stars:&gt;1000  star&gt;1000</span><br><span class="line">forks:&gt;1000  fork&gt;1000</span><br><span class="line">pushed:&gt;2019-09-01  &#x2F;&#x2F;2019年9月1日后有更新的</span><br><span class="line"></span><br><span class="line">language:java  &#x2F;&#x2F;用Java编写的项目</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CODE工具</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令</title>
    <url>/2020/06/29/git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>廖雪峰的教程<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304</a><br><a id="more"></a><br>创建忽略文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.gitignore文件，文件中填写需要忽略文件的正则表达式</span><br></pre></td></tr></table></figure>
<p>创建版本库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>提交到暂存区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>提交到版本库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;提示信息&quot;</span><br></pre></td></tr></table></figure>
<p>查看状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>查看修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>查看日志文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log  &#x2F;&#x2F;可以加参数 --pretty&#x3D;oneline</span><br><span class="line">git reflog &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
<p>版本回退</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^ &#x2F;&#x2F;回退到上个版本 HEAD指向当前版本</span><br><span class="line">git reset --hard &lt;commit id&gt;  &#x2F;&#x2F;回退到指定commit</span><br></pre></td></tr></table></figure>
<p>丢弃工作区的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- readme.txt &#x2F;&#x2F;让这个文件回到最近一次git commit或git add时的状态。</span><br></pre></td></tr></table></figure>
<p>撤销暂存区的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>删除文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>远程仓库</p>
<p>1.创建ssh密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>2.本地与远程关联</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:michaelliao&#x2F;learngit.git</span><br></pre></td></tr></table></figure>
<p>3.当前分支所有内容推送到远程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master &#x2F;&#x2F;-u参数：推送的同时将本地的master分支与远程的master分支关联</span><br></pre></td></tr></table></figure>
<p>4.克隆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone</span><br></pre></td></tr></table></figure>
<p>查看远程库的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br></pre></td></tr></table></figure>
<p><code>git remote -v</code>显示更详细的信息</p>
<p>推送dev分支到远程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>
<p>分支</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<p>分支合并图：<code>git log --graph</code></p>
<p>合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>:<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></p>
<p>BUG分支：</p>
<p>把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash &#x2F;&#x2F;储存</span><br><span class="line">git stash list  &#x2F;&#x2F;查看</span><br><span class="line">git stash apply  &#x2F;&#x2F;恢复，不删除</span><br><span class="line">git stash drop  &#x2F;&#x2F;删除</span><br><span class="line">git stash pop  &#x2F;&#x2F;恢复并删除</span><br></pre></td></tr></table></figure>
<p>创建远程<code>origin</code>的<code>dev</code>分支到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b dev origin&#x2F;dev</span><br></pre></td></tr></table></figure>
<p>删除远程分支：$ <strong>git push</strong> origin :heads/[name]</p>
<p>标签</p>
<p><code>git tag</code>查看所有标签</p>
<p><code>git tag &lt;name&gt;</code>就可以打一个新标签 默认标签是打在最新提交的commit上的</p>
<p><code>git tag v0.9 f52c633</code>给指定commit打标签</p>
<p><code>git show &lt;tagname&gt;</code>查看标签信息</p>
<p>创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure>
<p>删除标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d v0.1</span><br></pre></td></tr></table></figure>
<p>上传空文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -type d -empty -exec touch &#123;&#125;&#x2F;.gitignore \;</span><br></pre></td></tr></table></figure>
<p> <strong>一、创建与合并分支</strong> </p>
<p><strong>1、 从master分支创建dev分支并切换到dev分支</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure>
<p>其中，git checkout -b dev 等价于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>
<p>（1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。</p>
<p>（2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  branch  -a</span><br></pre></td></tr></table></figure>
<p>查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。</p>
<p><strong>2、修改代码、提交代码（当前的操作是在dev分支上进行）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add a.html</span><br><span class="line">git commit -m &quot;提交文件a.html&quot;</span><br></pre></td></tr></table></figure>
<p><strong>3、分支合并(将dev合并到master)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure>
<p><strong>4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>
<p><strong>5、删除后，查看分支(此时看不到dev分支了)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p><strong>6、总结 ：工作中经常从master创建新的分支，具体操作如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master创建新分支：git checkout master</span><br><span class="line">git checkout -b  issues1234  &#x2F;&#x2F; 从master分支创建issues1234分支</span><br><span class="line">git push origin issues1234</span><br><span class="line">git add ..</span><br><span class="line">git commit -m &quot;***&quot;</span><br><span class="line">git push origin issues1234</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：将本地分支branch1推到远端的branch2操作步骤：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin branch1:branch2</span><br></pre></td></tr></table></figure>
<p><strong>7、删除分支：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -D   issues1234  &#x2F;&#x2F; 本地强制删除分支issues1234</span><br><span class="line">git push origin  :issues1234  &#x2F;&#x2F; 推到远程</span><br></pre></td></tr></table></figure>
<hr>
<p> <strong>二、解决冲突</strong> </p>
<p><strong>1、发生冲突的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>
<p>其中，git使用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记文件中自己和别人产生冲突的部分。</p>
<p>在 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======</code>之间为自己的代码；=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。</p>
<p>如果保留自己的代码，将别人的代码删掉即可。</p>
<p><strong>2、冲突解决后提交</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add ***</span><br><span class="line">git commit -m &quot;fix conflict&quot;</span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure>
<hr>
<p> <strong>三、Bug分支</strong> </p>
<p><strong>1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p><strong>2、恢复储藏的代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop &#x2F;&#x2F; 恢复的同时把stash内容删掉</span><br></pre></td></tr></table></figure>
<p>或者<img src="image/640.webp" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过 git stash list，查看本地所有的stash,如果我要恢复第一个就执行：</span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br><span class="line">git stash apply  </span><br><span class="line">&#x2F;&#x2F; 恢复stash，但是stash内容并不删除</span><br><span class="line">git stash drop </span><br><span class="line">&#x2F;&#x2F; 在上面操作的基础上，以此来删除stash注： git stash list &#x2F;&#x2F; 查看全部的stash列表</span><br></pre></td></tr></table></figure>
<p><strong>3、将stash空间清空</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure>
<p><strong>4、git stash pop 和 git stash apply 区别</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原来git stash pop stash@&#123;id&#125;命令会在执行后将对应的stash id 从stash list里删除，而 git stash apply stash@&#123;id&#125; 命令则会继续保存stash id。</span><br></pre></td></tr></table></figure>
<hr>
<p> <strong>四、版本回退</strong> </p>
<p><strong>1、回退至上一个版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure>
<p><strong>2、回退至指定版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard  版本号</span><br></pre></td></tr></table></figure>
<p><strong>3、查看以往版本号(本地的commit)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<p><strong>4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<hr>
<p> <strong>五、撤销修改</strong> </p>
<p><strong>1、撤销修改</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git  checkout -- a.html</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分两种情况分析：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。</span><br><span class="line">②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。</p>
</blockquote>
<p><strong>2、撤销新建文件</strong></p>
<p>比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clean -f ..&#x2F;aa.html</span><br></pre></td></tr></table></figure>
<p><strong>3、撤销新建文件夹</strong></p>
<p>比如新建一个文件夹”demo”，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clean -df .&#x2F;demo</span><br></pre></td></tr></table></figure>
<hr>
<p> <strong>六、对已push版本进行回退</strong> </p>
<p><strong>1、第一步：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号 &#x2F;&#x2F; 本地回退到指定的版本</span><br></pre></td></tr></table></figure>
<p><strong>2、第二步：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push  -f origin dev    &#x2F;&#x2F;将远程的也回退到指定版本</span><br></pre></td></tr></table></figure>
<hr>
<p> <strong>七、本地同步远程删除的分支</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin -p  &#x2F;&#x2F; 用来清除已经没有远程信息的分支，这样git branch -a 就不会拉取远程已经删除的分支了</span><br></pre></td></tr></table></figure>
<hr>
<p> <strong>八、删掉未与远程分支对应的本地分支</strong> </p>
<p>从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch -p</span><br></pre></td></tr></table></figure>
<hr>
<p> <strong>九、查看远程库与本地分支的信息</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure>
<hr>
<p> <strong>十、标签管理</strong> </p>
<p><strong>1、给当前分支最新commit打标签</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag v1.0.0</span><br></pre></td></tr></table></figure>
<p><strong>2、比如现在周五，要给周一某个commit打标签，应执行以下步骤：</strong></p>
<p>（1）、查看log日志，找到相应的commit版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">&#x2F;&#x2F; 显示如下commit，比如我想在 &quot;34372b05&quot;这个commit打标签44d2e20b fix bug34372b05 fix bug29554931 fix bug</span><br></pre></td></tr></table></figure>
<p>（2）、给指定的commit打标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag v1.0.0 34372b05</span><br></pre></td></tr></table></figure>
<p>（3）、创建的标签只存在本地，推至远程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin v1.0.0</span><br></pre></td></tr></table></figure>
<p>（4）、一次性推送未推至远程的本地标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<p>（5）、查询所有标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>（6）、查询标签详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show v1.0.0</span><br></pre></td></tr></table></figure>
<p>（7）、删除本地标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d v1.0.0</span><br></pre></td></tr></table></figure>
<p>（8）、删除远程标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 先从本地删除git tag -d v1.0.0&#x2F;&#x2F; 然后从远程删除</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;v1.0.0&#x2F;&#x2F; 最后可以在gitlab上查看是否真正的删除了标签</span><br></pre></td></tr></table></figure>
<p><strong>3、创建带有说明的标签，用-a指定标签名，-m指定说明文字</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; git  tag  -a  版本号  -m  说明信息  commit版本号</span><br><span class="line">git tag -a v1.0.0 -m &quot;version 1.0.0 released&quot; 34372b05(commit版本号)     &#x2F;&#x2F; 查看标签详细信息git show v1.0.0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODE工具</category>
      </categories>
  </entry>
  <entry>
    <title>hexo主题更新</title>
    <url>/2020/07/22/hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="hexo更新"><a href="#hexo更新" class="headerlink" title="hexo更新"></a>hexo更新</h1><a id="more"></a>
<p>直接修改<code>package.json</code>中的版本号，执行<code>npm update</code>进行更新</p>
<h1 id="主题更新"><a href="#主题更新" class="headerlink" title="主题更新"></a>主题更新</h1><ol>
<li>主题下载<br>主题从github下载到<code>theme/icarus</code>目录</li>
<li>安装<br><code>hexo s</code>，按照提示通过npm安装对应的包。包的版本可以通过<code>package.json</code>中的版本号修改。所有包安装之后，再执行<code>hexo s</code>会在<code>icarus</code>目录生成对应的<code>_config.yml</code>文件</li>
</ol>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol>
<li>设置主页三栏，文章页两栏<br>将<code>_config.yml</code>复制到<code>_config.post.yml</code>，将<code>_config.post.yml</code>中的widget移动到一侧。</li>
</ol>
]]></content>
      <categories>
        <category>其他工具</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客备份</title>
    <url>/2019/12/09/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="备份步骤"><a href="#备份步骤" class="headerlink" title="备份步骤"></a>备份步骤</h1><a id="more"></a>
<ol>
<li>在博客仓库创建分支hexo（或其他）</li>
<li>设置hexo为默认分支</li>
<li>创建<code>.gitignore</code>文件<br>文件内容：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>
4.上传至github<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "blabla"</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></li>
<li>hexo g -d 发布博客</li>
</ol>
<h2 id="恢复步骤"><a href="#恢复步骤" class="headerlink" title="恢复步骤"></a>恢复步骤</h2><ol>
<li><code>git clone https://github.com/sjtu-xx/sjtu-xx.github.io.gito</code></li>
<li>在克隆的文件夹下输入<code>npm install hexo-cli</code>,<code>npm install</code>,<code>npm install hexo-deployer-git</code></li>
</ol>
]]></content>
      <categories>
        <category>其他工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客多设备同步</title>
    <url>/2021/02/04/hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>之前的hexo博客一直使用mac进行创建提交等。因为很多东西经常需要在windows上进行操作，如果发送到mac再进行提交就有些复杂，因此，尝试在两个操作系统上进行提交。</p>
<p>参考链接：<a href="https://www.jianshu.com/p/fceaf373d797" target="_blank" rel="noopener">https://www.jianshu.com/p/fceaf373d797</a></p>
<a id="more"></a>
<p>github上的repo创建了两个分支，master保存静态页面，hexo用于保存网站的全部文件。</p>
<h1 id="旧环境"><a href="#旧环境" class="headerlink" title="旧环境"></a>旧环境</h1><ol>
<li>将旧环境中的文件上传到github的hexo分支：<ul>
<li>github上切换到hexo分支，<code>git clone</code>仓库到本地。</li>
<li>此时本地会多出一个<code>username.github.io</code>文件夹，命令行<code>cd</code>进去，删除除<code>.git</code>文件夹（如果你看不到这个文件夹，说明是隐藏了。windows下需要右击文件夹内空白处，点选’显示/隐藏 异常文件’，Mac下我就不知道了）外的其他文件夹。</li>
<li>命令行<code>git add -A</code>把工作区的变化（包括已删除的文件）提交到暂存区（ps:<code>git add .</code>提交的变化不包括已删除的文件）。</li>
<li>命令行<code>git commint -m &quot;some description&quot;</code>提交。</li>
<li>命令行<code>git push origin hexo</code>推送到远程hexo分支。此时刷下github，如果正常操作，hexo分支应该已经被清空了。</li>
<li>复制本地<code>username.github.io</code>文件夹中的<code>.git</code>文件夹到hexo项目根目录下。此时，hexo项目已经变成了和远程hexo分支关联的本地仓库了。而<code>username.github.io</code>文件夹的使命到此为止，你可以把它删掉，因为我们只是把它作为一个“中转站”的角色。以后每次发布新文章或修改网站样式文件时，<code>git add . &amp; git commit -m &quot;some description&quot; &amp; git push origin hexo</code>即可把环境文件推送到hexo分支。然后再<code>hexo g -d</code>发布网站并推送静态文件到master分支。</li>
</ul>
</li>
</ol>
<h1 id="新环境"><a href="#新环境" class="headerlink" title="新环境"></a>新环境</h1><p>这部分应该要简单一点，如果你已经搭建过一个hexo博客的话。</p>
<ul>
<li>新电脑上安装node.js和git。</li>
<li>安装hexo：<code>npm install -g hexo-cli</code>。</li>
<li>clone远程仓库到本地 <code>git clone git@github.com:username/username.github.io.git</code>。</li>
<li>根据<code>packge.json</code>安装依赖<code>npm install</code>。</li>
<li>本地生成网站并开启博客服务器：<code>hexo g &amp; hexo s</code>。如果一切正常，此时打开浏览器输入<code>http://localhost:4000/</code>已经可以看到博客正常运行了。</li>
</ul>
<h1 id="在两台电脑上的同步操作"><a href="#在两台电脑上的同步操作" class="headerlink" title="在两台电脑上的同步操作"></a>在两台电脑上的同步操作</h1><p>至此，迁移工作已完成，在两台电脑之间的同步操作如下：</p>
<ul>
<li><code>git pull</code>从远程hexo分支拉取最新的环境文件到本地，可以理解为svn的更新操作。比如在公司写了博客，回家在电脑上也要写需要先执行这一步操作。</li>
<li>文章写完，要发布时，需要先提交环境文件，再发布文章。按以下顺序执行命令：<code>git add .</code>、<code>git commit -m &quot;some descrption&quot;</code>、<code>git push origin hexo</code>、<code>hexo g -d</code>。</li>
</ul>
]]></content>
      <categories>
        <category>其他工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/2020/06/29/jQuery/</url>
    <content><![CDATA[<h1 id="前端学习之jquery"><a href="#前端学习之jquery" class="headerlink" title="前端学习之jquery"></a><a href="https://www.cnblogs.com/yuanchenqi/articles/6070667.html" target="_blank" rel="noopener">前端学习之jquery</a></h1><a id="more"></a>
<h3 id="一-jQuery是什么？"><a href="#一-jQuery是什么？" class="headerlink" title="一 jQuery是什么？"></a>一 jQuery是什么？</h3><p><1> jQuery由美国人John Resig创建，至今已吸引了来自世界各地的众多 javascript高手加入其team。</p>
<p><2>jQuery是继prototype之后又一个优秀的Javascript框架。其宗旨是——WRITE LESS,DO MORE!</p>
<p><3>它是轻量级的js库(压缩后只有21k) ，这是其它的js库所不及的，它兼容CSS3，还兼容各种浏览器</p>
<p><4>jQuery是一个快速的，简洁的javaScript库，使用户能更方便地处理HTMLdocuments、events、实现动画效果，并且方便地为网站提供AJAX交互。</p>
<p><5>jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。</p>
<h3 id="二-什么是jQuery对象？"><a href="#二-什么是jQuery对象？" class="headerlink" title="二 什么是jQuery对象？"></a>二 什么是jQuery对象？</h3><p>jQuery 对象就是通过jQuery包装DOM对象后产生的对象。jQuery 对象是 jQuery 独有的<strong>.</strong> 如果一个对象是 jQuery 对象<strong>,</strong> 那么它就可以使用 jQuery 里的方法: $(“#test”).html();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#test&quot;).html()    </span><br><span class="line">       &#x2F;&#x2F;意思是指：获取ID为test的元素内的html代码。其中html()是jQuery里的方法 </span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 这段代码等同于用DOM实现代码： document.getElementById(&quot; test &quot;).innerHTML; </span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法.乱使用会报错</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;约定：如果获取的是 jQuery 对象, 那么要在变量前面加上$. </span><br><span class="line"></span><br><span class="line">var $variable &#x3D; jQuery 对象</span><br><span class="line">var variable &#x3D; DOM 对象</span><br><span class="line"></span><br><span class="line">$variable[0]：jquery对象转为dom对象      $(&quot;#msg&quot;).html(); $(&quot;#msg&quot;)[0].innerHTML</span><br></pre></td></tr></table></figure>
<p>jquery的基础语法：$(selector).action()</p>
<h3 id="三-寻找元素-选择器和筛选器"><a href="#三-寻找元素-选择器和筛选器" class="headerlink" title="三 寻找元素(选择器和筛选器)"></a>三 寻找元素(选择器和筛选器)</h3><h4 id="3-1-选择器"><a href="#3-1-选择器" class="headerlink" title="3.1   选择器"></a>3.1   选择器</h4><p>3.1.1 基本选择器      </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"*"</span>)  $(<span class="string">"#id"</span>)   $(<span class="string">".class"</span>)  $(<span class="string">"element"</span>)  $(<span class="string">".class,p,div"</span>)</span><br></pre></td></tr></table></figure>
<p>3.1.2 层级选择器      </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">".outer div"</span>)  $(<span class="string">".outer&gt;div"</span>)   $(<span class="string">".outer+div"</span>)  $(<span class="string">".outer~div"</span>) <span class="comment">//兄弟标签</span></span><br></pre></td></tr></table></figure>
<p>3.1.3 基本筛选器（过滤）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"li:first"</span>)  </span><br><span class="line">$(<span class="string">"li:eq(2)"</span>)  <span class="comment">//第3个</span></span><br><span class="line">$(<span class="string">"li:even"</span>)  <span class="comment">//偶数</span></span><br><span class="line">$(<span class="string">"li:gt(1)"</span>) <span class="comment">//从第二个开始</span></span><br></pre></td></tr></table></figure>
<p>3.1.4 属性选择器    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'[id="div1"]'</span>)   $(<span class="string">'["alex="sb"][id]'</span>)</span><br></pre></td></tr></table></figure>
<p>3.1.5 表单选择器     </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"[type='text']"</span>)-----&gt;$(<span class="string">":text"</span>)         注意只适用于input标签  : $(<span class="string">"input:checked"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>实例之左侧菜单</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>left_menu<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">          <span class="selector-class">.menu</span>&#123;</span></span><br><span class="line">              height: 500px;</span><br><span class="line">              width: 30%;</span><br><span class="line">              background-color: gainsboro;</span><br><span class="line">              float: left;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="css">          <span class="selector-class">.content</span>&#123;</span></span><br><span class="line">              height: 500px;</span><br><span class="line">              width: 70%;</span><br><span class="line">              background-color: rebeccapurple;</span><br><span class="line">              float: left;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="css">         <span class="selector-class">.title</span>&#123;</span></span><br><span class="line">             line-height: 50px;</span><br><span class="line"><span class="css">             <span class="selector-tag">background-color</span>: <span class="selector-id">#425a66</span>;</span></span><br><span class="line">             color: forestgreen;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="css">         <span class="selector-class">.hide</span>&#123;</span></span><br><span class="line">             display: none;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>菜单一<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"con"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>菜单二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"con hide"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>菜单三<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"con hide"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery-3.2.1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">           $(<span class="string">".item .title"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                $(<span class="keyword">this</span>).next().removeClass(<span class="string">"hide"</span>).parent().siblings().children(<span class="string">".con"</span>).addClass(<span class="string">"hide"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//                $(this).next().removeClass("hide");</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">//                $(this).parent().siblings().children(".con").addClass("hide");</span></span></span><br><span class="line">           &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>实例之tab切换</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>tab<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">           <span class="function"><span class="keyword">function</span> <span class="title">tab</span><span class="params">(self)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">var</span> index=$(self).attr(<span class="string">"xxx"</span>);</span></span><br><span class="line"><span class="javascript">               $(<span class="string">"#"</span>+index).removeClass(<span class="string">"hide"</span>).siblings().addClass(<span class="string">"hide"</span>);</span></span><br><span class="line"><span class="javascript">               $(self).addClass(<span class="string">"current"</span>).siblings().removeClass(<span class="string">"current"</span>);</span></span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line">            margin: 0px;</span><br><span class="line">            padding: 0px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.tab_outer</span>&#123;</span></span><br><span class="line">            margin: 0px auto;</span><br><span class="line">            width: 60%;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#cccccc</span>;</span></span><br><span class="line"><span class="css">            <span class="comment">/*border: 1px solid red;*/</span></span></span><br><span class="line">            line-height: 40px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line">            border-right: 1px solid red;</span><br><span class="line">            padding: 11px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.content</span>&#123;</span></span><br><span class="line">            background-color: tan;</span><br><span class="line">            border: 1px solid green;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.hide</span>&#123;</span></span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.current</span>&#123;</span></span><br><span class="line">            background-color: darkgray;</span><br><span class="line">            color: yellow;</span><br><span class="line">            border-top: solid 2px rebeccapurple;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab_outer"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span> <span class="attr">xxx</span>=<span class="string">"c1"</span> <span class="attr">class</span>=<span class="string">"current"</span> <span class="attr">onclick</span>=<span class="string">"tab(this);"</span>&gt;</span>菜单一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span> <span class="attr">xxx</span>=<span class="string">"c2"</span> <span class="attr">onclick</span>=<span class="string">"tab(this);"</span>&gt;</span>菜单二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">li</span> <span class="attr">xxx</span>=<span class="string">"c3"</span> <span class="attr">onclick</span>=<span class="string">"tab(this);"</span>&gt;</span>菜单三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c1"</span>&gt;</span>内容一<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c2"</span> <span class="attr">class</span>=<span class="string">"hide"</span>&gt;</span>内容二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c3"</span> <span class="attr">class</span>=<span class="string">"hide"</span>&gt;</span>内容三<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-筛选器"><a href="#3-2-筛选器" class="headerlink" title="3.2 筛选器"></a>3.2 筛选器</h4><p> 3.2.1  过滤筛选器     </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"li"</span>).eq(<span class="number">2</span>)  $(<span class="string">"li"</span>).first()  $(<span class="string">"ul li"</span>).hasclass(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure>
<p> 3.2.2  查找筛选器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).children(<span class="string">".test"</span>)  <span class="comment">//下一代</span></span><br><span class="line">$(<span class="string">"div"</span>).find(<span class="string">".test"</span>)  <span class="comment">//所有子代</span></span><br><span class="line">                               </span><br><span class="line">$(<span class="string">".test"</span>).next()</span><br><span class="line">$(<span class="string">".test"</span>).nextAll()</span><br><span class="line">$(<span class="string">".test"</span>).nextUntil() </span><br><span class="line">                           </span><br><span class="line">$(<span class="string">"div"</span>).prev()</span><br><span class="line">$(<span class="string">"div"</span>).prevAll()</span><br><span class="line">$(<span class="string">"div"</span>).prevUntil()   </span><br><span class="line">                        </span><br><span class="line">$(<span class="string">".test"</span>).parent()</span><br><span class="line">$(<span class="string">".test"</span>).parents()  </span><br><span class="line">$(<span class="string">".test"</span>).parentUntil() </span><br><span class="line"></span><br><span class="line">$(<span class="string">"div"</span>).siblings()</span><br></pre></td></tr></table></figure>
<h3 id="四-操作元素-属性，css，文档处理"><a href="#四-操作元素-属性，css，文档处理" class="headerlink" title="四 操作元素(属性，css，文档处理)"></a>四 操作元素(属性，css，文档处理)</h3><h4 id="4-1-属性操作"><a href="#4-1-属性操作" class="headerlink" title="4.1 属性操作"></a>4.1 属性操作</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">--------------------------属性</span><br><span class="line"><span class="comment">//自定义属性用attr</span></span><br><span class="line">$(<span class="string">""</span>).attr();   <span class="comment">//一个参数，取值；两个属性，设值（属性名，属性值）</span></span><br><span class="line">$(<span class="string">""</span>).removeAttr();</span><br><span class="line"><span class="comment">//固有属性用prop</span></span><br><span class="line">$(<span class="string">""</span>).prop();   <span class="comment">//对一些标签的固有属性，需要使用prop代替attr。</span></span><br><span class="line">$(<span class="string">""</span>).removeProp();</span><br><span class="line">--------------------------CSS类</span><br><span class="line">$(<span class="string">""</span>).addClass(<span class="class"><span class="keyword">class</span>|<span class="title">fn</span>)</span></span><br><span class="line">$("").removeClass([class|fn])</span><br><span class="line">--------------------------HTML代码/文本/值</span><br><span class="line">$(<span class="string">""</span>).html([val|fn])</span><br><span class="line">$(<span class="string">""</span>).text([val|fn])</span><br><span class="line">$(<span class="string">""</span>).val([val|fn|arr])</span><br><span class="line">---------------------------</span><br><span class="line">$(<span class="string">""</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;chk1&quot; type&#x3D;&quot;checkbox&quot; &#x2F;&gt;是否可见</span><br><span class="line">&lt;input id&#x3D;&quot;chk2&quot; type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot; &#x2F;&gt;是否可见</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。</span><br><span class="line">&#x2F;&#x2F;对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。</span><br><span class="line">&#x2F;&#x2F;像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此</span><br><span class="line">&#x2F;&#x2F;需要使用prop方法去操作才能获得正确的结果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    $(&quot;#chk1&quot;).attr(&quot;checked&quot;)</span><br><span class="line">&#x2F;&#x2F;    undefined</span><br><span class="line">&#x2F;&#x2F;    $(&quot;#chk1&quot;).prop(&quot;checked&quot;)</span><br><span class="line">&#x2F;&#x2F;    false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  ---------手动选中的时候attr()获得到没有意义的undefined-----------</span><br><span class="line">&#x2F;&#x2F;    $(&quot;#chk1&quot;).attr(&quot;checked&quot;)</span><br><span class="line">&#x2F;&#x2F;    undefined</span><br><span class="line">&#x2F;&#x2F;    $(&quot;#chk1&quot;).prop(&quot;checked&quot;)</span><br><span class="line">&#x2F;&#x2F;    true</span><br><span class="line"></span><br><span class="line">    console.log($(&quot;#chk1&quot;).prop(&quot;checked&quot;));&#x2F;&#x2F;false</span><br><span class="line">    console.log($(&quot;#chk2&quot;).prop(&quot;checked&quot;));&#x2F;&#x2F;true</span><br><span class="line">    console.log($(&quot;#chk1&quot;).attr(&quot;checked&quot;));&#x2F;&#x2F;undefined</span><br><span class="line">    console.log($(&quot;#chk2&quot;).attr(&quot;checked&quot;));&#x2F;&#x2F;checked</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>实例之全反选</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;jquery-1.11.3.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">             function selectall()&#123;</span><br><span class="line"></span><br><span class="line">                 $(&quot;table :checkbox&quot;).prop(&quot;checked&quot;,true)</span><br><span class="line">             &#125;</span><br><span class="line">             function cancel()&#123;</span><br><span class="line"></span><br><span class="line">                 $(&quot;table :checkbox&quot;).prop(&quot;checked&quot;,false)</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             function reverse()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                 &#x2F;&#x2F;                 var idlist&#x3D;$(&quot;table :checkbox&quot;)</span><br><span class="line">&#x2F;&#x2F;                 for(var i&#x3D;0;i&lt;idlist.length;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;                     var element&#x3D;idlist[i];</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;                     var ischecked&#x3D;$(element).prop(&quot;checked&quot;)</span><br><span class="line">&#x2F;&#x2F;                     if (ischecked)&#123;</span><br><span class="line">&#x2F;&#x2F;                         $(element).prop(&quot;checked&quot;,false)</span><br><span class="line">&#x2F;&#x2F;                     &#125;</span><br><span class="line">&#x2F;&#x2F;                     else &#123;</span><br><span class="line">&#x2F;&#x2F;                         $(element).prop(&quot;checked&quot;,true)</span><br><span class="line">&#x2F;&#x2F;                     &#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;                 &#125;</span><br><span class="line">&#x2F;&#x2F;    jquery循环的两种方式</span><br><span class="line">                 &#x2F;&#x2F;方式一</span><br><span class="line">&#x2F;&#x2F;                 li&#x3D;[10,20,30,40]</span><br><span class="line">&#x2F;&#x2F;                 dic&#x3D;&#123;name:&quot;yuan&quot;,sex:&quot;male&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;                 $.each(li,function(i,x)&#123;</span><br><span class="line">&#x2F;&#x2F;                     console.log(i,x)</span><br><span class="line">&#x2F;&#x2F;                 &#125;)</span><br><span class="line"></span><br><span class="line">                 &#x2F;&#x2F;方式二</span><br><span class="line">&#x2F;&#x2F;                    $(&quot;tr&quot;).each(function()&#123;</span><br><span class="line">&#x2F;&#x2F;                        console.log($(this).html())</span><br><span class="line">&#x2F;&#x2F;                    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                 $(&quot;table :checkbox&quot;).each(function()&#123;</span><br><span class="line"></span><br><span class="line">                     $(this).prop(&quot;checked&quot;,!$(this).prop(&quot;checked&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;                     if ($(this).prop(&quot;checked&quot;))&#123;</span><br><span class="line">&#x2F;&#x2F;                         $(this).prop(&quot;checked&quot;,false)</span><br><span class="line">&#x2F;&#x2F;                     &#125;</span><br><span class="line">&#x2F;&#x2F;                     else &#123;</span><br><span class="line">&#x2F;&#x2F;                         $(this).prop(&quot;checked&quot;,true)</span><br><span class="line">&#x2F;&#x2F;                     &#125;</span><br><span class="line"></span><br><span class="line">                     &#x2F;&#x2F; 思考:如果用attr方法可以实现吗?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                 &#125;);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">     &lt;button onclick&#x3D;&quot;selectall();&quot;&gt;全选&lt;&#x2F;button&gt;</span><br><span class="line">     &lt;button onclick&#x3D;&quot;cancel();&quot;&gt;取消&lt;&#x2F;button&gt;</span><br><span class="line">     &lt;button onclick&#x3D;&quot;reverse();&quot;&gt;反选&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">     &lt;table border&#x3D;&quot;1&quot;&gt;</span><br><span class="line">         &lt;tr&gt;</span><br><span class="line">             &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">             &lt;td&gt;111&lt;&#x2F;td&gt;</span><br><span class="line">         &lt;&#x2F;tr&gt;</span><br><span class="line">         &lt;tr&gt;</span><br><span class="line">             &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">             &lt;td&gt;222&lt;&#x2F;td&gt;</span><br><span class="line">         &lt;&#x2F;tr&gt;</span><br><span class="line">         &lt;tr&gt;</span><br><span class="line">             &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">             &lt;td&gt;333&lt;&#x2F;td&gt;</span><br><span class="line">         &lt;&#x2F;tr&gt;</span><br><span class="line">         &lt;tr&gt;</span><br><span class="line">             &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">             &lt;td&gt;444&lt;&#x2F;td&gt;</span><br><span class="line">         &lt;&#x2F;tr&gt;</span><br><span class="line">     &lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>实例之模态对话框</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .back&#123;</span><br><span class="line">            background-color: rebeccapurple;</span><br><span class="line">            height: 2000px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .shade&#123;</span><br><span class="line">            position: fixed;</span><br><span class="line">            top: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            left:0;</span><br><span class="line">            right: 0;</span><br><span class="line">            background-color: coral;</span><br><span class="line">            opacity: 0.4;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .hide&#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .models&#123;</span><br><span class="line">            position: fixed;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            margin-left: -100px;</span><br><span class="line">            margin-top: -100px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            width: 200px;</span><br><span class="line">            background-color: gold;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;back&quot;&gt;</span><br><span class="line">    &lt;input id&#x3D;&quot;ID1&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;click&quot; onclick&#x3D;&quot;action1(this)&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;shade hide&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;models hide&quot;&gt;</span><br><span class="line">    &lt;input id&#x3D;&quot;ID2&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;cancel&quot; onclick&#x3D;&quot;action2(this)&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;jquery-1.11.3.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    function action1(self)&#123;</span><br><span class="line">        $(self).parent().siblings().removeClass(&quot;hide&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function action2(self)&#123;</span><br><span class="line">        &#x2F;&#x2F;$(self).parent().parent().children(&quot;.models,.shade&quot;).addClass(&quot;hide&quot;)</span><br><span class="line"></span><br><span class="line">        $(self).parent().addClass(&quot;hide&quot;).prev().addClass(&quot;hide&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-文档处理"><a href="#4-2-文档处理" class="headerlink" title="4.2 文档处理"></a>4.2 文档处理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;创建一个标签对象</span><br><span class="line">    $(&quot;&lt;p&gt;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;内部插入</span><br><span class="line"></span><br><span class="line">    $(&quot;&quot;).append(content|fn)      -----&gt;$(&quot;p&quot;).append(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;);</span><br><span class="line">    $(&quot;&quot;).appendTo(content)       -----&gt;$(&quot;p&quot;).appendTo(&quot;div&quot;);</span><br><span class="line">    $(&quot;&quot;).prepend(content|fn)     -----&gt;$(&quot;p&quot;).prepend(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;);</span><br><span class="line">    $(&quot;&quot;).prependTo(content)      -----&gt;$(&quot;p&quot;).prependTo(&quot;#foo&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;外部插入</span><br><span class="line"></span><br><span class="line">    $(&quot;&quot;).after(content|fn)       -----&gt;$(&quot;p&quot;).after(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;);</span><br><span class="line">    $(&quot;&quot;).before(content|fn)      -----&gt;$(&quot;p&quot;).before(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;);</span><br><span class="line">    $(&quot;&quot;).insertAfter(content)    -----&gt;$(&quot;p&quot;).insertAfter(&quot;#foo&quot;);</span><br><span class="line">    $(&quot;&quot;).insertBefore(content)   -----&gt;$(&quot;p&quot;).insertBefore(&quot;#foo&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;替换</span><br><span class="line">    $(&quot;&quot;).replaceWith(content|fn) -----&gt;$(&quot;p&quot;).replaceWith(&quot;&lt;b&gt;Paragraph. &lt;&#x2F;b&gt;&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除</span><br><span class="line"></span><br><span class="line">    $(&quot;&quot;).empty()   &#x2F;&#x2F;删除内容</span><br><span class="line">    $(&quot;&quot;).remove([expr])    &#x2F;&#x2F;删除标签</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;复制</span><br><span class="line"></span><br><span class="line">    $(&quot;&quot;).clone([Even[,deepEven]])</span><br></pre></td></tr></table></figure>
<p><strong>实例之复制样式条</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                        &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;+&quot; onclick&#x3D;&quot;add(this);&quot;&gt;</span><br><span class="line">                        &lt;input type&#x3D;&quot;text&quot;&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;jquery-1.11.3.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">            &#x2F;&#x2F;var $clone_obj&#x3D;$(self).parent().clone();  &#x2F;&#x2F; $clone_obj放在这个位置可以吗?</span><br><span class="line">            function add(self)&#123;</span><br><span class="line">                &#x2F;&#x2F; 注意:if var $clone_obj&#x3D;$(&quot;.outer .item&quot;).clone();会一遍二,二变四的增加</span><br><span class="line">                 var $clone_obj&#x3D;$(self).parent().clone();</span><br><span class="line">                 $clone_obj.children(&quot;:button&quot;).val(&quot;-&quot;).attr(&quot;onclick&quot;,&quot;removed(this)&quot;);</span><br><span class="line">                 $(self).parent().parent().append($clone_obj);</span><br><span class="line">            &#125;</span><br><span class="line">           function removed(self)&#123;</span><br><span class="line"></span><br><span class="line">               $(self).parent().remove()</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-css操作"><a href="#4-3-css操作" class="headerlink" title="4.3 css操作"></a>4.3 css操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CSS</span><br><span class="line">        $(&quot;&quot;).css(name|pro|[,val|fn])</span><br><span class="line">    位置</span><br><span class="line">        $(&quot;&quot;).offset([coordinates])   &#x2F;&#x2F;相对视口的偏移量</span><br><span class="line">        $(&quot;&quot;).position()    &#x2F;&#x2F;相对已经定位的父标签的偏移量</span><br><span class="line">        $(&quot;&quot;).scrollTop([val])  &#x2F;&#x2F;无参数查看值，，参数为0返回顶部</span><br><span class="line">        $(&quot;&quot;).scrollLeft([val])</span><br><span class="line">    尺寸</span><br><span class="line">        $(&quot;&quot;).height([val|fn])</span><br><span class="line">        $(&quot;&quot;).width([val|fn])</span><br><span class="line">        $(&quot;&quot;).innerHeight()     &#x2F;&#x2F;height+padding</span><br><span class="line">        $(&quot;&quot;).innerWidth() </span><br><span class="line">        $(&quot;&quot;).outerHeight([soptions])   &#x2F;&#x2F;height+padding+border. &#x2F;&#x2F;参数为true时，加margin</span><br><span class="line">        $(&quot;&quot;).outerWidth([options])</span><br></pre></td></tr></table></figure>
<p><strong>实例返回顶部</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;js&#x2F;jquery-2.2.3.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          window.onscroll&#x3D;function()&#123;    &#x2F;&#x2F;监听scroll距离</span><br><span class="line"></span><br><span class="line">              var current&#x3D;$(window).scrollTop();</span><br><span class="line">              console.log(current)</span><br><span class="line">              if (current&gt;100)&#123;</span><br><span class="line"></span><br><span class="line">                  $(&quot;.returnTop&quot;).removeClass(&quot;hide&quot;)</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">              $(&quot;.returnTop&quot;).addClass(&quot;hide&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           function returnTop()&#123;</span><br><span class="line">&#x2F;&#x2F;               $(&quot;.div1&quot;).scrollTop(0);</span><br><span class="line"></span><br><span class="line">               $(window).scrollTop(0)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body&#123;</span><br><span class="line">            margin: 0px;</span><br><span class="line">        &#125;</span><br><span class="line">        .returnTop&#123;</span><br><span class="line">            height: 60px;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background-color: darkgray;</span><br><span class="line">            position: fixed;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            color: greenyellow;</span><br><span class="line">            line-height: 60px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        .div1&#123;</span><br><span class="line">            background-color: orchid;</span><br><span class="line">            font-size: 5px;</span><br><span class="line">            overflow: auto;</span><br><span class="line">            width: 500px;</span><br><span class="line">        &#125;</span><br><span class="line">        .div2&#123;</span><br><span class="line">            background-color: darkcyan;</span><br><span class="line">        &#125;</span><br><span class="line">        .div3&#123;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">        &#125;</span><br><span class="line">        .div&#123;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        .hide&#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;div class&#x3D;&quot;div1 div&quot;&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">         &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line">     &lt;div class&#x3D;&quot;div2 div&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">     &lt;div class&#x3D;&quot;div3 div&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">     &lt;div class&#x3D;&quot;returnTop hide&quot; onclick&#x3D;&quot;returnTop();&quot;&gt;返回顶部&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="五-事件"><a href="#五-事件" class="headerlink" title="五 事件"></a>五 事件</h3><p>绑定方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">on方法</span><br><span class="line">	可以动态的添加</span><br><span class="line">bind方法</span><br><span class="line">	对已经存在的标签进行添加</span><br><span class="line">简写：</span><br><span class="line">	$(<span class="string">"ul"</span>).bind(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">	$(<span class="string">"ul"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;)  <span class="comment">//前面两种方法作用相同</span></span><br><span class="line">	$(<span class="string">"ul"</span>).on(<span class="string">"click"</span>,<span class="string">"li"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">页面载入</span><br><span class="line">    ready(fn)  &#x2F;&#x2F;当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。</span><br><span class="line">    $(document).ready(function()&#123;&#125;) -----------&gt; $(function()&#123;&#125;)</span><br><span class="line"></span><br><span class="line">事件处理</span><br><span class="line">    $(&quot;&quot;).on(event,[selector],[data],fn)  &#x2F;&#x2F; 在选择元素上绑定一个或多个事件的事件处理函数。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  .on的selector参数是筛选出调用.on方法的dom元素的指定子元素，如：</span><br><span class="line">    &#x2F;&#x2F;  $(&#39;ul&#39;).on(&#39;click&#39;, &#39;li&#39;, function()&#123;console.log(&#39;click&#39;);&#125;)就是筛选出ul下的li给其绑定</span><br><span class="line">    &#x2F;&#x2F;  click事件；</span><br><span class="line"></span><br><span class="line">    [selector]参数的好处:</span><br><span class="line">        好处在于.on方法为动态添加的元素也能绑上指定事件；如：</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;$(&#39;ul li&#39;).on(&#39;click&#39;, function()&#123;console.log(&#39;click&#39;);&#125;)的绑定方式和</span><br><span class="line">        &#x2F;&#x2F;$(&#39;ul li&#39;).bind(&#39;click&#39;, function()&#123;console.log(&#39;click&#39;);&#125;)一样；我通过js给ul添加了一个</span><br><span class="line">        &#x2F;&#x2F;li：$(&#39;ul&#39;).append(&#39;&lt;li&gt;js new li&lt;li&gt;&#39;)；这个新加的li是不会被绑上click事件的</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;但是用$(&#39;ul&#39;).on(&#39;click&#39;, &#39;li&#39;, function()&#123;console.log(&#39;click&#39;);&#125;方式绑定，然后动态添加</span><br><span class="line">        &#x2F;&#x2F;li:$(&#39;ul&#39;).append(&#39;&lt;li&gt;js new li&lt;li&gt;&#39;);这个新生成的li被绑上了click事件</span><br><span class="line">    </span><br><span class="line">    [data]参数的调用:</span><br><span class="line">             function myHandler(event) &#123;</span><br><span class="line">                alert(event.data.foo);</span><br><span class="line">                &#125;</span><br><span class="line">             $(&quot;li&quot;).on(&quot;click&quot;, &#123;foo: &quot;bar&quot;&#125;, myHandler)</span><br></pre></td></tr></table></figure>
<p><strong>实例之面板拖动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;border: 1px solid #ddd;width: 600px;position: absolute;&quot;&gt;</span><br><span class="line">        &lt;div id&#x3D;&quot;title&quot; style&#x3D;&quot;background-color: black;height: 40px;color: white;&quot;&gt;</span><br><span class="line">            标题</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;height: 300px;&quot;&gt;</span><br><span class="line">            内容</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery-2.2.3.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        &#x2F;&#x2F; 页面加载完成之后自动执行</span><br><span class="line">        $(&#39;#title&#39;).mouseover(function()&#123;</span><br><span class="line">            $(this).css(&#39;cursor&#39;,&#39;move&#39;);</span><br><span class="line">        &#125;).mousedown(function(e)&#123;</span><br><span class="line">            &#x2F;&#x2F;console.log($(this).offset());</span><br><span class="line">            var _event &#x3D; e || window.event;</span><br><span class="line">            &#x2F;&#x2F; 原始鼠标横纵坐标位置</span><br><span class="line">            var ord_x &#x3D; _event.clientX;</span><br><span class="line">            var ord_y &#x3D; _event.clientY;</span><br><span class="line"></span><br><span class="line">            var parent_left &#x3D; $(this).parent().offset().left;</span><br><span class="line">            var parent_top &#x3D; $(this).parent().offset().top;</span><br><span class="line"></span><br><span class="line">            $(this).bind(&#39;mousemove&#39;, function(e)&#123;</span><br><span class="line">                var _new_event &#x3D; e || window.event;</span><br><span class="line">                var new_x &#x3D; _new_event.clientX;</span><br><span class="line">                var new_y &#x3D; _new_event.clientY;</span><br><span class="line"></span><br><span class="line">                var x &#x3D; parent_left + (new_x - ord_x);</span><br><span class="line">                var y &#x3D; parent_top + (new_y - ord_y);</span><br><span class="line"></span><br><span class="line">                $(this).parent().css(&#39;left&#39;,x+&#39;px&#39;);</span><br><span class="line">                $(this).parent().css(&#39;top&#39;,y+&#39;px&#39;);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).mouseup(function()&#123;</span><br><span class="line">            $(this).unbind(&#39;mousemove&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>实例之放大镜</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;bigger&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        *&#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding:0;</span><br><span class="line">        &#125;</span><br><span class="line">        .outer&#123;</span><br><span class="line">            height: 350px;</span><br><span class="line">            width: 350px;</span><br><span class="line">            border: dashed 5px cornflowerblue;</span><br><span class="line">        &#125;</span><br><span class="line">        .outer .small_box&#123;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        .outer .small_box .float&#123;</span><br><span class="line">            height: 175px;</span><br><span class="line">            width: 175px;</span><br><span class="line">            background-color: darkgray;</span><br><span class="line">            opacity: 0.4;</span><br><span class="line">            fill-opacity: 0.4;</span><br><span class="line">            position: absolute;</span><br><span class="line">            display: none;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .outer .big_box&#123;</span><br><span class="line">            height: 400px;</span><br><span class="line">            width: 400px;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            position:absolute;</span><br><span class="line">            left: 360px;</span><br><span class="line">            top: 0px;</span><br><span class="line">            z-index: 1;</span><br><span class="line">            border: 5px solid rebeccapurple;</span><br><span class="line">            display: none;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .outer .big_box img&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            z-index: 5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;small_box&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;float&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;img src&#x3D;&quot;small.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;big_box&quot;&gt;</span><br><span class="line">                &lt;img src&#x3D;&quot;big.jpg&quot;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    $(function()&#123;</span><br><span class="line"></span><br><span class="line">          $(&quot;.small_box&quot;).mouseover(function()&#123;</span><br><span class="line"></span><br><span class="line">              $(&quot;.float&quot;).css(&quot;display&quot;,&quot;block&quot;);</span><br><span class="line">              $(&quot;.big_box&quot;).css(&quot;display&quot;,&quot;block&quot;)</span><br><span class="line"></span><br><span class="line">          &#125;);</span><br><span class="line">          $(&quot;.small_box&quot;).mouseout(function()&#123;</span><br><span class="line"></span><br><span class="line">              $(&quot;.float&quot;).css(&quot;display&quot;,&quot;none&quot;);</span><br><span class="line">              $(&quot;.big_box&quot;).css(&quot;display&quot;,&quot;none&quot;)</span><br><span class="line"></span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          $(&quot;.small_box&quot;).mousemove(function(e)&#123;</span><br><span class="line"></span><br><span class="line">              var _event&#x3D;e || window.event;</span><br><span class="line"></span><br><span class="line">              var float_width&#x3D;$(&quot;.float&quot;).width();</span><br><span class="line">              var float_height&#x3D;$(&quot;.float&quot;).height();</span><br><span class="line"></span><br><span class="line">              console.log(float_height,float_width);</span><br><span class="line"></span><br><span class="line">              var float_height_half&#x3D;float_height&#x2F;2;</span><br><span class="line">              var float_width_half&#x3D;float_width&#x2F;2;</span><br><span class="line">              console.log(float_height_half,float_width_half);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               var small_box_width&#x3D;$(&quot;.small_box&quot;).height();</span><br><span class="line">               var small_box_height&#x3D;$(&quot;.small_box&quot;).width();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  鼠标点距离左边界的长度与float应该与左边界的距离差半个float的width,height同理</span><br><span class="line">              var mouse_left&#x3D;_event.clientX-float_width_half;</span><br><span class="line">              var mouse_top&#x3D;_event.clientY-float_height_half;</span><br><span class="line"></span><br><span class="line">              if(mouse_left&lt;0)&#123;</span><br><span class="line">                  mouse_left&#x3D;0</span><br><span class="line">              &#125;else if (mouse_left&gt;small_box_width-float_width)&#123;</span><br><span class="line">                  mouse_left&#x3D;small_box_width-float_width</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              if(mouse_top&lt;0)&#123;</span><br><span class="line">                  mouse_top&#x3D;0</span><br><span class="line">              &#125;else if (mouse_top&gt;small_box_height-float_height)&#123;</span><br><span class="line">                  mouse_top&#x3D;small_box_height-float_height</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">               $(&quot;.float&quot;).css(&quot;left&quot;,mouse_left+&quot;px&quot;);</span><br><span class="line">               $(&quot;.float&quot;).css(&quot;top&quot;,mouse_top+&quot;px&quot;)</span><br><span class="line"></span><br><span class="line">               var percentX&#x3D;($(&quot;.big_box img&quot;).width()-$(&quot;.big_box&quot;).width())&#x2F; (small_box_width-float_width);</span><br><span class="line">               var percentY&#x3D;($(&quot;.big_box img&quot;).height()-$(&quot;.big_box&quot;).height())&#x2F;(small_box_height-float_height);</span><br><span class="line"></span><br><span class="line">              console.log(percentX,percentY)</span><br><span class="line"></span><br><span class="line">               $(&quot;.big_box img&quot;).css(&quot;left&quot;, -percentX*mouse_left+&quot;px&quot;)</span><br><span class="line">               $(&quot;.big_box img&quot;).css(&quot;top&quot;, -percentY*mouse_top+&quot;px&quot;)</span><br><span class="line">          &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="六-动画效果"><a href="#六-动画效果" class="headerlink" title="六 动画效果"></a>六 动画效果</h3><h4 id="显示隐藏"><a href="#显示隐藏" class="headerlink" title="显示隐藏"></a>显示隐藏</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.hide()</span><br><span class="line">.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">$(document).ready(function() &#123;</span><br><span class="line">    $(&quot;#hide&quot;).click(function () &#123;</span><br><span class="line">        $(&quot;p&quot;).hide(1000);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(&quot;#show&quot;).click(function () &#123;</span><br><span class="line">        $(&quot;p&quot;).show(1000);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用于切换被选元素的 hide() 与 show() 方法。</span><br><span class="line">    $(&quot;#toggle&quot;).click(function () &#123;</span><br><span class="line">        $(&quot;p&quot;).toggle();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;link type&#x3D;&quot;text&#x2F;css&quot; rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button id&#x3D;&quot;hide&quot;&gt;隐藏&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button id&#x3D;&quot;show&quot;&gt;显示&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button id&#x3D;&quot;toggle&quot;&gt;切换&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    $(document).ready(function()&#123;</span><br><span class="line">     $(&quot;#slideDown&quot;).click(function()&#123;</span><br><span class="line">         $(&quot;#content&quot;).slideDown(1000);</span><br><span class="line">     &#125;);</span><br><span class="line">      $(&quot;#slideUp&quot;).click(function()&#123;</span><br><span class="line">         $(&quot;#content&quot;).slideUp(1000);</span><br><span class="line">     &#125;);</span><br><span class="line">      $(&quot;#slideToggle&quot;).click(function()&#123;</span><br><span class="line">         $(&quot;#content&quot;).slideToggle(1000);</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line">        #content&#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            background-color: lightblue;</span><br><span class="line">            border:solid 1px red;</span><br><span class="line">            display: none;</span><br><span class="line">            padding: 50px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id&#x3D;&quot;slideDown&quot;&gt;出现&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;slideUp&quot;&gt;隐藏&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;slideToggle&quot;&gt;toggle&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id&#x3D;&quot;content&quot;&gt;helloworld&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加stop来阻止动画重复响应</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    $(document).ready(function()&#123;</span><br><span class="line">   $(&quot;#in&quot;).click(function()&#123;</span><br><span class="line">       $(&quot;#id1&quot;).fadeIn(1000);</span><br><span class="line">   &#125;);</span><br><span class="line">    $(&quot;#out&quot;).click(function()&#123;</span><br><span class="line">       $(&quot;#id1&quot;).fadeOut(1000);</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line">    $(&quot;#toggle&quot;).click(function()&#123;</span><br><span class="line">       $(&quot;#id1&quot;).fadeToggle(1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line">    $(&quot;#fadeto&quot;).click(function()&#123;</span><br><span class="line">       $(&quot;#id1&quot;).fadeTo(1000,0.4);</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">      &lt;button id&#x3D;&quot;in&quot;&gt;fadein&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button id&#x3D;&quot;out&quot;&gt;fadeout&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button id&#x3D;&quot;toggle&quot;&gt;fadetoggle&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button id&#x3D;&quot;fadeto&quot;&gt;fadeto&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div id&#x3D;&quot;id1&quot; style&#x3D;&quot;display:none; width: 80px;height: 80px;background-color: blueviolet&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;jquery-2.1.4.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button&gt;hide&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;p&gt;helloworld helloworld helloworld&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   $(&quot;button&quot;).click(function()&#123;</span><br><span class="line">       $(&quot;p&quot;).hide(1000,function()&#123;</span><br><span class="line">           alert($(this).html())</span><br><span class="line">       &#125;)</span><br><span class="line"></span><br><span class="line">   &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="七-扩展方法-插件机制"><a href="#七-扩展方法-插件机制" class="headerlink" title="七 扩展方法 (插件机制)"></a>七 扩展方法 (插件机制)</h3><h4 id="一-用JQuery写插件时，最核心的方两个方法"><a href="#一-用JQuery写插件时，最核心的方两个方法" class="headerlink" title="一 用JQuery写插件时，最核心的方两个方法"></a>一 用JQuery写插件时，最核心的方两个方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    </span><br><span class="line">$.extend(object)      <span class="comment">//为JQuery 添加一个静态方法。</span></span><br><span class="line">$.fn.extend(object)   <span class="comment">//为JQuery实例添加一个方法。</span></span><br><span class="line"></span><br><span class="line">$.extend(</span><br><span class="line">	Myfunc:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;<span class="built_in">console</span>.log($.min(<span class="number">3</span>,<span class="number">4</span>));&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    jQuery.extend(&#123;</span><br><span class="line">          min: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;,</span><br><span class="line">          max: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line">    <span class="string">"print"</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log($(<span class="keyword">this</span>)[i].innerHTML)</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// $.each($(this),function()&#123;&#125;)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"p"</span>).print();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="二-定义作用域"><a href="#二-定义作用域" class="headerlink" title="二 定义作用域"></a>二 定义作用域</h4><p>​      定义一个JQuery插件，首先要把这个插件的代码放在一个不受外界干扰的地方。如果用专业些的话来说就是要为这个插件定义私有作用域。外部的代码不能直接访问插件内部的代码。插件内部的代码不污染全局变量。在一定的作用上解耦了插件与运行环境的依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(a,b)&#123;return a+b&#125;)(3,5)</span><br><span class="line"></span><br><span class="line">       (function ($) &#123; &#125;)(jQuery);</span><br><span class="line">&#x2F;&#x2F;相当于</span><br><span class="line">        var fn &#x3D; function ($) &#123; &#125;;</span><br><span class="line">        fn(jQuery);</span><br></pre></td></tr></table></figure>
<h4 id="三-默认参数"><a href="#三-默认参数" class="headerlink" title="三 默认参数"></a>三 默认参数</h4><p>定义了jQuery插件之后，如果希望某些参数具有默认值，那么可以以这种方式来指定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;step01 定义JQuery的作用域</span><br><span class="line">(function ($) &#123;</span><br><span class="line">    &#x2F;&#x2F;step03-a 插件的默认值属性</span><br><span class="line">    var defaults &#x3D; &#123;</span><br><span class="line">        prevId: &#39;prevBtn&#39;,</span><br><span class="line">        prevText: &#39;Previous&#39;,</span><br><span class="line">        nextId: &#39;nextBtn&#39;,</span><br><span class="line">        nextText: &#39;Next&#39;</span><br><span class="line">        &#x2F;&#x2F;……</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;step06-a 在插件里定义方法</span><br><span class="line">    var showLink &#x3D; function (obj) &#123;</span><br><span class="line">        $(obj).append(function () &#123; return &quot;(&quot; + $(obj).attr(&quot;href&quot;) + &quot;)&quot; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;step02 插件的扩展方法名称</span><br><span class="line">    $.fn.easySlider &#x3D; function (options) &#123;</span><br><span class="line">        &#x2F;&#x2F;step03-b 合并用户自定义属性，默认属性</span><br><span class="line">        var options &#x3D; $.extend(defaults, options);</span><br><span class="line">        &#x2F;&#x2F;step4 支持JQuery选择器</span><br><span class="line">        &#x2F;&#x2F;step5 支持链式调用</span><br><span class="line">        return this.each(function () &#123;</span><br><span class="line">            &#x2F;&#x2F;step06-b 在插件里定义方法</span><br><span class="line">            showLink(this);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>
<h3 id="八-经典实例练习"><a href="#八-经典实例练习" class="headerlink" title="八 经典实例练习"></a><strong>八 经典实例练习</strong></h3><h4 id="实例之注册验证"><a href="#实例之注册验证" class="headerlink" title="实例之注册验证"></a><strong>实例之注册验证</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form class&#x3D;&quot;Form&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;&lt;input class&#x3D;&quot;v1&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; mark&#x3D;&quot;用户名&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input class&#x3D;&quot;v1&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; mark&#x3D;&quot;邮箱&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input class&#x3D;&quot;v1&quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;  onclick&#x3D;&quot;return validate()&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;jquery-3.1.1.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 注意:</span><br><span class="line">    &#x2F;&#x2F; DOM对象---&gt;jquery对象    $(DOM)</span><br><span class="line">    &#x2F;&#x2F; jquery对象---&gt;DOM对象    $(&quot;&quot;)[0]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; DOM绑定版本</span><br><span class="line">    function validate()&#123;</span><br><span class="line"></span><br><span class="line">        flag&#x3D;true;</span><br><span class="line"></span><br><span class="line">        $(&quot;Form .v1&quot;).each(function()&#123;</span><br><span class="line">            $(this).next(&quot;span&quot;).remove();&#x2F;&#x2F; 防止对此点击按钮产生多个span标签</span><br><span class="line">              var value&#x3D;$(this).val();</span><br><span class="line">            if (value.trim().length&#x3D;&#x3D;0)&#123;</span><br><span class="line">                 var mark&#x3D;$(this).attr(&quot;mark&quot;);</span><br><span class="line">                 var ele&#x3D;document.createElement(&quot;span&quot;);</span><br><span class="line">                 ele.innerHTML&#x3D;mark+&quot;不能为空!&quot;;</span><br><span class="line">                 $(this).after(ele);</span><br><span class="line">                 $(ele).prop(&quot;class&quot;,&quot;error&quot;);&#x2F;&#x2F; DOM对象转换为jquery对象</span><br><span class="line">                 flag&#x3D;false;</span><br><span class="line">                 &#x2F;&#x2F;  return false--------&gt;引出$.each的return false注意点</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return flag</span><br><span class="line">    &#125;</span><br><span class="line">                   &#x2F;&#x2F;---------------------------------------------------------</span><br><span class="line">&#x2F;&#x2F;---------------------------------------------------------</span><br><span class="line">                   &#x2F;&#x2F;---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        function f()&#123;</span><br><span class="line"></span><br><span class="line">        for(var i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line"></span><br><span class="line">            if (i&#x3D;&#x3D;2)&#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    f();  &#x2F;&#x2F; 这个例子大家应该不会有问题吧!!!</span><br><span class="line">&#x2F;&#x2F;------------------------------------------</span><br><span class="line">    li&#x3D;[11,22,33,44];</span><br><span class="line">    $.each(li,function(i,v)&#123;</span><br><span class="line"></span><br><span class="line">        if (v&#x3D;&#x3D;33)&#123;</span><br><span class="line">                return ;   &#x2F;&#x2F;  &#x3D;&#x3D;&#x3D;试一试 return false会怎样?</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(v)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  $.MyEach(obj,function(i,v)&#123;&#125;):</span><br><span class="line">         for(var i in obj)&#123;</span><br><span class="line"></span><br><span class="line">             func(i,obj[i]) ; &#x2F;&#x2F;  i就是索引,v就是对应值</span><br><span class="line">             &#x2F;&#x2F; &#123;&#125;:我们写的大括号的内容就是func的执行语句;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 大家再考虑: function里的return只是结束了当前的函数,并不会影响后面函数的执行</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;本来这样没问题,但因为我们的需求里有很多这样的情况:我们不管循环到第几个函数时,一旦return了,</span><br><span class="line">    &#x2F;&#x2F;希望后面的函数也不再执行了!基于此,jquery在$.each里又加了一步:</span><br><span class="line">         for(var i in obj)&#123;</span><br><span class="line"></span><br><span class="line">             ret&#x3D;func(i,obj[i]) ;</span><br><span class="line">             if(ret&#x3D;&#x3D;false)&#123;</span><br><span class="line">                 return ;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">    &#x2F;&#x2F; 这样就很灵活了:</span><br><span class="line">    &#x2F;&#x2F; &lt;1&gt;如果你想return后下面循环函数继续执行,那么就直接写return或return true</span><br><span class="line">    &#x2F;&#x2F; &lt;2&gt;如果你不想return后下面循环函数继续执行,那么就直接写return false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ---------------------------------------------------------------------</span><br><span class="line">   &#x2F;&#x2F; 说了这么多,请问大家如果我们的需求是:判断出一个输入有问题后面就不判断了(当然也就不显示了),</span><br><span class="line">   &#x2F;&#x2F; 怎么办呢?</span><br><span class="line">   &#x2F;&#x2F; 对了</span><br><span class="line">    if (value.trim().length&#x3D;&#x3D;0)&#123;</span><br><span class="line">                  &#x2F;&#x2F;...</span><br><span class="line">                  &#x2F;&#x2F;...</span><br><span class="line">                  &#x2F;&#x2F;flag&#x3D;false;  &#x2F;&#x2F;   flag&#x3D;false不要去,它的功能是最后如果有问题,不提交数据!</span><br><span class="line">                  return false</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;最后,大家尝试着用jquery的绑定来完成这个功能!</span><br><span class="line"></span><br><span class="line">      $(&quot;.Form :submit&quot;).click(function()&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p> <strong>轮播图片</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">            clear: both;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-id">#outer</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            height: 340px;</span><br><span class="line">            width: 790px;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            top: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.imgarea</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            height: 100%;</span><br><span class="line">            width: 100%;</span><br><span class="line">            list-style: none;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.imgarea</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">            display: inline-block;</span><br><span class="line">            position: absolute;</span><br><span class="line">            height: 100%;</span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.count</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            height: 20px;</span><br><span class="line">            list-style: none;</span><br><span class="line">            margin-left: 50%;</span><br><span class="line">            left: -30px;</span><br><span class="line">            bottom: 3px;</span><br><span class="line">            background-color: white;</span><br><span class="line">            padding: 5px 5px;</span><br><span class="line">            border-radius: 20px;</span><br><span class="line">            border: 0px solid red;</span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: 0<span class="selector-class">.7</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.count</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">            display: inline-block;</span><br><span class="line">            width: 20px;</span><br><span class="line">            height: 20px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#bbeff5</span>;</span></span><br><span class="line">            border-radius: 20px;</span><br><span class="line">            margin-left: 5px;</span><br><span class="line"></span><br><span class="line">            line-height: 20px;</span><br><span class="line">            text-align: center;</span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: 0<span class="selector-class">.5</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.count</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: 0<span class="selector-class">.9</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-id">#outer</span> <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 20px;</span><br><span class="line">            height: 60px;</span><br><span class="line">            top: 50%;</span><br><span class="line">            margin-top: -30px;</span><br><span class="line"></span><br><span class="line">            background-color: lightgrey;</span><br><span class="line">            color: white;</span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: 0<span class="selector-class">.5</span>;</span></span><br><span class="line"></span><br><span class="line">            line-height: 60px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-id">#outer</span> <span class="selector-id">#leftbtn</span> &#123;</span></span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-id">#outer</span> <span class="selector-id">#rightbtn</span> &#123;</span></span><br><span class="line">            right: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-id">#leftbtn</span><span class="selector-pseudo">:hover</span>, <span class="selector-id">#rightbtn</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: 0<span class="selector-class">.8</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.count</span> <span class="selector-class">.activate</span> &#123;</span></span><br><span class="line">            background-color: red;</span><br><span class="line">            opacity: 1;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"imgarea"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/1.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/2.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/4.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/5.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/6.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"count"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;div class="btn" id="leftbtn"&gt; &lt;&lt;/div&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">id</span>=<span class="string">"rightbtn"</span>&gt;</span> &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery-3.4.1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> cur_index = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; $(<span class="string">".imgarea li"</span>).length; ++i) &#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">".count"</span>).append(<span class="string">"&lt;li&gt;"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        $(<span class="string">".imgarea li"</span>).eq(cur_index).show().siblings().hide();</span></span><br><span class="line"><span class="javascript">        $(<span class="string">".count li"</span>).eq(cur_index).addClass(<span class="string">'activate'</span>).siblings().removeClass(<span class="string">'activate'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">goR</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">            ++cur_index;</span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (cur_index &gt; $(<span class="string">".imgarea li"</span>).length) &#123;</span></span><br><span class="line">                cur_index = 0;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            $(<span class="string">".imgarea li"</span>).eq(cur_index).stop().fadeIn(<span class="number">800</span>).siblings().stop().fadeOut(<span class="number">800</span>)</span></span><br><span class="line"><span class="javascript">            $(<span class="string">".count li"</span>).eq(cur_index).addClass(<span class="string">'activate'</span>).siblings().removeClass(<span class="string">'activate'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">goL</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">            --cur_index;</span><br><span class="line">            if (cur_index &lt; 0) &#123;</span><br><span class="line"><span class="javascript">                cur_index = $(<span class="string">".imgarea li"</span>).length;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            $(<span class="string">".imgarea li"</span>).eq(cur_index).stop().fadeIn(<span class="number">800</span>).siblings().stop().fadeOut(<span class="number">800</span>)</span></span><br><span class="line"><span class="javascript">            $(<span class="string">".count li"</span>).eq(cur_index).addClass(<span class="string">'activate'</span>).siblings().removeClass(<span class="string">'activate'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        $(<span class="string">".count li"</span>).mouseover(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            cur_index = $(<span class="keyword">this</span>).index()</span></span><br><span class="line"><span class="javascript">            $(<span class="string">".imgarea li"</span>).eq(cur_index).stop().fadeIn(<span class="number">800</span>).siblings().stop().fadeOut(<span class="number">800</span>)</span></span><br><span class="line"><span class="javascript">            $(<span class="string">".count li"</span>).eq(cur_index).addClass(<span class="string">'activate'</span>).siblings().removeClass(<span class="string">'activate'</span>);</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        $(<span class="string">"#rightbtn"</span>).click(goR)</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#leftbtn"</span>).click(goL)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> intv = setInterval(goR, <span class="number">1500</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        $(<span class="string">"#outer"</span>).hover(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            clearInterval(intv)</span><br><span class="line"><span class="actionscript">        &#125;, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">            intv = setInterval(goR, 1500)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>kaggle笔记-1(数据处理)</title>
    <url>/2020/01/30/kaggle%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h1 id="分类的分析"><a href="#分类的分析" class="headerlink" title="分类的分析"></a>分类的分析</h1><a id="more"></a>
<ol>
<li>获得数据</li>
<li>分析数据<ul>
<li>类别数据<ul>
<li>等级数据</li>
<li>分类数据</li>
</ul>
</li>
<li>连续数据</li>
<li>字母/数字/混合数据</li>
</ul>
</li>
<li>通过透视表pivot table分析数据</li>
<li>通过图表可视化分析数据<ul>
<li>分析等级数据</li>
<li>分析普通分类数据</li>
<li>分析数据之间的关系<ul>
<li>相关性 <code>data.corr().nlargest(10,&quot;result&quot;)[&quot;result]</code></li>
</ul>
</li>
</ul>
</li>
<li>处理数据<ul>
<li>选择特征<ul>
<li>缺失数据少</li>
<li>具有代表性</li>
</ul>
</li>
<li>处理缺失数据<ul>
<li>随机数</li>
<li>使用其他相关的参数进行估计（均值、中位数等）</li>
</ul>
</li>
<li>处理离群值</li>
<li>根据实际情况添加特征</li>
<li>删除特征</li>
<li>添加新特征</li>
</ul>
</li>
<li><p>模型选择</p>
<ul>
<li>监督学习<ul>
<li>分类问题（逻辑回归，KNN，决策树，SVM，朴素贝叶斯，随机森林，感知机，人工神经网络，RVE(关联向量机)）</li>
</ul>
</li>
</ul>
</li>
<li><p>模型训练</p>
</li>
<li>模型结果分析</li>
</ol>
<h1 id="常用技术"><a href="#常用技术" class="headerlink" title="常用技术"></a>常用技术</h1><h2 id="特征提取和分析"><a href="#特征提取和分析" class="headerlink" title="特征提取和分析"></a>特征提取和分析</h2><p><a href="https://www.kaggle.com/kashnitsky/topic-6-feature-engineering-and-feature-selection/notebook" target="_blank" rel="noopener">https://www.kaggle.com/kashnitsky/topic-6-feature-engineering-and-feature-selection/notebook</a></p>
<ul>
<li><strong>文本</strong><br><code>from sklearn.feature_extraction.text import CountVectorizer</code></li>
<li><strong>图像</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(url)</span><br><span class="line">img = Image.open(BytesIO(response.content))</span><br></pre></td></tr></table></figure></li>
<li><strong>地理位置数据</strong></li>
<li><strong>时间和日期</strong></li>
<li><strong>时间序列</strong></li>
</ul>
<h2 id="特征转换"><a href="#特征转换" class="headerlink" title="特征转换"></a>特征转换</h2><ul>
<li>正则化和改变分布<br><code>from sklearn.preprocessing import StandardScaler</code> 规范化<br><code>from sklearn.preprocessing import MinMaxScaler</code> 将数据重新分布在min和max之间<br><code>from scipy.stats import lognorm;
data = lognorm(s=1).rvs(1000)</code> 将对数正态分布转换为正态分布</li>
</ul>
<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><ul>
<li>统计方法<br>方差小的认为数据的变化小<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line">VarianceThreshold(<span class="number">.7</span>).fit_transform(x_data_generated)</span><br></pre></td></tr></table></figure>
<a href="https://scikit-learn.org/stable/modules/feature_selection.html#univariate-feature-selection" target="_blank" rel="noopener">其他统计学方法</a></li>
<li>通过模型选择</li>
<li>GridSearch</li>
</ul>
<h2 id="xgboost"><a href="#xgboost" class="headerlink" title="xgboost"></a>xgboost</h2><p>　　Xgboost是Boosting算法的其中一种，Boosting算法的思想是将许多弱分类器集成在一起，形成一个强分类器。因为Xgboost是一种提升树模型，所以它是将许多树模型集成在一起，形成一个很强的分类器。而所用到的树模型则是CART回归树模型。<br>　　Xgboost是在GBDT的基础上进行改进，使之更强大，适用于更大范围。<br>　　Xgboost一般和sklearn一起使用，但是由于sklearn中没有集成Xgboost，所以才需要单独下载安装。</p>
<h3 id="xgboost教程"><a href="#xgboost教程" class="headerlink" title="xgboost教程"></a>xgboost教程</h3><pre><code>分类问题和回归问题
https://zhuanlan.zhihu.com/p/31182879
</code></pre><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><ol>
<li>选择特定dtype对应的列<br><code>[x  if data[c].dtype == np.dtype(&quot;O&quot;) else y for c in data]</code><br><code>categorical_features = df.select_dtypes(include=&quot;object&quot;)</code><br><code>numerical_features = df.select_dtypes(exclude=&quot;object&quot;)</code></li>
</ol>
<h2 id="seaborn"><a href="#seaborn" class="headerlink" title="seaborn"></a>seaborn</h2><ol>
<li><p>分析相关性<br><code>sns.heatmap(titanic.corr())</code></p>
<details>
<summary><b>heatmap参数</b></summary>
<p><b>cmap</b>：matplotlib 颜色条名称或者对象，或者是颜色列表，可选参数。 </p>
<p><b>center</b>：浮点数，可选参数。 </p>
<p><b>annot</b>:布尔值或者矩形数据，可选参数。(如果为True，则在每个热力图单元格中写入数据值。) </p>
<p><b>fmt</b>：字符串，可选参数。 </p>
<p><b>annot_kws</b>：字典或者键值对，可选参数。 </p>
<p><b>linewidths</b>：浮点数，可选参数。 </p>
<p><b>linecolor</b>：颜色，可选参数 </p>
<p><b>square</b>：布尔值，可选参数。(如果为True，则将坐标轴方向设置为“equal”，以使每个单元格为方形。) </p>
<p><b>xticklabels, yticklabels</b>：“auto”，布尔值，类列表值，或者整形数值，可选参数。 </p>
<p><b>mask</b>：布尔数组或者DataFrame数据，可选参数。 </p>
</details>
</li>
<li><p>检查正态和线性<br>:```python</p>
<h1 id="histogram-and-normal-probability-plot"><a href="#histogram-and-normal-probability-plot" class="headerlink" title="histogram and normal probability plot"></a>histogram and normal probability plot</h1><p>sns.distplot(df_train[‘GrLivArea’], fit=norm);<br>fig = plt.figure()<br>res = stats.probplot(df_train[‘GrLivArea’], plot=plt)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## sklearn</span><br><span class="line">1. 预处理</span><br><span class="line">  - 将字符串类别转换为数字</span><br><span class="line">  &#96;&#96;&#96; python</span><br><span class="line">  from sklearn.preprocessing import LabelEncoder</span><br><span class="line">  la &#x3D; LabelEncoder()</span><br><span class="line">  result &#x3D; la.fit_transform(data)</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义转换器<blockquote>
<p>FeatureUnion将不同的转换器应用于整个输入数据，然后通过将它们合并来组合结果。<br>另一方面，ColumnTransformer将不同的转换器应用于整个输入数据的不同子集，并再次将结果连接起来(比如说对每一列的数据进行处理)。</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TitleSelector</span><span class="params">(BaseEstimator, TransformerMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">( self)</span>:</span></span><br><span class="line">        self.dict_title = &#123;</span><br><span class="line">            <span class="string">"Capt"</span>:       <span class="number">0</span>,</span><br><span class="line">            <span class="string">"Col"</span>:        <span class="number">0</span>,</span><br><span class="line">            <span class="string">"Major"</span>:      <span class="number">0</span>,</span><br><span class="line">            <span class="string">"Jonkheer"</span>:   <span class="number">1</span>,</span><br><span class="line">            <span class="string">"Don"</span>:        <span class="number">1</span>,</span><br><span class="line">            <span class="string">"Sir"</span> :       <span class="number">1</span>,</span><br><span class="line">            <span class="string">"Dr"</span>:         <span class="number">0</span>,</span><br><span class="line">            <span class="string">"Rev"</span>:        <span class="number">0</span>,</span><br><span class="line">            <span class="string">"the Countess"</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">"Dona"</span>:       <span class="number">1</span>,</span><br><span class="line">            <span class="string">"Mme"</span>:        <span class="number">2</span>,</span><br><span class="line">            <span class="string">"Mlle"</span>:       <span class="number">3</span>,</span><br><span class="line">            <span class="string">"Ms"</span>:         <span class="number">2</span>,</span><br><span class="line">            <span class="string">"Mr"</span> :        <span class="number">4</span>,</span><br><span class="line">            <span class="string">"Mrs"</span> :       <span class="number">2</span>,</span><br><span class="line">            <span class="string">"Miss"</span> :      <span class="number">3</span>,</span><br><span class="line">            <span class="string">"Master"</span> :    <span class="number">5</span>,</span><br><span class="line">            <span class="string">"Lady"</span> :      <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">( self, X, y=None)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(X[<span class="string">"Name"</span>]):</span><br><span class="line">            <span class="keyword">for</span> title <span class="keyword">in</span> self.dict_title.keys():</span><br><span class="line">                <span class="keyword">if</span> title <span class="keyword">in</span> name:</span><br><span class="line">                    X[<span class="string">"Name"</span>][i] = self.dict_title[title]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">assert</span> X[<span class="string">"Name"</span>][i] <span class="keyword">in</span> self.dict_title.values()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line">    </span><br><span class="line">name_transformer = Pipeline(steps=[</span><br><span class="line">    (<span class="string">'name'</span>, TitleSelector()),</span><br><span class="line">    (<span class="string">'onehot'</span>, OneHotEncoder(handle_unknown=<span class="string">'ignore'</span>))</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><strong>使用ColumnTransformer</strong>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_cols = [<span class="string">"Age"</span>, <span class="string">"Fare"</span>, ]</span><br><span class="line">cat_cols = [<span class="string">"Pclass"</span>, <span class="string">"Sex"</span>, <span class="string">"SibSp"</span>, <span class="string">"Parch"</span>, <span class="string">"Ticket"</span>, <span class="string">"Cabin"</span>, <span class="string">"Embarked"</span>]</span><br><span class="line">cols = num_cols + cat_cols + [<span class="string">"Name"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">preprocessor = ColumnTransformer(transformers=[</span><br><span class="line">    (<span class="string">'num'</span>, numerical_transformer, num_cols),</span><br><span class="line">    (<span class="string">'name'</span>, name_transformer, [<span class="string">"Name"</span>]),</span><br><span class="line">    (<span class="string">'cat'</span>, categorical_transformer, cat_cols),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">X_train = preprocessor.fit_transform(df_train[cols])</span><br><span class="line">y_train = df_train[<span class="string">"Survived"</span>].values</span><br></pre></td></tr></table></figure>
<ul>
<li>标准化、正则化<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准化：均值为0，方差为1</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> scale,StandardScaler</span><br><span class="line">scaler = preprocessing.StandardScaler().fit(X)</span><br><span class="line">scaler = preprocessing.StandardScaler().fit_transform(X)</span><br><span class="line"><span class="comment"># 限制范围</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line">preprocessing.MinMaxScaler().fit_transform(X)</span><br><span class="line"><span class="comment"># 正则化:范数为1</span></span><br><span class="line">preprocessing.normalize(X, norm=<span class="string">'l2'</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>模型训练<ul>
<li>pipeline</li>
<li>超参数搜索<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line">   <span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">   <span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">   </span><br><span class="line">   clf = Pipeline([(<span class="string">"cls"</span>,AdaBoostClassifier(DecisionTreeClassifier(),algorithm=<span class="string">"SAMME"</span>,n_estimators=<span class="number">600</span>, learning_rate=<span class="number">0.7</span>))])</span><br><span class="line">   params = [&#123;<span class="string">"cls__learning_rate"</span>:np.linspace(<span class="number">0.1</span>,<span class="number">1</span>,<span class="number">10</span>)&#125;]</span><br><span class="line">   grid_search = GridSearchCV(clf,params,cv=<span class="number">3</span>)</span><br><span class="line">   </span><br><span class="line">   grid_search.fit(X_train,Y_train)</span><br><span class="line">   grid_search.best_score_</span><br><span class="line">  ``` </span><br><span class="line"><span class="number">3.</span> 模型结果</span><br><span class="line">  ```python</span><br><span class="line">  model.predict(x_test)</span><br><span class="line">  model.score(X_train,y_train)</span><br><span class="line">  ```  </span><br><span class="line"><span class="number">4.</span> 结果分析</span><br><span class="line">   ```python</span><br><span class="line">   <span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> learning_curve</span><br><span class="line">   N_train, val_train, val_test = learning_curve(pipeline,</span><br><span class="line">                                                  X, y, train_sizes=train_sizes, cv=<span class="number">5</span>,</span><br><span class="line">                                                  scoring=<span class="string">'roc_auc'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h2><ol>
<li><p>层</p>
<ul>
<li>Dense：全连接层</li>
<li>Dropout：dropout层</li>
<li>BatchNormalization：批标准化层</li>
<li>conv2D：卷积层</li>
<li>Embedding：类似onehot编码处理，但是会避免稀疏性</li>
</ul>
</li>
<li><p>模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense, Dropout, BatchNormalization</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">32</span>, input_dim=<span class="number">858</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.9</span>))</span><br><span class="line">model.add(Dense(<span class="number">32</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(Dropout(<span class="number">0.9</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.compile(loss=<span class="string">'binary_crossentropy'</span>, optimizer=<span class="string">'adam'</span>, metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.fit(X_train, y_train, epochs=<span class="number">1000</span>, batch_size=<span class="number">8</span>)</span><br><span class="line">X_test = preprocessor.transform(df_test[cols])</span><br><span class="line">y_pred = model.predict_classes(X_test)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>print(model.summary())</code>显示模型的详细信息</p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>   <a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="noopener">泰坦尼克号1</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title>html</title>
    <url>/2020/06/29/html/</url>
    <content><![CDATA[<h2 id="前端概述"><a href="#前端概述" class="headerlink" title="前端概述"></a>前端概述</h2><a id="more"></a>
<p><img src="image/877318-20160622221214969-916045696.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.bind((&#39;localhost&#39;,8089))</span><br><span class="line">    sock.listen(5)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        connection, address &#x3D; sock.accept()</span><br><span class="line">        buf &#x3D; connection.recv(1024)</span><br><span class="line"></span><br><span class="line">        connection.sendall(bytes(&quot;HTTP&#x2F;1.1 201 OK\r\n\r\n&quot;,&quot;utf8&quot;))</span><br><span class="line"></span><br><span class="line">        connection.sendall(bytes(&quot;&lt;h1&gt;Hello,World&lt;&#x2F;h1&gt;&quot;,&quot;utf8&quot;))</span><br><span class="line"></span><br><span class="line">        connection.close()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="html-css-以及js的关系"><a href="#html-css-以及js的关系" class="headerlink" title="html css 以及js的关系"></a>html css 以及js的关系</h3><p><img src="image/877318-20160621155609897-1758730933.jpg" alt="img"></p>
<h2 id="HTML的学习"><a href="#HTML的学习" class="headerlink" title="HTML的学习"></a>HTML的学习</h2><h3 id="HTML-是什么？"><a href="#HTML-是什么？" class="headerlink" title="HTML 是什么？"></a>HTML 是什么？</h3><p>htyper text markup language  即超文本标记语言</p>
<p>超文本: 就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。</p>
<p>标记语言: 标记（标签）构成的语言.</p>
<p>网页==HTML文档，由浏览器解析，用来展示的</p>
<p>静态网页：静态的资源，如xxx.html</p>
<p>动态网页：html代码是由某种开发语言根据用户请求动态生成的</p>
<p><strong>html文档树形结构图：</strong></p>
<p>  <img src="image/877318-20161025132859984-662031019.png" alt="img"></p>
<h3 id="什么是标签"><a href="#什么是标签" class="headerlink" title="什么是标签"></a>什么是标签</h3><ul>
<li>是由一对尖括号包裹的单词构成 例如: <code>&lt;html&gt;</code> *所有标签中的单词不可能以数字开头.</li>
<li>标签不区分大小写.<code>&lt;html&gt;</code> 和 <code>&lt;HTML&gt;</code>. 推荐使用小写.</li>
<li>标签分为两部分: 开始标签<code>&lt;a&gt;</code> 和 结束标签<code>&lt;/a&gt;</code>. 两个标签之间的部分 我们叫做标签体.</li>
<li>有些标签功能比较简单.使用一个标签即可.这种标签叫做自闭和标签.例如: <code>&lt;br/&gt; &lt;hr/&gt; &lt;input /&gt; &lt;img /&gt;</code></li>
<li>标签可以嵌套.但是不能交叉嵌套. <code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code></li>
</ul>
<h3 id="标签的属性"><a href="#标签的属性" class="headerlink" title="标签的属性"></a>标签的属性</h3><ul>
<li>通常是以键值对形式出现的. 例如 name=”alex”</li>
<li>属性只能出现在开始标签 或 自闭和标签中.</li>
<li>属性名字全部小写. *属性值必须使用双引号或单引号包裹 例如 name=”alex”</li>
<li>如果属性值和属性名完全一样.直接写属性名即可. 例如 readonly</li>
</ul>
<h3 id="lt-DOCTYPE-html-gt-标签"><a href="#lt-DOCTYPE-html-gt-标签" class="headerlink" title="&lt;!DOCTYPE html&gt;标签"></a><code>&lt;!DOCTYPE html&gt;</code>标签</h3><p>​      由于历史的原因，各个浏览器在对页面的渲染上存在差异，甚至同一浏览器在不同版本中，对页面的渲染也不同。在<br>W3C标准出台以前，浏览器在对页面的渲染上没有统一规范，产生了差异(Quirks mode或者称为Compatibility<br>Mode)；由于W3C标准的推出，浏览器渲染页面有了统一的标准(CSScompat或称为Strict mode也有叫做Standars<br>mode)，这就是二者最简单的区别。<br>​      W3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，<br>很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以<br>前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。这样浏览器渲染上就产生了Quircks mode<br>和Standars mode，两种渲染方法共存在一个浏览器上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.top.document.compatMode：</span><br><span class="line">&#x2F;&#x2F;BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。 </span><br><span class="line">&#x2F;&#x2F;CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。</span><br></pre></td></tr></table></figure>
<p>​       这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat,</p>
<p>这也就是恶魔的开始 — 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。</p>
<p>​    如果你的页面添加了<code>&lt;!DOCTYPE html&gt;</code>那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的</p>
<p>标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。</p>
<p>这就是<code>&lt;!DOCTYPE html&gt;</code>的作用。</p>
<h3 id="head标签"><a href="#head标签" class="headerlink" title="head标签"></a>head标签</h3><p><code>&lt;meta&gt;</code><br>​         meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</p>
<p>​        1: name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。     </p>
<p>​        2: http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content, content中的内容其实就是各个参数的变量值。   </p>
<p> 注意：X-UA-Compatible</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个主要版本IE新增的功能都是为了让浏览器更容易使用、增加安全性及更支持业界标准。以这些作为IE的特色，其中</span><br><span class="line">一个风险就是旧版本网站无法正确的显示。</span><br><span class="line"></span><br><span class="line">为了将这个风险降到最低，IE6允许网页开发人员选择IE编译和显示他们网页的方式。&quot;Quirks mode&quot;为预设，这会</span><br><span class="line">使页面以旧版本浏览器的视点显示，&quot;Standards mode&quot;(也称为&quot;strict mode&quot;)特点是支持业界标准最为完善。</span><br><span class="line">然而要利用这个增强的支持功能，网页必须包含恰当的&lt;!DOCTYPE&gt;指令。</span><br><span class="line"></span><br><span class="line">若一个网页没有包含&lt;!DOCTYPE&gt;指令，IE6会将它以quirks mode显示。若网页包含有效的&lt;!DOCTYPE&gt;指令但浏</span><br><span class="line">览器无法辨识，IE6会将它以IE6 standards mode显示。因为少数网站已经包含&lt;!DOCTYPE&gt;指令，兼容性模式的</span><br><span class="line">切换相当成功。这使网页开发人员能选择将他们的网页转移为standards mode的最佳时机。</span><br><span class="line"></span><br><span class="line">随著时间经过，更多网站开始使用standards mode。它们也开始使用IE6的特性和功能来检测IE。举例来说，IE6</span><br><span class="line">不支持universal selector(即css之全局选择器 * &#123;&#125;)，一些网站便使用它来针对IE做特定的对应。</span><br><span class="line"></span><br><span class="line">当 IE7增加了对全域选择器的支持，那些依赖IE6特点的网站便无法侦测出这个新版本的浏览器。因此那些针对IE的</span><br><span class="line">特定对应无法应用于IE7，造成这些网站便无法如他们预期的显示。由于&lt;!DOCTYPE&gt;只支持两种兼容性模式，受到影</span><br><span class="line">响的网站拥有者被迫更新他们的网站使其能支持IE7。</span><br><span class="line"></span><br><span class="line">IE8 比之前的任何版本浏览器都更支持业界标准，因此针对旧版本浏览器设计的网页可能无法如预期般呈现。为了帮</span><br><span class="line">助减轻所有问题，IE8引入文件兼容性的概念，使你能选择你的网页设计要对应的特定IE版本。文件兼容性在IE8增加</span><br><span class="line">了一些新的模式，这些模式能告诉浏览器如何解析和编译一个网页。若你的网页无法在 ie8正确的显示，你可以更新</span><br><span class="line">你的网站使它支持最新的网页标准(优先选项)或在你的页面上新增一个meta元素用于告诉IE8如何依照旧版本浏览器</span><br><span class="line">编译你的页面。</span><br><span class="line"></span><br><span class="line">这能让你选择将你的网站更新支持IE8新特点的时机。</span><br><span class="line"></span><br><span class="line">当 Internet Explorer 8 遇到未包含 X-UA-Compatible 标头的网页时，它将使用 &lt;!DOCTYPE&gt; 指令来确</span><br><span class="line">定如何显示该网页。 如果该指令丢失或未指定基于标准的文档类型，则 Internet Explorer 8 将以 IE5 模式</span><br><span class="line">（Quirks 模式）显示该网页。</span><br></pre></td></tr></table></figure>
<p> <strong>非meta标签</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;title&gt;oldboy&lt;&#x2F;title&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.jd.com&#x2F;favicon.ico&quot;&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;hello.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h3><h4 id="一-基本标签（块级标签和内联标签）"><a href="#一-基本标签（块级标签和内联标签）" class="headerlink" title="一 基本标签（块级标签和内联标签）"></a>一 基本标签（<strong>块级标签和内联标签</strong>）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hn&gt;: n的取值范围是1~6; 从大到小. 用来表示标题.</span><br><span class="line"></span><br><span class="line">&lt;p&gt;: 段落标签. 包裹的内容被换行.并且也上下内容之间有一行空白.</span><br><span class="line"></span><br><span class="line">&lt;b&gt; &lt;strong&gt;: 加粗标签.</span><br><span class="line"></span><br><span class="line">&lt;strike&gt;: 为文字加上一条中线.</span><br><span class="line"></span><br><span class="line">&lt;em&gt;: 文字变成斜体.</span><br><span class="line"></span><br><span class="line">&lt;sup&gt;和&lt;sub&gt;: 上角标 和 下角表.</span><br><span class="line"></span><br><span class="line">&lt;br&gt;:换行.</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;:水平线</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;span&gt;</span><br></pre></td></tr></table></figure>
<p><strong>块级标签</strong>：<code>&lt;p&gt;&lt;h1&gt;&lt;table&gt;&lt;ol&gt;&lt;ul&gt;&lt;form&gt;&lt;div&gt;</code></p>
<p><strong>内联标签：</strong><code>&lt;a&gt;&lt;input&gt;&lt;img&gt;&lt;sub&gt;&lt;sup&gt;&lt;textarea&gt;&lt;span&gt;</code></p>
<p><strong>block（块）元素的特点</strong></p>
<p> 总是在新行上开始；<br> <strong>宽度缺省是它的容器的100%，除非设定一个宽度。</strong><br> 它可以容纳内联元素和其他块元素</p>
<p><strong>inline元素的特点</strong></p>
<p>和其他元素都在一行上；<br>宽度就是它的文字或图片的宽度，不可改变<br>内联元素只能容纳文本或者其他内联元素</p>
<p><strong>特殊字符</strong></p>
<p>​     <code>&amp;lt; &amp;gt；&amp;quot；\&amp;copy;\&amp;reg;</code></p>
<p><strong>标签属性</strong></p>
<p>id 标签的属性！！！！！  用#符号来引用</p>
<h4 id="二-图形标签"><a href="#二-图形标签" class="headerlink" title="二 图形标签: \"></a>二 图形标签: \<img></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src: 要显示图片的路径.</span><br><span class="line"></span><br><span class="line">alt: 图片没有加载成功时的提示.</span><br><span class="line"></span><br><span class="line">title: 鼠标悬浮时的提示信息.</span><br><span class="line"></span><br><span class="line">width: 图片的宽</span><br><span class="line"></span><br><span class="line">height:图片的高 (宽高两个属性只用一个会自动等比缩放.)</span><br></pre></td></tr></table></figure>
<h4 id="三-超链接标签-锚标签"><a href="#三-超链接标签-锚标签" class="headerlink" title="三 超链接标签(锚标签)\"></a>三 超链接标签(锚标签)\<a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">href:要连接的资源路径 格式如下: href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; </span><br><span class="line"></span><br><span class="line">target: _blank : 在新的窗口打开超链接. 框架名称: 在指定框架中打开连接内容.</span><br><span class="line"></span><br><span class="line">name: 定义一个页面的书签.</span><br><span class="line"></span><br><span class="line">用于跳转 href : #id.（锚）</span><br></pre></td></tr></table></figure>
<h4 id="四-列表标签："><a href="#四-列表标签：" class="headerlink" title="四 列表标签："></a>四 列表标签：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;: 无序列表</span><br><span class="line"></span><br><span class="line">&lt;ol&gt;: 有序列表</span><br><span class="line">         &lt;li&gt;:列表中的每一项.</span><br><span class="line"></span><br><span class="line">&lt;dl&gt;  定义列表</span><br><span class="line"></span><br><span class="line">         &lt;dt&gt; 列表标题</span><br><span class="line">         &lt;dd&gt; 列表项</span><br></pre></td></tr></table></figure>
<h4 id="五-表格标签"><a href="#五-表格标签" class="headerlink" title="五 表格标签: \"></a>五 表格标签: \<table></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border: 表格边框.</span><br><span class="line"></span><br><span class="line">cellpadding: 内边距</span><br><span class="line"></span><br><span class="line">cellspacing: 外边距.</span><br><span class="line"></span><br><span class="line">width: 像素 百分比.（最好通过css来设置长宽）</span><br><span class="line"></span><br><span class="line">&lt;tr&gt;: table rowc</span><br><span class="line"></span><br><span class="line">&lt;th&gt;: table head cell</span><br><span class="line"></span><br><span class="line">&lt;td&gt;: table data cell</span><br><span class="line"></span><br><span class="line">rowspan:  单元格竖跨多少行</span><br><span class="line"></span><br><span class="line">colspan:  单元格横跨多少列（即合并单元格）</span><br><span class="line"></span><br><span class="line">&lt;th&gt;: table header &lt;tbody&gt;(不常用): 为表格进行分区.</span><br></pre></td></tr></table></figure>
<h4 id="六-表单标签-lt-form-gt"><a href="#六-表单标签-lt-form-gt" class="headerlink" title="六 表单标签&lt;form&gt;"></a>六 表单标签<code>&lt;form&gt;</code></h4><p>​      表单用于向服务器传输数据。</p>
<p>​      表单能够包含 <a href="http://www.w3school.com.cn/tags/tag_input.asp" target="_blank" rel="noopener">input 元素</a>，比如文本字段、复选框、单选框、提交按钮等等。</p>
<p>​      表单还可以包含<a href="http://www.w3school.com.cn/tags/tag_textarea.asp" target="_blank" rel="noopener">textarea</a>、select、<a href="http://www.w3school.com.cn/tags/tag_fieldset.asp" target="_blank" rel="noopener">fieldset</a>和 <a href="http://www.w3school.com.cn/tags/tag_label.asp" target="_blank" rel="noopener">label 元素</a>。</p>
<p><strong>1.表单属性</strong></p>
<p>　　HTML 表单用于接收不同类型的用户输入，用户提交表单时向服务器传输数据，从而实现用户与Web服务器的交互。表单标签, 要提交的所有内容都应该在该标签中.</p>
<p>​       action: 表单提交到哪. 一般指向服务器端一个程序,程序接收到表单提交过来的数据（即表单元素值）作相应处理，比如<a href="https://www.sogou.com/web" target="_blank" rel="noopener">https://www.sogou.com/web</a></p>
<p>​       method: 表单的提交方式 post/get 默认取值 就是 get（信封）</p>
<p>​       get: 1.提交的键值对.放在地址栏中url后面. 2.安全性相对较差. 3.对提交内容的长度有限制.4.请求或查看数据时使用。</p>
<p>​       post:1.提交的键值对 不在地址栏. 2.安全性相对较高. 3.对提交内容的长度理论上无限制.</p>
<p>​       get/post是常见的两种请求方式.</p>
<p><strong>2.表单元素</strong></p>
<p>​          <strong><code>&lt;input&gt;</code>  标签的属性和对应值</strong>              </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type:        text 文本输入框</span><br><span class="line"></span><br><span class="line">             password 密码输入框</span><br><span class="line"></span><br><span class="line">             radio 单选框</span><br><span class="line"></span><br><span class="line">             checkbox 多选框  </span><br><span class="line"></span><br><span class="line">             submit 提交按钮（submit的value属性只是用于显示）     </span><br><span class="line"></span><br><span class="line">             button 按钮(需要配合js使用.) button和submit的区别？</span><br><span class="line"></span><br><span class="line">             file 提交文件：form表单需要加上属性enctype&#x3D;&quot;multipart&#x2F;form-data&quot;  </span><br><span class="line">             </span><br><span class="line">             reset 重置：value为按钮上显示的字符</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: 表单提交项的键.注意和id属性的区别：name属性是和服务器通信时使用的名称；而id属性是浏览器端使用的名称，该属性主要是为了方便客户端编程，而在css和javascript中使用的</span><br><span class="line">value:   表单提交项的值.对于不同的输入类型，value 属性的用法也不同</span><br><span class="line">placeholder：放在输入框后</span><br><span class="line">checked:  radio 和 checkbox 默认被选中</span><br><span class="line">readonly: 只读. text 和 password</span><br><span class="line">disabled: 对所用input都好使.</span><br></pre></td></tr></table></figure>
<p>上传文件注意两点：</p>
<p> 1 请求方式必须是post</p>
<p> 2 enctype=”multipart/form-data”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    print request.POST</span><br><span class="line">    print request.GET</span><br><span class="line">    print request.FILES</span><br><span class="line">    for item in request.FILES:</span><br><span class="line">        fileObj &#x3D; request.FILES.get(item)</span><br><span class="line">        f &#x3D; open(fileObj.name, &#39;wb&#39;)</span><br><span class="line">        iter_file &#x3D; fileObj.chunks()</span><br><span class="line">        for line in iter_file:</span><br><span class="line">            f.write(line)</span><br><span class="line">        f.close()</span><br><span class="line">    return HttpResponse(&#39;ok&#39;)</span><br></pre></td></tr></table></figure>
<p> <strong><code>&lt;select&gt;</code> 下拉选标签属性</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name:表单提交项的键.</span><br><span class="line"></span><br><span class="line">size：选项个数</span><br><span class="line"></span><br><span class="line">multiple：multiple </span><br><span class="line"></span><br><span class="line">       &lt;option&gt; 下拉选中的每一项 属性：</span><br><span class="line"></span><br><span class="line">             value:表单提交项的值.   selected: selected下拉选默认被选中</span><br><span class="line"></span><br><span class="line">       &lt;optgroup&gt;为每一项加上分组</span><br><span class="line">       				&lt;optgroup label &#x3D; &quot;name&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>   <strong><code>&lt;textarea&gt;</code> 文本域</strong>              </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name:    表单提交项的键.</span><br><span class="line"></span><br><span class="line">cols:    文本域默认有多少列</span><br><span class="line"></span><br><span class="line">rows:    文本域默认有多少行</span><br></pre></td></tr></table></figure>
<p>​    <strong><code>&lt;label&gt;</code></strong>    获得对应id焦点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span> = <span class="string">"wwww"</span>&gt;</span><span class="tag">&lt;/<span class="name">lable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span> = <span class="string">"www"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>\<fieldset></strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">legend</span>&gt;</span></span><br><span class="line">    登录吧</span><br><span class="line">  <span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><a href="https://www.cnblogs.com/yuanchenqi/articles/5977825.html" target="_blank" rel="noopener">CSS</a></h2><h3 id="css概述"><a href="#css概述" class="headerlink" title="css概述"></a>css概述</h3><p>CSS是Cascading Style Sheets的简称，中文称为层叠样式表，用来控制网页数据的表现，可以使网页的表现与数据内容分离。</p>
<p><strong>基本语法：</strong></p>
<p>selector{</p>
<p>property:value</p>
<p>}</p>
<p>属性大于1个之后，属性之间用分号隔开</p>
<p>值大于1个单词，需要加上引号</p>
<h3 id="一-css的四种引入方式"><a href="#一-css的四种引入方式" class="headerlink" title="一 css的四种引入方式"></a>一 css的四种引入方式</h3><p><strong>1.行内式</strong><br>          行内式是在标记的style属性中设定CSS样式。这种方式没有体现出CSS的优势，不推荐使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p style&#x3D;&quot;background-color: rebeccapurple&quot;&gt;hello yuan&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2.嵌入式</strong><br>          嵌入式是将CSS样式集中写在网页的<head></head>标签对的<style></style>标签对中。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        p&#123;</span><br><span class="line">            background-color: #2b99ff;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>
<p><strong>3 链接式</strong><br>            将一个.css文件引入到HTML文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href&#x3D;&quot;mystyle.css&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>4.导入式</strong><br>          将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，<code>&lt;style&gt;</code>标记也是写在<code>&lt;head&gt;</code>标记中，使用的语法如下：    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line"> </span><br><span class="line">          @import&quot;mystyle.css&quot;; 此处要注意.css文件的路径</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>​      导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。使用链接式时与导入式不同的是它会以网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样式的效果的，它不会象导入式那样先显示无样式的网页，然后再显示有样式的网页，这是链接式的优点。</p>
<h3 id="二-css的选择器（Selector）"><a href="#二-css的选择器（Selector）" class="headerlink" title="二 css的选择器（Selector）"></a>二 css的选择器（Selector）</h3><p>“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素</p>
<h4 id="1-基础选择器"><a href="#1-基础选择器" class="headerlink" title="1 基础选择器"></a>1 基础选择器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＊ ：通用元素选择器，匹配任何元素                    * &#123; margin:0; padding:0; &#125;</span><br><span class="line"></span><br><span class="line">E ：标签选择器，匹配所有使用E标签的元素               p &#123; color:green; &#125;</span><br><span class="line"></span><br><span class="line">.info和E.info: class选择器，匹配所有class属性中包含info的元素   .info &#123; background:#ff0; &#125;    p.info &#123; background:blue; &#125;</span><br><span class="line"></span><br><span class="line">#info和E#info  id选择器，匹配所有id属性等于footer的元素         #info &#123; background:#ff0; &#125;   p#info &#123; background:#ff0; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-组合选择器"><a href="#2-组合选择器" class="headerlink" title="2 组合选择器"></a>2 组合选择器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E,F  多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔         div,p &#123; color:#f00; &#125;</span><br><span class="line">E F  后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔    li a &#123; font-weight:bold;</span><br><span class="line">E &gt; F  子元素选择器，匹配所有E元素的子元素F                            div &gt; p &#123; color:#f00; &#125;</span><br><span class="line">E + F  毗邻元素选择器，匹配紧随E元素之后的同级元素F                  div + p &#123; color:#f00; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line">        .div1&gt;p&#123;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">            color: deeppink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .main2&gt;div&#123;</span><br><span class="line">            background-color: blueviolet;</span><br><span class="line">            color: chartreuse;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class&#x3D;&quot;div1&quot;&gt;hello1</span><br><span class="line">          &lt;div class&#x3D;&quot;div2&quot;&gt;hello2</span><br><span class="line">              &lt;div&gt;hello4&lt;&#x2F;div&gt;</span><br><span class="line">              &lt;p&gt;hello5&lt;&#x2F;p&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">          &lt;p&gt;hello3&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;p&gt;hello6&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">     &lt;div class&#x3D;&quot;main2&quot;&gt;1</span><br><span class="line">       &lt;div&gt;2</span><br><span class="line">           &lt;div&gt;</span><br><span class="line">               4</span><br><span class="line">           &lt;&#x2F;div&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">               3</span><br><span class="line">           &lt;&#x2F;div&gt;</span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>注意<strong>嵌套规则</strong>：</p>
<ol>
<li>块级元素可以包含内联元素或<strong>某些</strong>块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。</li>
<li><strong>有几个特殊的块级元素只能包含内联元素，不能包含块级元素</strong>。如h1,h2,h3,h4,h5,h6,p,dt</li>
<li>li内可以包含div</li>
<li>块级元素与块级元素并列、内联元素与内联元素并列。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        [suoning]&#123;</span><br><span class="line">            color: blueviolet;</span><br><span class="line">        &#125;</span><br><span class="line">        .he&gt;div&#123;</span><br><span class="line">            color: bisque;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;he&quot;&gt;111</span><br><span class="line">    &lt;p class&#x3D;&quot;fr&quot;&gt;222</span><br><span class="line">        &lt;div&gt;333&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div&gt;444&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">&lt;div suoning&#x3D;&quot;sb&quot;&gt;ddd</span><br><span class="line">         &lt;p&gt;pppp&lt;&#x2F;p&gt;</span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line">     &lt;p suoning&#x3D;&quot;sb2&quot;&gt;ddd2</span><br><span class="line">         &lt;p&gt;pppp2&lt;&#x2F;p&gt;</span><br><span class="line">     &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-属性选择器"><a href="#3-属性选择器" class="headerlink" title="3 属性选择器"></a>3 属性选择器</h4><p>多个属性</p>
<p>class = “div1 div2”表示设定css样式时，class属性为div1或div2均可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> E[att]         匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如“[cheacked]”。以下同。）   p[title] &#123; color:#f00; &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> E[att&#x3D;val]     匹配所有att属性等于“val”的E元素                                 div[class&#x3D;”error”] &#123; color:#f00; &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> E[att~&#x3D;val]    匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素      td[class~&#x3D;”name”] &#123; color:#f00; &#125;</span><br><span class="line"></span><br><span class="line"> E[attr^&#x3D;val]    匹配属性值以指定值开头的每个元素                     div[class^&#x3D;&quot;test&quot;]&#123;background:#ffff00;&#125;</span><br><span class="line"></span><br><span class="line"> E[attr$&#x3D;val]    匹配属性值以指定值结尾的每个元素                     div[class$&#x3D;&quot;test&quot;]&#123;background:#ffff00;&#125;</span><br><span class="line"></span><br><span class="line"> E[attr*&#x3D;val]    匹配属性值中包含指定值的每个元素                     div[class*&#x3D;&quot;test&quot;]&#123;background:#ffff00;&#125;</span><br><span class="line"> </span><br><span class="line"> 为了将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色，可以这样写：</span><br><span class="line">a[href][title] &#123;color:red;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-伪类-Pseudo-classes"><a href="#4-伪类-Pseudo-classes" class="headerlink" title="4 伪类(Pseudo-classes)"></a>4 伪类(Pseudo-classes)</h4><p>CSS伪类是用来给选择器添加一些特殊效果。</p>
<p><strong>anchor伪类：</strong>专用于控制链接的显示效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a:link（没有接触过的链接）,用于定义了链接的常规状态。</span><br><span class="line"></span><br><span class="line">a:hover（鼠标放在链接上的状态）,用于产生视觉效果。</span><br><span class="line"></span><br><span class="line">a:visited（访问过的链接）,用于阅读文章，能清楚的判断已经访问过的链接。</span><br><span class="line"></span><br><span class="line">a:active（在链接上按下鼠标时的状态）,用于表现鼠标按下时的链接状态。</span><br><span class="line"></span><br><span class="line">伪类选择器 : 伪类指的是标签的不同状态:</span><br><span class="line"></span><br><span class="line">a &#x3D;&#x3D;&gt; 点过状态 没有点过的状态 鼠标悬浮状态 激活状态</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">    a:link&#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    a:visited &#123;</span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    a:hover &#123;</span><br><span class="line">        color: green;</span><br><span class="line">    &#125;</span><br><span class="line">    a:active &#123;</span><br><span class="line">        color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;01-hello-world.html&quot;&gt;hello-world&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>补充：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer:hover .right&#123;color: red&#125;    outer下的right类进行渲染</span><br></pre></td></tr></table></figure>
<p><strong>before after</strong>伪类 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:before    p:before       在每个&lt;p&gt;元素之前插入内容</span><br><span class="line">:after     p:after        在每个&lt;p&gt;元素之后插入内容</span><br><span class="line"> p:before        在每个 &lt;p&gt; 元素的内容之前插入内容                    p:before&#123;content:&quot;hello&quot;;color:red&#125;</span><br><span class="line"> p:after         在每个 &lt;p&gt; 元素的内容之前插入内容                    p:after&#123; content:&quot;hello&quot;；color:red&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-css优先级和继承"><a href="#5-css优先级和继承" class="headerlink" title="5 css优先级和继承"></a>5 css优先级和继承</h4><p><strong>CSS优先级:</strong></p>
<p>所谓CSS优先级，即是指CSS样式在浏览器中被解析的先后顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样式表中的特殊性描述了不同规则的相对权重，它的基本规则是：</span><br><span class="line">      1 内联样式表的权值最高       style&#x3D;&quot;&quot;-------------------1000；</span><br><span class="line">　　 2 统计选择符中的ID属性个数。    #id    －－－－－－－－－－－－－100</span><br><span class="line">　　3 统计选择符中的CLASS属性个数。 .class  －－－－－－－－－－－－－10</span><br><span class="line"> 4 统计选择符中的HTML标签名个数。     p     －－－－－－－－－－－－－-1</span><br></pre></td></tr></table></figure>
<p>按这些规则将数字符串逐位相加，就得到最终的权重，然后在比较取舍时按照从左到右的顺序逐位比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">        #p&#123;</span><br><span class="line">            color: rebeccapurple;</span><br><span class="line">        &#125;</span><br><span class="line">        .p&#123;</span><br><span class="line">            color: #2459a2;</span><br><span class="line">        &#125;</span><br><span class="line">        p&#123;</span><br><span class="line">            color: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p&quot; class&#x3D;&quot;p&quot; style&#x3D;&quot;color: deeppink&quot;&gt;hello yuan&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p><strong>CSS的继承性:</strong> </p>
<p>​      继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个BODY定义了的颜色值也会应用到段落的文本中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;color:red;&#125;       &lt;p&gt;helloyuan&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p>这段文字都继承了由body {color:red;}样式定义的颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p&#123;color:green&#125;</span><br></pre></td></tr></table></figure>
<p>发现只需要给加个颜色值就能覆盖掉它继承的样式颜色。由此可见：任何显示申明的规则都可以覆盖其继承样式。　</p>
<p>​      此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin, padding, background等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  border:1px solid #222</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;hello &lt;p&gt;yuan&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p><strong>附加说明:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、文内的样式优先级为1,0,0,0，所以始终高于外部定义。这里文内样式指形如&lt;div style&#x3D;&quot;color:red&gt;blah&lt;&#x2F;div&gt;的样式，而外部定义指经由&lt;link&gt;或&lt;style&gt;卷标定义的规则。</span><br><span class="line"></span><br><span class="line">　　2、有!important声明的规则高于一切。</span><br><span class="line"></span><br><span class="line">　　3、如果!important声明冲突，则比较优先权。</span><br><span class="line"></span><br><span class="line">　　4、如果优先权一样，则按照在源码中出现的顺序决定，后来者居上。</span><br><span class="line"></span><br><span class="line">　　5、由继承而得到的样式没有specificity的计算，它低于一切其它规则(比如全局选择符*定义的规则)。</span><br></pre></td></tr></table></figure>
<h3 id="三-CSS的常用属性"><a href="#三-CSS的常用属性" class="headerlink" title="三  CSS的常用属性"></a>三  CSS的常用属性</h3><h4 id="1-颜色属性"><a href="#1-颜色属性" class="headerlink" title="1  颜色属性"></a>1  颜色属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;color:blueviolet&quot;&gt;ppppp&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div style&#x3D;&quot;color:#ffee33&quot;&gt;ppppp&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div style&#x3D;&quot;color:rgb(255,0,0)&quot;&gt;ppppp&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div style&#x3D;&quot;color:rgba(255,0,0,0.5)&quot;&gt;ppppp&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-字体属性"><a href="#2-字体属性" class="headerlink" title="2  字体属性"></a>2  字体属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-size: 20px&#x2F;50%&#x2F;larger</span><br><span class="line"> </span><br><span class="line">font-family:&#39;Lucida Bright&#39;</span><br><span class="line"> </span><br><span class="line">font-weight: lighter&#x2F;bold&#x2F;border&#x2F;</span><br><span class="line"> </span><br><span class="line">&lt;h1 style&#x3D;&quot;font-style: oblique&quot;&gt;老男孩&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-背景属性"><a href="#3-背景属性" class="headerlink" title="3  背景属性"></a>3  背景属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-color: cornflowerblue</span><br><span class="line"></span><br><span class="line">background-image: url(&#39;1.jpg&#39;);</span><br><span class="line"></span><br><span class="line">background-repeat: no-repeat;(repeat:平铺满)</span><br><span class="line"></span><br><span class="line">background-position: right top（20px 20px）;(横向：left center right)(纵向：top center bottom)</span><br><span class="line"></span><br><span class="line">      简写：&lt;body style&#x3D;&quot;background: 20px 20px no-repeat #ff4 url(&#39;1.jpg&#39;)&quot;&gt;</span><br><span class="line"></span><br><span class="line">              &lt;div style&#x3D;&quot;width: 300px;height: 300px;background: 20px 20px no-repeat #ff4 url(&#39;1.jpg&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>注意：如果将背景属性加在body上，要记得给body加上一个height，否则结果异常，这是因为body为空，无法撑起背景图片；另外，如果此时要设置一个width＝100px，你也看不出效果，除非你设置出html。   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        html&#123;</span><br><span class="line">            background-color: antiquewhite;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        body&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 600px;</span><br><span class="line">            background-color: deeppink;</span><br><span class="line">            background-image: url(1.jpg);</span><br><span class="line">            background-repeat: no-repeat;</span><br><span class="line">            background-position: center center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line">        span&#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            width: 18px;</span><br><span class="line">            height: 20px;</span><br><span class="line">            background-image: url(&quot;http:&#x2F;&#x2F;dig.chouti.com&#x2F;images&#x2F;icon_18_118.png?v&#x3D;2.13&quot;);</span><br><span class="line">            background-position: 0 -100px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-文本属性"><a href="#4-文本属性" class="headerlink" title="4  文本属性"></a>4  文本属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-size: 10px;</span><br><span class="line">text-align: center;   横向排列</span><br><span class="line">line-height: 200px;   文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比</span><br><span class="line">vertical-align:－4px  设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效</span><br><span class="line"></span><br><span class="line">text-indent: 150px;   首行缩进</span><br><span class="line">letter-spacing: 10px;</span><br><span class="line">word-spacing: 20px;</span><br><span class="line">text-transform: capitalize;</span><br></pre></td></tr></table></figure>
<h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .outer .item &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: chartreuse;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;item&quot; style&#x3D;&quot;vertical-align: top&quot;&gt;ll</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-边框属性"><a href="#5-边框属性" class="headerlink" title="5   边框属性"></a>5   边框属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border-style: solid;</span><br><span class="line"> </span><br><span class="line">border-color: chartreuse;</span><br><span class="line"> </span><br><span class="line">border-width: 20px;</span><br><span class="line"> </span><br><span class="line">简写：border: 30px rebeccapurple solid;</span><br><span class="line"></span><br><span class="line">控制某一条边：border-left</span><br></pre></td></tr></table></figure>
<h4 id="6-列表属性"><a href="#6-列表属性" class="headerlink" title="6   列表属性"></a>6   列表属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ul,ol&#123;   list-style: decimal-leading-zero;</span><br><span class="line">         list-style: none; &lt;br&gt;         list-style: circle;</span><br><span class="line">         list-style: upper-alpha;</span><br><span class="line">         list-style: disc; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-dispaly属性"><a href="#7-dispaly属性" class="headerlink" title="7  dispaly属性"></a>7  dispaly属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;none&#96;&#96;block&#96;&#96;inline&#96;</span><br></pre></td></tr></table></figure>
<p>display:inline-block可做列表布局，其中的类似于图片间的间隙小bug可以通过如下设置解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#outer&#123;</span><br><span class="line">        border: 3px dashed;</span><br><span class="line">        word-spacing: -5px;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-外边距和内边"><a href="#8-外边距和内边" class="headerlink" title="8  外边距和内边"></a>8  外边距和内边</h4><p><img src="image/877318-20161020102135748-1861483747.png" alt="img"></p>
<ul>
<li><strong>margin:            用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。</strong></li>
<li><strong>padding:           用于控制内容与边框之间的距离；</strong>   </li>
<li><strong>Border(边框)     围绕在内边距和内容外的边框。</strong></li>
<li><strong>Content(内容)   盒子的内容，显示文本和图像。</strong></li>
</ul>
<p>元素的宽度和高度:</p>
<p><img src="image/lamp.gif" alt="Remark"><strong>重要:</strong> 当您指定一个CSS元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完全大小的元素，你还必须添加填充，边框和边距。.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">margin:10px 5px 15px 20px;-----------上 右 下 左</span><br><span class="line">margin:10px 5px 15px;----------------上 右左 下</span><br><span class="line">margin:10px 5px;---------------------上下  右左</span><br><span class="line">margin:10px;    ---------------------上右下左</span><br></pre></td></tr></table></figure>
<p>下面的例子中的元素的总宽度为300px：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width:250px;</span><br><span class="line">padding:10px;</span><br><span class="line">border:5px solid gray;</span><br><span class="line">margin:10px;</span><br></pre></td></tr></table></figure>
<p> 练习： 300px<em>300px的盒子装着100px</em>100px的盒子，分别通过margin和padding设置将小盒子 移到大盒子的中间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line">        .div1&#123;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        .div2&#123;</span><br><span class="line">            background-color: blueviolet;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">       &lt;div class&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">           &lt;div class&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">           &lt;div class&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>思考1:</p>
<p>​       边框在默认情况下会定位于浏览器窗口的左上角，但是并没有紧贴着浏览器的窗口的边框，这是因为body本身也是一个盒子（外层还有html），在默认情况下，   body距离html会有若干像素的margin，具体数值因各个浏览器不尽相同，所以body中的盒子不会紧贴浏览器窗口的边框了，为了验证这一点，加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    border: 1px solid;</span><br><span class="line">    background-color: cadetblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>>&gt;&gt;&gt;解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考2：</p>
<p>​           margin collapse（边界塌陷或者说边界重叠）</p>
<p>​          外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段     落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。又比如停车场</p>
<p>​           1兄弟div：上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值</p>
<p>​           2父子div    </p>
<p>​                   if  父级div中没有 border，padding，inline content，子级div的margin会一直向上找，直到找到某个标签包括border，padding，inline content              中的其中一个，然后按此div 进行margin ；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot; style&#x3D;&quot;padding: 0px&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line">        body&#123;</span><br><span class="line">            margin: 0px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .div1&#123;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        .div2&#123;</span><br><span class="line">            background-color: blueviolet;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            margin: 20px;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style&#x3D;&quot;background-color: cadetblue;width: 300px;height: 300px&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">       &lt;div class&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">           &lt;div class&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">           &lt;div class&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p> 解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: border:1px solid transparent</span><br><span class="line">2:  padding:1px</span><br><span class="line">3: over-flow:hidden;</span><br></pre></td></tr></table></figure>
<h3 id="9-float属性"><a href="#9-float属性" class="headerlink" title="9 float属性"></a>9 float属性</h3><p>先来了解一下block元素和inline元素在文档流中的排列方式。</p>
<p>　　block元素通常被现实为独立的一块，独占一行，多个block元素会各自新起一行，默认block元素宽度自动填满其父元素宽度。block元素可以设置width、height、margin、padding属性；</p>
<p>　　inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。inline元素设置width、height属性无效。inline元素的margin和padding属性。水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。</p>
<ul>
<li>常见的块级元素有 div、form、table、p、pre、h1～h5、dl、ol、ul 等。</li>
<li>常见的内联元素有span、a、strong、em、label、input、select、textarea、img、br等</li>
</ul>
<p><strong>所谓的文档流</strong>，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。</p>
<p><strong>脱离文档流</strong>，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，<strong>会当做脱离文档流的元素不存在而进行定位</strong>。</p>
<p><strong>只有绝对定位absolute和浮动float才会脱离文档流。</strong></p>
<p>​     —-部分无视和完全无视的区别？需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围(可以说是部分无视)。而对于使用absolute position脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。(可以说是完全无视)</p>
<h4 id="浮动的表现"><a href="#浮动的表现" class="headerlink" title="浮动的表现"></a><strong>浮动的表现</strong></h4><p>​      定义：浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的浮动框之后的块框表现得就像浮动框不存在一样。（注意这里是块框而不是内联元素；浮动框只对它后面的元素造成影响）</p>
<p><strong>注意 当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，即float是一种不彻底的脱离文档流方式。</strong>无论多么复杂的布局，其基本出发点均是：“<strong>如何在一行显示多个div元素</strong>”。</p>
<p><strong>现象1:</strong></p>
<p>​      假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。此外，浮动的框之后的block元素元素会认为这个框不存在，但其中的文本依然会为这个元素让出位置。 浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列。</p>
<p><strong>现象2:</strong></p>
<p>(1)左右结构div盒子重叠现象，一般是由于相邻两个DIV一个使用浮动一个没有使用浮动。如上面的例1：相邻的两个盒子box2向左浮动、box3未浮动。一个使用浮动一个没有导致DIV不是在同个“平面”上，但内容不会照成覆盖现象，只有DIV形成覆盖现象。</p>
<p>解决方法：要么都不使用浮动；要么都使用float浮动；要么对没有使用float浮动的DIV设置margin样式。</p>
<p>(2)上下结构div盒子重叠现象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">         * &#123;</span><br><span class="line">             margin:0;padding:0;</span><br><span class="line">         &#125;</span><br><span class="line">        .container&#123;</span><br><span class="line">            border:1px solid red;width:300px;</span><br><span class="line">        &#125;</span><br><span class="line">        #box1&#123;</span><br><span class="line">            background-color:green;float:left;width:100px;height:100px;</span><br><span class="line">        &#125;</span><br><span class="line">        #box2&#123;</span><br><span class="line">            background-color:deeppink; float:right;width:100px;height:100px; </span><br><span class="line">        &#125;</span><br><span class="line">         #box3&#123;</span><br><span class="line">             background-color:pink;height:40px;</span><br><span class="line">         &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">                &lt;div id&#x3D;&quot;box1&quot;&gt;box1 向左浮动&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div id&#x3D;&quot;box2&quot;&gt;box2 向右浮动&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div id&#x3D;&quot;box3&quot;&gt;box3&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>例子如上：.container和box3的布局是上下结构，上图发现box3跑到了上面，与.container产生了重叠，但文本内容没有发生覆盖，只有div发生覆盖现象。这个原因是因为第一个大盒子里的子元素使用了浮动，脱离了文档流，导致.container没有被撑开。box3认为.container没有高度（未被撑开），因此跑上去了。</p>
<p>解决方法：</p>
<p>1、要么给.container设置固定高度，一般情况下文字内容不确定多少就不能设置固定高度，所以一般不能设置“.container”高度(当然能确定内容多高，这种情况下“.container是可以设置一个高度即可解决覆盖问题。</p>
<p>2、要么清除浮动。</p>
<h4 id="清除浮动："><a href="#清除浮动：" class="headerlink" title="清除浮动："></a><strong>清除浮动：</strong></h4><p><strong>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。</strong></p>
<p>clear语法：<br>clear : none | left | right | both</p>
<p>取值：<br>none : 默认值。允许两边都可以有浮动对象<br>left : 不允许左边有浮动对象<br>right : 不允许右边有浮动对象<br>both : 不允许有浮动对象</p>
<p>但是需要注意的是：clear属性只会对<strong>自身</strong>起作用，而不会影响其他元素。如果一个元素的右侧有一浮动对象，而这个元素设置了不允许右边有浮动对象，即clear：right，则这个元素会自动下移一格，达到本元素右边没有浮动对象的目的。</p>
<p><strong>方式1(推荐):</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clearfix:after &#123;             &lt;----在类名为“clearfix”的元素内最后面加入内容； </span><br><span class="line">content: &quot;.&quot;;                 &lt;----内容为“.”就是一个英文的句号而已。也可以不写。 </span><br><span class="line">display: block;               &lt;----加入的这个元素转换为块级元素。 </span><br><span class="line">clear: both;                  &lt;----清除左右两边浮动。 </span><br><span class="line">visibility: hidden;           &lt;----可见度设为隐藏。注意它和display:none;是有区别的。visibility:hidden;仍然占据空间，只是看不到而已； </span><br><span class="line">line-height: 0;               &lt;----行高为0； </span><br><span class="line">height: 0;                    &lt;----高度为0； </span><br><span class="line">font-size:0;                  &lt;----字体大小为0； </span><br><span class="line">&#125; </span><br><span class="line">.clearfix &#123; *zoom:1;&#125;         &lt;----这是针对于IE6的，因为IE6不支持:after伪类，这个神奇的zoom:1让IE6的元素可以清除浮动来包裹内部元素。</span><br></pre></td></tr></table></figure>
<p>整段代码就相当于在浮动元素后面跟了个宽高为0的空div，然后设定它clear:both来达到清除浮动的效果。<br>之所以用它，是因为，你不必在html文件中写入大量无意义的空标签，又能清除浮动。 </p>
<p>话说回来，你这段代码真是个累赘啊，这样写不利于维护。<br>只要写一个.clearfix就行了，然后在需要清浮动的元素中 添加clearfix类名就好了。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;head clearfix&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p><strong>方式2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">overflow:hidden;</span><br></pre></td></tr></table></figure>
<p><strong>overflow</strong>：hidden的含义是超出的部分要裁切隐藏，float的元素虽然不在普通流中，但是他是浮动在普通流之上的，可以把普通流元素+浮动元素想象成一个立方体。如果没有明确设定包含容器高度的情况下，它要计算内容的全部高度才能确定在什么位置hidden，这样浮动元素的高度就要被计算进去。这样包含容器就会被撑开，清除浮动。</p>
<h3 id="10-position-定位"><a href="#10-position-定位" class="headerlink" title="10 position(定位)"></a>10 position(定位)</h3><h4 id="1-static"><a href="#1-static" class="headerlink" title="1 static"></a><strong>1 static</strong></h4><p><strong>static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。</strong></p>
<h4 id="2-position-relative／absolute"><a href="#2-position-relative／absolute" class="headerlink" title="2  position: relative／absolute"></a><strong>2  position: relative／absolute</strong></h4><p>​    <strong>relative</strong> 相对定位。相对定位是<strong>相对于该元素在文档流中的原始位置</strong>，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间<strong>。对象遵循正常文档流，</strong>但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。</p>
<p>注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。</p>
<h4 id="absolute-绝对定位。"><a href="#absolute-绝对定位。" class="headerlink" title="absolute 绝对定位。"></a><strong>absolute</strong> 绝对定位。</h4><p>​      定义：设置为绝对定位的元素框从文档流完全删除，并<strong>相对于最近的已定位祖先元素定位</strong>，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</p>
<p>重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。</p>
<p>​      另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。</p>
<p>总结：参照物用相对定位，子元素用绝对定位，并且保证相对定位参照物不会偏移即可。</p>
<h4 id="3-position-fixed"><a href="#3-position-fixed" class="headerlink" title="3  position:fixed"></a><strong>3  position:fixed</strong></h4><p>​        fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是“定位流”。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。</p>
<p>​       在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。</p>
<h4 id="4-仅使用margin属性布局绝对定位元素"><a href="#4-仅使用margin属性布局绝对定位元素" class="headerlink" title="4 仅使用margin属性布局绝对定位元素"></a>4 <strong>仅使用margin属性布局绝对定位元素</strong></h4><p>此情况，margin-bottom 和margin-right的值不再对文档流中的元素产生影响，因为该元素已经脱离了文档流。另外，不管它的祖先元素有没有定位，都是以文档流中原来所在的位置上偏移参照物。<br>　　图9中，使用margin属性布局相对定位元素。<br>　　层级关系为：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">　　<span class="tag">&lt;<span class="name">div</span> ——————————— <span class="attr">position:relative</span>;</span></span><br><span class="line">　　&lt;div—————————-没有设置为定位元素，不是参照物</span><br><span class="line">　　<span class="tag">&lt;<span class="name">div———————-没有设置为定位元素，不是参照物</span></span></span><br><span class="line">　　&lt;div box1</span><br><span class="line">　　<span class="tag">&lt;<span class="name">div</span> <span class="attr">box2</span> ——–<span class="attr">position:absolute</span>; <span class="attr">margin-top:50px</span>; <span class="attr">margin-left:120px</span>;</span></span><br><span class="line">　　&lt;div box3</span><br><span class="line">　　效果图：</span><br></pre></td></tr></table></figure><br>　　<img src="image/292243208766594.jpg" alt="img"></p>
<h3 id="11-关于css的拾遗"><a href="#11-关于css的拾遗" class="headerlink" title="11 关于css的拾遗"></a>11 关于css的拾遗</h3><h4 id="11-1-inline-block-的间隙"><a href="#11-1-inline-block-的间隙" class="headerlink" title="11.1 inline-block 的间隙"></a>11.1 inline-block 的间隙</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        a&#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            background-color: #2459a2;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;a&gt;111&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a&gt;222&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a&gt;333&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>inline-block默认的空格符就是标签与标签之间的空隙造成的。</p>
<p>(1) 我们可以通过margin:-3px来解决，但是</p>
<p>1.我们布局肯定很多元素，不可能每个都添加margin负这样维护成本太大了</p>
<p>2.我们线上代码如果压缩，那么我们就不存在哪个4px的问题了，那么我们的margin负就回造成布局混乱！</p>
<p>(2)我们可以给几个标签加一个父级div，然后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;div&#123;word-spacing: -5px;&#125;　　&#96;</span><br></pre></td></tr></table></figure>
<h4 id="11-2-word-wrap-amp-word-break"><a href="#11-2-word-wrap-amp-word-break" class="headerlink" title="11.2 word-wrap &amp; word-break:"></a>11.2 word-wrap &amp; <strong>word-break:</strong></h4><p><strong>word-wrap:</strong></p>
<p>the word-wrap CSS property is used to specify whether or not the browser is allowd to<br>break lines within words in order to prevent overflow when an otherwise unbreakable<br>string is too long to fit.</p>
<p>The <code>word-wrap</code> property was invented by Microsoft and added to CSS3. It allows long words to be able to be broken and wrap onto the next line. It takes in two values; <code>normal</code> or <code>break-word</code>.</p>
<p><strong>word-break:</strong></p>
<p>The word-break CSS property is used to specify how (or if) to break lines within words</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .p1&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background-color: #84a42b;</span><br><span class="line">            word-wrap: break-word;</span><br><span class="line">            word-break: break-all;</span><br><span class="line">        &#125;</span><br><span class="line">        .p2&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background-color: darkgoldenrod;</span><br><span class="line">            word-wrap: break-word;</span><br><span class="line">            word-break: break-all;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p class&#x3D;&quot;p1&quot;&gt;hello yuan hello yuan hello yuan hello yuan hello yuan&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p class&#x3D;&quot;p2&quot;&gt;helloyuanhelloyuanhelloyuanhelloyuanhelloyuanhelloyuan&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h4><p>​      一旦给元素加上absolute或float就相当于给元素加上了display:block;。什么意思呢？比如内联元素span默认宽度是自适应的，你给其加上width是不起作用的。要想width定宽，你需要将span设成display:block。但如果你给span加上absolute或float，那span的display属性自动就变成block，就可以指定width了。</p>
<h4 id="1-4-快写"><a href="#1-4-快写" class="headerlink" title="1.4 快写"></a>1.4 快写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div   tab   </span><br><span class="line">a     tab</span><br><span class="line">div.main&gt;ul&gt;li.c*4    tab</span><br></pre></td></tr></table></figure>
<h4 id="1-5-display-flex"><a href="#1-5-display-flex" class="headerlink" title="1.5 display:flex"></a>1.5 display:flex</h4><h4 id="1-6-响应式布局"><a href="#1-6-响应式布局" class="headerlink" title="1.6 响应式布局"></a>1.6 响应式布局</h4><h4 id="1-7水平居中"><a href="#1-7水平居中" class="headerlink" title="1.7水平居中"></a>1.7水平居中</h4><p>margin: 0 auto;</p>
<h4 id="1-8-float和position公用"><a href="#1-8-float和position公用" class="headerlink" title="1.8 float和position公用"></a>1.8 float和position公用</h4><p><a href="https://www.cnblogs.com/coffeedeveloper/p/3145790.html#float" target="_blank" rel="noopener">https://www.cnblogs.com/coffeedeveloper/p/3145790.html#float</a></p>
<h4 id="1-9-连用"><a href="#1-9-连用" class="headerlink" title="1.9 连用"></a>1.9 连用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background: url("img.png") no-repeat 0 -100px</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>keras搭建yolo3目标检测平台</title>
    <url>/2020/02/18/keras%E6%90%AD%E5%BB%BAyolo3%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p>github：<a href="https://github.com/qqwweee/keras-yolo3" target="_blank" rel="noopener">https://github.com/qqwweee/keras-yolo3</a><br>csdn: <a href="https://blog.csdn.net/weixin_44791964/article/details/103276106" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103276106</a></p>
<h1 id="yolo3检测基本原理"><a href="#yolo3检测基本原理" class="headerlink" title="yolo3检测基本原理"></a>yolo3检测基本原理</h1><a id="more"></a>
<p><img src="1.png" alt="原理"><br>现将图片转换为<code>416*416</code>的网格（加灰条防止失真），再将其转换为<code>13*13</code>或其他大小，如果检测大物体，选择<code>13*13</code>,检测小物体选择<code>52*52</code>的网格。每个网格负责一个区域的检测，只要物体的中心点落在这个区域，这个物体就是这个网格点来确定的。</p>
<h1 id="yolo3的网络结构"><a href="#yolo3的网络结构" class="headerlink" title="yolo3的网络结构"></a>yolo3的网络结构</h1><p><img src="2.jpg" alt="网络结构"><br>Darknet-53为特征提取网络，后面为利用特征进行目标检测。<br>Darknet-53中的最后三个特征层，对应不同尺度的目标检测。</p>
<ol>
<li>最后一个特征层 ：5次卷积后<code>3*3</code>卷积,<code>1*1</code>卷积进行通道调整，最后<code>13*13</code>的网络中的输出<code>13*13*75</code>大小，这<code>13*13</code>代表<code>13*13</code>个格点，3为每个点生成3个先验框，25为（4+1+20，4:x_offset,y_offset,h和w，1:置信度，分类结果：20）。</li>
<li>倒数第二个特征层：对<code>13*13</code>进行上采样，结合后进行5次卷积，然后<code>3*3</code>卷积，<code>1*1</code>进行通道调整</li>
</ol>
<p><strong>Darknet53主干网络</strong><br>残差结构块使得前一个特征层中的其中一部分特征可以不经过卷积直接映射到下一个特征层，利于特征提取。<br>残差结构块：3<em>3的卷积将通道数压缩为原来的一半(得x)，之后对x进行1</em>1卷积将通道数复原，同时对x进行残差操作，将这两部分结合。</p>
<p><strong>解码过程</strong><br>由第二步我们可以获得三个特征层的预测结果，shape分别为(N,13,13,255)，(N,26,26,255)，(N,52,52,255)的数据，对应每个图分为13x13、26x26、52x52的网格上3个预测框的位置。</p>
<p>但是这个预测结果并不对应着最终的预测框在图片上的位置，还需要解码才可以完成。</p>
<p>此处要讲一下yolo3的预测原理，yolo3的3个特征层分别将整幅图分为13x13、26x26、52x52的网格，每个网络点负责一个区域的检测。</p>
<p>我们知道特征层的预测结果对应着三个预测框的位置，我们先将其reshape一下，其结果为(N,13,13,3,85)，(N,26,26,3,85)，(N,52,52,3,85)。</p>
<p>最后一个维度中的85包含了4+1+80，分别代表x_offset、y_offset、h和w、置信度、分类结果。</p>
<p>yolo3的解码过程就是将每个网格点加上它对应的x_offset和y_offset，加完后的结果就是预测框的中心，然后再利用 先验框和h、w结合 计算出预测框的长和宽。这样就能得到整个预测框的位置了。</p>
<p>YOLOv3相比于之前的yolo1和yolo2，改进较大，主要改进方向有：</p>
<p>1、主干网络修改为darknet53，其重要特点是使用了残差网络Residual，darknet53中的残差卷积就是进行一次3X3、步长为2的卷积，然后保存该卷积layer，再进行一次1X1的卷积和一次3X3的卷积，并把这个结果加上layer作为最后的结果， 残差网络的特点是容易优化，并且能够通过增加相当的深度来提高准确率。其内部的残差块使用了跳跃连接，缓解了在深度神经网络中增加深度带来的梯度消失问题。</p>
<p>2、darknet53的每一个卷积部分使用了特有的DarknetConv2D结构，每一次卷积的时候进行l2正则化，完成卷积后进行BatchNormalization标准化与LeakyReLU。普通的ReLU是将所有的负值都设为零，Leaky ReLU则是给所有负值赋予一个非零斜率。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>keras</tag>
        <tag>yolo3</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode(1-10)记录</title>
    <url>/2019/11/27/leetcode-1-10-%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>题目1-7为之前做过的题目，这里不再记录</p>
<h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h2><a id="more"></a>
<blockquote>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:</p>
<p>输入: “42”<br>输出: 42<br>示例 2:</p>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>    我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p>
<p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>    因此无法执行有效的转换。<br>示例 5:</p>
<p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>    因此返回 INT_MIN (−231) 。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>由于python中不存在字符限制，可以使用正则表达式进行解决</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max(min(int(*re.findall(<span class="string">'^[\+\-]?\d+'</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), <span class="number">-2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>kaggle笔记-2（常见模型）</title>
    <url>/2020/02/06/kaggle%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h1 id="常见的模型"><a href="#常见的模型" class="headerlink" title="常见的模型"></a>常见的模型</h1><a id="more"></a>
<h2 id="监督模型"><a href="#监督模型" class="headerlink" title="监督模型"></a>监督模型</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>文本分类中线性模型具有很好的准确性。<br>对XOR问题线性模型难以区分<br>对于非线性问题，支持向量机往往结果更好</p>
<h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>回归和分类树</p>
<h3 id="集成学习方法"><a href="#集成学习方法" class="headerlink" title="集成学习方法"></a>集成学习方法</h3><p>通过多个模型集成来获得最终结果</p>
<ul>
<li>随机森林</li>
<li>Adaboost</li>
<li>xgboost</li>
</ul>
<h2 id="无监督模型"><a href="#无监督模型" class="headerlink" title="无监督模型"></a>无监督模型</h2><h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><ol>
<li>PCA<br>有线性约束<br>用法:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> decomposition</span><br><span class="line">pca = decomposition.PCA(n_components=<span class="number">2</span>)</span><br><span class="line">pca.fit(data_x)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>t-SNE<br>没有线性约束<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklean.manifold <span class="keyword">import</span> TSNE</span><br><span class="line">tsne = TSNE(random_state=<span class="number">20</span>)</span><br><span class="line">tsne.fit(data_x)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h3><ol>
<li>KMeans<br>簇个数的选择,选择inertia下降慢的簇个数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">kmeans = KMeans(n_cluster=<span class="number">3</span>).fit(X)</span><br><span class="line">inertia = np.sqrt(kmeans.inertia_)</span><br></pre></td></tr></table></figure></li>
<li><p>Affinity Propagation（近邻传播聚类）<br>不需要设置簇的个数，将每个数据视为一个节点，观察与其他节点的相似性。不断更新吸引度和归属度进行分析。</p>
</li>
<li><p>Spectral Clustering（谱聚类）<br>首先定义相似矩阵（用来确定两个数据之间的距离），该矩阵描述了一个以观测值为顶点，以观测值对间的估计相似度值为边权的完整图。对于上面定义的度量和二维观测，这是非常直观的-如果两个观测之间的边较短，则两个观测是相似的。我们想把图分解成两个子图，这样每个子图中的每个观察都与该子图中的另一个观察相似。</p>
</li>
<li><p>Agglomerative clustering（层次聚类）<br>将每个观测值赋给不同的簇，计算簇之间的距离，不断的合并最近邻的簇</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.cluster <span class="keyword">import</span> hierarchy</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist</span><br><span class="line"></span><br><span class="line">X = np.zeros((<span class="number">150</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">np.random.seed(seed=<span class="number">42</span>)</span><br><span class="line">X[:<span class="number">50</span>, <span class="number">0</span>] = np.random.normal(loc=<span class="number">0.0</span>, scale=<span class="number">.3</span>, size=<span class="number">50</span>)</span><br><span class="line">X[:<span class="number">50</span>, <span class="number">1</span>] = np.random.normal(loc=<span class="number">0.0</span>, scale=<span class="number">.3</span>, size=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">X[<span class="number">50</span>:<span class="number">100</span>, <span class="number">0</span>] = np.random.normal(loc=<span class="number">2.0</span>, scale=<span class="number">.5</span>, size=<span class="number">50</span>)</span><br><span class="line">X[<span class="number">50</span>:<span class="number">100</span>, <span class="number">1</span>] = np.random.normal(loc=<span class="number">-1.0</span>, scale=<span class="number">.2</span>, size=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">X[<span class="number">100</span>:<span class="number">150</span>, <span class="number">0</span>] = np.random.normal(loc=<span class="number">-1.0</span>, scale=<span class="number">.2</span>, size=<span class="number">50</span>)</span><br><span class="line">X[<span class="number">100</span>:<span class="number">150</span>, <span class="number">1</span>] = np.random.normal(loc=<span class="number">2.0</span>, scale=<span class="number">.5</span>, size=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pdist will calculate the upper triangle of the pairwise distance matrix</span></span><br><span class="line">distance_mat = pdist(X) </span><br><span class="line"><span class="comment"># linkage — is an implementation if agglomerative algorithm</span></span><br><span class="line">Z = hierarchy.linkage(distance_mat, <span class="string">'single'</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">dn = hierarchy.dendrogram(Z, color_threshold=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></li>
<li>聚类结果的判定</li>
</ol>
<ul>
<li>Adjusted Rand Index (ARI)</li>
<li>Adjusted Mutual Information (AMI)</li>
<li>Homogeneity, completeness, V-measure</li>
<li>Silhouette</li>
</ul>
<ol>
<li>聚类算法的使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans, AgglomerativeClustering, AffinityPropagation, SpectralClustering</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = datasets.load_digits()</span><br><span class="line">X, y = data.data, data.target</span><br><span class="line"></span><br><span class="line">algorithms = []</span><br><span class="line">algorithms.append(KMeans(n_clusters=<span class="number">10</span>, random_state=<span class="number">1</span>))</span><br><span class="line">algorithms.append(AffinityPropagation())</span><br><span class="line">algorithms.append(SpectralClustering(n_clusters=<span class="number">10</span>, random_state=<span class="number">1</span>,</span><br><span class="line">                                     affinity=<span class="string">'nearest_neighbors'</span>))</span><br><span class="line">algorithms.append(AgglomerativeClustering(n_clusters=<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> algo <span class="keyword">in</span> algorithms:</span><br><span class="line">    algo.fit(X)</span><br><span class="line">    data.append((&#123;</span><br><span class="line">        <span class="string">'ARI'</span>: metrics.adjusted_rand_score(y, algo.labels_),</span><br><span class="line">        <span class="string">'AMI'</span>: metrics.adjusted_mutual_info_score(y, algo.labels_,</span><br><span class="line">                                                 average_method=<span class="string">'arithmetic'</span>),</span><br><span class="line">        <span class="string">'Homogenity'</span>: metrics.homogeneity_score(y, algo.labels_),</span><br><span class="line">        <span class="string">'Completeness'</span>: metrics.completeness_score(y, algo.labels_),</span><br><span class="line">        <span class="string">'V-measure'</span>: metrics.v_measure_score(y, algo.labels_),</span><br><span class="line">        <span class="string">'Silhouette'</span>: metrics.silhouette_score(X, algo.labels_)&#125;))</span><br><span class="line"></span><br><span class="line">results = pd.DataFrame(data=data, columns=[<span class="string">'ARI'</span>, <span class="string">'AMI'</span>, <span class="string">'Homogenity'</span>,</span><br><span class="line">                                           <span class="string">'Completeness'</span>, <span class="string">'V-measure'</span>, </span><br><span class="line">                                           <span class="string">'Silhouette'</span>],</span><br><span class="line">                       index=[<span class="string">'K-means'</span>, <span class="string">'Affinity'</span>, </span><br><span class="line">                              <span class="string">'Spectral'</span>, <span class="string">'Agglomerative'</span>])</span><br><span class="line"></span><br><span class="line">results</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><h3 id="普通卷积模型"><a href="#普通卷积模型" class="headerlink" title="普通卷积模型"></a>普通卷积模型</h3><p>两个卷积层+一个池化层</p>
<h2 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h2><h3 id="U-NET：用于图像分割的卷积神经网路"><a href="#U-NET：用于图像分割的卷积神经网路" class="headerlink" title="U-NET：用于图像分割的卷积神经网路"></a>U-NET：用于图像分割的卷积神经网路</h3><p><a href="https://blog.csdn.net/Formlsl/article/details/80373200" target="_blank" rel="noopener">https://blog.csdn.net/Formlsl/article/details/80373200</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>kaggle</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode记录</title>
    <url>/2019/12/02/leetcode%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="题目记录"><a href="#题目记录" class="headerlink" title="题目记录"></a>题目记录</h1><h2 id="题51-八皇后问题"><a href="#题51-八皇后问题" class="headerlink" title="题51.八皇后问题"></a>题51.八皇后问题</h2><a id="more"></a>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>可以理解为一个坐标系，0，0是原点，<code>N*N</code>里面的每个点有两个函数，斜率分别是1，-1，（y=-x+b, y=-x+b）xy_sum中记录的是y=x+b里面的b xy_dif记录的是y=-x+b里面的b 如果之后的点里面有相同的元素在这两个列表里面就说明在这条线上已经有另一个皇后在了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(queens:List[int],xy_dif:List[int],xy_sum:List[int])</span>:</span></span><br><span class="line">            q = len(queens)</span><br><span class="line">            <span class="comment"># 终止条件</span></span><br><span class="line">            <span class="keyword">if</span> len(queens) == n:</span><br><span class="line">                result.append(queens)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> p <span class="keyword">not</span> <span class="keyword">in</span> queens <span class="keyword">and</span> q-p <span class="keyword">not</span> <span class="keyword">in</span> xy_dif <span class="keyword">and</span> q+p <span class="keyword">not</span> <span class="keyword">in</span> xy_sum:</span><br><span class="line">                    DFS(queens+[p],xy_dif+[q-p],xy_sum+[q+p])</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        DFS([],[],[])</span><br><span class="line">        <span class="keyword">return</span> [[<span class="string">"."</span>*i+<span class="string">"Q"</span>+<span class="string">"."</span>*(n-i<span class="number">-1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> sol] <span class="keyword">for</span> sol <span class="keyword">in</span> result]</span><br></pre></td></tr></table></figure>
<h2 id="题49-字母异位词分组"><a href="#题49-字母异位词分组" class="headerlink" title="题49.字母异位词分组"></a>题49.字母异位词分组</h2><blockquote>
<p>python中的集合操作符<br>S | T 返回一个新的集合，包括在集合S和T的所有元素<br>S - T 返回一个新集合，包括在集合S但不在T中的元素<br>S &amp; T 返回一个新集合，包括同时在集合S和T中的元素<br>S ^ T 返回一个新集合， 包括集合S和T中非相同元素<br>S &lt;= T 或 S &lt; T 返回True/False， 判断S和T的子集关系<br>S &gt;= T 或 S &gt; T 返回True/False， 判断S和T的包括关系</p>
</blockquote>
<h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            dic[tuple(sorted(s))] = dic.get(tuple(sorted(s)), []) + [s]</span><br><span class="line">        <span class="keyword">return</span> dic.values()</span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                count[ord(c) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">            dic[tuple(count)] = dic.get(tuple(count), []) + [s]</span><br><span class="line">        <span class="keyword">return</span> dic.values()</span><br></pre></td></tr></table></figure>
<h2 id="题891-子序列宽度之和"><a href="#题891-子序列宽度之和" class="headerlink" title="题891. 子序列宽度之和"></a>题891. 子序列宽度之和</h2><p><img src="1.jpg" alt="数学推导"></p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>快慢指针法判断循环：快指针每次前进2步，慢指针每次1步，如果快指针指向None表示不存在循环，如果慢指针追上快指针，表示存在循环。</p>
<h2 id="异或操作"><a href="#异或操作" class="headerlink" title="异或操作"></a>异或操作</h2><p>按位进行异或操作的性质：</p>
<ul>
<li>如果a、b两个值不相同，则异或结果为1(不同的位为1)。如果a、b两个值相同，异或结果为0（这里假设a、b 只能包含 1、0 两值，但别忘了，每个比特恰好是表示零和一的。也可以这么说：真 xor 假 = 真；真 xor 真 = 假；假 xor 假 = 假）。</li>
<li>满足交换律。</li>
</ul>
<p>即：<br>有a、b不等两值<br>a xor a = 0<br>b xor 0 = b<br>所以：(a xor a) xor b = a xor b xor a = b xor 0 = b</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote>
<p>(1)传统二分法查找的问题<br><code>mid = (left+right)//2</code>如果left和right较大，可能会出现溢出问题<br>为了避免溢出应当写为<code>mid=left+(right-left)//2</code><br>更好的写法是<code>mid=(left+right)&gt;&gt;&gt;1</code> 无符号右移，在python中不存在无符号右移<br>(2)避免边界问题<br>传统写法while(left&lt;=right)需要考虑退出循环时返回的是left还是right</p>
</blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li>考虑左右边界，如果target不在目标数组的范围内，则会报错</li>
<li>当数组元素个数是偶数个时，存在左中位数和右中位数；当数组元素个数是奇数时，则只存在确定的中位数。</li>
</ol>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 这个技巧是很多高效算法的基础，如排序算法、傅立叶变换。</p>
<h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><p>贪心算法（英語：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。 比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。</p>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<h1 id="python中的操作"><a href="#python中的操作" class="headerlink" title="python中的操作"></a>python中的操作</h1><h2 id="python中sort的实现算法timsort"><a href="#python中sort的实现算法timsort" class="headerlink" title="python中sort的实现算法timsort"></a>python中sort的实现算法timsort</h2><p><a href="https://www.cnblogs.com/clement-jiao/p/9243066.html#_label1" target="_blank" rel="noopener">https://www.cnblogs.com/clement-jiao/p/9243066.html#_label1</a></p>
<h2 id="python中哈希表的时间复杂符"><a href="#python中哈希表的时间复杂符" class="headerlink" title="python中哈希表的时间复杂符"></a>python中哈希表的时间复杂符</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。</p>
<h2 id="python中的位操作"><a href="#python中的位操作" class="headerlink" title="python中的位操作"></a>python中的位操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x &lt;&lt; y</span><br><span class="line">Returns x <span class="keyword">with</span> the bits shifted to the left by y places (<span class="keyword">and</span> new bits on the right-hand-side are zeros). This <span class="keyword">is</span> the same <span class="keyword">as</span> multiplying x by <span class="number">2</span>**y.</span><br><span class="line">x &gt;&gt; y</span><br><span class="line">Returns x <span class="keyword">with</span> the bits shifted to the right by y places. This <span class="keyword">is</span> the same <span class="keyword">as</span> //<span class="string">'ing x by 2**y.</span></span><br></pre></td></tr></table></figure>
<h2 id="python中的无穷大"><a href="#python中的无穷大" class="headerlink" title="python中的无穷大"></a>python中的无穷大</h2><p>python中不存在直接的无穷大表示，但可以通过<code>float(&#39;inf&#39;)</code>来创建，可以使用<br><code>isinf()</code>来验证</p>
<h2 id="python中生成器和迭代器的联合使用"><a href="#python中生成器和迭代器的联合使用" class="headerlink" title="python中生成器和迭代器的联合使用"></a>python中生成器和迭代器的联合使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> generator</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>
<h2 id="python中的字符编码"><a href="#python中的字符编码" class="headerlink" title="python中的字符编码"></a>python中的字符编码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ord(<span class="string">"A"</span>) <span class="comment">#将A转换为整数</span></span><br><span class="line">chr(<span class="number">123</span>) <span class="comment">#将整数转换为字符</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>八皇后问题</tag>
      </tags>
  </entry>
  <entry>
    <title>mac/linux常用命令</title>
    <url>/2019/11/29/mac-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="查看指定端口占用，并杀死对应进程"><a href="#查看指定端口占用，并杀死对应进程" class="headerlink" title="查看指定端口占用，并杀死对应进程"></a>查看指定端口占用，并杀死对应进程</h1><a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof: -i:80 #-i表示网络连接，80指明端口号，该命令会同时列出PID</span><br><span class="line">kill -9 1863 # 杀掉pid=1863的进程</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown流程图</title>
    <url>/2020/12/27/markdown%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    <content><![CDATA[<p>平常使用markdown写博客，最近发现markdown可以画流程图，稍微总结一下。</p>
<a id="more"></a>
<h2 id="hexo支持"><a href="#hexo支持" class="headerlink" title="hexo支持"></a>hexo支持</h2><p>hexo默认不支持markdown中的流程图渲染，需要安装：<code>npm install --save hexo-filter-flowchart</code></p>
<h2 id="一个简单的流程图"><a href="#一个简单的流程图" class="headerlink" title="一个简单的流程图"></a>一个简单的流程图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: Start</span><br><span class="line">op&#x3D;&gt;operation: Your Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<div id="flowchart-0" class="flow-chart"></div>



<h2 id="稍微复杂的流程图"><a href="#稍微复杂的流程图" class="headerlink" title="稍微复杂的流程图"></a>稍微复杂的流程图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: Start:&gt;http:&#x2F;&#x2F;www.google.com[blank]</span><br><span class="line">e&#x3D;&gt;end:&gt;http:&#x2F;&#x2F;www.google.com</span><br><span class="line">op1&#x3D;&gt;operation: My Operation</span><br><span class="line">sub1&#x3D;&gt;subroutine: My Subroutine</span><br><span class="line">cond&#x3D;&gt;condition: Yes</span><br><span class="line">or No?:&gt;http:&#x2F;&#x2F;www.google.com</span><br><span class="line">io&#x3D;&gt;inputoutput: catch something...</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line"># 指定位置</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op1</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<div id="flowchart-1" class="flow-chart"></div>

<h2 id="流程图中的模块类型"><a href="#流程图中的模块类型" class="headerlink" title="流程图中的模块类型"></a>流程图中的模块类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作模块</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>start</td>
<td>开始</td>
</tr>
<tr>
<td>end</td>
<td>结束</td>
</tr>
<tr>
<td>operation</td>
<td>普通操作块</td>
</tr>
<tr>
<td>condition</td>
<td>判断块</td>
</tr>
<tr>
<td>subroutine</td>
<td>子任务块</td>
</tr>
<tr>
<td>inputoutput</td>
<td>输入输出块</td>
</tr>
</tbody>
</table>
</div>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start
op=>operation: Your Operation
cond=>condition: Yes or No?
e=>end
st->op->cond
cond(yes)->e
cond(no)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: Start:>http://www.google.com[blank]
e=>end:>http://www.google.com
op1=>operation: My Operation
sub1=>subroutine: My Subroutine
cond=>condition: Yes or No?:>http://www.google.com
io=>inputoutput: catch something...

st->op1->cond
cond(yes)->io->e
cond(no)->sub1(right)->op1</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script></p>
]]></content>
      <categories>
        <category>其他工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下的c++库安装</title>
    <url>/2019/11/25/mac%E4%B8%8B%E7%9A%84c-%E5%BA%93%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="1-qt的安装"><a href="#1-qt的安装" class="headerlink" title="1.qt的安装"></a>1.qt的安装</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>命令行执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install qt</span><br></pre></td></tr></table></figure><br><a id="more"></a><br>记录执行结果<br><img src="qt.png" alt="执行结果截图"></p>
<h2 id="提示无法找到QtWidgets等时"><a href="#提示无法找到QtWidgets等时" class="headerlink" title="提示无法找到QtWidgets等时"></a>提示无法找到QtWidgets等时</h2><p>在环境变量中添加<code>export CMAKE_PREFIX_PATH=/usr/local/opt/qt5/</code>,重启使得环境生效</p>
<h2 id="qt-assistant中帮助文档的安装"><a href="#qt-assistant中帮助文档的安装" class="headerlink" title="qt assistant中帮助文档的安装"></a>qt assistant中帮助文档的安装</h2><p>qt assistant中的帮助文档发现不存在，所以进行安装<br>qt assistant中的帮助文档不能单独安装，需要下载所有的源码进行安装</p>
<ol>
<li>下载源码<br><code>git clone git://code.qt.io/qt/qt5.git</code><br><code>git checkout v5.14.0</code><br><code>perl init-repository</code></li>
<li>configure生成makefile<br><code>cd qt5</code><br><code>qt5</code></li>
</ol>
<h1 id="2-vtk的安装"><a href="#2-vtk的安装" class="headerlink" title="2.vtk的安装"></a>2.vtk的安装</h1><p><a href="https://stackoverflow.com/questions/32853082/how-to-install-vtk-on-a-mac" target="_blank" rel="noopener">ref</a></p>
<h2 id="安装步骤-1"><a href="#安装步骤-1" class="headerlink" title="安装步骤"></a>安装步骤</h2><ul>
<li>命令行执行<code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>
<li>命令行执行<code>brew install vtk</code></li>
</ul>
<h1 id="3-oce（OpenCASCADE）的安装"><a href="#3-oce（OpenCASCADE）的安装" class="headerlink" title="3.oce（OpenCASCADE）的安装"></a>3.oce（OpenCASCADE）的安装</h1><p><a href="https://github.com/tpaviot/oce/wiki/Build-%28Mac-OSX%29" target="_blank" rel="noopener">ref</a><br>命令行执行<code>brew tap brewsci/science &amp;&amp; brew install oce</code><br>执行结果<br><img src="oce.png" alt="执行结果"></p>
<h1 id="4-opencv的安装"><a href="#4-opencv的安装" class="headerlink" title="4.opencv的安装"></a>4.opencv的安装</h1><p>命令行执行<code>brew install opencv</code><br>执行结果<br><img src="opencv.png" alt="执行结果"></p>
<h1 id="Clion-QT-VTK环-OpenCV环境搭建"><a href="#Clion-QT-VTK环-OpenCV环境搭建" class="headerlink" title="Clion+QT+VTK环+OpenCV环境搭建"></a>Clion+QT+VTK环+OpenCV环境搭建</h1><blockquote>
<p>注意：<br>在clion中编译时，不要使用gcc，将编译器设置为系统默认的clang。（由于brew install默认识别系统自带的编译器）<br>Perferences-&gt;Toolchains-&gt;System(default) (如果之前修改过，新建一个设置为默认)</p>
</blockquote>
<h2 id="clion中cmakelist配置"><a href="#clion中cmakelist配置" class="headerlink" title="clion中cmakelist配置"></a>clion中cmakelist配置</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(Qt5_DIR /usr/local/opt/qt/lib/)</span><br><span class="line"><span class="comment">#set(OCE_DIR /usr/local/Cellar/oce/0.18.2/OCE.framework)</span></span><br><span class="line"><span class="keyword">find_package</span>(VTK REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(Qt5Widgets REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(Qt5Gui REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(Qt5Core REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(Qt5OpenGL REQUIRED)</span><br><span class="line"><span class="comment">#find_package(OCE REQUIRED COMPONENTS TKPrim)</span></span><br><span class="line"><span class="comment">#include_directories($&#123;OCE_INCLUDE_DIRS&#125;)</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;VTK_USE_FILE&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span> main.cpp)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;OpenCV_LIBRARY_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> Qt5::Widgets Qt5::Widgets Qt5::Core Qt5::Gui Qt5::OpenGL <span class="variable">$&#123;VTK_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>由于vtk,opencv等会自动调用qt，不对qt进行单独测试</strong><br>测试文件:（opencv）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">" Usage: display_image ImageToLoadAndDisplay"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat <span class="built_in">image</span>;</span><br><span class="line">    <span class="built_in">image</span> = imread(argv[<span class="number">1</span>], <span class="number">1</span>);   <span class="comment">// Read the file</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(! <span class="built_in">image</span>.data )                              <span class="comment">// Check for invalid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;  <span class="string">"Could not open or find the image"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    namedWindow( <span class="string">"Display window"</span>, WINDOW_AUTOSIZE );<span class="comment">// Create a window for display.</span></span><br><span class="line">    imshow( <span class="string">"Display window"</span>, <span class="built_in">image</span> );                   <span class="comment">// Show our image inside it.</span></span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);                                          <span class="comment">// Wait for a keystroke in the window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试文件（vtk）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=========================================================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Program:   Visualization Toolkit</span></span><br><span class="line"><span class="comment">  Module:    Cube.cxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen</span></span><br><span class="line"><span class="comment">  All rights reserved.</span></span><br><span class="line"><span class="comment">  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     This software is distributed WITHOUT ANY WARRANTY; without even</span></span><br><span class="line"><span class="comment">     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR</span></span><br><span class="line"><span class="comment">     PURPOSE.  See the above copyright notice for more information.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">=========================================================================*/</span></span><br><span class="line"><span class="comment">// This example shows how to manually create vtkPolyData.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For a python version, please see:</span></span><br><span class="line"><span class="comment">// [Cube](https://lorensen.github.io/VTKExamples/site/Python/GeometricObjects/Cube/)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkActor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkCamera.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkCellArray.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkFloatArray.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkNamedColors.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkNew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkPointData.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkPoints.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkPolyData.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkPolyDataMapper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRenderWindow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRenderWindowInteractor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRenderer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vtkNew&lt;vtkNamedColors&gt; colors;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 3&gt;, 8&gt; pts = &#123;&#123;&#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">                                                        &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">                                                        &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">                                                        &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">                                                        &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">                                                        &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">                                                        &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">                                                        &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;&#125;&#125;;</span><br><span class="line">    <span class="comment">// The ordering of the corner points on each face.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">array</span>&lt;vtkIdType, 4&gt;, 6&gt; ordering = &#123;&#123;&#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;,</span><br><span class="line">                                                                &#123;&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;&#125;,</span><br><span class="line">                                                                &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>&#125;&#125;,</span><br><span class="line">                                                                &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>&#125;&#125;,</span><br><span class="line">                                                                &#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>&#125;&#125;,</span><br><span class="line">                                                                &#123;&#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>&#125;&#125;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We'll create the building blocks of polydata including data attributes.</span></span><br><span class="line">    vtkNew&lt;vtkPolyData&gt; cube;</span><br><span class="line">    vtkNew&lt;vtkPoints&gt; points;</span><br><span class="line">    vtkNew&lt;vtkCellArray&gt; polys;</span><br><span class="line">    vtkNew&lt;vtkFloatArray&gt; scalars;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the point, cell, and data attributes.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0u</span>l; i &lt; pts.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        points-&gt;InsertPoint(i, pts[i].data());</span><br><span class="line">        scalars-&gt;InsertTuple1(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : ordering)</span><br><span class="line">    &#123;</span><br><span class="line">        polys-&gt;InsertNextCell(vtkIdType(i.<span class="built_in">size</span>()), i.data());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We now assign the pieces to the vtkPolyData.</span></span><br><span class="line">    cube-&gt;SetPoints(points);</span><br><span class="line">    cube-&gt;SetPolys(polys);</span><br><span class="line">    cube-&gt;GetPointData()-&gt;SetScalars(scalars);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we'll look at it.</span></span><br><span class="line">    vtkNew&lt;vtkPolyDataMapper&gt; cubeMapper;</span><br><span class="line">    cubeMapper-&gt;SetInputData(cube);</span><br><span class="line">    cubeMapper-&gt;SetScalarRange(cube-&gt;GetScalarRange());</span><br><span class="line">    vtkNew&lt;vtkActor&gt; cubeActor;</span><br><span class="line">    cubeActor-&gt;SetMapper(cubeMapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The usual rendering stuff.</span></span><br><span class="line">    vtkNew&lt;vtkCamera&gt; camera;</span><br><span class="line">    camera-&gt;SetPosition(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    camera-&gt;SetFocalPoint(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    vtkNew&lt;vtkRenderer&gt; renderer;</span><br><span class="line">    vtkNew&lt;vtkRenderWindow&gt; renWin;</span><br><span class="line">    renWin-&gt;AddRenderer(renderer);</span><br><span class="line"></span><br><span class="line">    vtkNew&lt;vtkRenderWindowInteractor&gt; iren;</span><br><span class="line">    iren-&gt;SetRenderWindow(renWin);</span><br><span class="line"></span><br><span class="line">    renderer-&gt;AddActor(cubeActor);</span><br><span class="line">    renderer-&gt;SetActiveCamera(camera);</span><br><span class="line">    renderer-&gt;ResetCamera();</span><br><span class="line">    renderer-&gt;SetBackground(colors-&gt;GetColor3d(<span class="string">"Cornsilk"</span>).GetData());</span><br><span class="line"></span><br><span class="line">    renWin-&gt;SetSize(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// interact with data</span></span><br><span class="line">    renWin-&gt;Render();</span><br><span class="line">    iren-&gt;Start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试文件（oce/opencascade）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>通过cmake安装的软件要通过如下方式进行卸载：<br><code>cat install_manifest.txt | sudo xargs rm</code></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>mac内置python环境</title>
    <url>/2019/12/28/mac%E5%86%85%E7%BD%AEpython%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>防止与anaconda中的环境冲突设置alias<br>在<code>~/.bash_profile</code>(如果使用zsh需要在<code>~/.zshrc</code>中)中添加<code>alias python_mac=&quot;/usr/local/Cellar/python/3.7.5/bin/python3&quot;</code><br>然后通过<code>python_mac</code>安装包<br><code>python_mac -m pip install scikit-image</code></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>mac（catalina）下miniconda的安装配置</title>
    <url>/2020/01/26/mac%EF%BC%88catalina%EF%BC%89%E4%B8%8Bminiconda%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="mac-catalina-下的miniconda环境配置"><a href="#mac-catalina-下的miniconda环境配置" class="headerlink" title="mac(catalina)下的miniconda环境配置"></a>mac(catalina)下的miniconda环境配置</h1><ol>
<li><code>brew install miniconda</code></li>
<li><code>conda init zsh</code>   或 <code>conda init shell</code></li>
<li><code>conda create env -f *.yml</code>  //yml文件通过<code>conda env export --file result.yml</code>进行备份</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>anaconda</tag>
        <tag>miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>mtcnn人脸检测</title>
    <url>/2020/02/20/mtcnn%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>cdsn：<a href="https://blog.csdn.net/weixin_44791964/article/details/103530206" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103530206</a><br><a id="more"></a><br><img src="1.png" alt="mtcnn检测流程"></p>
<h1 id="什么是mtcnn"><a href="#什么是mtcnn" class="headerlink" title="什么是mtcnn"></a>什么是mtcnn</h1><p>MTCNN，英文全称是Multi-task convolutional neural network，中文全称是多任务卷积神经网络，该神经网络将人脸区域检测与人脸关键点检测放在了一起。总体可分为P-Net、R-Net、和O-Net三层网络结构。</p>
<h1 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h1><h2 id="1-构建图像金字塔"><a href="#1-构建图像金字塔" class="headerlink" title="1.构建图像金字塔"></a>1.构建图像金字塔</h2><p>首先将图像进行不同尺度的变换，构建图像金字塔，以适应不同大小的人脸的进行检测。<br>构建方式是通过不同的缩放系数factor对图片进行缩放，每次缩小为原来的factor大小。<br>实现示意图如下：<br><img src="2.png" alt=""><br>当一个图片输入的时候，会缩放为不同大小的图片，但是缩小后的长宽最小不可以小于12</p>
<h2 id="2-Pnet"><a href="#2-Pnet" class="headerlink" title="2.Pnet"></a>2.Pnet</h2><p>Pnet的全称为Proposal Network，其基本的构造是一个全卷积网络。对上一步构建完成的图像金字塔，通过一个FCN进行初步特征提取与标定边框。<br>实现图片示意图如下：<br><img src="3.png" alt=""><br>在完成初步提取后，还需要进行Bounding-Box Regression调整窗口与NMS(非极大抑制)进行大部分窗口的过滤。<br>Pnet有两个输出，classifier用于判断这个网格点上的框的可信度，bbox_regress表示框的位置。<br>bbox_regress并不代表这个框在图片上的真实位置，如果需要将bbox_regress映射到真实图像上，还需要进行一次解码过程。</p>
<h2 id="3-Rnet"><a href="#3-Rnet" class="headerlink" title="3.Rnet"></a>3.Rnet</h2><p>Rnet全称为Refine Network，其基本的构造是一个卷积神经网络，相对于第一层的P-Net来说，增加了一个全连接层，因此对于输入数据的筛选会更加严格。在图片经过P-Net后，会留下许多预测窗口，我们将所有的预测窗口送入R-Net，这个网络会滤除大量效果比较差的候选框。<br>实现图片示意图如下：<br><img src="4.png" alt=""></p>
<h2 id="4-Onet"><a href="#4-Onet" class="headerlink" title="4.Onet"></a>4.Onet</h2><p>Onet与Rnet工作流程类似。输出框的可信度，调整框的位置大小，五个标记点。<br>全称为Output Network，基本结构是一个较为复杂的卷积神经网络，相对于R-Net来说多了一个卷积层。O-Net的效果与R-Net的区别在于这一层结构会通过更多的监督来识别面部的区域，而且会对人的面部特征点进行回归，最终输出五个人脸面部特征点。<br>实现图片示意图如下：<br><img src="5.png" alt=""></p>
<h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h1><p>以Rnet为例，其他见cdsn中的github链接</p>
<h2 id="Rnet"><a href="#Rnet" class="headerlink" title="Rnet"></a>Rnet</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_Rnet</span><span class="params">(weight_path)</span>:</span></span><br><span class="line">    input = Input(shape=[<span class="number">24</span>, <span class="number">24</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="comment"># 24,24,3 -&gt; 11,11,28</span></span><br><span class="line">    <span class="comment"># 卷积层 28通道，卷积核大小（3*3），stride步长为1，padding（valid：无填充；same为0填充）。输出为28通道，22*22</span></span><br><span class="line">    x = Conv2D(<span class="number">28</span>, (<span class="number">3</span>, <span class="number">3</span>), strides=<span class="number">1</span>, padding=<span class="string">'valid'</span>, name=<span class="string">'conv1'</span>)(input)</span><br><span class="line">    x = PReLU(shared_axes=[<span class="number">1</span>, <span class="number">2</span>], name=<span class="string">'prelu1'</span>)(x)</span><br><span class="line">    <span class="comment"># 池化层大小(3*3),步长为2，输出通道数不变，大小变为11*11</span></span><br><span class="line">    x = MaxPool2D(pool_size=<span class="number">3</span>,strides=<span class="number">2</span>, padding=<span class="string">'same'</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 11,11,28 -&gt; 4,4,48</span></span><br><span class="line">    x = Conv2D(<span class="number">48</span>, (<span class="number">3</span>, <span class="number">3</span>), strides=<span class="number">1</span>, padding=<span class="string">'valid'</span>, name=<span class="string">'conv2'</span>)(x)</span><br><span class="line">    x = PReLU(shared_axes=[<span class="number">1</span>, <span class="number">2</span>], name=<span class="string">'prelu2'</span>)(x)</span><br><span class="line">    x = MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4,4,48 -&gt; 3,3,64</span></span><br><span class="line">    x = Conv2D(<span class="number">64</span>, (<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">1</span>, padding=<span class="string">'valid'</span>, name=<span class="string">'conv3'</span>)(x)</span><br><span class="line">    x = PReLU(shared_axes=[<span class="number">1</span>, <span class="number">2</span>], name=<span class="string">'prelu3'</span>)(x)</span><br><span class="line">    <span class="comment"># 3,3,64 -&gt; 64,3,3</span></span><br><span class="line">    x = Permute((<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>))(x)</span><br><span class="line">    x = Flatten()(x)</span><br><span class="line">    <span class="comment"># 576 -&gt; 128</span></span><br><span class="line">    x = Dense(<span class="number">128</span>, name=<span class="string">'conv4'</span>)(x)</span><br><span class="line">    x = PReLU( name=<span class="string">'prelu4'</span>)(x)</span><br><span class="line">    <span class="comment"># 128 -&gt; 2 128 -&gt; 4</span></span><br><span class="line">    classifier = Dense(<span class="number">2</span>, activation=<span class="string">'softmax'</span>, name=<span class="string">'conv5-1'</span>)(x)</span><br><span class="line">    bbox_regress = Dense(<span class="number">4</span>, name=<span class="string">'conv5-2'</span>)(x)</span><br><span class="line">    model = Model([input], [classifier, bbox_regress])</span><br><span class="line">    model.load_weights(weight_path, by_name=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>mtcnn</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy中的axis和广播</title>
    <url>/2020/02/17/numpy%E4%B8%AD%E7%9A%84axis%E5%92%8C%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<h1 id="通俗易懂的解释numpy中的广播"><a href="#通俗易懂的解释numpy中的广播" class="headerlink" title="通俗易懂的解释numpy中的广播"></a>通俗易懂的解释numpy中的广播</h1><a id="more"></a>
<p>原连接： <a href="https://blog.csdn.net/xiang_freedom/article/details/77968164" target="_blank" rel="noopener">https://blog.csdn.net/xiang_freedom/article/details/77968164</a></p>
<p>广播是numpy对不同shape的array进行数值计算的方式，符合一定规则的前提下，将较小的array“广播”成更大的、可以计算的array。广播意味着一种向量化操作，从而在类似C语言中产生大量循环，这会导致内存和计算效率的低效。在Python中，广播不会做大量的数据复制并且通常使计算更加高效。</p>
<p>标准的数组计算形式为两个shape形状一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; np.array([1.0, 2.0, 3.0])</span><br><span class="line">&gt;&gt;&gt; b &#x3D; np.array([2.0, 2.0, 2.0])</span><br><span class="line">&gt;&gt;&gt; a * b</span><br><span class="line">array([ 2.,  4.,  6.])</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p>如果shape不一致，需要满足一定规则，可以使用广播。</p>
<h2 id="广播规则"><a href="#广播规则" class="headerlink" title="广播规则"></a>广播规则</h2><p>网上很多文章的写法都是：</p>
<ol>
<li>让所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐</li>
<li>输出数组的shape是输入数组shape的各个轴上的最大值</li>
<li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为1时，这个数组能够用来计算，否则出错</li>
<li>当输入数组的某个轴的长度为1时，沿着此轴运算时都用此轴上的第一组值</li>
</ol>
<p>我看的时候看了很久都没有看懂。其实可以更简单的描述：<br>对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p>
<ol>
<li>当前维度的值相等</li>
<li>当前维度的值有一个是1</li>
</ol>
<p>若条件不满足，抛出“ValueError: frames are not aligned”异常。<br>输出数组的维度是每一个维度的最大值，广播将值为1的维度进行“复制”、“拉伸”，如图所示</p>
<p><img src="image/123.gif" alt="img"><br>需要注意的是这里的“复制”只是一个抽象概念，Python并不会对数据进行真实复制。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Image  (3d array): 256 x 256 x 3</span><br><span class="line">Scale  (1d array):             3</span><br><span class="line">Result (3d array): 256 x 256 x 3</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>在第三个维度相等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A      (4d array):  8 x 1 x 6 x 1</span><br><span class="line">B      (3d array):      7 x 1 x 5</span><br><span class="line">Result (4d array):  8 x 7 x 6 x 5</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>在第2、3、4维度满足第2个条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A      (2d array):      2 x 1</span><br><span class="line">B      (3d array):  8 x 4 x 3</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>错误的情况，在第二个维度不满足条件。</p>
<p>参考资料<br>numpy文档 ：<a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html" target="_blank" rel="noopener">https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html</a><br>图形化描述：<a href="http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc" target="_blank" rel="noopener">http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc</a></p>
<h1 id="Python之NumPy（axis-0-与axis-1）区分"><a href="#Python之NumPy（axis-0-与axis-1）区分" class="headerlink" title="Python之NumPy（axis=0 与axis=1）区分"></a>Python之NumPy（axis=0 与axis=1）区分</h1><p>2018年06月23日 15:42:06 <a href="https://me.csdn.net/hlang8160" target="_blank" rel="noopener">hlang8160</a> 阅读数 237</p>
<p>转自：<a href="http://blog.csdn.net/wangying19911991/article/details/73928172" target="_blank" rel="noopener">http://blog.csdn.net/wangying19911991/article/details/73928172</a></p>
<p><a href="https://www.zhihu.com/question/58993137" target="_blank" rel="noopener">https://www.zhihu.com/question/58993137</a><br><a href="https://www.cnblogs.com/rrttp/p/8028421.html" target="_blank" rel="noopener">https://www.cnblogs.com/rrttp/p/8028421.html</a></p>
<p>python中的axis究竟是如何定义的呢？他们究竟代表是DataFrame的行还是列？考虑以下代码：</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pd.DataFrame([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], \<br>columns=[“col1”, “col2”, “col3”, “col4”])<br>df<br>col1 col2 col3 col4<br>0 1 1 1 1<br>1 2 2 2 2<br>2 3 3 3 3<br>如果我们调用df.mean(axis=1),我们将得到按行计算的均值</p>
<p>df.mean(axis=1)<br>0 1<br>1 2<br>2 3<br>然而，如果我们调用 df.drop((name, axis=1),我们实际上删掉了一列，而不是一行：</p>
<p>df.drop(“col4”, axis=1)<br>col1 col2 col3<br>0 1 1 1<br>1 2 2 2<br>2 3 3 3</p>
</blockquote>
</blockquote>
</blockquote>
<p>Can someone help me understand what is meant by an “axis” in pandas/numpy/scipy?<br>有人能帮我理解一下，在pandas、numpy、scipy三都当中axis参数的真实含义吗？</p>
<p>投票最高的答案揭示了问题的本质：</p>
<p>其实问题理解axis有问题，df.mean其实是在每一行上取所有列的均值，而不是保留每一列的均值。也许简单的来记就是axis=0代表往跨行（down)，而axis=1代表跨列（across)，作为方法动作的副词（译者注）</p>
<p>换句话说:</p>
<p>使用0值表示沿着每一列或行标签\索引值向下执行方法<br>使用1值表示沿着每一行或者列标签模向执行对应的方法<br>下图代表在DataFrame当中axis为0和1时分别代表的含义:</p>
<p>axis参数作用方向图示</p>
<p><img src="image/70-2401463.png" alt="这里写图片描述"></p>
<p>另外，记住，Pandas保持了Numpy对关键字axis的用法，用法在Numpy库的词汇表当中有过解释：</p>
<p>轴用来为超过一维的数组定义的属性，二维数据拥有两个轴：第0轴沿着行的垂直往下，第1轴沿着列的方向水平延伸。</p>
<p>所以问题当中第一个列子 df.mean(axis=1)代表沿着列水平方向计算均值，而第二个列子df.drop(name, axis=1) 代表将name对应的列标签（们）沿着水平的方向依次删掉。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>pyqt5</title>
    <url>/2020/06/29/pyqt5/</url>
    <content><![CDATA[<h2 id="PYQT5"><a href="#PYQT5" class="headerlink" title="PYQT5"></a>PYQT5</h2><a id="more"></a>
<p>pyqt5下，dialog用exec_()方法，widget用show()方法;</p>
<h4 id="1-QDockWidget"><a href="#1-QDockWidget" class="headerlink" title="1.QDockWidget"></a>1.QDockWidget</h4><p><a href="https://blog.csdn.net/czyt1988/article/details/51209619" target="_blank" rel="noopener">Dock嵌套布局</a></p>
<p>QDockWidget是一个可以停靠在QMainWindow内的窗口控件，它可以保持浮动状态或在指定位置作为子窗口附加到主窗口中。其常用方法有：<br>setWidget()，用于设置在DockWidget内显示的QWidget及其子类对象。<br>setFloating()，设置DockWidget是否可以浮动，参数为True或False。<br>setAllowedArea()，设置可以停靠的区域，可用参数为Qt.DockWidgetAreas{LeftDockWidgetArea, RightDockWidgetArea, TopDockWidgetArea, BottomDockWidgetArea, AllDockWidgetAreas, NoDockWidgetArea}。<br>setFeatures()，设置停靠窗口的功能属性（有些属性决定了显示哪些按钮），可用参数为QDockWidget.DockWidgetFeatures{DockWidgetClosable, DockWidgetMovable, DockWidgetFloatable, DockWidgetVerticalTitleBar, AllDockWidgetFeatures, NoDockWidgetFeatures}。<br>其常用信号有：<br>topLevelChanged(bool topLevel)：当浮动状态变化时发生，参数为True时为浮动状态。<br>void visibilityChanged(bool visible)：当显示状态变化时发生（一般是在以Tab方式显示时使用），参数为True时可见。</p>
<p>QMainWindow类中包含了有关DockWidget的一些函数方法，主要有：<br>addDockWidget(Qt.DockWidgetArea area, QDockWidget dockwidget)，将DockWidget添加到主窗口，第一个参数为停靠位置，第二个参数为要添加的DockWidget。<br>setDockOptions()，设置停靠属性，参数类型为QMainWindow.DockOptions { AnimatedDocks, AllowNestedDocks, AllowTabbedDocks, ForceTabbedDocks, VerticalTabs, GroupedDragging }<br>setTabPosition(Qt.DockWidgetAreas areas, QTabWidget.TabPosition position)，设置停靠和标题位置，第一个参数为停靠位置，第二个参数为标题位置，取值范围QtabWidget.TabPosition { North, South, West, East }。<br>tabifyDockWidget(QDockWidget first, QDockWidget second)，以Tab方式显示DockWidget，其中第二个窗体排在第一个之后。<br>setTabShape(QTabWidget.TabShape shape)，设置Tab标签样式，取值范围QTabWidget.TabShape { Rounded, Triangular }。</p>
<h4 id="2-右键菜单"><a href="#2-右键菜单" class="headerlink" title="2.右键菜单"></a>2.右键菜单</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">item_widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)</span><br><span class="line">item_widget.customContextMenuRequested[QtCore.QPoint].connect(lambda pos: main_window.cad_item_right_click_menu(pos, item, item_widget))</span><br></pre></td></tr></table></figure>
<p><strong>将菜单在当前位置显示</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">	self.TextContextMenu.move(QtGui.QCursor.pos()) </span><br><span class="line">       self.TextContextMenu.show()  </span><br><span class="line">    方法二：</span><br><span class="line">       <span class="comment">#在当前坐标下显示，但是菜单停止不走动</span></span><br><span class="line">       self.TextContextMenu.exec_(QtGui.QCursor.pos())        </span><br><span class="line">       </span><br><span class="line">       <span class="comment">#将菜单在右上方显示</span></span><br><span class="line">       self.TextContextMenu.move(self.pos() + pos)</span><br></pre></td></tr></table></figure>
<h4 id="3-自定义list-item"><a href="#3-自定义list-item" class="headerlink" title="3.自定义list item"></a>3.自定义list item</h4><p><a href="https://stackoverflow.com/questions/25187444/pyqt-qlistwidget-custom-items" target="_blank" rel="noopener">https://stackoverflow.com/questions/25187444/pyqt-qlistwidget-custom-items</a></p>
<h4 id="4-Margin"><a href="#4-Margin" class="headerlink" title="4.Margin"></a>4.Margin</h4><p>(left, top, right, bottom)</p>
<h4 id="5-信号额外参数传递"><a href="#5-信号额外参数传递" class="headerlink" title="5.信号额外参数传递"></a>5.信号额外参数传递</h4><p><a href="https://blog.csdn.net/fengyu09/article/details/39498777" target="_blank" rel="noopener">https://blog.csdn.net/fengyu09/article/details/39498777</a></p>
<p><a href="https://codeday.me/bug/20190326/831567.html" target="_blank" rel="noopener">传递额外参数但是不影响默认信号</a></p>
<h4 id="6-拖放技术"><a href="#6-拖放技术" class="headerlink" title="6.拖放技术"></a>6.拖放技术</h4><p><a href="https://www.jianshu.com/p/378ee9b63d48" target="_blank" rel="noopener">拖放技术</a></p>
<p>使用拖放技术可实现在不同控件或应用之间的数据交换。使用该技术的典型示例是在Windows资源管理器中移动文件。要将文件移动到另一个目录，只需用鼠标左键单击文件图标差按住不放，将文件拖动到目标目录图标，然后释放鼠标按钮。如果要复制文件，而不是移动文件，则还要按住键。<br><strong>1.拖动</strong><br>(1) 在<code>mousePressEvent()</code>中，记录鼠标按下时的位置；<br>(2) 在<code>mouseMoveEvent ()</code>中，计算鼠标移动的距离，可用来防止无意的拖动。QApplication的下列静态方法可用来控制延迟量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setstartDragDistance (Distance) - 拖动开始的最小移动量；</span><br><span class="line">startDragDistance() - 返回拖动开始的最小移动量；</span><br><span class="line">setstartDragTime (Time) -拖动开始的按压毫秒数；</span><br><span class="line">startDragTime () - 返回拖动开始的按压毫秒数；</span><br></pre></td></tr></table></figure>
<p>(3) 鼠标移动超过最小移动值或按压鼠标超过最小毫秒数，拖动操作开始。此时，创建一个QDrag对象，调用exce()方法进行相关操作。QDrag有以下方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec( ) -  开始拖放操作,返回一个代表放置操作的枚举值。有两个格式：</span><br><span class="line">exec(supportedActions &#x3D; Qt.MoveAction)</span><br><span class="line">exec(supportedActions, defaultDropAction)</span><br><span class="line">详细用法参见http:&#x2F;&#x2F;doc.qt.io&#x2F;qt-5&#x2F;qdrag.html#exec</span><br><span class="line">setMimeData (QMimeData qmd) - 设置拖放中传输的数据, 参数为QMimeData类型。传输文本的例子：</span><br><span class="line">data &#x3D; QtCore.QMimeData ()</span><br><span class="line">data.setText (&quot;Drag text&quot;)</span><br><span class="line">drag &#x3D; QtGui.QDrag (self)</span><br><span class="line">drag.setMimeData (data)</span><br><span class="line">mimeData () - 返回拖放过程中传输数据的QMimeData 对象；</span><br><span class="line">setPixmap(QPixmap qpix) - 设定拖放过程鼠标显示的图像。如：</span><br><span class="line">drag.setPixmap (QtGui.QPixmap (&quot;dd representer.png&quot;))</span><br><span class="line">pixmap() - 返回拖放过程中鼠标显示图像的QPixmap对象；</span><br><span class="line">setHotSpot (QPoint pt) - 设置图像的热点位置。</span><br><span class="line">drag.setHotSpot (QtCore.QPoint (20, 20))</span><br><span class="line">hotSpot() - 返回热点位置的QPoint对象；</span><br><span class="line">setDragCursor (QPixmap pix, Qt.DropAction dact) - 设置拖放的鼠标形状。第一个参数为鼠标形状的QPixmap对象；第二参数为相关操作的枚举值，只能是 CopyAction, MoveAction 或LinkAction。drag.setDragCursor (QtGui.QPixmap (&quot;move_cursor.png&quot;), QtCore.Qt.MoveAction)</span><br><span class="line">dragCursor ( Qt.DropAction dact) - 返回dact操作的鼠标形状的QPixmap对象;</span><br><span class="line">source() - 返回源控件的引用；</span><br><span class="line">target() - 返回目标控件的引用。如果拖放的目标对象为另一应用，返回值为None.</span><br><span class="line">supportedActions () - 返回当前有效操作的组合值。</span><br><span class="line">defaultAction () - 返回缺省的操作。</span><br></pre></td></tr></table></figure><br>QDrag有两个信号：<br><code>actionChanged (Qt.DropAction dact)</code> - 当拖放的行为被该变时，发射该信号；<br><code>targetchanged (QWidget obj)</code> - 当目标控件被改变时，将会发射该信号；</p>
<p><strong>2.QMineData类</strong><br>拖放过过程中的MIME类型的数据传递通过将QMineData对象作为参数调用QDrag的setMimeData()函数实现。<br>创建QMimeData方法：<br>data=QtCore.QMimeData()<br>QMimeData类支持以下方法（详见<a href="http://doc.qt.io/qt-5/qmimedata.html" target="_blank" rel="noopener">http://doc.qt.io/qt-5/qmimedata.html</a>):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setText(text) - 设置文本数据（MIME型文本&#x2F;文本格式）:</span><br><span class="line">data.setText(&quot;拖动文本&quot;)</span><br><span class="line">text( ) - 返回文本数据;</span><br><span class="line">hasText( ) - 如果对象包含文本数据，则返回True，否则返回False。</span><br><span class="line">setHtml(HTML-text) - 以HTML格式设置文本数据（MIME型文本 &#x2F; html格式）:</span><br><span class="line">data.setHtml(&quot;拖动HTML文本&lt;&#x2F; b&gt;&quot;)</span><br><span class="line">html( ) - 返回HTML格式的文本数据;</span><br><span class="line">hasHtml( ) - 如果对象包含HTML格式的文本数据，则返回True，否则为False.</span><br><span class="line">setUrls( QList  url) - 设置地址列表，参数为QUrl类的列表；</span><br><span class="line">data.setUrls ([QtCore.QUrl (&quot;http:&#x2F;&#x2F;www.google.com&#x2F;&quot;)])</span><br><span class="line">urls () - 返回地址列表:</span><br><span class="line">url &#x3D; e.mimeData (). urls () [0] .toString ()</span><br><span class="line">hasUrls () - 如果对象包Url地址，则返回True，否则为False.</span><br><span class="line">setlmageData(QVarinat  img) - 设置图像数据，可以是QImage或QPixmap实例：</span><br><span class="line">data.setlmageData (QtGui.Qlmage(&quot;pixmap.png&quot;))</span><br><span class="line">data.setlmageData (QtGui.QPixmap(&quot;pixmap.png&quot;))</span><br><span class="line">imageData( ) - 返回图像对象;</span><br><span class="line">haslmage( ) - 如果对象包含图像数据，则返回True，否则为False.</span><br><span class="line">setData(QString mimetype, QCore.QByteData data) 设置任意类型的MIME类型数据；参数1为QString类型，指定MIME类型；参数2为QByteData类实例。该方法可以用MIME不同类型，多次调用：</span><br><span class="line">data.setData(&quot;text&#x2F;plain&quot;,QtCore.QByteArray (bytes (&quot;Data&quot;, &quot;utf-8&quot;)))</span><br><span class="line">data(QString mimetype) -  返回mimetype类型的QByteData数据对象;</span><br><span class="line">hasFormat(QString mimetype) -  如果对象包含mimetype类型数据，则返回True，否则为False.</span><br><span class="line">formats ( ) - 返回包括的mimetype类型列表；</span><br><span class="line">removeFormat (QString mimetype) - 删除mimetype类型的数据;</span><br><span class="line">clear ( ) - 删除所有数据。</span><br></pre></td></tr></table></figure>
<p>如果要实现特殊类型数据的拖放，需要创建一个QMimeData子类，并重载retrieveData( ) 和 formats ( )方法。详细内容，请参考Qt文档。</p>
<p><strong>3.放置操作</strong><br>在处理拖放对象之前，必须告诉系统该组件可以处理这些事件。 为此，要在组件的构造函数中，调用继承自QWidget类的setAcceptDrops方法，参数值为True：<br><code>self.setAcceptDrops（True）</code><br>拖放对象的过程执行如下：<br>在控件的dragEnterEvent()方法中，检查拖动的MIME类型数据。如果该控件能处理此类型数据，则调用事件对象的acceptProposedAction( )方法。如果要变更操作，则将新事件传递给事件对象的setDropAction( )方法，然后调用accept( )方法，而不是调用acceptProposedAction( )方法。<br>如果要限制控件的特定区域才能放置操作，必须在dragMoveEvent( )方法中处理。即当拖放进入到特定的区域，调用accept( QRect rect)方法，参数rect为特定区域的QRect对象。<br>在控件的dropEvent()方法中，完成相关操作。</p>
<p>QWidget类的下列方法可以处理在拖放过程中发生的事件：</p>
<pre><code>dragEnterEvent (self,event) - 当拖动进入到控件区域时调用。通过event参数， 可取得QDragEnterEvent实例;
dragLeaveEvent(self,event) - 当拖动离开控件区域时调用。通过event参数， 可取得QDragLeaveEvent实例;
dragMoveEvent (self, event) -当拖动在控件区域移动时调用。通过event参数， 可取得QDragMoveEvent实例;
dropEvent (self, event) - 当拖动在控件区域放开时调用。通过event参数， 可取得QDropEvent实例;
</code></pre><p>QDragLeaveEvent类继承自QEvent类，不附带任何其他信息。因为在该类中只要知道拖动的对象已经离开组件区域就够了。<br>相关类的继承顺序为：<br>QEvent - QDropEvent - QDragMoveEvent - QDragEnterEvent<br>QDragEnterEvent类中没有增加新方法。<br>QDropEvent类有下列方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimeData( ) - 返回含有所传输数据和MIME类型信息的QMimeData类的实例；</span><br><span class="line">pos( ) - 返回QPoint类的实例，为拖放对象放置的整数坐标;</span><br><span class="line">posF( ) - 返回QPointF类的实例，为拖放对象放置的浮点坐标;</span><br><span class="line">possibleAction( ) - 返回拖放可能的操作组合,如:</span><br><span class="line">if e.possibleActions () &amp; QtCore.Qt.MoveAction:</span><br><span class="line">    print (&quot;MoveAction&quot;)</span><br><span class="line">if e.possibleActions () &amp; QtCore.Qt.CopyAction:</span><br><span class="line">    print (&quot;CopyAction&quot;)</span><br><span class="line">proposedAction( ) - 返回默认的放置操作；</span><br><span class="line">acceptProposedAction( ) - 表示已准备好接受传输的数据和由proposalAction( )返回的默认操作。该方法(或者accept()方法)必须在dragEnterEvent()中调用，否则，dropEvent()不会被调用。</span><br><span class="line">setDropAction (action) - 允许在放置时指定为action. 作了此设置后，必须调用accept( )方法, 而不是acceptProposedAction( )方法;</span><br><span class="line">dropAction( ) - 返回放置时进行的操作。如果用setDropAction( )进行了更改，可能与proposedAction ()的返回值不一致。</span><br><span class="line">keyboardModifiers( ) - 用于判断按下了哪些修饰键 (, , , 等.) ，可参考“PyQt5编程(18)：键盘事件”中的对应函数。</span><br><span class="line">mouseButtons () - 用于判断在拖放过程中按下的鼠标键;</span><br><span class="line">source( ) - 如果拖放是从另一个应用程来的，返回为None；否则，返回对拖放源控件的引用。</span><br></pre></td></tr></table></figure>
<p>QDragMoveEvent类的方法有：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accept (QRect rect) - 表明允许后续的移动操作。 rect用来指定可接受拖放操作的区域；</span><br><span class="line">ignore (QRect rect) - 表明不允许后续的移动操作。 rect用来指定不接受拖放操作的区域；;</span><br><span class="line">answerRect () - 返回可接受拖放操作区域的QRect对象。</span><br></pre></td></tr></table></figure><br>PyQt中的有些控件，如单行文本控件，已有拖放功能。因此，在自己实现拖放功能之前，请仔细阅读相关控件的文档。</p>
<h4 id="7-List和Tree之间的拖拽事件"><a href="#7-List和Tree之间的拖拽事件" class="headerlink" title="7.List和Tree之间的拖拽事件"></a>7.List和Tree之间的拖拽事件</h4><p><a href="https://stackoverflow.com/questions/54837869/drag-items-between-qtreewidget-and-qlistwidget-in-pyqt5#comment96451219_54838206" target="_blank" rel="noopener">list和tree之间的拖拽</a></p>
<p><a href="https://stackoverflow.com/questions/41595014/dragndrop-custom-widget-items-between-qlistwidgets" target="_blank" rel="noopener">listwidget中自定义widget的drag&amp;drop</a></p>
<p><a href="http://www.xdbcb8.com/archives/701.html" target="_blank" rel="noopener">listview的使用</a></p>
<p><a href="http://rowinggolfer.blogspot.com/2010/04/pyqt4-modelview-drag-drop-example.html" target="_blank" rel="noopener">pyqt model/view drag&amp;drop example</a></p>
<h4 id="8-show和exec的区别"><a href="#8-show和exec的区别" class="headerlink" title="8. show和exec的区别"></a>8. show和exec的区别</h4><p>Pyqt中 QDialog  show和exec的区别</p>
<p>QDialog的显示有两个函数show()和exec()。他们的区别在参考文档上的解释如下：</p>
<p><strong>show():</strong><br>显示一个<strong>非模式</strong>对话框。控制权即刻返回给调用函数。<br>弹出窗口是否模式对话框，取决于modal属性的值。</p>
<p>原文：Shows the dialog as a modeless dialog. Control returns immediately to the calling code.<br>The dialog will be modal or modeless according to the value of the modal property.</p>
<p><strong>exec():</strong><br>显示一个<strong>模式</strong>对话框，并且锁住程序直到用户关闭该对话框为止。函数返回一个DialogCode结果。<br>在对话框弹出期间，用户不可以切换同程序下的其它窗口，直到该对话框被关闭。<br>原文：Shows the dialog as a modal dialog, blocking until the user closes it. The function returns a DialogCode result.<br>Users cannot interact with any other window in the same application until they close the dialog. </p>
<p><strong>模式与非模式</strong></p>
<p>模式对话框，就是在弹出窗口的时候，整个程序就被锁定了，处于等待状态，直到对话框被关闭。这时往往是需要对话框的返回值进行下面的操作。如：确认窗口（选择“是”或“否”）。<br>非模式对话框，在调用弹出窗口之后，调用即刻返回，继续下面的操作。这里只是一个调用指令的发出，不等待也不做任何处理。如：查找框。</p>
<p>简单的理解：</p>
<p><strong>首先这两个方法返回值不同。exec()有返回值，show()没有返回值。</strong></p>
<p><strong>其次这两个方法的作用也不同。调用show()的作用仅仅是将widget及其上的内容都显示出来，控制权即刻返回给调用函数。而调用exec()后，调用线程将会被阻塞，锁住程序直到用户关闭该对话框，期间用户不可以切换同程序下的其它窗口直到Dialog关闭。</strong></p>
<h4 id="9-只接受数字-amp-密文"><a href="#9-只接受数字-amp-密文" class="headerlink" title="9.只接受数字&amp;密文"></a>9.只接受数字&amp;密文</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.kernel1_size_text &#x3D; QtWidgets.QLineEdit()</span><br><span class="line">self.kernel1_size_text.setPlaceholderText(&#39;k-size&#39;)</span><br><span class="line">self.kernel1_size_text.setToolTip(&#39;kernel size(odd,odd)&#39;)</span><br><span class="line">self.kernel1_size_text.setValidator(QtGui.QIntValidator())  QtGui.QDoubleValidata</span><br><span class="line">self.kernel1_size_text.setEchoMode(QtWidgets.QLineEdit.Password)</span><br><span class="line">self.kernel1_size_text.setText(&#39;3&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="10-自定义信号和槽"><a href="#10-自定义信号和槽" class="headerlink" title="10.自定义信号和槽"></a>10.自定义信号和槽</h4><p><a href="https://blog.csdn.net/zhulove86/article/details/52563131" target="_blank" rel="noopener">自定义信号槽</a></p>
<p><a href="https://stackoverflow.com/questions/2970312/pyqt4-qtcore-pyqtsignal-object-has-no-attribute-connect" target="_blank" rel="noopener">自定义信号必须放在类中函数的定义外</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_signal = QtCore.pyqtSignal(str)  <span class="comment"># 定义信号,定义参数为str类型</span></span><br><span class="line">self._signal.emit(<span class="string">"正在打印，请稍候..."</span>)</span><br><span class="line">self._signal.connect(self.mySignal)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mySignal</span><span class="params">(self, string)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
  </entry>
  <entry>
    <title>pyinstaller打包</title>
    <url>/2020/07/01/pyinstaller%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>pyinstaller用于windows下python代码的打包。<br><a id="more"></a></p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>指定打包后只生成一个 exe 格式的文件</td>
</tr>
<tr>
<td>-D</td>
<td>–onedir 创建一个目录，包含 exe 文件，但会依赖很多文件（默认选项）</td>
</tr>
<tr>
<td>-c</td>
<td>–console, –nowindowed 使用控制台，无界面 (默认)</td>
</tr>
<tr>
<td>-w</td>
<td>去除控制台，建议在开发 gui 的时候使用</td>
</tr>
<tr>
<td>-i</td>
<td>改变生成程序的 icon 图标</td>
</tr>
</tbody>
</table>
</div>
<p>测试文件<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide2.QtCore <span class="keyword">import</span> Slot</span><br><span class="line"><span class="keyword">from</span> PySide2.QtGui <span class="keyword">import</span> QKeySequence</span><br><span class="line"><span class="keyword">from</span> PySide2.QtWidgets <span class="keyword">import</span> QMainWindow, QAction,QApplication,QVBoxLayout,QLabel,QFrame</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        QMainWindow.__init__(self)</span><br><span class="line">        self.setWindowTitle(<span class="string">"Eartquakes information"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Menu</span></span><br><span class="line">        self.menu = self.menuBar()</span><br><span class="line">        self.file_menu = self.menu.addMenu(<span class="string">"File"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Exit QAction</span></span><br><span class="line">        exit_action = QAction(<span class="string">"Exit"</span>, self)</span><br><span class="line">        exit_action.setShortcut(QKeySequence.Quit)</span><br><span class="line">        exit_action.triggered.connect(self.close)</span><br><span class="line"></span><br><span class="line">        self.file_menu.addAction(exit_action)</span><br><span class="line"></span><br><span class="line">        frame = QFrame()</span><br><span class="line">        g_layout = QVBoxLayout()</span><br><span class="line">        g_layout.addWidget(QLabel(<span class="string">','</span>.join(map(str,np.arange(<span class="number">1</span>,<span class="number">5</span>).tolist()))))</span><br><span class="line"></span><br><span class="line">        g_layout.addWidget(QLabel(reduce(<span class="keyword">lambda</span> x,y:str(x)+<span class="string">","</span>+str(y),pd.read_csv(<span class="string">r"C:\Users\10993\Desktop\1.csv"</span>, header=<span class="literal">None</span>).values.ravel().tolist())))</span><br><span class="line">        frame.setLayout(g_layout)</span><br><span class="line">        self.setCentralWidget(frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Status Bar</span></span><br><span class="line">        self.status = self.statusBar()</span><br><span class="line">        self.status.showMessage(<span class="string">"Data loaded and plotted"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Window dimensions</span></span><br><span class="line">        geometry = QApplication.desktop().availableGeometry(self)</span><br><span class="line">        self.setFixedSize(int(geometry.width() * <span class="number">0.8</span>), int(geometry.height() * <span class="number">0.7</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    wind = MainWindow()</span><br><span class="line">    wind.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><br>执行<code>pyinstaller -w --hidden-import=pkg_resources.py2_warn -F example.py</code></p>
<h2 id="出现的一些问题"><a href="#出现的一些问题" class="headerlink" title="出现的一些问题"></a>出现的一些问题</h2><ol>
<li>打包完成执行exe文件时，提示<code>Failed to execute script pyi_rth_pkgres</code></li>
</ol>
<p>可以通过增加hidden-import参数（Name an import not visible in the code of the script(s). This option can be used multiple times.）解决：<code>&quot;pyinstaller --hidden-import=pkg_resources.py2_warn example.py&quot;</code></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>应用</category>
      </categories>
  </entry>
  <entry>
    <title>python中的absl库</title>
    <url>/2020/02/25/python%E4%B8%AD%E7%9A%84absl%E5%BA%93/</url>
    <content><![CDATA[<p>absl库用来进行命令行命令解析<br><a id="more"></a><br>absl 库全称是 Abseil Python Common Libraries。它原本是个C++库，后来被迁移到了Python上。</p>
<p>它是创建Python应用的代码集合。这些代码从谷歌自己的Python代码基地中搜集而来，已经过全面的测试并广泛用于生产中。</p>
<p>特点：</p>
<p>简单的应用创建<br>分布式的命令行标志系统<br>用户自定义的记录模块，并拥有额外的功能。<br>拥有测试工具<br>下面是它的 hello world 样例。我们输入参数：name 代表名字，num_times 代表语句重复次数。name是必填参数，num_times是可选参数，默认值为1.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> absl <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> absl <span class="keyword">import</span> flags</span><br><span class="line"> </span><br><span class="line">FLAGS = flags.FLAGS <span class="comment"># 用法和TensorFlow的FLAGS类似，具有谷歌独特的风格。</span></span><br><span class="line">flags.DEFINE_string(<span class="string">"name"</span>, <span class="literal">None</span>, <span class="string">"Your name."</span>)</span><br><span class="line">flags.DEFINE_integer(<span class="string">"num_times"</span>, <span class="number">1</span>,</span><br><span class="line">                     <span class="string">"Number of times to print greeting."</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定必须输入的参数</span></span><br><span class="line">flags.mark_flag_as_required(<span class="string">"name"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  <span class="keyword">del</span> argv  <span class="comment"># 无用</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, FLAGS.num_times):</span><br><span class="line">    print(<span class="string">'Hello, %s!'</span> % FLAGS.name)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  app.run(main)  <span class="comment"># 和tf.app.run()类似</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pyside2与pyqt5的差异</title>
    <url>/2020/07/01/pyside2%E4%B8%8Epyqt5%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<p>由于pyqt5的GPLv3协议要求，使用其的软件必须开源。而pyside2的LGPL协议允许闭源商用。<br><a id="more"></a></p>
<ol>
<li>导入库的差异<br><code>from PySide.QtCore import *</code></li>
<li>pyside只支持pyqt中的api2<br>api1指的是使用qt中的QString,QVariant等类型<br>api2则是另外一种更加pythonic的接口，使用原生的Python的数据类型。</li>
<li>信号和槽<br>pyside2:<code>QtCore.Signal()</code>和<code>QtCore.Slot()</code><br>pyqt:<code>QtCore.pyqtSignal()</code>和<code>QtCore.pyqtSignal</code></li>
<li>属性<br>pyside2:<code>QtCore.Property</code><br>pyqt:<code>QtCore.pyqtProperty</code></li>
<li>功能性差异<br>pyside中不提供qt4.5之前已经废弃函数的python接口</li>
<li>sender() 成员在 partial 或 lambda 函数内返回 None</li>
<li>当继承一个类时，父类的构造函数总是需要被调用</li>
<li>旧式风格的信号需要使用圆括号<br><code>self.emit(SIGNAL (&#39;text_changed_cb(QString)&#39;), text)</code></li>
</ol>
<p>由于兼容性问题，pyside还存在一些问题<br>安装：<br>测试成功的办法<br>python3.7<br>pyside2 5.14.2</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
  </entry>
  <entry>
    <title>python文件混淆</title>
    <url>/2020/07/25/python%E6%96%87%E4%BB%B6%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[<p>选择了一种比较合适的加密方式对python文件进行加密。<br><a id="more"></a></p>
<h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>网址：<a href="https://pyob.oxyry.com/" target="_blank" rel="noopener">https://pyob.oxyry.com/</a></p>
<p>该方法通过将变量名替换，实现加密效果。</p>
<p>该方法的缺点在于，只能对单个文件进行加密。无法对多个文件进行加密</p>
<h2 id="pyc"><a href="#pyc" class="headerlink" title="pyc"></a>pyc</h2><p>在混淆后对文件进行编译生成pyc文件，这样反解码出来的文件也是乱码。</p>
<h3 id="单个pyc文件生成"><a href="#单个pyc文件生成" class="headerlink" title="单个pyc文件生成"></a>单个pyc文件生成</h3><p><code>python -m foo.py</code></p>
<p><code>import py_compile   py_compile.compile(&#39;/path/to/foo.py&#39;)</code></p>
<h3 id="批量生成"><a href="#批量生成" class="headerlink" title="批量生成"></a>批量生成</h3><p><code>python -m compileall &lt;dir&gt;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> compileall</span><br><span class="line">compileall.compile_dir(<span class="string">r'/path'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>还可以考虑将混淆文件打包成exe文件发布。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>应用</category>
      </categories>
  </entry>
  <entry>
    <title>overload、override和hide的区别</title>
    <url>/2020/07/24/overload%E3%80%81override%E5%92%8Chide%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="重载-overload-、覆盖-override-、隐藏-hide-的区别"><a href="#重载-overload-、覆盖-override-、隐藏-hide-的区别" class="headerlink" title="重载(overload)、覆盖(override)、隐藏(hide)的区别"></a>重载(overload)、覆盖(override)、隐藏(hide)的区别</h1><a id="more"></a>
<p>这三个概念都是与OO中的多态有关系的。如果单是区别重载与覆盖这两个概念是比较容易的，但是隐藏这一概念却使问题变得有点复杂了，下面说说它们的区别吧。</p>
<p> 重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。</p>
<p> 覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样。</p>
<p> 隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。什么叫多态？简单地说就是一个接口，多种实现吧。</p>
<p> 还是引用一下别人的代码来说明问题吧（引用自林锐的《高质量C/C++编程指南》）。</p>
<p>仔细看下面的代码： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> 1 #include &lt;iostream.h&gt;  </span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>  </span></span><br><span class="line"><span class="class"> 4 </span></span><br><span class="line"><span class="class"> 5 </span>&#123;  </span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> public:  </span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span>     virtual <span class="keyword">void</span> f(float x)&#123; cout &lt;&lt; <span class="string">"Base::f(float) "</span> &lt;&lt; x &lt;&lt; endl; &#125;  </span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span>     <span class="keyword">void</span> g(float x)&#123; cout &lt;&lt; <span class="string">"Base::g(float) "</span> &lt;&lt; x &lt;&lt; endl; &#125; </span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span>     <span class="keyword">void</span> h(float x)&#123; cout &lt;&lt; <span class="string">"Base::h(float) "</span> &lt;&lt; x &lt;&lt; endl; &#125;  </span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> &#125;;  </span><br><span class="line"> 1 class Derived : public Base </span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> &#123;  </span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> public:  </span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span>     virtual <span class="keyword">void</span> f(float x)&#123; cout &lt;&lt; <span class="string">"Derived::f(float) "</span> &lt;&lt; x &lt;&lt; endl; &#125;  </span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span>     <span class="keyword">void</span> g(int x)&#123; cout &lt;&lt; <span class="string">"Derived::g(int) "</span> &lt;&lt; x &lt;&lt; endl; &#125; </span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span>     <span class="keyword">void</span> h(float x)&#123; cout &lt;&lt; <span class="string">"Derived::h(float) "</span> &lt;&lt; x &lt;&lt; endl; &#125; </span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>看出什么了吗？下面说明一下：</p>
<p>（1）函数Derived::f(float)覆盖了Base::f(float)。 </p>
<p>（2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。 </p>
<p>（3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。  </p>
<p> 嗯，概念大概明白了，但是在实际的编程中，我们会因此遇到什么问题呢？再看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">void</span> main(<span class="keyword">void</span>)  </span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> &#123;  </span><br><span class="line"> <span class="number">4</span>     Derived  d;  </span><br><span class="line"> <span class="number">5</span>     Base *pb = &amp;d;  </span><br><span class="line"> <span class="number">6</span>     Derived *pd = &amp;d; </span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="comment">// Good : behavior depends solely on type of the object  </span></span><br><span class="line"> <span class="number">9</span>     pb-&gt;f(<span class="number">3.14</span>f); <span class="comment">// Derived::f(float) 3.14  </span></span><br><span class="line"><span class="number">10</span>     pd-&gt;f(<span class="number">3.14</span>f); <span class="comment">// Derived::f(float) 3.14  </span></span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     <span class="comment">// Bad : behavior depends on type of the pointer  </span></span><br><span class="line"><span class="number">13</span>     pb-&gt;g(<span class="number">3.14</span>f); <span class="comment">// Base::g(float) 3.14  </span></span><br><span class="line"><span class="number">14</span>     pd-&gt;g(<span class="number">3.14</span>f); <span class="comment">// Derived::g(int) 3        (surprise!)  </span></span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span>     <span class="comment">// Bad : behavior depends on type of the pointer  </span></span><br><span class="line"><span class="number">17</span>     pb-&gt;h(<span class="number">3.14</span>f); <span class="comment">// Base::h(float) 3.14      (surprise!)  </span></span><br><span class="line"><span class="number">18</span>     pd-&gt;h(<span class="number">3.14</span>f); <span class="comment">// Derived::h(float) 3.14  </span></span><br><span class="line"><span class="number">19</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在第一种调用中，函数的行为取决于指针所指向的对象。在第二第三种调用中，函数的行为取决于指针的类型。所以说，隐藏破坏了面向对象编程中多态这一特性，会使得OOP人员产生混乱。 </p>
<p>不过隐藏也并不是一无是处，它可以帮助编程人员在编译时期找出一些错误的调用。但我觉得还是应该尽量使用隐藏这一些特性，该加virtual时就加吧。</p>
<p><strong>成员函数被重载的特征</strong> （1）相同的范围（在同一个类中）； （2）函数名字相同； （3）参数不同； （4）virtual 关键字可有可无。 <strong>覆盖是指派生类函数覆盖基类函数，特征是</strong> （1）不同的范围（分别位于派生类与基类）； （2）函数名字相同； （3）参数相同； （4）基类函数必须有virtual 关键字。 <strong>“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下</strong> （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） </p>
<p>3种情况怎么执行：</p>
<p>1。重载：看参数</p>
<p>2。隐藏：用什么就调用什么</p>
<p>3。覆盖：调用派生类</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>pytorch教程（七月在线笔记）</title>
    <url>/2020/03/15/pytorch%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%83%E6%9C%88%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AE%B0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Pytorch基础"><a href="#Pytorch基础" class="headerlink" title="Pytorch基础"></a>Pytorch基础</h1><a id="more"></a>
<ol>
<li>原位修改<br>函数后加下划线“<code>_</code>”表示原位修改:<code>y.add_(x)</code>。</li>
<li>numpy和tensor的转化<br>numpy转换为tensor-》<code>torch.from_array(a)</code><br>tensor转换为numpy-》<code>a.numpy()</code></li>
<li>cuda向量<br><code>a.cuda()</code><br><code>a.to(&quot;cuda&quot;)</code><br><code>a.to(torch.device(&quot;cuda&quot;))</code><br><code>torch.ones_like(device=torch.device(&quot;cuda&quot;))</code></li>
<li>简单的双层神经网络案例<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># N is batch size; D_in is input dimension;</span></span><br><span class="line"><span class="comment"># H is hidden dimension; D_out is output dimension.</span></span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line">x = torch.randn(N,D_in)</span><br><span class="line">y = torch.randn(N,D_out)</span><br><span class="line"></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Linear(D_in,H),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(H,D_out))</span><br><span class="line"></span><br><span class="line">loss_fn = nn.MSELoss(reduction=<span class="string">"sum"</span>)</span><br><span class="line">learning_rate = <span class="number">1e-4</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(),lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    <span class="comment"># forward：构建模型</span></span><br><span class="line">    y_pred = model(x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># loss</span></span><br><span class="line">    loss = loss_fn(y_pred,y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 默认情况下grad是叠加，zero_grad用来重置参数列表</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># backward：计算梯度</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    print(i,<span class="string">":"</span>,loss.item())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：验证时要no_grad</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    testY = model(testX)</span><br></pre></td></tr></table></figure>
<ol>
<li>FizzBuzz游戏简单案例<br>游戏规则如下：从1开始往上数数，当遇到3的倍数的时候，说fizz，当遇到5的倍数，说buzz，当遇到15的倍数，就说fizzbuzz，其他情况下则正常数数。</li>
</ol>
<h2 id="Pytorch模型的建立"><a href="#Pytorch模型的建立" class="headerlink" title="Pytorch模型的建立"></a>Pytorch模型的建立</h2><p>模型的建立包括几个步骤：</p>
<ol>
<li>处理数据</li>
<li>搭建模型</li>
<li>forward pass</li>
<li>optimizer</li>
<li>backward pass</li>
</ol>
<h1 id="词向量和语言模型"><a href="#词向量和语言模型" class="headerlink" title="词向量和语言模型"></a>词向量和语言模型</h1><h2 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h2><p><a href="https://github.com/sjtu-xx/pytorch_course/blob/master/notebooks/2.word-embedding.ipynb" target="_blank" rel="noopener">github</a><br>资料地址 链接: <a href="https://pan.baidu.com/s/1QEFLWKRkMh-wh2nE5kD4Xw" target="_blank" rel="noopener">https://pan.baidu.com/s/1QEFLWKRkMh-wh2nE5kD4Xw</a> 提取码: x8iw<br>分布式表示：用一个词附近的其他词来表示该词。<br>Word2Vec：Skip-Gram<br><img src="1.png" alt=""></p>
<h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p><strong>实现Dataloader</strong><br>一个dataloader需要以下内容：</p>
<ul>
<li>把所有text编码成数字，然后用subsampling预处理这些文字。</li>
<li>保存vocabulary，单词count，normalized word frequency</li>
<li>每个iteration sample一个中心词</li>
<li>根据当前的中心词返回context单词</li>
<li>根据中心词sample一些negative单词</li>
<li>返回单词的counts<br>这里有一个好的tutorial介绍如何使用<a href="https://pytorch.org/tutorials/beginner/data_loading_tutorial.html" target="_blank" rel="noopener">PyTorch dataloader</a>. 为了使用dataloader，我们需要定义以下两个function:</li>
</ul>
<p><strong>len</strong> function需要返回整个数据集中有多少个item<br><strong>getitem</strong> 根据给定的index返回一个item<br>有了dataloader之后，我们可以轻松随机打乱整个数据集，拿到一个batch的数据等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordEmbeddingDataset</span><span class="params">(tud.Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,text,word_to_idx,idx_to_word,word_freqs)</span>:</span></span><br><span class="line">        super(WordEmbeddingDataset,self).__init__()</span><br><span class="line">        self.word_to_idx = word_to_idx</span><br><span class="line">        self.idx_to_word = idx_to_word</span><br><span class="line">        self.word_freqs = torch.Tensor(word_freqs)</span><br><span class="line">        self.text_encoded = torch.Tensor([self.word_to_idx.get(w,self.word_to_idx[<span class="string">"&lt;unk&gt;"</span>]) <span class="keyword">for</span> w <span class="keyword">in</span> text])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.text_encoded)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,idx)</span>:</span></span><br><span class="line">        center_word = self.text_encoded[idx]</span><br><span class="line">        pos_indices = list(range(idx-C,idx))+list(range(idx+<span class="number">1</span>,idx+C+<span class="number">1</span>))</span><br><span class="line">        pos_indices = [i%len(self.word_to_idx) <span class="keyword">for</span> i <span class="keyword">in</span> pos_indices]</span><br><span class="line">        pos_words = torch.Tensor([self.text_encoded[i] <span class="keyword">for</span> i <span class="keyword">in</span> pos_indices])</span><br><span class="line">        neg_words = torch.multinomial(self.word_freqs,K*pos_words.shape[<span class="number">0</span>],<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> center_word,pos_words,neg_words</span><br><span class="line"></span><br><span class="line">dataset = WordEmbeddingDataset(text,word_to_idx,idx_to_word,word_freqs)</span><br><span class="line">dataloader = tud.DataLoader(dataset,batch_size=BATCH_SIZE,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmbeddingModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,vocab_size,embed_size)</span>:</span></span><br><span class="line">        super(EmbeddingModel,self).__init__()</span><br><span class="line">        self.vocab_size = vocab_size</span><br><span class="line">        self.embed_size = embed_size</span><br><span class="line">        </span><br><span class="line">        self.in_embed = nn.Embedding(self.vocab_size,self.embed_size)</span><br><span class="line">        self.out_embed = nn.Embedding(self.vocab_size,self.embed_size)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,input_label,pos_labels,neg_labels)</span>:</span></span><br><span class="line">        <span class="comment"># input_label : [batch_size]</span></span><br><span class="line">        <span class="comment"># pos_label : [batch_size,window_size*2]</span></span><br><span class="line">        <span class="comment"># neg_label : [batch_size,window_size*2*K]</span></span><br><span class="line">        input_embed = self.in_embed(input_label) <span class="comment"># [batch_size,embed_size]</span></span><br><span class="line">        pos_embed = self.out_embed(pos_labels) <span class="comment"># [batch_size,window_size*2,embed_size]</span></span><br><span class="line">        neg_embed = self.out_embed(neg_labels) <span class="comment"># [batch_size,window_size*2*K,embed_size]</span></span><br><span class="line">        </span><br><span class="line">        input_embed = input_embed.unsqueeze(<span class="number">2</span>)</span><br><span class="line">        pos_dot = torch.bmm(pos_embed,input_embed).squeeze(<span class="number">2</span>) <span class="comment"># [batch_size,window_size*2]</span></span><br><span class="line">        neg_dot = torch.bmm(neg_embed,-input_embed).squeeze(<span class="number">2</span>) <span class="comment"># [batch_size,window_size*2*K]</span></span><br><span class="line">        </span><br><span class="line">        pos_loss = F.logsigmoid(pos_dot).sum(<span class="number">1</span>) <span class="comment">#.sum(1)</span></span><br><span class="line">        neg_loss = F.logsigmoid(neg_dot).sum(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        loss = pos_loss+neg_loss</span><br><span class="line">        <span class="keyword">return</span> -loss</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">input_embeddings</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.in_embed.weight.data.cpu().numpy()</span><br></pre></td></tr></table></figure>
<h2 id="training"><a href="#training" class="headerlink" title="training"></a>training</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = EmbeddingModel(VOCAB_SIZE,EMBEDDING_SIZE)</span><br><span class="line"><span class="keyword">if</span> USE_CUDA:</span><br><span class="line">    model = model.cuda()</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=LEARNING_RATE)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(NUM_EPOCHS):</span><br><span class="line">    <span class="keyword">for</span> i,(input_label,pos_labels,neg_labels) <span class="keyword">in</span> enumerate(dataloader):</span><br><span class="line">        <span class="keyword">if</span> USE_CUDA:</span><br><span class="line">            input_label = input_label.long().cuda()</span><br><span class="line">            pos_labels = pos_labels.long().cuda()</span><br><span class="line">            neg_labels = neg_labels.long().cuda()</span><br><span class="line">            </span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss = model(input_label,pos_labels,neg_labels).mean()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"epoch: &#123;&#125;, iter: &#123;&#125;, loss: &#123;&#125;"</span>.format(e, i, loss.item()))</span><br></pre></td></tr></table></figure>
<h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(filename, embedding_weights)</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> filename.endswith(<span class="string">".csv"</span>):</span><br><span class="line">        data = pd.read_csv(filename, sep=<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = pd.read_csv(filename, sep=<span class="string">"\t"</span>)</span><br><span class="line">    human_similarity = []</span><br><span class="line">    model_similarity = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data.iloc[:, <span class="number">0</span>:<span class="number">2</span>].index:</span><br><span class="line">        word1, word2 = data.iloc[i, <span class="number">0</span>], data.iloc[i, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> word1 <span class="keyword">not</span> <span class="keyword">in</span> word_to_idx <span class="keyword">or</span> word2 <span class="keyword">not</span> <span class="keyword">in</span> word_to_idx:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            word1_idx, word2_idx = word_to_idx[word1], word_to_idx[word2]</span><br><span class="line">            word1_embed, word2_embed = embedding_weights[[word1_idx]], embedding_weights[[word2_idx]]</span><br><span class="line">            model_similarity.append(float(sklearn.metrics.pairwise.cosine_similarity(word1_embed, word2_embed)))</span><br><span class="line">            human_similarity.append(float(data.iloc[i, <span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scipy.stats.spearmanr(human_similarity, model_similarity)<span class="comment"># , model_similarity</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_nearest</span><span class="params">(word)</span>:</span></span><br><span class="line">    index = word_to_idx[word]</span><br><span class="line">    embedding = embedding_weights[index]</span><br><span class="line">    cos_dis = np.array([scipy.spatial.distance.cosine(e, embedding) <span class="keyword">for</span> e <span class="keyword">in</span> embedding_weights])</span><br><span class="line">    <span class="keyword">return</span> [idx_to_word[i] <span class="keyword">for</span> i <span class="keyword">in</span> cos_dis.argsort()[:<span class="number">10</span>]]</span><br></pre></td></tr></table></figure>
<h1 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h1><h2 id="常见的语言模型"><a href="#常见的语言模型" class="headerlink" title="常见的语言模型"></a>常见的语言模型</h2><h3 id="RNN（Recurrent-neural-network）"><a href="#RNN（Recurrent-neural-network）" class="headerlink" title="RNN（Recurrent neural network）"></a>RNN（Recurrent neural network）</h3><h3 id="Long-short-term-memory-LSTM-："><a href="#Long-short-term-memory-LSTM-：" class="headerlink" title="Long short-term memory(LSTM)："></a>Long short-term memory(LSTM)：</h3><p><img src="4.png" alt=""><br>几个门来控制输入输出：<br>忘记门、输入门、更新门、输出门<br>原始的LSTM：<br><img src="2.png" alt=""><br>优化的LSTM（Pytorch中的LSTM）：<br><img src="3.png" alt=""></p>
<p>训练时训练CrossEntropy</p>
<h3 id="Gated-Recurrent-unit"><a href="#Gated-Recurrent-unit" class="headerlink" title="Gated Recurrent unit"></a>Gated Recurrent unit</h3><p><img src="5.png" alt=""></p>
<h2 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h2><p>这些循环神经网络都可能出现梯度爆炸的问题。因此最好做一个gradient clipping<br><a href="https://github.com/sjtu-xx/pytorch_course/blob/master/notebooks/3.language-model.ipynb" target="_blank" rel="noopener">github</a></p>
<ol>
<li>文本处理<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TEXT = torchtext.data.Field(lower=<span class="literal">True</span>)</span><br><span class="line">train, val, test = torchtext.datasets.LanguageModelingDataset.splits(path=<span class="string">"."</span>, </span><br><span class="line">    train=<span class="string">"word2vec/text8.train.txt"</span>, validation=<span class="string">"word2vec/text8.dev.txt"</span>, test=<span class="string">"word2vec/text8.test.txt"</span>, text_field=TEXT)</span><br><span class="line">TEXT.build_vocab(train, max_size=MAX_VOCAB_SIZE)</span><br><span class="line">print(<span class="string">"vocabulary size: &#123;&#125;"</span>.format(len(TEXT.vocab)))</span><br><span class="line"></span><br><span class="line">VOCAB_SIZE = len(TEXT.vocab)</span><br><span class="line">TEXT.vocab.itos <span class="comment"># index to string. type:list 包含两个特殊字符&lt;unk&gt; &lt;pad&gt;</span></span><br><span class="line">TEXT.vocab.stoi <span class="comment"># string to index. type:dict 包含两个特殊字符&lt;unk&gt; &lt;pad&gt;</span></span><br><span class="line">train_iter, val_iter, test_iter = torchtext.data.BPTTIterator.splits(</span><br><span class="line">    (train, val, test), batch_size=BATCH_SIZE, device=<span class="number">-1</span>, bptt_len=<span class="number">32</span>, repeat=<span class="literal">False</span>, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
<li>模型保存<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val_loss = evaluate(model, val_iter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(val_losses) == <span class="number">0</span> <span class="keyword">or</span> val_loss &lt; min(val_losses):</span><br><span class="line">    print(<span class="string">"best model, val loss: "</span>, val_loss)</span><br><span class="line">    torch.save(model.state_dict(), <span class="string">"lm-best.th"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    scheduler.step()</span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span><br><span class="line">val_losses.append(val_loss) <span class="comment"># scheduler = torch.optim.lr_scheduler.ExponentialLR(optimizer, 0.5)</span></span><br></pre></td></tr></table></figure></li>
<li>模型加载<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best_model = RNNModel(<span class="string">"LSTM"</span>, VOCAB_SIZE, EMBEDDING_SIZE, EMBEDDING_SIZE, <span class="number">2</span>, dropout=<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">if</span> USE_CUDA:</span><br><span class="line">    best_model = best_model.cuda()</span><br><span class="line">best_model.load_state_dict(torch.load(<span class="string">"lm-best.th"</span>))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="文本分类模型"><a href="#文本分类模型" class="headerlink" title="文本分类模型"></a>文本分类模型</h2><p><img src="6.png" alt=""><br><img src="7.png" alt=""><br><img src="8.png" alt=""><br><img src="9.png" alt=""></p>
<p>logits : 任何数字<br>sigmoid处理后： probability</p>
<p>BCEWithLogitsLoss()  binary cross entropy: 二分类问题<br>文本分类模型中，dropout很重要，特别是数据量比较少的时候。（可以dropout，或把部分单词的word调成<code>&lt;unk&gt;</code>）<br>WordAVG 很强。</p>
<h1 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h1><p>local feature detect</p>
<blockquote>
<p>Batchnormalization<br><img src="16.png" alt=""></p>
<h2 id="常见的卷积网络"><a href="#常见的卷积网络" class="headerlink" title="常见的卷积网络"></a>常见的卷积网络</h2><p><img src="11.png" alt=""><br><img src="12.png" alt=""><br><img src="13.png" alt=""><br><img src="14.png" alt=""><br><img src="15.png" alt=""></p>
</blockquote>
<h2 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h2><p>我们常用以下两种方法做迁移学习。</p>
<ul>
<li>fine tuning: 从一个预训练模型开始，我们改变一些模型的架构，然后继续训练整个模型的参数。</li>
<li>feature extraction: 我们不再改变预训练模型的参数，而是只更新我们改变过的部分模型参数。我们之所以叫它feature extraction是因为我们把预训练的CNN模型当做一个特征提取模型，利用提取出来的特征做来完成我们的训练任务。<br>通过requires_grad = False 来冻结层<br><strong>以下是构建和训练迁移学习模型的基本步骤</strong>：</li>
<li>初始化预训练模型</li>
<li>把最后一层的输出层改变成我们想要分的类别总数</li>
<li>定义一个optimizer来更新参数</li>
<li>模型训练</li>
</ul>
<h1 id="图片风格迁移和GAN"><a href="#图片风格迁移和GAN" class="headerlink" title="图片风格迁移和GAN"></a>图片风格迁移和GAN</h1><h2 id="风格迁移"><a href="#风格迁移" class="headerlink" title="风格迁移"></a>风格迁移</h2><p><strong>content loss</strong><br><img src="17.png" alt=""><br><strong>style</strong><br>Gram Matrix可以被拿来表示两张图片的texture相似度<br><img src="18.png" alt=""><br><strong>style loss</strong><br><img src="19.png" alt=""></p>
<h2 id="GAN-Generative-Adversarial-Networks"><a href="#GAN-Generative-Adversarial-Networks" class="headerlink" title="GAN(Generative Adversarial Networks)"></a>GAN(Generative Adversarial Networks)</h2><p>Generator: 生成器，目标是让生成的数据接近真实数据<br>Discriminator: 判别器，目标是能够鉴别真实数据和生成的假数据</p>
<p>论文：style transfer from non-parallel text by cross-alignment</p>
<h2 id="DCGAN"><a href="#DCGAN" class="headerlink" title="DCGAN"></a>DCGAN</h2><p>使用deconv层作为图片生成器<br>Deconvolutional Layer <a href="https://datascience.stackexchange.com/questions/6107/what-are-deconvolutional-layers" target="_blank" rel="noopener">https://datascience.stackexchange.com/questions/6107/what-are-deconvolutional-layers</a><br>介绍deconv<br><a href="https://arxiv.org/pdf/1603.07285.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1603.07285.pdf</a></p>
<h1 id="Seq2Seq和Attention"><a href="#Seq2Seq和Attention" class="headerlink" title="Seq2Seq和Attention"></a>Seq2Seq和Attention</h1><p><img src="20.png" alt=""><br><img src="21.png" alt=""><br><img src="22.png" alt=""></p>
<h1 id="大规模预训练语言模型"><a href="#大规模预训练语言模型" class="headerlink" title="大规模预训练语言模型"></a>大规模预训练语言模型</h1><p><a href="https://zhuanlan.zhihu.com/p/46652512" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46652512</a><br>BERT、ELMO、OpenAI GPT</p>
<h2 id="ELMO"><a href="#ELMO" class="headerlink" title="ELMO"></a>ELMO</h2><p>一个预训练两层双向LSTM语言模型：-》得到的是词向量-&gt;用来替代embedding层，通常能提高很多<br><a href="https://www.aclweb.org/anthology/N18-1202" target="_blank" rel="noopener">https://www.aclweb.org/anthology/N18-1202</a><br><a href="https://github.com/allenai/allennlp" target="_blank" rel="noopener">https://github.com/allenai/allennlp</a><br><img src="23.png" alt=""><br><img src="24.png" alt=""><br><strong>AllenNLP</strong><br>一个很好的构建NLP模型的package，基于PyTorch<br>AllenAI在2018 EMNLP上的一个tutorial<br><a href="https://github.com/allenai/writing-code-for-nlp-research-emnlp2018/blob/master/writing_code_for_nlp_research.pdf" target="_blank" rel="noopener">https://github.com/allenai/writing-code-for-nlp-research-emnlp2018/blob/master/writing_code_for_nlp_research.pdf</a></p>
<p>elmo的训练代码：<a href="https://github.com/allenai/bilm-tf" target="_blank" rel="noopener">bilm-tf</a><br>elmo使用tensorflow训练再导出到pytorch中</p>
<h2 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h2><p>不是一个语言模型，目标是预测masked word</p>
<h2 id="OpenAI-GPT-2"><a href="#OpenAI-GPT-2" class="headerlink" title="OpenAI GPT-2"></a>OpenAI GPT-2</h2><p>一种<a href="https://zhuanlan.zhihu.com/p/39034683" target="_blank" rel="noopener">Transformer模型</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>shell脚本编程</title>
    <url>/2020/09/12/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="认识bash"><a href="#认识bash" class="headerlink" title="认识bash"></a>认识bash</h1><a id="more"></a>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>变量设置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME&#x3D;shell</span><br></pre></td></tr></table></figure></p>
<p>变量取用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $HOME</span><br><span class="line">echo $&#123;HOME&#125;</span><br><span class="line"></span><br><span class="line">双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示: </span><br><span class="line">“var&#x3D;&quot;lang is $LANG&quot;”则“echo $var”可得“lang is zh_TW.UTF-8” </span><br><span class="line">单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示: </span><br><span class="line">“var&#x3D;&#39;lang is $LANG&#39;”则“echo $var”可得“lang is $LANG”</span><br></pre></td></tr></table></figure></p>
<p>扩增变量内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATH&#x3D;&quot;$PATH&quot;:&#x2F;home&#x2F;bin</span><br><span class="line">PATH&#x3D;$&#123;PATH&#125;:&#x2F;home&#x2F;bin</span><br></pre></td></tr></table></figure></p>
<p>取消变量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unset NAME</span><br></pre></td></tr></table></figure></p>
<h2 id="env和set"><a href="#env和set" class="headerlink" title="env和set"></a>env和set</h2><p><code>env</code>为环境变量</p>
<p><code>set</code>为自定义变量</p>
<p><code>export</code>自定义变量转为环境变量</p>
<h2 id="read、array、declare"><a href="#read、array、declare" class="headerlink" title="read、array、declare"></a>read、array、declare</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输入</span></span><br><span class="line">read -p "Please keyin your name: " -t 30 named</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 声明变量类型</span></span><br><span class="line">declare [-aixr] variable</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> array</span></span><br><span class="line">var[1]="min"</span><br></pre></td></tr></table></figure>
<h2 id="ulimit文件系统限制"><a href="#ulimit文件系统限制" class="headerlink" title="ulimit文件系统限制"></a>ulimit文件系统限制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit文件系统限制</span><br></pre></td></tr></table></figure>
<h2 id="删除字串"><a href="#删除字串" class="headerlink" title="删除字串"></a>删除字串</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从头删</span><br><span class="line">echo $&#123;path#&#x2F;*:&#125;  # 删掉&#x2F;到：的最长部分</span><br><span class="line">echo $&#123;path##&#x2F;*:&#125;  # 删掉&#x2F;到：的最短部分</span><br><span class="line"></span><br><span class="line"># 从末尾删</span><br><span class="line">echo $&#123;path%:bin&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量设置方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${变量#关键字}</td>
<td>若变量内容从头开始的数据符合“关键字”，则将符合的最短数据删除</td>
</tr>
<tr>
<td>${变量##关键字}</td>
<td>若变量内容从头开始的数据符合“关键字”，则将符合的最长数据删除</td>
</tr>
<tr>
<td>${变量%关键字}</td>
<td>若变量内容从尾向前的数据符合“关键字”，则将符合的最短数据删除</td>
</tr>
<tr>
<td>${变量%%关键字}</td>
<td>若变量内容从尾向前的数据符合“关键字”，则将符合的最 长数据删除</td>
</tr>
<tr>
<td>${变量/旧字串/新字串}</td>
<td>若变量内容符合“旧字串”则“第一个旧字串会被新字串取代”</td>
</tr>
<tr>
<td>${变量//旧字串/新字串}</td>
<td>若变量内容符合“旧字串”则“全部的旧字串会被新字串取代”</td>
</tr>
</tbody>
</table>
</div>
<p><img src="1.png" alt=""></p>
<h2 id="命令别名与历史命令"><a href="#命令别名与历史命令" class="headerlink" title="命令别名与历史命令"></a>命令别名与历史命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias lm='ls -al|more'</span><br><span class="line"></span><br><span class="line">history</span><br></pre></td></tr></table></figure>
<h1 id="Bash环境"><a href="#Bash环境" class="headerlink" title="Bash环境"></a>Bash环境</h1><p>bash初始化会读取两个文件<code>/etc/profile</code>和<code>~/.bash_profile</code>或类似名称的文件</p>
<h2 id="etc-profile-d-sh"><a href="#etc-profile-d-sh" class="headerlink" title="/etc/profile.d/*.sh"></a><code>/etc/profile.d/*.sh</code></h2><p>只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使 用者能够具有 r 的权限， 那么该文件就会被 /etc/profile 调用进来。在 CentOS 7.x 中，这个 目录下面的文件规范了 bash 操作接口的颜色、 语系、ll 与 ls 指令的命令别名、vi 的命令别 名、which 的命令别名等等。如果你需要帮所有使用者设置一些共享的命令别名时， 可以在 这个目录下面自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可喔!</p>
<p><img src="2.png" alt=""><br><img src="3.png" alt=""></p>
<h2 id=""><a href="#" class="headerlink" title="$$$$"></a>$$$$</h2><p>1.若 cmd1 执行完毕且正确执行($?=0)，则开始执行 cmd2。 2. 若 cmd1 执行完毕且为错误 ($?≠0)，则 cmd2 不执行。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="||"></a><code>||</code></h2><p>1.若 cmd1 执行完毕且正确执行($?=0)，则 cmd2 不执行。 2. 若 cmd1 执 cmd2 行完毕且为错误 ($?≠0)，则开始执行 cmd2。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道|"></a>管道<code>|</code></h2><h2 id="cut和grep"><a href="#cut和grep" class="headerlink" title="cut和grep"></a>cut和grep</h2><p>cut分析每行，截取对应部分</p>
<p>grep截取满足要求的行。</p>
<h2 id="sort-wc-uniq"><a href="#sort-wc-uniq" class="headerlink" title="sort,wc,uniq"></a>sort,wc,uniq</h2><h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><p>双重重定向：同时屏幕和文件</p>
<h2 id="字符转换命令-tr-col-join-paste-expand"><a href="#字符转换命令-tr-col-join-paste-expand" class="headerlink" title="字符转换命令 tr, col, join, paste, expand"></a>字符转换命令 tr, col, join, paste, expand</h2><h2 id="参数代换-xargs"><a href="#参数代换-xargs" class="headerlink" title="参数代换: xargs"></a>参数代换: xargs</h2><h2 id="分区命令-split"><a href="#分区命令-split" class="headerlink" title="分区命令: split"></a>分区命令: split</h2><h1 id="shell-script"><a href="#shell-script" class="headerlink" title="shell script"></a>shell script</h1><h2 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h2><p>通过<code>./test.sh</code>和<code>sh test.sh</code>的方式是在子程序中执行的。</p>
<p>通过<code>source test.sh</code>的方式是在父程序中执行的。</p>
<h2 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号"></a>判断符号</h2><p><code>[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</code></p>
<h2 id="参数变量-0-1-2"><a href="#参数变量-0-1-2" class="headerlink" title="参数变量($0,$1,$2)"></a>参数变量(<code>$0,$1,$2</code>)</h2><h2 id="条件判断式"><a href="#条件判断式" class="headerlink" title="条件判断式"></a>条件判断式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]; then 当条件判断式成立时，可以进行的指令工作内容;</span><br><span class="line">fi &amp;lt;==将 if 反过来写，就成为 fi 啦!结束 if 之意!</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式一 ]; then</span><br><span class="line">  当条件判断式一成立时，可以进行的指令工作内容;</span><br><span class="line">elif [ 条件判断式二 ]; then</span><br><span class="line"> 当条件判断式二成立时，可以进行的指令工作内容;</span><br><span class="line">else</span><br><span class="line"> 当条件判断式一与二均不成立时，可以进行的指令工作内容;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case  $变量名称 in   &amp;lt;==关键字为 case ，还有变量前有钱字号</span><br><span class="line">  "第一个变量内容"）   &amp;lt;==每个变量内容建议用双引号括起来，关键字则为小括号 ）</span><br><span class="line">    程序段</span><br><span class="line">    ;;            &amp;lt;==每个类别结尾使用两个连续的分号来处理！</span><br><span class="line">  "第二个变量内容"）</span><br><span class="line">    程序段</span><br><span class="line">    ;;</span><br><span class="line">  *）                  &amp;lt;==最后一个变量内容都会用 * 来代表所有其他值</span><br><span class="line">    不包含第一个变量内容与第二个变量内容的其他程序执行段</span><br><span class="line">    exit 1</span><br><span class="line">    ;;</span><br><span class="line">esac                  &amp;lt;==最终的 case 结尾！“反过来写”思考一下！</span><br></pre></td></tr></table></figure>
<p>function<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function printit（）&#123;</span><br><span class="line">    echo "Your choice is $&#123;1&#125;"   # 这个 $1 必须要参考下面指令的下达</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "This program will print your selection !"</span><br><span class="line">case $&#123;1&#125; in</span><br><span class="line">  "one"）</span><br><span class="line">    **printit 1**  # 请注意， printit 指令后面还有接参数！</span><br><span class="line">    ;;</span><br><span class="line">  "two"）</span><br><span class="line">    **printit 2**</span><br><span class="line">    ;;</span><br><span class="line">  "three"）</span><br><span class="line">    **printit 3**</span><br><span class="line">    ;;</span><br><span class="line">  *）</span><br><span class="line">    echo "Usage $&#123;0&#125; &#123;one&amp;#124;two&amp;#124;three&#125;"</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ condition ]  &amp;lt;==中括号内的状态就是判断式</span><br><span class="line">do            &amp;lt;==do 是循环的开始！</span><br><span class="line">    程序段落</span><br><span class="line">done          &amp;lt;==done 是循环的结束</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until [ condition ]</span><br><span class="line">do</span><br><span class="line">    程序段落</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in con1 con2 con3 ...</span><br><span class="line">do</span><br><span class="line">    程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for （（ 初始值; 限制值; 执行步阶 ））</span><br><span class="line">do</span><br><span class="line">    程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>vim操作记录</title>
    <url>/2019/12/09/vim%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>通过命令行输入<code>vimtutor</code>打开教程</p>
<a id="more"></a>
<h2 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Many commands that change text are made from an operator and a motion.</span><br><span class="line">The format for a delete command with the  d  delete operator is as follows:</span><br><span class="line"></span><br><span class="line">      d   motion</span><br><span class="line"></span><br><span class="line">Where:</span><br><span class="line">  d      - is the delete operator.</span><br><span class="line">  motion - is what the operator will operate on (listed below).</span><br><span class="line"></span><br><span class="line">A short list of motions:</span><br><span class="line">  w - until the start of the next word, EXCLUDING its first character.</span><br><span class="line">  e - to the end of the current word, INCLUDING the last character.</span><br><span class="line">  $ - to the end of the line, INCLUDING the last character.</span><br><span class="line"></span><br><span class="line">Thus typing  de  will delete from the cursor to the end of the word.</span><br><span class="line"></span><br><span class="line">                   Lesson 2.4: USING A COUNT FOR A MOTION</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ** Typing a number before a motion repeats it that many times. **</span><br><span class="line"></span><br><span class="line">1. Move the cursor to the start of the line marked ---&gt; below.</span><br><span class="line"></span><br><span class="line">2. Type  2w  to move the cursor two words forward.</span><br><span class="line"></span><br><span class="line">3. Type  3e  to move the cursor to the end of the third word forward.</span><br><span class="line"></span><br><span class="line">4. Type  0  (zero) to move to the start of the line.</span><br></pre></td></tr></table></figure>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><pre><code>         ^
         k              Hint:  The h key is at the left and moves left.
   &lt; h       l &gt;               The l key is at the right and moves right.
         j                     The j key looks like a down arrow.
         v
</code></pre><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ESC&gt;</span><br><span class="line">:q   # 退出</span><br><span class="line">:wq  # 退出并保存</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x # 删除单个字符</span><br><span class="line">dw # 删除从当前字母开始到结束的单词</span><br><span class="line">d$ # 删除从当前字母到行末的内容</span><br><span class="line">ndd  # 删除n行</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a # 在后面添加</span><br><span class="line">i # 在前面插入</span><br><span class="line">p # 粘贴</span><br></pre></td></tr></table></figure>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u # 撤销一步</span><br><span class="line">U # 返回当前行的初始状态</span><br><span class="line">ctrl+R #撤销undo</span><br></pre></td></tr></table></figure>
<h2 id="光标位置"><a href="#光标位置" class="headerlink" title="光标位置"></a>光标位置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nG # 移动到某一行</span><br><span class="line">G # 移动到末尾</span><br><span class="line">gg # 移动到开头</span><br><span class="line">Ctrl-G 显示当前位置</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;word 查找word</span><br><span class="line">查找后按n可以继续查找下一个，N向相反的方向查找</span><br><span class="line">在相反方向查找使用？代替&#x2F;</span><br><span class="line">CTRL-o  返回到上一个位置</span><br><span class="line">CTRL-i  进入到下一个位置</span><br><span class="line"></span><br><span class="line">光标指向（，[,&#123;按下%可以跳转到),],&#125;位置</span><br><span class="line"></span><br><span class="line">替换</span><br><span class="line">:s&#x2F;old&#x2F;new &lt;ENTER&gt; # 替换第一个old出现的位置</span><br><span class="line">:s&#x2F;old&#x2F;new&#x2F;g  # 替换当前行global出现的位置</span><br><span class="line">:#,#s&#x2F;old&#x2F;new&#x2F;g  # 替换#行和#行之间的old</span><br><span class="line">:%s&#x2F;old&#x2F;new&#x2F;g  #替换当前文件所有出现的old</span><br><span class="line">:%s&#x2F;old&#x2F;new&#x2F;gc #查找所有出现的位置，不确定是否替换c confirmation</span><br></pre></td></tr></table></figure>
<h2 id="执行外部命令"><a href="#执行外部命令" class="headerlink" title="执行外部命令"></a>执行外部命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:! COMMAND 可以执行命令</span><br></pre></td></tr></table></figure>
<h2 id="选择行"><a href="#选择行" class="headerlink" title="选择行"></a>选择行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按住v 进行选择</span><br><span class="line">选择行后，按下:, 然后 w &lt;FILENAME&gt; 保存选中的部分</span><br></pre></td></tr></table></figure>
<h2 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a>插入文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:r FILENAME 将文件内容插入到下方</span><br><span class="line">:r !ls 将ls执行结果插入到文件下方</span><br></pre></td></tr></table></figure>
<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">o 在当前行下方新建行，进入插入模式</span><br><span class="line">O 在当前行下方新建行，进入插入模式</span><br><span class="line">a 在后方插入</span><br></pre></td></tr></table></figure>
<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y 复制yank</span><br><span class="line">p 粘贴paste</span><br></pre></td></tr></table></figure>
<h2 id="查找设置"><a href="#查找设置" class="headerlink" title="查找设置"></a>查找设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set ic  # ignore case</span><br><span class="line">:set noic # 关闭</span><br><span class="line">:set hlsearch # 高亮</span><br></pre></td></tr></table></figure>
<h2 id="多行缩紧"><a href="#多行缩紧" class="headerlink" title="多行缩紧"></a>多行缩紧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法1: v 进入视图模式后，选择多行，然后按&gt;</span><br><span class="line">方法2: 输入:21,324&gt;  将21到324行进行缩进</span><br></pre></td></tr></table></figure>
<h2 id="复制文件中的某些行"><a href="#复制文件中的某些行" class="headerlink" title="复制文件中的某些行"></a>复制文件中的某些行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:5,10 w&gt;&gt; filename   将本文件中的某些行复制到filename中</span><br><span class="line">:5,10 w! filename  将文件中的某些行复制到filename中，覆盖原来的内容</span><br><span class="line"></span><br><span class="line">&quot;+100yy   复制100行到系统的剪切板（+寄存器）</span><br></pre></td></tr></table></figure>
<h2 id="替换-M"><a href="#替换-M" class="headerlink" title="替换^M"></a>替换<code>^M</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim下 :%s&#x2F;^M&#x2F;&#x2F;g 或者 :1,$s&#x2F;^M&#x2F;&#x2F;g 均可</span><br><span class="line">补充一点：</span><br><span class="line">^M是使用 &quot;CTRL-V CTRL-M&quot; 而不是字面上的 ^M</span><br></pre></td></tr></table></figure>
<h2 id="修改括号中的内容"><a href="#修改括号中的内容" class="headerlink" title="修改括号中的内容"></a>修改括号中的内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ci&quot; 修改引号中的内容</span><br><span class="line">di&quot; 删除引号中的内容</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CODE工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vtk流水线</title>
    <url>/2020/02/13/vtk%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="vtk中的流水线"><a href="#vtk中的流水线" class="headerlink" title="vtk中的流水线"></a>vtk中的流水线</h1><a id="more"></a>
<p>在VTK中将原始数据转换为我们看到的屏幕上的一幅图像，要经过许多步骤的处理，这些步骤由众多的VTK的对象共同协调完成，就好象生产线上加工零件一样，每位工人都负责一部分的工作，整条生产线就能将原材料制作成产品。因此在VTK中，这种对象之间协调完成工作的过程被称作流水线(Pipeline)。</p>
<p>原始数据被转换为图像要经过两条流水线：</p>
<ul>
<li>可视化流水线(Visualization Pipeline)：它的工作是将原始数据加工成图形数据。通常我们需要可视化的数据本身并不是图形数据，例如某个零件内部各个部分的温度，或者是流体在各个坐标点上的速度等等。</li>
<li>图形流水线(Graphics Pipeline)：它的工作是将将图形数据加工为我们所看到的图像。可视化流水线所产生的图形数据通常是三维空间的数据，如何在二维的屏幕上显示出来就需要图形流水线的加工了。</li>
</ul>
<p>映射器(Mapper)则是可视化流水线的终点，图形流水线的起点，它将各种派生类能将众多的数据映射为图形数据以供图形流水线加工。</p>
<p>让我们对照一下前面的的圆锥的例子：ConeSource的对象通过程序内部计算输出一组描述圆锥的数据(PolyData)：然后，PolyData通过PolyDataMapper映射器将数据映射为图形数据。在这个例子中，可视化流水线由ConSource和PolyDataMapper组成。</p>
<p>图形数据依次通过Actor、Renderer最终在RenderWindow中显示出来，这一部分就是图形流水线。</p>
<ul>
<li><strong>Actor</strong> : 表示润色场景中的一个实体。它包括一个图形数据(mapper)，并且具有描述实体的位置、方向、大小的属性。</li>
<li><strong>Renderer</strong> : 表示润色的场景。它包括多个需要润色的Actor。在圆锥的例子中，它只包括一个表示圆锥的Actor。</li>
<li><strong>RenderWindow</strong> : 表示润色用的图形窗口，它包括一个或者多个Render。在圆锥的例子中，它只包括一个Renderer。</li>
<li><strong>RenderWindowInteractor</strong> : 给图形窗口提供一些用户交互功能，例如平移、旋转、放大缩小。这些交互式操作并不改变Actor或者图形数据的属性，只是调整场景中的照相机(Camera)的一些设置而已。</li>
</ul>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>vtk</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow和pytorch环境部署（windows下）</title>
    <url>/2020/03/14/tensorflow%E5%92%8Cpytorch%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%88windows%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>由于现在tensorflow和pytorch更新都依赖cuda，更新比较麻烦，最近正好闲着，想着把电脑里面的环境更新一下。<br><a id="more"></a></p>
<h1 id="cuda和cudnn的安装"><a href="#cuda和cudnn的安装" class="headerlink" title="cuda和cudnn的安装"></a>cuda和cudnn的安装</h1><h2 id="cuda的安装"><a href="#cuda的安装" class="headerlink" title="cuda的安装"></a>cuda的安装</h2><p>直接从官网下载cuda。cuda直接运行安装。</p>
<h2 id="cudnn的安装"><a href="#cudnn的安装" class="headerlink" title="cudnn的安装"></a>cudnn的安装</h2><p>cudnn下载完成后，解压到cuda的安装目录即可。</p>
<h1 id="tensorflow的安装"><a href="#tensorflow的安装" class="headerlink" title="tensorflow的安装"></a>tensorflow的安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>conda install tensorflow-gpu==2.1.0</code></p>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span>  <span class="comment"># 不显示等级2以下的提示信息</span></span><br><span class="line">print(<span class="string">'GPU'</span>, tf.test.is_gpu_available())</span><br><span class="line"></span><br><span class="line">a = tf.constant(<span class="number">2.0</span>)</span><br><span class="line">b = tf.constant(<span class="number">4.0</span>)</span><br><span class="line">print(a + b)</span><br></pre></td></tr></table></figure>
<h1 id="pytorch的安装"><a href="#pytorch的安装" class="headerlink" title="pytorch的安装"></a>pytorch的安装</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><code>conda install pytorch torchvision cudatoolkit=10.1 -c pytorch</code></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">print(torch.cuda.is_available())</span><br></pre></td></tr></table></figure>
<h1 id="其他软件包的安装"><a href="#其他软件包的安装" class="headerlink" title="其他软件包的安装"></a>其他软件包的安装</h1><p><code>conda install jupyter notebook scikit-learn opencv pillow lxml</code></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>vtk相关</title>
    <url>/2020/05/08/vtk%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="Observer的使用"><a href="#Observer的使用" class="headerlink" title="Observer的使用"></a>Observer的使用</h1><a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkPolyDataMapper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkObjectFactory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkCommand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkActor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkSmartPointer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRenderWindow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRenderer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRenderWindowInteractor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkInteractorStyle.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkPolyData.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkSphereSource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkInteractorStyleTrackballCamera.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A class not derived from vtkObjectBase</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KeypressCallbackFunction</span><span class="params">(vtkObject*,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> vtkNotUsed(eventId),</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">void</span>* vtkNotUsed(callData))</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught event in MyClass"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A class that is derived from vtkObjectBase</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteractorStyle</span> :</span> <span class="keyword">public</span> vtkInteractorStyleTrackballCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> MyInteractorStyle* <span class="title">New</span><span class="params">()</span></span>;</span><br><span class="line">  vtkTypeMacro(MyInteractorStyle, vtkInteractorStyleTrackballCamera);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">KeypressCallbackFunction</span><span class="params">(vtkObject*,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> vtkNotUsed(eventId),</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span>* vtkNotUsed(callData) )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught event in MyInteractorStyle"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">vtkStandardNewMacro(MyInteractorStyle);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Create a sphere</span></span><br><span class="line">  vtkSmartPointer&lt;vtkSphereSource&gt; sphereSource =</span><br><span class="line">    vtkSmartPointer&lt;vtkSphereSource&gt;::New();</span><br><span class="line">  sphereSource-&gt;SetCenter(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">  sphereSource-&gt;SetRadius(<span class="number">5.0</span>);</span><br><span class="line">  sphereSource-&gt;Update();</span><br><span class="line"></span><br><span class="line">  vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper =</span><br><span class="line">    vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();</span><br><span class="line">  mapper-&gt;SetInputConnection(sphereSource-&gt;GetOutputPort());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an actor</span></span><br><span class="line">  vtkSmartPointer&lt;vtkActor&gt; actor =</span><br><span class="line">    vtkSmartPointer&lt;vtkActor&gt;::New();</span><br><span class="line">  actor-&gt;SetMapper(mapper);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A renderer and render window</span></span><br><span class="line">  vtkSmartPointer&lt;vtkRenderer&gt; renderer =</span><br><span class="line">    vtkSmartPointer&lt;vtkRenderer&gt;::New();</span><br><span class="line">  vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow =</span><br><span class="line">    vtkSmartPointer&lt;vtkRenderWindow&gt;::New();</span><br><span class="line">  renderWindow-&gt;AddRenderer(renderer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An interactor</span></span><br><span class="line">  vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor =</span><br><span class="line">    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();</span><br><span class="line">  renderWindowInteractor-&gt;SetRenderWindow(renderWindow);</span><br><span class="line"></span><br><span class="line">  MyClass myClass;</span><br><span class="line">  renderWindowInteractor-&gt;AddObserver(vtkCommand::KeyPressEvent, &amp;myClass, &amp;MyClass::KeypressCallbackFunction);</span><br><span class="line"></span><br><span class="line">  MyInteractorStyle* style = MyInteractorStyle::New();</span><br><span class="line">  renderWindowInteractor-&gt;AddObserver(vtkCommand::KeyPressEvent, style, &amp;MyInteractorStyle::KeypressCallbackFunction);</span><br><span class="line"></span><br><span class="line">  vtkSmartPointer&lt;MyInteractorStyle&gt; style2 =</span><br><span class="line">    vtkSmartPointer&lt;MyInteractorStyle&gt;::New();</span><br><span class="line">  renderWindowInteractor-&gt;AddObserver(vtkCommand::KeyPressEvent, style2, &amp;MyInteractorStyle::KeypressCallbackFunction);</span><br><span class="line">  </span><br><span class="line">  renderer-&gt;AddActor(actor);</span><br><span class="line">  renderer-&gt;SetBackground(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// Background color white</span></span><br><span class="line">  renderWindow-&gt;Render();</span><br><span class="line">  renderWindowInteractor-&gt;Start();</span><br><span class="line"></span><br><span class="line">  style-&gt;Delete();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br></pre></td></tr></table></figure>
<h1 id="cell的拾取"><a href="#cell的拾取" class="headerlink" title="cell的拾取"></a>cell的拾取</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkAutoInit.h&gt;</span></span></span><br><span class="line">VTK_MODULE_INIT(vtkRenderingOpenGL)</span><br><span class="line">VTK_MODULE_INIT(vtkInteractionStyle)</span><br><span class="line">VTK_MODULE_INIT(vtkRenderingFreeType)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkSmartPointer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkSphereSource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkPolyDataMapper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkActor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkProperty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRenderer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRenderWindow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRenderWindowInteractor.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkInteractorStyleTrackballCamera.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkDataSetMapper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkCellPicker.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkSelectionNode.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkSelection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkRendererCollection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkExtractSelection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vtkObjectFactory.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**************************************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CellPickerInteractorStyle</span> :</span><span class="keyword">public</span> vtkInteractorStyleTrackballCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> CellPickerInteractorStyle* <span class="title">New</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	CellPickerInteractorStyle()</span><br><span class="line">	&#123;</span><br><span class="line">		selectedMapper = vtkSmartPointer&lt;vtkDataSetMapper&gt;::New();</span><br><span class="line">		selectedActor = vtkSmartPointer&lt;vtkActor&gt;::New();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnLeftButtonDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span>* pos = <span class="keyword">this</span>-&gt;GetInteractor()-&gt;GetEventPosition();</span><br><span class="line">		vtkSmartPointer&lt;vtkCellPicker&gt; picker =</span><br><span class="line">			vtkSmartPointer&lt;vtkCellPicker&gt;::New();</span><br><span class="line">		picker-&gt;SetTolerance(<span class="number">0.0005</span>);</span><br><span class="line">		picker-&gt;Pick(pos[<span class="number">0</span>], pos[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">this</span>-&gt;GetDefaultRenderer());</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (picker-&gt;GetCellId() != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			vtkSmartPointer&lt;vtkIdTypeArray&gt; ids =</span><br><span class="line">				vtkSmartPointer&lt;vtkIdTypeArray&gt;::New();</span><br><span class="line">			ids-&gt;SetNumberOfComponents(<span class="number">1</span>);</span><br><span class="line">			ids-&gt;InsertNextValue(picker-&gt;GetCellId());</span><br><span class="line"> </span><br><span class="line">			vtkSmartPointer&lt;vtkSelectionNode&gt; selectionNode =</span><br><span class="line">				vtkSmartPointer&lt;vtkSelectionNode&gt;::New();</span><br><span class="line">			selectionNode-&gt;SetFieldType(vtkSelectionNode::CELL);</span><br><span class="line">			selectionNode-&gt;SetContentType(vtkSelectionNode::INDICES);</span><br><span class="line">			selectionNode-&gt;SetSelectionList(ids);</span><br><span class="line"> </span><br><span class="line">			vtkSmartPointer&lt;vtkSelection&gt; selection =</span><br><span class="line">				vtkSmartPointer&lt;vtkSelection&gt;::New();</span><br><span class="line">			selection-&gt;AddNode(selectionNode);</span><br><span class="line"> </span><br><span class="line">			vtkSmartPointer&lt;vtkExtractSelection&gt; extractSelection =</span><br><span class="line">				vtkSmartPointer&lt;vtkExtractSelection&gt;::New();</span><br><span class="line">			extractSelection-&gt;SetInputData(<span class="number">0</span>, polyData);</span><br><span class="line">			extractSelection-&gt;SetInputData(<span class="number">1</span>, selection);</span><br><span class="line">			extractSelection-&gt;Update();</span><br><span class="line"> </span><br><span class="line">			selectedMapper-&gt;SetInputData((vtkDataSet*)extractSelection-&gt;GetOutput());</span><br><span class="line">			selectedActor-&gt;SetMapper(selectedMapper);</span><br><span class="line">			selectedActor-&gt;GetProperty()-&gt;EdgeVisibilityOn();</span><br><span class="line">			selectedActor-&gt;GetProperty()-&gt;SetEdgeColor(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			selectedActor-&gt;GetProperty()-&gt;SetLineWidth(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">this</span>-&gt;Interactor-&gt;GetRenderWindow()-&gt;GetRenderers()-&gt;GetFirstRenderer()-&gt;AddActor(selectedActor);</span><br><span class="line">		&#125;</span><br><span class="line">		vtkInteractorStyleTrackballCamera::OnLeftButtonDown();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vtkSmartPointer&lt;vtkPolyData&gt;      polyData; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	</span><br><span class="line">	vtkSmartPointer&lt;vtkDataSetMapper&gt; selectedMapper;</span><br><span class="line">	vtkSmartPointer&lt;vtkActor&gt;         selectedActor;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*********************************************************************************/</span></span><br><span class="line"> </span><br><span class="line">vtkStandardNewMacro(CellPickerInteractorStyle);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vtkSmartPointer&lt;vtkSphereSource&gt; sphereSource =</span><br><span class="line">		vtkSmartPointer&lt;vtkSphereSource&gt;::New();</span><br><span class="line">	sphereSource-&gt;Update();</span><br><span class="line"> </span><br><span class="line">	vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper =</span><br><span class="line">		vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();</span><br><span class="line">	mapper-&gt;SetInputData(sphereSource-&gt;GetOutput());</span><br><span class="line"> </span><br><span class="line">	vtkSmartPointer&lt;vtkActor&gt; actor =</span><br><span class="line">		vtkSmartPointer&lt;vtkActor&gt;::New();</span><br><span class="line">	actor-&gt;GetProperty()-&gt;SetColor(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	actor-&gt;SetMapper(mapper);</span><br><span class="line"> </span><br><span class="line">	vtkSmartPointer&lt;vtkRenderer&gt; renderer =</span><br><span class="line">		vtkSmartPointer&lt;vtkRenderer&gt;::New();</span><br><span class="line">	renderer-&gt;AddActor(actor);</span><br><span class="line">	renderer-&gt;SetBackground(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">	vtkSmartPointer&lt;vtkRenderWindow&gt; rw =</span><br><span class="line">		vtkSmartPointer&lt;vtkRenderWindow&gt;::New();</span><br><span class="line">	rw-&gt;Render();</span><br><span class="line">	rw-&gt;SetWindowName(<span class="string">"CellPicker Interaction"</span>);</span><br><span class="line">	rw-&gt;AddRenderer(renderer);</span><br><span class="line"> </span><br><span class="line">	vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; rwi =</span><br><span class="line">		vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();</span><br><span class="line">	rwi-&gt;SetRenderWindow(rw);</span><br><span class="line"><span class="comment">/****************************************************************************/</span></span><br><span class="line">	vtkSmartPointer&lt;CellPickerInteractorStyle&gt; style =</span><br><span class="line">		vtkSmartPointer&lt;CellPickerInteractorStyle&gt;::New();</span><br><span class="line">	style-&gt;SetDefaultRenderer(renderer);</span><br><span class="line">	style-&gt;polyData = sphereSource-&gt;GetOutput();</span><br><span class="line">	rwi-&gt;SetInteractorStyle(style);</span><br><span class="line"> </span><br><span class="line">	rw-&gt;Render();</span><br><span class="line">	rwi-&gt;Initialize();</span><br><span class="line">	rwi-&gt;Start();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「沈子恒」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//shenchunxu.blog.csdn.net/article/details/54966221</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>材料</category>
      </categories>
  </entry>
  <entry>
    <title>交叉熵和负对数损失</title>
    <url>/2020/03/17/%E4%BA%A4%E5%8F%89%E7%86%B5%E5%92%8CKL%E6%95%A3%E5%BA%A6/</url>
    <content><![CDATA[<p>最近学的有点迷糊。复习一下各种常用的损失函数的公式。<br><a id="more"></a></p>
<h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><p>交叉熵主要用于分类问题。用于比较两组数据的分布差异。<br>交叉熵避免了使用二次代价函数带来的梯度消失问题（<a href="https://juejin.im/post/5b40a5156fb9a04faf478a45" target="_blank" rel="noopener">消除了sigmoid的导数项</a>）。</p>
<h2 id="单分类问题的loss"><a href="#单分类问题的loss" class="headerlink" title="单分类问题的loss"></a>单分类问题的loss</h2><p>一个样本只能有一个类别<br>一个样本的loss</p>
<script type="math/tex; mode=display">loss=-\sum_{i=1}^{n}{y_i\log(\hat{y_i})}</script><p>batch的loss(m为batch size)</p>
<script type="math/tex; mode=display">loss=-\frac{1}{m}\sum_{j=1}^{m}\sum_{i=1}^{n}{y_{ji}\log(\hat{y_{ji}})}</script><h2 id="多标签问题的loss"><a href="#多标签问题的loss" class="headerlink" title="多标签问题的loss"></a>多标签问题的loss</h2><p>一个样本可以有多个类别。n-hot<br>Pred采用的是sigmoid函数计算。将每一个节点的输出归一化到[0,1]之间。所有Pred值的和也不再为1。<br>一个样本的loss：</p>
<script type="math/tex; mode=display">loss=-ylog(\hat{y})-(1-y)log(1-\hat{y})</script><p>batch的loss</p>
<script type="math/tex; mode=display">loss=\sum_{j=1}^{m}\sum_{i=1}^{m}{-y_{ji}log{\hat{y_{ji}}}-(1-y_{ji})log(1-\hat{y_{ji}})}</script><h1 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h1><p>KL散度是信息论中的重要概念，用来描述两个概率分布的差异。</p>
<p>如果对于同一个随机变量x有两个单独的概率分布P(x)和Q(x)，则可以使用KL散度(Kullback-Leiber(KL) divergence)来衡量这两个分布的差异：</p>
<script type="math/tex; mode=display">D_{KL}(P||Q) = E_{x\sim P}[log\frac{P(x)}{Q(x)}] = E_{x\sim P}[log{P(x)}-log{Q(x)}]</script><p>KL散度有很多有用的性质：</p>
<ul>
<li>最重要的是，它是非负的。 </li>
<li>当x是离散型变量时，KL散度为0当且仅当P(x)与Q(x)具有相同的分布。</li>
<li>KL散度表征了某种距离，但不是真正的距离，因为KL散度不对称：$D<em>{KL}(P||Q)\not=D</em>{KL}(Q||P)$</li>
</ul>
<h1 id="交叉熵和KL散度"><a href="#交叉熵和KL散度" class="headerlink" title="交叉熵和KL散度"></a>交叉熵和KL散度</h1><blockquote>
<p>KL散度可以被用于计算代价，而在特定情况下最小化KL散度等价于最小化交叉熵。而交叉熵的运算更简单，所以用交叉熵来当做代价。</p>
</blockquote>
<p>交叉熵与KL散度密切相关：</p>
<script type="math/tex; mode=display">H(P,Q) = H(P) + D_{KL}(P||Q)</script><p>其中H(P,Q)是交叉熵(cross-entropy)，H(P)是概率分布P的香农熵。<br>在深度学习中，针对Q最小化交叉熵等价于最小化KL散度，因为Q与P独立，Q与P的香农熵无关。</p>
<h1 id="交叉熵和负对数损失（negative-log-likelihood，NLL"><a href="#交叉熵和负对数损失（negative-log-likelihood，NLL" class="headerlink" title="交叉熵和负对数损失（negative log likelihood，NLL)"></a>交叉熵和负对数损失（negative log likelihood，NLL)</h1><p><a href="https://stats.stackexchange.com/questions/198038/cross-entropy-or-log-likelihood-in-output-layer" target="_blank" rel="noopener">参考链接</a><br>具有交叉熵的S形(sigmoid激活，每一个输出具有独立分布)输出层与具有对数似然的softmax（输出和为1）输出层非常相似。</p>
<p>考虑使用以下分类任务(K类)。<br>让我们分别看一下网络的输出层和成本函数。就我们的目的而言，输出层是S形或softmax，成本函数是交叉熵或对数似然。<br><strong>输出层</strong><br>如果是S型，输出层将具有𝐾每个Sigmoid的值在0到1之间。至关重要的是，这些输出的总和可能不等于1，因此不能将它们解释为概率分布。这两个语句的唯一例外是以下情况𝐾=2即二分类，此时只有一个S形就足够了。在这种情况下，第二类的预测值可以由1减去输出的预测值得到。<br>如果输出层是softmax，则它还具有𝐾输出。但是在这种情况下，输出之和为1。由于这一限制，具有softmax输出层的网络比具有多个S型网络的网络具有更低的灵活性。<br>为了说明该约束，请考虑用于对数字进行分类的网络。它有十个输出节点。如果它们是S形，则它们中的两个（例如8和9或0和6）都可以输出（例如0.9）。对于softmax，这是不可能的。输出仍然可以相等（例如均为0.45），但是由于受到限制，当调整权重以增加一位数字的输出时，它必然会降低其他位数的输出。该文本在同一章中有一个滑块演示来说明这种效果。<br>那预测呢？好吧，一种简单的方法是简单地分配具有最大输出的类。对于两种类型的输出层都是如此。<br>至于代价函数，可以对任何一个网络使用交叉熵或对数似然（或其他成本函数，例如均方误差）<br><strong>代价函数</strong><br>K分类问题的交叉熵损失为：</p>
<script type="math/tex; mode=display">C_\text{CE} = -\frac{1}{n} \sum\limits_x \sum\limits_{k=1}^K (y_k \ln a_k^L + (1 - y_k) \ln (1 - a_k^L))</script><p>这里x是输入(对于每个x，只有$y_k$为1，其余为0（即one-hot编码）)， n是input size<br>K分类的NLL损失为：</p>
<script type="math/tex; mode=display">C_\text{LL} = -\frac{1}{n} \sum\limits_x y^T \ln(a^L) = -\frac{1}{n} \sum\limits_x \sum\limits_{k=1}^K y_k \ln(a_k^L)</script><p>这里，y是one-hot编码的输出，并且$a^L$是模型的输出<br>这是两个成本函数之间的关键区别：对数似然仅考虑相应类别的输出，而交叉熵函数也考虑其他输出。您可以在上面的表达式中看到这一点-总而言之CE和CLL有相同的项，但是CE还有一个附加项。这意味着CE和LL都以正确类别的输出量奖励网络。但是，CE还对网络中其他类别的输出量进行了惩罚。如果混乱很严重，那么惩罚也很严重。</p>
<blockquote>
<p>总而言之，如果要考虑其他类别输出量的影响就使用CE，如果不考虑就使用CLL</p>
</blockquote>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>人脸识别(mtcnn+facenet)</title>
    <url>/2020/02/21/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-mtcnn-facenet/</url>
    <content><![CDATA[<p>csdn链接：<a href="https://blog.csdn.net/weixin_44791964/article/details/103697409" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103697409</a><br><a id="more"></a></p>
<h1 id="什么是mtcnn和facenet"><a href="#什么是mtcnn和facenet" class="headerlink" title="什么是mtcnn和facenet"></a>什么是mtcnn和facenet</h1><h2 id="1、mtcnn"><a href="#1、mtcnn" class="headerlink" title="1、mtcnn"></a>1、mtcnn</h2><p>MTCNN，英文全称是Multi-task convolutional neural network，中文全称是多任务卷积神经网络，该神经网络将人脸区域检测与人脸关键点检测放在了一起。总体可分为P-Net、R-Net、和O-Net三层网络结构。</p>
<p><img src="1.png" alt=""></p>
<h2 id="2、facenet"><a href="#2、facenet" class="headerlink" title="2、facenet"></a>2、facenet</h2><p>谷歌人脸检测算法，发表于 CVPR 2015，利用相同人脸在不同角度等姿态的照片下有高内聚性，不同人脸有低耦合性，提出使用 cnn + triplet mining 方法，在 LFW 数据集上准确度达到 99.63%。</p>
<p>通过 CNN 将人脸映射到欧式空间的特征向量上，实质上：不同图片人脸特征的距离较大；通过相同个体的人脸的距离，总是小于不同个体的人脸这一先验知识训练网络。</p>
<p>测试时只需要计算人脸特征EMBEDDING，然后计算距离使用阈值即可判定两张人脸照片是否属于相同的个体。</p>
<p><img src="2.png" alt=""></p>
<p>简单来讲，在使用阶段，facenet即是：<br>1、输入一张人脸图片<br>2、通过深度学习网络提取特征<br>3、L2标准化<br>4、得到128维特征向量。</p>
<h2 id="人脸对齐"><a href="#人脸对齐" class="headerlink" title="人脸对齐"></a>人脸对齐</h2><p>常见的对齐方法有<br>1、通过双眼坐标进行旋正<br>2、通过矩阵运算求解仿射矩阵进行旋正</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title>利用hexo搭建个人博客</title>
    <url>/2019/11/18/%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="基于hexo搭建个人博客"><a href="#基于hexo搭建个人博客" class="headerlink" title="基于hexo搭建个人博客"></a>基于hexo搭建个人博客</h2><p>1.安装nodejs</p>
<p>2.添加淘宝源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>3.安装hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>4.创建空文件夹</p>
<p>5.切换到空文件夹</p>
<p>6.生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure>
<p>7.新建github仓库</p>
<p>仓库名必须为  用户名.github.io</p>
<p>8.</p>
<p>cnpm install —save hexo-deployer-git</p>
<p>9.设置<code>_config.yml</code></p>
<p>配置(repo为仓库地址，使用ssh可能会提示权限错误，更改https地址后，删除./deploygit文件夹，重新部署。)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;sjtu-xx&#x2F;sjtu-xx.github.io.git </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d  #部署</span><br></pre></td></tr></table></figure>
<p>10.更换主题</p>
<p>将主题下载到theme文件夹下，然后更改_config.yml中的theme文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>11.添加gitalk评论系统</p>
<ul>
<li>新建一个仓库如blog_comment,在设置中进行授权。settings-》Developer settings - &gt; OAuth Apps -》新建</li>
<li>Application name 与仓库名称一致，主页url和回调url一致，为主页地址。</li>
<li>在icarus的config文件中添加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment:</span><br><span class="line">    # Name of the comment plugin</span><br><span class="line">    type: gitalk</span><br><span class="line">    owner: sjtu-xx         # (required) GitHub user name</span><br><span class="line">    repo: blog_comment   # (required) GitHub repository name</span><br><span class="line">    client_id: xxxxxxx # (required) OAuth application client id</span><br><span class="line">    client_secret: xxxxxxxxx  # (required) OAuth application client secret</span><br><span class="line">    admin: sjtu-xx</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>遇到的问题：</p>
<p><strong>插入图片：</strong></p>
<p><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a></p>
<p><strong>icarus主题详细配置：</strong></p>
<p><a href="https://cloudy-liu.github.io/2019/06/23/Hexo主题迁移到icarus/" target="_blank" rel="noopener">https://cloudy-liu.github.io/2019/06/23/Hexo%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB%E5%88%B0icarus/</a></p>
<p><strong>家里的网络在deploy时，连接github显示timeout错误</strong><br>通过连接手机运营商网络可以上传<br>连接学校的vpn也可以成功上传</p>
<h2 id="hexo数学公式"><a href="#hexo数学公式" class="headerlink" title="hexo数学公式"></a>hexo数学公式</h2><p>原生hexo并不支持数学公式，需要安装插件 mathJax。mathJax 是一款运行于浏览器中的开源数学符号渲染引擎，使用 mathJax 可以方便的在浏览器中嵌入数学公式。mathJax 使用网络字体产生高质量的排版，因此可适应各种分辨率，它的显示是基于文本的而非图片，因此显示效果更好。这些公式可以被搜索引擎使用，因此公式里的符号一样可以被搜索引擎检索到。</p>
<p>1.安装<br><code>$ npm install hexo-math --save</code></p>
<p>2.配置<br>在站点yml文件中添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  engine: &#39;mathjax&#39; # or &#39;katex&#39;</span><br><span class="line">  mathjax:</span><br><span class="line">    # src: custom_mathjax_source</span><br><span class="line">    config:</span><br><span class="line">      # MathJax config</span><br></pre></td></tr></table></figure></p>
<p>在文档开头加入：<br><code>mathjax: true</code></p>
]]></content>
      <categories>
        <category>其他工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>icarus</tag>
      </tags>
  </entry>
  <entry>
    <title>几种对抗生成网络</title>
    <url>/2020/02/23/%E5%87%A0%E7%A7%8D%E5%AF%B9%E6%8A%97%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="DCGAN深度卷积对抗生成网络"><a href="#DCGAN深度卷积对抗生成网络" class="headerlink" title="DCGAN深度卷积对抗生成网络"></a>DCGAN深度卷积对抗生成网络</h1><a id="more"></a>
<p>CSDN：<a href="https://blog.csdn.net/weixin_44791964/article/details/103743038" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103743038</a><br>DCGAN的全称是Deep Convolutional Generative Adversarial Networks ,<br>意即深度卷积对抗生成网络。</p>
<p>它是由Alec Radford在论文Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks中提出的。</p>
<p>实际上它是在GAN的基础上增加深度卷积网络结构。</p>
<h1 id="CGAN待条件约束的GAN"><a href="#CGAN待条件约束的GAN" class="headerlink" title="CGAN待条件约束的GAN"></a>CGAN待条件约束的GAN</h1><p>CSDN：<a href="https://blog.csdn.net/weixin_44791964/article/details/103744620" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103744620</a></p>
<p>CGAN一种带条件约束的GAN，在生成模型（D）和判别模型（G）的建模中均引入条件变量y（conditional variable y）。</p>
<p>使用额外信息y对模型增加条件，可以指导数据生成过程。这些条件变量y可以基于多种信息，例如类别标签，用于图像修复的部分数据，来自不同模态（modality）的数据。</p>
<p>如果条件变量y是类别标签，可以看做CGAN是把纯无监督的 GAN 变成有监督的模型的一种改进。</p>
<p>这个简单直接的改进被证明非常有效。</p>
<p>简单来讲，普通的GAN输入的是一个N维的正态分布随机数，而CGAN会为这个随机数添上标签，其利用Embedding层将正整数（索引值）转换为固定尺寸的稠密向量，并将这个稠密向量与N维的正态分布随机数相乘，从而获得一个有标签的随机数。此时，模型的LOSS将包括标签的损失和准确率的损失。</p>
<h1 id="ACGAN"><a href="#ACGAN" class="headerlink" title="ACGAN"></a>ACGAN</h1><p>CSDN: <a href="https://blog.csdn.net/weixin_44791964/article/details/103746380" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103746380</a><br>ACGAN一种带条件约束的DCGAN，在生成模型（D）和判别模型（G）的建模中均引入条件变量y（conditional variable y）。</p>
<p>ACGAN相当于是DCGAN和CGAN的结合，将深度卷积网络和标签带入到GAN当中。</p>
<p>使用额外信息y对模型增加条件，可以指导数据生成过程。这些条件变量y可以基于多种信息，例如类别标签，用于图像修复的部分数据，来自不同模态（modality）的数据。</p>
<p>在存在类别标签的情况下，将深度卷积网络带入到GAN当中，提高图片的生成质量。</p>
<p>这个简单直接的改进被证明非常有效。</p>
<p>简单来讲，普通的GAN输入的是一个N维的正态分布随机数，而ACGAN会为这个随机数添上标签，其利用Embedding层将正整数（索引值）转换为固定尺寸的稠密向量，并将这个稠密向量与N维的正态分布随机数相乘，从而获得一个有标签的随机数。</p>
<p>与此同时，ACGAN将深度卷积网络带入到存在标签的GAN中，可以生成更加高质量的图片</p>
<h1 id="COGAN"><a href="#COGAN" class="headerlink" title="COGAN"></a>COGAN</h1><p>COGAN是一种耦合生成式对抗网络，其内部具有一定的耦合，可以对同一个输入有不同的输出。</p>
<p>其具体实现方式就是：<br>1、建立两个生成模型，两个判别模型。<br>2、两个生成模型的特征提取部分有一定的重合，在最后生成图片的部分分开，以生成不同类型的图片。<br>3、两个判别模型的特征提取部分有一定的重合，在最后判别真伪的部分分开，以判别不同类型的图片。</p>
<h1 id="LSGAN"><a href="#LSGAN" class="headerlink" title="LSGAN"></a>LSGAN</h1><p>CSDN:<a href="https://blog.csdn.net/weixin_44791964/article/details/103758751" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103758751</a><br>LSGAN是一种最小二乘GAN。</p>
<p>其主要特点为将loss函数的计算方式由交叉熵更改为均方差。<br>无论是判别模型的训练，还是生成模型的训练，都需要将交叉熵更改为均方差。</p>
<h1 id="CycleGAN"><a href="#CycleGAN" class="headerlink" title="CycleGAN"></a>CycleGAN</h1><p>CSDN:<a href="https://blog.csdn.net/weixin_44791964/article/details/103780922" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103780922</a><br>CycleGAN是一种完成图像到图像的转换的一种GAN。</p>
<p>图像到图像的转换是一类视觉和图形问题，其目标是获得输入图像和输出图像之间的映射。</p>
<p>但是，对于许多任务，配对的训练数据将不可用。</p>
<p>CycleGAN提出了一种在没有成对例子的情况下学习将图像从源域X转换到目标域Y的方法。<br><img src="1.png" alt=""></p>
<h1 id="SRGAN"><a href="#SRGAN" class="headerlink" title="SRGAN"></a>SRGAN</h1><p>CSDN:<a href="https://blog.csdn.net/weixin_44791964/article/details/103825427" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/103825427</a></p>
<p>SRGAN出自论文Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Network。<br>其主要的功能就是输入一张低分辨率图片，生成高分辨率图片。<br>文章提到，普通的超分辨率模型训练网络时只用到了均方差作为损失函数，虽然能够获得很高的峰值信噪比，但是恢复出来的图像通常会丢失高频细节。<br>SRGAN利用感知损失(perceptual loss)和对抗损失(adversarial loss)来提升恢复出的图片的真实感。<br>其中感知损失是利用卷积神经网络提取出的特征，通过比较生成图片经过卷积神经网络后的特征和目标图片经过卷积神经网络后的特征的差别，使生成图片和目标图片在语义和风格上更相似<br>对抗损失由GAN提供，根据图像是否可以欺骗过判别网络进行训练。</p>
<h2 id="生成网络"><a href="#生成网络" class="headerlink" title="生成网络"></a>生成网络</h2><p><img src="2.png" alt=""><br>此图从左至右来看，我们可以知道：<br>SRGAN的生成网络由三个部分组成。<br>1、低分辨率图像进入后会经过一个卷积+RELU函数<br>2、然后经过B个残差网络结构，每个残差网络内部包含两个卷积+标准化+RELU，还有一个残差边。<br>3、然后进入上采样部分，将长宽进行放大，两次上采样后，变为原来的4倍，实现提高分辨率。</p>
<h2 id="判别网络"><a href="#判别网络" class="headerlink" title="判别网络"></a>判别网络</h2><p><img src="3.png" alt=""><br>此图从左至右来看，我们可以知道：<br>SRGAN的判别网络由不断重复的 卷积+LeakyRELU和标准化 组成。</p>
<h2 id="训练思路"><a href="#训练思路" class="headerlink" title="训练思路"></a>训练思路</h2><p>1、对判别模型进行训练<br>将真实的高分辨率图像和虚假的高分辨率图像传入判别模型中。<br>将真实的高分辨率图像的判别结果与1对比得到loss。<br>将虚假的高分辨率图像的判别结果与0对比得到loss。<br>利用得到的loss进行训练。</p>
<p>2、对生成模型进行训练<br>将低分辨率图像传入生成模型，得到高分辨率图像，利用该高分辨率图像获得判别结果与1进行对比得到loss。<br>将真实的高分辨率图像和虚假的高分辨率图像传入VGG网络，获得两个图像的特征，通过这两个图像的特征进行比较获得loss。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python进行数据分析3（绘图与可视化）</title>
    <url>/2020/02/17/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%903%EF%BC%88%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%EF%BC%89/</url>
    <content><![CDATA[<h1 id="六、绘图与可视化"><a href="#六、绘图与可视化" class="headerlink" title="六、绘图与可视化"></a>六、绘图与可视化</h1><a id="more"></a>
<h2 id="1-matplotlib入门"><a href="#1-matplotlib入门" class="headerlink" title="1.matplotlib入门"></a>1.matplotlib入门</h2><h3 id="（1）图片与子图"><a href="#（1）图片与子图" class="headerlink" title="（1）图片与子图"></a>（1）图片与子图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.plot(np.arange(10))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>plt绘制的图位于Figure对象中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">ax1 &#x3D; fig.add_subplot(2,2,1)  两行两列，第一个位置</span><br><span class="line">ax2 &#x3D; fig.add_subplot(2,2,2)</span><br><span class="line">ax3 &#x3D; fig.add_subplot(2,2,3)</span><br><span class="line">此时调用plt.plot()会在最后一张图进行绘制</span><br></pre></td></tr></table></figure>
<p>fig.add_subplot返回的是Axes Subplot对象</p>
<p><strong>图形类型：</strong></p>
<p>hist，scatter</p>
<p><strong>子图：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fig,axes &#x3D; plt.subplots(2,3)</span><br><span class="line">axes为Axes Subplot对象列表</span><br><span class="line">索引方法：axes[0,1]</span><br><span class="line"></span><br><span class="line">subplots方法参数：</span><br><span class="line">sharex：所有子图使用相同的x刻度</span><br><span class="line">subplot_kw：传入add_subplot的关键字参数字典，用于生成子图</span><br></pre></td></tr></table></figure>
<h4 id="调整子图间距"><a href="#调整子图间距" class="headerlink" title="调整子图间距"></a>调整子图间距</h4><p><code>plt.subplot_adjust(left=None,bottom=None,right=None,top=None,wspace=None,hspace=None)</code></p>
<p>wspace和hspace分别控制的是图片的宽度和高度百分比，用作子图间距。</p>
<h4 id="颜色，标记和线型"><a href="#颜色，标记和线型" class="headerlink" title="颜色，标记和线型"></a>颜色，标记和线型</h4><p>1）字符串参数指定：</p>
<p><code>plt.plot(x,y,&#39;g--&#39;)</code>绿色，虚线</p>
<p><code>plt.plot(x,y,&#39;go--&#39;)</code>绿色，虚线,标记为点</p>
<p>2）参数指定</p>
<p><code>plt.plot(x,y,color=&#39;g&#39;,linestyle=&#39;--&#39;)</code></p>
<p><code>plt.plot(x,y,color=&#39;g&#39;,linestyle=&#39;dashed&#39;，marker=&#39;o&#39;)</code></p>
<p>3）折线图的线性插值</p>
<p><code>plt.plot(x,y,&#39;k--&#39;,drawstyle=&#39;step-post&#39;)</code> drawstyle默认为线性插值</p>
<h3 id="（2）刻度、标签和图例"><a href="#（2）刻度、标签和图例" class="headerlink" title="（2）刻度、标签和图例"></a>（2）刻度、标签和图例</h3><p><code>xlim,xticks,xticklabels</code></p>
<p>使用方法：</p>
<p>1）不带参数</p>
<p>plt.xlim() 返回当前的x轴绘图范围</p>
<p>2)带参数</p>
<p>plt.xlim([0,10]) 设置范围</p>
<p>这些方法对应子图中的get_xlim()和set_xlim()方法</p>
<h4 id="2-1设置标题、轴标签、刻度和刻度标签"><a href="#2-1设置标题、轴标签、刻度和刻度标签" class="headerlink" title="2.1设置标题、轴标签、刻度和刻度标签"></a>2.1设置标题、轴标签、刻度和刻度标签</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ax.set_title(&#39;Title&#39;)</span><br><span class="line">ax.set_xlable(&#39;Stages&#39;)</span><br><span class="line">ax.set_xticks([0,200,500,750])</span><br><span class="line">ax.set_xticklabels([&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;],rotation&#x3D;30,fontsize&#x3D;&#39;small&#39;)</span><br><span class="line"></span><br><span class="line">prop&#x3D;&#123;</span><br><span class="line">	&#39;title&#39;:&quot;Title&quot;,</span><br><span class="line">	&#39;xlabel&#39;:&quot;Stages&quot;</span><br><span class="line">&#125;</span><br><span class="line">ax.set(**prop)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-图例"><a href="#2-2-图例" class="headerlink" title="2.2 图例"></a>2.2 图例</h4><p>要使用图例，在绘制时要穿入 label参数，</p>
<p>不使用图例，绘制时不要穿入label或传入<code>label=&#39;_nolegend_&#39;</code></p>
<p><img src="image/image-20190706151130509-2397090.png" alt="image-20190706151130509"></p>
<h3 id="3-注释与子图加工"><a href="#3-注释与子图加工" class="headerlink" title="(3)注释与子图加工"></a>(3)注释与子图加工</h3><p>文本，箭头：text，arrow，annotate方法</p>
<p>文本：</p>
<p><code>ax.text(x,y,&#39;hello world&#39;,family=&#39;monospace&#39;,fontsize=10)</code></p>
<p>添加箭头：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ax.annotate(label,</span><br><span class="line">						xy&#x3D;(x, data.asof(x)+75),</span><br><span class="line">						xytext&#x3D;(x, data.asof(x)+275),</span><br><span class="line">						arrowprops&#x3D;&#123;</span><br><span class="line">								facecolor:&#39;black&#39;,</span><br><span class="line">								headwidth:4,</span><br><span class="line">								width:2,</span><br><span class="line">								headlength:4</span><br><span class="line">						&#125;,</span><br><span class="line">						horizontalalignment&#x3D;&#39;left&#39;,</span><br><span class="line">						verticalalignment&#x3D;&#39;top&#39;)</span><br></pre></td></tr></table></figure>
<p>其他图形：</p>
<p>matplotlib.pyplot中提供了常见图形的引用，完整的引用在matplotlib.patches中</p>
<p>使用时，先生成patch对象shp，然后调用ax.add_patch将图形添加到子图中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rect &#x3D; plt.Rectangle((0.2,0.75),0.4,0.15,color&#x3D;&#39;k&#39;,alpha&#x3D;0.3)</span><br><span class="line">ax.add_patches(rect)</span><br></pre></td></tr></table></figure>
<h3 id="4-将图像保存到文件"><a href="#4-将图像保存到文件" class="headerlink" title="(4)将图像保存到文件"></a>(4)将图像保存到文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.savefig(filename)</span><br><span class="line">plt.savefig(filename,dpi&#x3D;400,bbox_inches&#x3D;&#39;tight&#39;)  bbox_inches修建图片的空白</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">facecolor,edgecolor. 子图之外背景的颜色；&#39;w&#39;默认</span><br><span class="line">format 导出图片的格式</span><br><span class="line">bbox_inches. 导出图片中figure所占的百分比</span><br></pre></td></tr></table></figure>
<h3 id="（5）修改配置"><a href="#（5）修改配置" class="headerlink" title="（5）修改配置"></a>（5）修改配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.rc()</span><br><span class="line">rc的第一个参数时想要自定义的组件，如figure，axes，xtick等</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">font_options &#x3D; &#123;</span><br><span class="line">			&#39;family&#39;:&#39;monospace&#39;,</span><br><span class="line">			&#39;size&#39;:&#39;small&#39;,</span><br><span class="line">			&#39;weigth&#39;:bold</span><br><span class="line">&#125;</span><br><span class="line">plt.rc(&#39;font&#39;,**font_options)</span><br></pre></td></tr></table></figure>
<h2 id="2-使用pandas和seaborn绘图"><a href="#2-使用pandas和seaborn绘图" class="headerlink" title="2.使用pandas和seaborn绘图"></a>2.使用pandas和seaborn绘图</h2><h3 id="（1）折线图"><a href="#（1）折线图" class="headerlink" title="（1）折线图"></a>（1）折线图</h3><p>默认情况下pandas对象调用plot函数会绘制折线图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.plot()</span><br><span class="line">df.plot() 等价df.plot.line()</span><br><span class="line"></span><br><span class="line">Series方法参数：</span><br><span class="line">lable:标签</span><br><span class="line">ax：绘图所用的matplotlib子图对象；如果没有传值，使用当前活动的matplotlib子图</span><br><span class="line">style：&#39;g--&#39;等</span><br><span class="line">kind：可以是area,bar,barh,density,hist,kde,line,pie</span><br><span class="line">logy:在y轴上对数缩放</span><br><span class="line">use_index：使用对象索引刻度标签</span><br><span class="line">rot：刻度标签的旋转</span><br><span class="line">xticks：用于x轴刻度的值</span><br><span class="line">xlim：x轴范围</span><br><span class="line">grid：展示轴的网格</span><br><span class="line"></span><br><span class="line">Dataframe方法参数：</span><br><span class="line">subplots：将每一列绘制在单独的子图</span><br><span class="line">sharex：共享x轴的参数</span><br><span class="line">figsize：</span><br><span class="line">title：标题</span><br><span class="line">legend：添加子图图例（默认为True）</span><br><span class="line">sort_columns:按字母顺序绘制各列，默认情况使用已有的列顺序</span><br></pre></td></tr></table></figure>
<h3 id="（2）柱状图"><a href="#（2）柱状图" class="headerlink" title="（2）柱状图"></a>（2）柱状图</h3><p>bar(),barh() :垂直/水平柱状图</p>
<p>使用：</p>
<p><code>data.plot.bar(ax=axes[0],color=&#39;k&#39;,alpha=0.7)</code></p>
<p>堆积柱状图：</p>
<p><code>data.plot.bar(stacked=True)</code></p>
<p><img src="image/image-20190706155525312-2399725.png" alt="image-20190706155525312"></p>
<p>使用seaborn绘制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import seaborn as sns</span><br><span class="line">sns.barplot(x&#x3D;&#39;tip_pct&#39;,y&#x3D;&#39;day&#39;,data&#x3D;tips,orient&#x3D;&#39;h&#39;)</span><br><span class="line">sns.barplot(x&#x3D;&#39;tip_pct&#39;,y&#x3D;&#39;day&#39;,hue&#x3D;&#39;time&#39;,data&#x3D;tips,orient&#x3D;&#39;h&#39;)  hue参数：将数据按照time进行分类</span><br><span class="line">样式：</span><br><span class="line">sns.set(style&#x3D;&#39;whitegrid&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="image/image-20190706163812460-2402292.png" alt="image-20190706163812460"></p>
<h3 id="（4）直方图和密度图"><a href="#（4）直方图和密度图" class="headerlink" title="（4）直方图和密度图"></a>（4）直方图和密度图</h3><p>直方图：<code>data.plot.hist(bins=50)</code>分成50列</p>
<p>内核密度估计图：<code>data.plot.density()</code> </p>
<p>同时绘制两者：<code>sns.distplot(data,bins=100,color=&#39;k&#39;)</code></p>
<h3 id="5-散点图和点图"><a href="#5-散点图和点图" class="headerlink" title="(5)散点图和点图"></a>(5)散点图和点图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">散点图</span><br><span class="line">sns.regplot(&#39;col1&#39;,&#39;col2&#39;,data&#x3D;trans_data)</span><br><span class="line"></span><br><span class="line">散点图组</span><br><span class="line">sns.pairplot(trans_data,kind&#x3D;&#39;scatter&#39;,diag_kind&#x3D;&#39;kde&#39;,plot_kws&#x3D;&#123;&#39;alpha&#39;:0.2&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="（6）特征网格和分类数据"><a href="#（6）特征网格和分类数据" class="headerlink" title="（6）特征网格和分类数据"></a>（6）特征网格和分类数据</h3><p><img src="image/image-20190706170519024-2403919.png" alt="image-20190706170519024"></p>
<p><code>sns.factorplot(x=&#39;day&#39;,y=&#39;tip&#39;,row=&#39;time&#39;,col=&#39;smoker&#39;,data=tips,kind=&#39;bar&#39;)</code></p>
<p>通用的特征网格 sns.FacetGrid</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>seaborn</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>利用mAP(mean Average Precision)计算目标检测精确度</title>
    <url>/2020/03/09/%E5%88%A9%E7%94%A8mAP%E8%AE%A1%E7%AE%97%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%B2%BE%E7%A1%AE%E5%BA%A6/</url>
    <content><![CDATA[<p>CSDN: <a href="https://blog.csdn.net/weixin_44791964/article/details/104695264" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/104695264</a><br><a id="more"></a></p>
<h1 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h1><h2 id="1、IOU的概念"><a href="#1、IOU的概念" class="headerlink" title="1、IOU的概念"></a>1、IOU的概念</h2><p>IOU的概念应该比较简单，就是衡量预测框和真实框的重合程度。<br>下图是一个示例：图中绿色框为实际框（好像不是很绿……），红色框为预测框，当我们需要判断两个框之间的关系时，主要就是判断两个框的重合程度</p>
<p><img src="1.jpg" alt=""><br>计算IOU的公式为：</p>
<script type="math/tex; mode=display">IOU=\frac{S_交}{S_并}</script><h2 id="2、TP-TN-FP-FN的概念"><a href="#2、TP-TN-FP-FN的概念" class="headerlink" title="2、TP TN FP FN的概念"></a>2、TP TN FP FN的概念</h2><p>TP TN FP FN里面一共出现了4个字母，分别是T F P N。<br>T是True；<br>F是False；<br>P是Positive；<br>N是Negative。</p>
<p>T或者F代表的是该样本 是否被正确分类。<br>P或者N代表的是该样本 原本是正样本还是负样本。</p>
<p>TP（True Positives）意思就是被分为了正样本，而且分对了。<br>TN（True Negatives）意思就是被分为了负样本，而且分对了，<br>FP（False Positives）意思就是被分为了正样本，但是分错了（事实上这个样本是负样本）。<br>FN（False Negatives）意思就是被分为了负样本，但是分错了（事实上这个样本是这样本）。</p>
<p>在mAP计算的过程中主要用到了，TP、FP、FN这三个概念。</p>
<h2 id="3、precision（精确度）和recall（召回率）"><a href="#3、precision（精确度）和recall（召回率）" class="headerlink" title="3、precision（精确度）和recall（召回率）"></a>3、precision（精确度）和recall（召回率）</h2><p>精确度：模型预测为真的样本中，实际为真的比例</p>
<script type="math/tex; mode=display">Precision=\frac{TP}{TP+FP}</script><p>召回率：模型预测为真且实际为真的样本占实际为真的样本的比例</p>
<script type="math/tex; mode=display">Recall=\frac{TP}{TP+FN}</script><h2 id="4、概念举例"><a href="#4、概念举例" class="headerlink" title="4、概念举例"></a>4、概念举例</h2><p><img src="2.jpg" alt=""><br>如图所示，蓝色的框是 真实框。绿色和红色的框是 预测框，绿色的框是正样本，红色的框是负样本。一般来讲，当预测框和真实框IOU&gt;=0.5时，被认为是正样本。<br>因此对于这幅图来讲。<br>真实框一共有3个，正样本一共有2个，负样本一共有2个。<br>此时</p>
<script type="math/tex; mode=display">Precision= \frac{2}{2+2}=\frac{1}{2}</script><script type="math/tex; mode=display">Recall=\frac{2}{2+1} = \frac{2}{3}</script><h1 id="单个指标的局限性"><a href="#单个指标的局限性" class="headerlink" title="单个指标的局限性"></a>单个指标的局限性</h1><p>在目标检测算法里面有一个非常重要的概念是置信度，如果置信度设置的高的话，预测的结果和实际情况就很符合，如果置信度低的话，就会有很多误检测。</p>
<p>假设一幅图里面总共有3个正样本，目标检测对这幅图的预测结果有10个，其中3个实际上是正样本，7个实际上是负样本。对应置信度如下。<br><img src="3.png" alt=""></p>
<p>如果我们将可以接受的置信度设置为0.95的话，那么目标检测算法就会将序号为1的样本作为正样本，其它的都是负样本。此时TP = 1，FP = 0，FN = 2。</p>
<script type="math/tex; mode=display">Precision=\frac{1}{1+0}=1</script><script type="math/tex; mode=display">Recall= \frac{1}{1+2} = \frac{1}{3}</script><p>此时Precision非常高，但是事实上我们只检测出一个正样本，还有两个没有检测出来，因此只用Precision就不合适。</p>
<p>这个时候如果我们将可以接受的置信度设置为0.35的话，那么目标检测算法就会将序号为1的样本作为正样本，其它的都是负样本。此时TP = 3，FP = 3，FN = 0。</p>
<script type="math/tex; mode=display">Precision=\frac{3}{3+3}=\frac{1}{2}</script><script type="math/tex; mode=display">Recall= \frac{3}{3+0} = \frac{1}{2}</script><p>此时Recall非常高，但是事实上目标检测算法认为是正样本的样本里面，有3个样本确实是正样本，但有三个是负样本，存在非常严重的误检测，因此只用Recall就不合适。</p>
<p>二者进行结合才是评价的正确方法。</p>
<h1 id="什么是AP"><a href="#什么是AP" class="headerlink" title="什么是AP"></a>什么是AP</h1><p>AP事实上指的是，利用不同的Precision和Recall的点的组合，画出来的曲线下面的面积。<br>如下面这幅图所示。<br><img src="4.png" alt=""><br>当我们取不同的置信度，可以获得不同的Precision和不同的Recall，当我们取得置信度够密集的时候，就可以获得非常多的Precision和Recall。</p>
<p>此时Precision和Recall可以在图片上画出一条线，这条线下部分的面积就是某个类的AP值。<br><strong>mAP就是所有的类的AP值求平均。</strong></p>
<p>github: <a href="https://github.com/Cartucho/mAP" target="_blank" rel="noopener">https://github.com/Cartucho/mAP</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>利用python进行数据分析2（pandas数据处理基础）</title>
    <url>/2020/02/17/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%902%EF%BC%88pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    <content><![CDATA[<p>pandas中的字符串方法<br><a id="more"></a><br>df[“col1”].str.startswith()</p>
<p><img src="https://mlln.cn/2015/07/05/pandas%E6%95%99%E7%A8%8B%EF%BC%9A[18]%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/54baacfb43166d222fae9790452309f79152d29e.jpg" alt="img"></p>
<h1 id="三、数据载入，存储及文件格式"><a href="#三、数据载入，存储及文件格式" class="headerlink" title="三、数据载入，存储及文件格式"></a>三、数据载入，存储及文件格式</h1><h2 id="1。文本格式数据的读写"><a href="#1。文本格式数据的读写" class="headerlink" title="1。文本格式数据的读写"></a>1。文本格式数据的读写</h2><p>方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>read_csv</td>
<td>从文件对象读取分隔好的数据，默认分隔符为逗号</td>
</tr>
<tr>
<td>read_table</td>
<td>从文件对象读取分隔好的数据，默认分隔符为制表符（‘\t’）</td>
</tr>
<tr>
<td>read_fwf</td>
<td>从特定宽度的文件中读取数据，无分隔符</td>
</tr>
<tr>
<td>read_clipboard</td>
<td>read_table的剪贴板版本</td>
</tr>
<tr>
<td>read_excel</td>
<td>从xls或xlsx中读取数据</td>
</tr>
<tr>
<td>read_hdf</td>
<td>读取用pandas存储的HDF5文件</td>
</tr>
<tr>
<td>read_json</td>
<td>从json字符串读取表格数据</td>
</tr>
<tr>
<td>read_html</td>
<td>从html文件读取表格数据</td>
</tr>
<tr>
<td>read_msgpack</td>
<td>读取MessagePack二进制格式的Pandas数据</td>
</tr>
<tr>
<td>read_pickle</td>
<td></td>
</tr>
<tr>
<td>read_sas</td>
<td>读取储存在SAS系统中定制储存格式的SAS数据集</td>
</tr>
<tr>
<td>read_sql</td>
<td>将SQL查询结果（使用SQLAlchemy）读取为DataFrame</td>
</tr>
<tr>
<td>read_stata</td>
<td>读取Stata格式的数据集</td>
</tr>
<tr>
<td>read_feather</td>
<td>读取Feather二进制格式</td>
</tr>
</tbody>
</table>
</div>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.read_table(tablename,sep&#x3D;&#39;,&#39;)</span><br><span class="line">pd.read_csv(csv_file,names&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]，index_col&#x3D;&#39;c&#39;)  #names列名，index_col将指定列作为索引列</span><br><span class="line"></span><br><span class="line">分层索引:</span><br><span class="line">pd.read_csv(csv_file,names&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]，index_col&#x3D;[&#39;a&#39;,&#39;b&#39;])</span><br><span class="line"></span><br><span class="line">可以使用正则表达式</span><br><span class="line">pd.read_csv(csv_file,sep&#x3D;&#39;\s+&#39;) 以多个空格分开</span><br><span class="line"></span><br><span class="line">跳过行</span><br><span class="line">pd.read_csv(csv_file,skiprows&#x3D;[1，2，3])</span><br><span class="line"></span><br><span class="line">处理缺省值(na_values需要用NA替换的对象)</span><br><span class="line">pd.read_csv(file,na_values&#x3D;[&quot;NULL&quot;])</span><br><span class="line">指定缺省值标识(将message列中的foo和NA认为是缺省值，赋值np.nan)</span><br><span class="line">sentinels &#x3D; &#123;&#39;message&#39;:[&#39;foo&#39;,&#39;NA&#39;]&#125;</span><br><span class="line">pd.read_csv(file,na_values&#x3D;sentinels)</span><br></pre></td></tr></table></figure>
<p>参数（P170）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>path</td>
<td>文件路径</td>
</tr>
<tr>
<td>sep/delimiter</td>
<td>分隔符</td>
</tr>
<tr>
<td>header</td>
<td>用作索引的行号，默认为0，如果没有，应为None</td>
</tr>
<tr>
<td>index_col</td>
<td>应作行索引的列名或列号</td>
</tr>
<tr>
<td>names</td>
<td>结果的列名列表，和header=None连用</td>
</tr>
<tr>
<td>skiprows</td>
<td>跳过的行数或行号列表</td>
</tr>
<tr>
<td>na_values</td>
<td>需要用NA替换的值序列</td>
</tr>
<tr>
<td>comment</td>
<td>在行结尾处分隔注释的字符</td>
</tr>
<tr>
<td>parse_dates</td>
<td>尝试将数据解析为datetime，默认时False。如果为True，将尝试解析所有的列。也可以指定列名。如果列表的元素是元组或列表，将会组合起来进行解析</td>
</tr>
<tr>
<td>keep_date_col</td>
<td>如果连接列到parse_dates，保留被连接的列，默认False</td>
</tr>
<tr>
<td>converters</td>
<td>包含列名称映射到函数的字典（）</td>
</tr>
<tr>
<td>dayfirst</td>
<td>解析非明确日期，按照国际标准格式处理</td>
</tr>
<tr>
<td>date_parser</td>
<td>用于解析日期的函数</td>
</tr>
<tr>
<td>nrows</td>
<td>从文件开头处读入的行数</td>
</tr>
<tr>
<td>iterator</td>
<td>返回一个TextParser，用于零散的读文件</td>
</tr>
<tr>
<td>chunksize</td>
<td>用于迭代的块大小</td>
</tr>
<tr>
<td>skip_footer</td>
<td>忽略文件尾部的行数</td>
</tr>
<tr>
<td>verbose</td>
<td>打印各种解释器输出的信息，如缺失值的数量</td>
</tr>
<tr>
<td>encoding</td>
<td>文本编码</td>
</tr>
<tr>
<td>squeeze</td>
<td>如果解析数据只包含一列，返回一个 Series</td>
</tr>
<tr>
<td>thousands</td>
<td>千位分隔符</td>
</tr>
</tbody>
</table>
</div>
<h3 id="（1）分块读取文件"><a href="#（1）分块读取文件" class="headerlink" title="（1）分块读取文件"></a>（1）分块读取文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.options.display.maxrow = <span class="number">10</span> 显示设置</span><br><span class="line"> </span><br><span class="line"> 分块读取</span><br><span class="line"> chunk = pd.read_csv(file,chunksize=<span class="number">1000</span>)</span><br><span class="line"> <span class="keyword">for</span> item <span class="keyword">in</span> chunk:</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="2-将数据写入文本格式"><a href="#2-将数据写入文本格式" class="headerlink" title="(2)将数据写入文本格式"></a>(2)将数据写入文本格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.to_csv(file)</span><br><span class="line">data.to_csv(file,sep&#x3D;&#39;|&#39;)</span><br><span class="line">data.to_csv(sys.stdout,na_rep&#x3D;&#39;NULL&#39;) 缺省值的表示</span><br><span class="line">data.to_csv(sys.stdout,index&#x3D;False) 不输出行的标签</span><br><span class="line">data.to_csv(sys.stdout,header&#x3D;False) 不输出列的标签</span><br><span class="line">data.to_csv(sys.stdout,columns&#x3D;[&#39;a&#39;,&#39;b&#39;]) 写入列的子集</span><br><span class="line"></span><br><span class="line">Series也有to_csv方法</span><br></pre></td></tr></table></figure>
<h3 id="（3）使用分隔CSV格式"><a href="#（3）使用分隔CSV格式" class="headerlink" title="（3）使用分隔CSV格式"></a>（3）使用分隔CSV格式</h3><p>python自带了csv库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line">with open(&#39;file&#39;,&#39;r&#39;) as f:</span><br><span class="line">	read &#x3D; csv.reader(f)</span><br><span class="line">	for i in read():</span><br><span class="line">		pass</span><br><span class="line">逐行读取</span><br></pre></td></tr></table></figure>
<p>reader可选参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>delimiter</td>
<td>分隔符</td>
</tr>
<tr>
<td>lineterminator</td>
<td>平台默认的行终止符</td>
</tr>
<tr>
<td>quotechar</td>
<td>用在含有特殊字符字段中的引号，默认是“</td>
</tr>
<tr>
<td>quoting</td>
<td>引用惯例。csv.QUOTE_ALL：引用所有字段，csv.QUOTE_MINIMAL:只使用特殊字符，。。。</td>
</tr>
<tr>
<td>skipinitialsqace</td>
<td>忽略分隔分隔符后的空白，默认False</td>
</tr>
<tr>
<td>doublequote</td>
<td>如何处理字段内部的引号。</td>
</tr>
<tr>
<td>escapechar</td>
<td>默认禁用。</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>写入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(file,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">  writer = csv.writer(f,dialect = my_dialect)</span><br><span class="line">  writer.writerow((<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="4-JSON"><a href="#4-JSON" class="headerlink" title="(4) JSON"></a>(4) JSON</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">json.dumps(obj)</span><br><span class="line">json.load(pbj)</span><br><span class="line"></span><br><span class="line">pandas.read_json(&#39;json file path&#39;) 默认每个对象是表里的一行</span><br><span class="line">data.to_json(orient&#x3D;&#39;record&#39;) 按照每一行数据一个&#123;&#125;记录</span><br></pre></td></tr></table></figure>
<h3 id="5-XML和HTML网络抓取"><a href="#5-XML和HTML网络抓取" class="headerlink" title="(5) XML和HTML网络抓取"></a>(5) XML和HTML网络抓取</h3><p>html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table &#x3D; pd.read_html(&#39;filename&#39;) 会搜并尝试解析所有包含在&lt;table&gt;标签中的表格型数据类型。</span><br><span class="line">table[0]</span><br></pre></td></tr></table></figure>
<p>xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from lxml import objectify</span><br><span class="line"></span><br><span class="line">parsed &#x3D; objectify.parse(open(path))</span><br><span class="line">root &#x3D; parsed.getroot()</span><br></pre></td></tr></table></figure>
<h2 id="2-二进制格式"><a href="#2-二进制格式" class="headerlink" title="2.二进制格式"></a>2.二进制格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pickle仅作为临时储存格式，由于库的更新，pickle化的对象未来可能无法被反序列化</span><br><span class="line">pd.read_pickle()</span><br><span class="line">pd.to_pickle()</span><br></pre></td></tr></table></figure>
<h3 id="1-使用HDF5格式"><a href="#1-使用HDF5格式" class="headerlink" title="(1)使用HDF5格式"></a>(1)使用HDF5格式</h3><p>HDF代表分层数据格式</p>
<p>每个HDF5文件可以储存多个数据集并且支持元数据</p>
<p>HDF5适用于处理不适合在内存中存储的超大型数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store &#x3D; pd.HDFStore(&#39;file&#39;)</span><br><span class="line">store[&#39;obj1&#39;] &#x3D; frame</span><br><span class="line">store[&#39;obj2&#39;] &#x3D; frame[&#39;a&#39;]</span><br><span class="line">store.put(&#39;obj2&#39;,frame,format&#x3D;&#39;table&#39;) 两种格式：table和fixed，TABLe格式支持特殊语法的查询操作</span><br><span class="line">store.select(&#39;obj2&#39;,where&#x3D;[&#39;index&gt;&#x3D;10 and index&lt;&#x3D;15&#39;])</span><br></pre></td></tr></table></figure>
<p>高阶方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame.to_hdf(&#39;file&#39;,&#39;obj3&#39;,format&#x3D;&#39;table&#39;)</span><br><span class="line">pd.read_hdf(&#39;mydata.h5&#39;,&#39;obj3&#39;,where&#x3D;[&#39;index&lt;5&#39;])</span><br></pre></td></tr></table></figure>
<h3 id="2-读取Microsoft-Excel文件"><a href="#2-读取Microsoft-Excel文件" class="headerlink" title="(2)读取Microsoft Excel文件"></a>(2)读取Microsoft Excel文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读取(推荐):</span><br><span class="line">xlsx &#x3D; pd.ExcelFile(&#39;exp.xlsx&#39;)</span><br><span class="line">df &#x3D; pd.read_excel(xlsx,&#39;sheet1&#39;)</span><br><span class="line">读取简化</span><br><span class="line">df &#x3D; pd.read_excel(&#39;exp.xlsx&#39;,&#39;sheet1&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="（3）与Web-API交互"><a href="#（3）与Web-API交互" class="headerlink" title="（3）与Web API交互"></a>（3）与Web API交互</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.get()</span><br><span class="line">request.post()</span><br></pre></td></tr></table></figure>
<h3 id="4-与数据库交互"><a href="#4-与数据库交互" class="headerlink" title="(4) 与数据库交互"></a>(4) 与数据库交互</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sqlalchemy as sqla</span><br><span class="line">db &#x3D; sqlalchemy.create_engine(&#39;sqlite:&#x2F;&#x2F;mydata.sqlite&#39;)</span><br><span class="line">pd.read_sql(&#39;select * from test&#39;,db)</span><br></pre></td></tr></table></figure>
<h1 id="四、数据的清洗与准备"><a href="#四、数据的清洗与准备" class="headerlink" title="四、数据的清洗与准备"></a>四、数据的清洗与准备</h1><h2 id="1-处理缺失值"><a href="#1-处理缺失值" class="headerlink" title="1.处理缺失值"></a>1.处理缺失值</h2><p>对于数据值型的数据，pandas使用NaN(Not a number)表示缺失值。我们称NaN为容易检测到的标识值。</p>
<p>方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dropna</td>
<td>根据每个标签的值是否是缺失值来筛选轴标签，并根据允许丢失的数据量来确定阈值</td>
</tr>
<tr>
<td>fillna</td>
<td>用某些值填充缺失的数据或使用差值方法</td>
</tr>
<tr>
<td>isnull</td>
<td>返回表明哪些值是缺失值的布尔值</td>
</tr>
<tr>
<td>notnull</td>
</tr>
</tbody>
</table>
</div>
<h3 id="（1）过滤缺失值"><a href="#（1）过滤缺失值" class="headerlink" title="（1）过滤缺失值"></a>（1）过滤缺失值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from numpy import nan as NA</span><br><span class="line"></span><br><span class="line"># 删除缺失值</span><br><span class="line"># 处理Series对象</span><br><span class="line">data &#x3D; pd.Series([1,NA,2,3423,4,NA])</span><br><span class="line">data.dropna()</span><br><span class="line"></span><br><span class="line">data[data.notnull()]</span><br><span class="line"></span><br><span class="line">#处理dataframe对象</span><br><span class="line">df.dropna() #默认删除包含缺失值的行</span><br><span class="line">df.dropna(how&#x3D;&#39;all&#39;) #删除所有值均为NA的行</span><br><span class="line">df.dropna(axis&#x3D;1，how&#x3D;&#39;all&#39;) #删除所有值均为NA的列</span><br><span class="line">df.dropna(thresh&#x3D;2) #保留至少有两个非NA数据的行</span><br></pre></td></tr></table></figure>
<h3 id="（2）补全缺失值"><a href="#（2）补全缺失值" class="headerlink" title="（2）补全缺失值"></a>（2）补全缺失值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 所有的缺失值用相同的值补全</span><br><span class="line">df.fillna(0)</span><br><span class="line"># 不同列使用不同的值进行补全</span><br><span class="line">df.fillna(&#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;)</span><br><span class="line">修改已经存在的对象</span><br><span class="line">df.fillna(0,inplace&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>fillna函数参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>标量值或字典型对象用于填充缺失值</td>
</tr>
<tr>
<td>method</td>
<td>差值方法，如果没有其他参数，默认是ffill</td>
</tr>
<tr>
<td>axis</td>
<td>需要填充的轴</td>
</tr>
<tr>
<td>inplace</td>
<td>修改对象，而不是生成一个视图</td>
</tr>
<tr>
<td>limit</td>
<td>用于前向或后向填充时最大的填充范围</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-数据转换"><a href="#2-数据转换" class="headerlink" title="2.数据转换"></a>2.数据转换</h2><h3 id="（1）删除重复值"><a href="#（1）删除重复值" class="headerlink" title="（1）删除重复值"></a>（1）删除重复值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.duplicated()  返回布尔值的Series，表示每一行是否存在重复</span><br><span class="line"></span><br><span class="line">data.drop_duplicates()  #删除相同的行</span><br><span class="line"></span><br><span class="line">data.drop_duplicates([&#39;k1&#39;])  #删除k1列相同的行</span><br><span class="line"></span><br><span class="line">data.drop_duplicates([&#39;k1&#39;,&#39;k2&#39;],keep&#x3D;&#39;last&#39;) #保留重复的最后一行</span><br></pre></td></tr></table></figure>
<h3 id="（2）使用函数或映射进行数据转换"><a href="#（2）使用函数或映射进行数据转换" class="headerlink" title="（2）使用函数或映射进行数据转换"></a>（2）使用函数或映射进行数据转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lowercased &#x3D; data[&#39;food&#39;].str.lower()</span><br><span class="line">lowercased.map(&#123;&#39;meat&#39;:&#39;pig&#39;&#125;)</span><br><span class="line"></span><br><span class="line">data[food].map(lambda x:meat_to_animal[x])</span><br></pre></td></tr></table></figure>
<h3 id="3-替代值"><a href="#3-替代值" class="headerlink" title="(3) 替代值"></a>(3) 替代值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">替换某些值</span><br><span class="line">data.replace(999,np.nan)</span><br><span class="line">data.replace([999,1000],np.nan)</span><br><span class="line"></span><br><span class="line">不同的值用不同的替换</span><br><span class="line">data.replace([999,1000],[np.nan,0])</span><br><span class="line">data.replace(&#123;999:np.nan,1000:0&#125;)</span><br><span class="line"></span><br><span class="line">data.str.replace是对字符串按照元素替代的</span><br></pre></td></tr></table></figure>
<h3 id="（4）重命名轴索引"><a href="#（4）重命名轴索引" class="headerlink" title="（4）重命名轴索引"></a>（4）重命名轴索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map索引并赋值</span><br><span class="line">data.index &#x3D; data.index.map(lambda x:x[:4].upper())</span><br><span class="line"></span><br><span class="line">使用rename函数</span><br><span class="line">data.rename(index&#x3D;str.title,columns&#x3D;str.upper)</span><br><span class="line">data.rename(index&#x3D;&#123;&#39;ohio&#39;:&#39;OHIO&#39;&#125;)</span><br><span class="line"></span><br><span class="line">inplace:替换原有数据集</span><br></pre></td></tr></table></figure>
<h3 id="（5）离散化和分箱-分段"><a href="#（5）离散化和分箱-分段" class="headerlink" title="（5）离散化和分箱(分段)"></a>（5）离散化和分箱(分段)</h3><p>将数据分段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cut按照数据值进行切分</span><br><span class="line">cats &#x3D; pd.cut(ages,bins)  ages是想要划分的数据，bins是区间的断点</span><br><span class="line">返回一个Categorical对象。</span><br><span class="line"></span><br><span class="line">cats.codes 返回每个数据属于那个箱的Series</span><br><span class="line">cats.categories 返回每个箱的区间</span><br><span class="line">pd.value_count(cats) 返回cats的值</span><br><span class="line"></span><br><span class="line">改变区间的开闭</span><br><span class="line">cats &#x3D; pd.cut(ages,bins，right&#x3D;false) 默认是右封闭</span><br><span class="line">自定义箱名</span><br><span class="line">cats &#x3D; pd.cut(ages,bins,lables&#x3D;[&#39;Youth&#39;,&quot;YoungAdult&quot;])</span><br><span class="line"></span><br><span class="line">根据最大值和最小值，创建等长的箱</span><br><span class="line">pd.cut(data,4,precision&#x3D;2)  将数据切成4份,每个区间长度相同</span><br><span class="line"></span><br><span class="line">qcut按照数据分位数进行切分</span><br><span class="line">pd.qcut(data,4) 	将数据切成4份，每个区间的数据数量相同</span><br><span class="line">pd.qcut(data,[0,0.1,0.5,1])</span><br><span class="line"></span><br><span class="line">labels&#x3D;False可以使得分组名返回数值</span><br></pre></td></tr></table></figure>
<h3 id="6-检测和过滤异常值"><a href="#6-检测和过滤异常值" class="headerlink" title="(6) 检测和过滤异常值"></a>(6) 检测和过滤异常值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出每列的信息</span><br><span class="line">data.describe()</span><br><span class="line"></span><br><span class="line">找出存在绝对值大于3的行</span><br><span class="line">data[(np.abs(data)&gt;3).any(axis&#x3D;1)]</span><br></pre></td></tr></table></figure>
<h3 id="7-置换和随机抽样"><a href="#7-置换和随机抽样" class="headerlink" title="(7)置换和随机抽样"></a>(7)置换和随机抽样</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">随机抽样：先生成一个随机序列，然后取样</span><br><span class="line">df.take(np.random.permutation(5))</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.DataFrame(np.arange(20).reshape(5,4))</span><br><span class="line">生成一个不含重复值的随机序列</span><br><span class="line">df.sample(n&#x3D;3)  #随机三个列</span><br><span class="line"></span><br><span class="line">生成一个含重复值的随机序列(有放回的抽取)</span><br><span class="line">df.sample(n&#x3D;10,replace&#x3D;True)</span><br></pre></td></tr></table></figure>
<h3 id="（8）计算指标-虚拟变量"><a href="#（8）计算指标-虚拟变量" class="headerlink" title="（8）计算指标/虚拟变量"></a>（8）计算指标/虚拟变量</h3><p><code>pd.get_dummies</code>将某一列变量转换为机器学习或统计建模可用的矩阵</p>
<p><img src="image/1562332179999.png" alt="1562332179999"></p>
<p>给变量添加前缀</p>
<p><img src="image/1562332266313.png" alt="1562332266313"></p>
<p>将get_dummies和cut等离散化函数连用</p>
<p><img src="image/1562333488951.png" alt="1562333488951"></p>
<h2 id="3-字符串操作"><a href="#3-字符串操作" class="headerlink" title="3.字符串操作"></a>3.字符串操作</h2><h3 id="（1）Python中的字符串方法"><a href="#（1）Python中的字符串方法" class="headerlink" title="（1）Python中的字符串方法"></a>（1）Python中的字符串方法</h3><h3 id="（2）正则表达式"><a href="#（2）正则表达式" class="headerlink" title="（2）正则表达式"></a>（2）正则表达式</h3><h3 id="（3）-pandas中的字符串函数"><a href="#（3）-pandas中的字符串函数" class="headerlink" title="（3） pandas中的字符串函数"></a>（3） pandas中的字符串函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pattern &#x3D; re.compile(&#39;\s+&#39;)</span><br><span class="line">data.str.findall(pattern,flags&#x3D;re.IGNORECASE)</span><br><span class="line">data.str.match(pattern)</span><br><span class="line">返回索引处的元素</span><br><span class="line">data.str.get(1)</span><br><span class="line">data.str[0]</span><br></pre></td></tr></table></figure>
<h1 id="五、数据规整：连接、联合和重塑"><a href="#五、数据规整：连接、联合和重塑" class="headerlink" title="五、数据规整：连接、联合和重塑"></a>五、数据规整：连接、联合和重塑</h1><h2 id="1、分层索引"><a href="#1、分层索引" class="headerlink" title="1、分层索引"></a>1、分层索引</h2><p>多级index</p>
<p><img src="image/1562336614212.png" alt="1562336614212"></p>
<p>将多层索引重塑 unstack()</p>
<p><img src="image/1562336661234.png" alt="1562336661234"></p>
<p>恢复 stack()</p>
<p><img src="image/1562336683445.png" alt="1562336683445"></p>
<p>多层索引对象</p>
<p><img src="image/image-20190706104149673-2380909.png" alt="image-20190706104149673"></p>
<h3 id="（1）重排序和层级排序"><a href="#（1）重排序和层级排序" class="headerlink" title="（1）重排序和层级排序"></a>（1）重排序和层级排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.swaplevel(&#39;key1&#39;,&#39;key2&#39;)</span><br><span class="line">df.sort_index(level&#x3D;0)  按照第0级的索引重新排序</span><br></pre></td></tr></table></figure>
<h3 id="（2）按层级进行汇总统计"><a href="#（2）按层级进行汇总统计" class="headerlink" title="（2）按层级进行汇总统计"></a>（2）按层级进行汇总统计</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.sum(level&#x3D;&#39;key1&#39;)</span><br><span class="line">df.sum(level&#x3D;&#39;color&#39;,axis&#x3D;1)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用DataFrame的列进行索引"><a href="#3-使用DataFrame的列进行索引" class="headerlink" title="(3)使用DataFrame的列进行索引"></a>(3)使用DataFrame的列进行索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.set_index([&#39;c&#39;,&#39;d&#39;])</span><br><span class="line">恢复</span><br><span class="line">df.reset_index()</span><br></pre></td></tr></table></figure>
<p><img src="image/image-20190706105620843-2381780.png" alt="image-20190706105620843"></p>
<h2 id="2-联合与合并数据集"><a href="#2-联合与合并数据集" class="headerlink" title="2.联合与合并数据集"></a>2.联合与合并数据集</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.merge:根据一个或多个键的值进行连接，类似于数据库中的join操作</span><br><span class="line">pd.concat:在axis的方向堆叠</span><br><span class="line">combine_first:允许将重叠数据拼接，来使用一个对象中的值填充到另一个对象中的缺失值。</span><br></pre></td></tr></table></figure>
<h3 id="（1）数据库风格的DataFrame-join操作"><a href="#（1）数据库风格的DataFrame-join操作" class="headerlink" title="（1）数据库风格的DataFrame join操作"></a>（1）数据库风格的DataFrame join操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.merge(df1,df2,on&#x3D;&#39;key&#39;)  内连接</span><br><span class="line">pd.merge(df1,df2,left_on&#x3D;&#39;key1&#39;,right_on&#x3D;&#39;key2&#39;) 当inner join的两个df的间不相同时，可以使用这种方法，等效inner join.</span><br><span class="line">pd.merge(df1,df2,how&#x3D;&#39;outer&#39;)  外连接</span><br><span class="line">pd.merge(df1,df2,on&#x3D;&#39;key&#39;,how&#x3D;&#39;left&#39;)  左连接</span><br><span class="line"></span><br><span class="line">多个键</span><br><span class="line">pd.merge(df1,df2,on&#x3D;[&#39;key1&#39;,&#39;key2&#39;])</span><br><span class="line"></span><br><span class="line">当两组数据中存在重叠的列名时，需要使用suffixes参数添加后缀</span><br><span class="line">pd.merge(df1,df2,on&#x3D;&#39;key1&#39;,suffixes&#x3D;[&#39;_left&#39;,&#39;_right&#39;])</span><br><span class="line"></span><br><span class="line">每一行数据的来源</span><br><span class="line">indicator参数，添加一个列返回数据来源</span><br><span class="line"></span><br><span class="line">使用行索引进行连接</span><br><span class="line">left_index&#x3D;True</span><br><span class="line">pd.merge(df1,df2,left_on&#x3D;&#39;key1&#39;,right_index&#x3D;&#39;True&#39;,how&#x3D;&#39;outer&#39;)</span><br><span class="line">简单的写法</span><br><span class="line">df1.join([df2,df3],how&#x3D;&#39;outer&#39;) 将直接根据索引进行连接</span><br></pre></td></tr></table></figure>
<h3 id="2-沿轴向连接"><a href="#2-沿轴向连接" class="headerlink" title="(2)沿轴向连接"></a>(2)沿轴向连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.concat([s1,s2,s3]) 默认沿着axis&#x3D;0的轴向生效，默认外连接</span><br><span class="line">pd.concat([s1,s2],axis&#x3D;1,join&#x3D;&#39;inner&#39;,join_axes&#x3D;[[&#39;a&#39;,&#39;b&#39;,&#39;e&#39;]])</span><br><span class="line"></span><br><span class="line">连接轴上创建多层索引</span><br><span class="line">pd.concat([s1,s2],keys&#x3D;[&#39;one&#39;,&#39;two&#39;]) 每一个连接对象对应一个索引</span><br><span class="line">pd.concat(&#123;&#39;one&#39;:s1,&#39;two&#39;:s2&#125;)</span><br><span class="line"></span><br><span class="line">pd.concat([s1,s2],ignor_index&#x3D;True)  忽略默认的index</span><br></pre></td></tr></table></figure>
<h3 id="（3）联合重叠数据"><a href="#（3）联合重叠数据" class="headerlink" title="（3）联合重叠数据"></a>（3）联合重叠数据</h3><p>使用传入的对象修补缺失值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df1.combine_first(df2)</span><br><span class="line">与下面的等价</span><br><span class="line">np.where(np.isnull(df1),df2,df1)</span><br></pre></td></tr></table></figure>
<h2 id="3-重塑和透视"><a href="#3-重塑和透视" class="headerlink" title="3.重塑和透视"></a>3.重塑和透视</h2><p>stack：“旋转”或将列中的数据透视到行</p>
<p>unstack:将行中的数据透视到列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df1.unstack(0)</span><br><span class="line">df1.unstack(&#39;state&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="image/image-20190706135311325-2392391.png" alt="image-20190706135311325"></p>
<p><img src="image/image-20190706135343353-2392423.png" alt="image-20190706135343353"></p>
<p><img src="image/image-20190706135400690-2392440.png" alt="image-20190706135400690"></p>
<h3 id="（1）将long的数据转换为wide的格式"><a href="#（1）将long的数据转换为wide的格式" class="headerlink" title="（1）将long的数据转换为wide的格式"></a>（1）将long的数据转换为wide的格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.pivot(&#39;data&#39;,&#39;item&#39;,&#39;value&#39;)  第一个参数作为行索引，第二个参数为列索引，第三个参数是填充df的值。</span><br><span class="line"></span><br><span class="line">pivot方法等价于按照set_index方法建立分层索引，然后unstack。</span><br></pre></td></tr></table></figure>
<p><img src="image/image-20190706140433052-2393073.png" alt="image-20190706140433052"></p>
<h3 id="（2）将width的数据转换为long的格式"><a href="#（2）将width的数据转换为long的格式" class="headerlink" title="（2）将width的数据转换为long的格式"></a>（2）将width的数据转换为long的格式</h3><p>pivot的相反的操作是melt：将多列合并为一列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.melt(df,[&#39;key&#39;])  [&#39;key&#39;]为分组指标</span><br><span class="line"></span><br><span class="line">指定列作为值列</span><br><span class="line">pd.melt(df,id_vars&#x3D;[&#39;key&#39;],value_vars&#x3D;[&#39;A&#39;,&#39;B&#39;])</span><br></pre></td></tr></table></figure>
<h1 id="pandas1-0-0新特性"><a href="#pandas1-0-0新特性" class="headerlink" title="pandas1.0.0新特性"></a>pandas1.0.0新特性</h1><h2 id="markdown导出"><a href="#markdown导出" class="headerlink" title="markdown导出"></a>markdown导出</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: df = pd.DataFrame(&#123;<span class="string">"A"</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">"B"</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;, index=[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: print(df.to_markdown())</span><br><span class="line">|    |   A |   B |</span><br><span class="line">|:---|----:|----:|</span><br><span class="line">| a  |   <span class="number">1</span> |   <span class="number">1</span> |</span><br><span class="line">| a  |   <span class="number">2</span> |   <span class="number">2</span> |</span><br><span class="line">| b  |   <span class="number">3</span> |   <span class="number">3</span> |</span><br></pre></td></tr></table></figure>
<h2 id="实验特性"><a href="#实验特性" class="headerlink" title="实验特性"></a>实验特性</h2><h3 id="NA"><a href="#NA" class="headerlink" title="NA"></a>NA</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: s = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="literal">None</span>], dtype=<span class="string">"Int64"</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: s</span><br><span class="line">Out[<span class="number">4</span>]: </span><br><span class="line"><span class="number">0</span>       <span class="number">1</span></span><br><span class="line"><span class="number">1</span>       <span class="number">2</span></span><br><span class="line"><span class="number">2</span>    &lt;NA&gt;</span><br><span class="line">Length: <span class="number">3</span>, dtype: Int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: s[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">5</span>]: &lt;NA&gt;</span><br></pre></td></tr></table></figure>
<h3 id="string和bool类型"><a href="#string和bool类型" class="headerlink" title="string和bool类型"></a>string和bool类型</h3><p>之前的时间和字符串都为object类型，现在可以更改为string和bool类型</p>
<h3 id="select-dtypes"><a href="#select-dtypes" class="headerlink" title="select_dtypes"></a>select_dtypes</h3><p><code>df.select_dtypes(&quot;string&quot;)</code>可以选择所有类型为string的列</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>数据分析</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python进行数据分析4（pandas数据处理进阶）</title>
    <url>/2020/02/17/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%904%EF%BC%88pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6%EF%BC%89/</url>
    <content><![CDATA[<h1 id="七、数据聚合和分组操作"><a href="#七、数据聚合和分组操作" class="headerlink" title="七、数据聚合和分组操作"></a>七、数据聚合和分组操作</h1><a id="more"></a>
<h2 id="1-GroupBy机制"><a href="#1-GroupBy机制" class="headerlink" title="1.GroupBy机制"></a>1.GroupBy机制</h2><p>groupby的结果会自动过滤掉非数值列</p>
<p><img src="image/image-20190707151329772-2483609-1934894.png" alt="image-20190707151329772"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####以自身的列作为键</span><br><span class="line">grouped &#x3D; df[&#39;data1&#39;].groupby(df[key1])</span><br><span class="line">grouped 是一个GroupBy对象</span><br><span class="line">grouped.mean() 返回对应键的均值</span><br><span class="line"></span><br><span class="line">grouped &#x3D; df[&#39;data1&#39;].groupby([df[&#39;key1&#39;],df[&#39;key2&#39;]]).mean()  #多层</span><br><span class="line"></span><br><span class="line"># 还可以直接使用列名进行分组</span><br><span class="line">df[&#39;data1&#39;].groupby(&#39;key1&#39;).mean()</span><br><span class="line">df[&#39;data1&#39;].groupby([&#39;key1&#39;,&#39;key2&#39;]).mean()</span><br></pre></td></tr></table></figure>
<p><img src="image/image-20190707153301322-2484781-1934894.png" alt="image-20190707153301322"></p>
<p>分组的键还可以是正确长度的任何数组：</p>
<p><img src="image/image-20190707153502518-2484902-1934894.png" alt="image-20190707153502518"></p>
<p><code>grouped.size()</code>返回一个包含组大小信息的Series。</p>
<h3 id="（1）遍历各分组"><a href="#（1）遍历各分组" class="headerlink" title="（1）遍历各分组"></a>（1）遍历各分组</h3><p>1.</p>
<p><img src="image/image-20190707154602162-2485562-1934894.png" alt="image-20190707154602162"></p>
<p>2.</p>
<p><img src="image/image-20190707154624660-2485584-1934894.png" alt="image-20190707154624660"></p>
<p>3.</p>
<p><img src="image/image-20190707154809186-2485689-1934894.png" alt="image-20190707154809186"></p>
<p>4.</p>
<p>​    axis=1 表示将每一列分给不同的组</p>
<p>​    默认axis=1表示将每一行分给不同的组</p>
<h3 id="（2）使用字典-Series分组"><a href="#（2）使用字典-Series分组" class="headerlink" title="（2）使用字典/Series分组"></a>（2）使用字典/Series分组</h3><p>1.使用字典作为索引</p>
<p><img src="image/image-20190707155643473-2486203-1934894.png" alt="image-20190707155643473"></p>
<p><img src="image/image-20190707155600334-2486160-1934894.png" alt="image-20190707155600334"></p>
<p><img src="image/image-20190707155616480-2486176-1934894.png" alt="image-20190707155616480"></p>
<p>2.使用Series作为索引</p>
<p><img src="image/image-20190707155729260-2486249-1934894.png" alt="image-20190707155729260"></p>
<p><img src="image/image-20190707155745929-2486265-1934894.png" alt="image-20190707155745929"></p>
<h3 id="（3）使用函数分组"><a href="#（3）使用函数分组" class="headerlink" title="（3）使用函数分组"></a>（3）使用函数分组</h3><p>将行索引作为调用函数的参数，以返回值作为分组依据</p>
<p><code>df.groupby(len).sum()</code></p>
<h3 id="（4）以索引层级进行分组"><a href="#（4）以索引层级进行分组" class="headerlink" title="（4）以索引层级进行分组"></a>（4）以索引层级进行分组</h3><p><img src="image/image-20190707160358983-2486639-1934894.png" alt="image-20190707160358983"></p>
<p><img src="image/image-20190707160412210-2486652-1934894.png" alt="image-20190707160412210"></p>
<h2 id="2-数据聚合"><a href="#2-数据聚合" class="headerlink" title="2.数据聚合"></a>2.数据聚合</h2><p>apply方法传入的是整个dataframe，而agg方法传入的是每一列数据</p>
<p>常用的聚合方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>非NA值的数量</td>
</tr>
<tr>
<td>sum</td>
<td>非NA值的和</td>
</tr>
<tr>
<td>mean</td>
<td>非NA值的均值</td>
</tr>
<tr>
<td>median</td>
<td>非NA值的中位数</td>
</tr>
<tr>
<td>std，var</td>
<td>无偏的（分母n-1）标准差和方差</td>
</tr>
<tr>
<td>min，max</td>
<td>非NA值的最值</td>
</tr>
<tr>
<td>prod</td>
<td>非NA值的乘积</td>
</tr>
<tr>
<td>first，last</td>
<td>非NA值的第一个，最后一个</td>
</tr>
</tbody>
</table>
</div>
<p>Series的方法生来就可以用于聚合</p>
<p>自定义聚合方法：</p>
<p><img src="image/image-20190707161508864-2487308-1934894.png" alt="image-20190707161508864"></p>
<p>同时使用多个聚合函数：传入函数名列表</p>
<p>​        <code>grouped.agg([&#39;sum&#39;,&#39;std&#39;,peak_to_peak])</code></p>
<p>使用多个聚合函数时的列名难以辨认：可以通过传入元组列表（name，function）</p>
<p>​        <code>grouped.agg([(&#39;mean&#39;,&#39;foo&#39;)])</code>    </p>
<p>对不同的列使用不同的聚合函数：传入字典列表{列名：函数名}</p>
<p>​    <code>grouped.agg({&#39;tip&#39;:np.max})</code></p>
<p>​    <code>grouped.agg({&#39;tip&#39;:[np.max,&#39;sum&#39;]})</code></p>
<p>返回不含行索引的聚合数据：</p>
<p>​        <code>df.groupby(&#39;key1&#39;,as_index=False)</code></p>
<p>也可以将结果进行reset_index()获得，但as_index方法可以避免不必要的计算</p>
<h2 id="3-应用（split-apply-combine）"><a href="#3-应用（split-apply-combine）" class="headerlink" title="3.应用（split-apply-combine）"></a>3.应用（split-apply-combine）</h2><p>对分组后的df采用apply（）方法，函数必须返回标量值或pandas对象</p>
<p><img src="image/image-20190707164001487-2488801-1934894.png" alt="image-20190707164001487"></p>
<p><img src="image/image-20190707164047780-2488847-1934894.png" alt="image-20190707164047780"></p>
<p>apply方法可以传入关键字参数：</p>
<p><img src="image/image-20190707164145159-2488905-1934894.png" alt="image-20190707164145159"></p>
<h3 id="（1）压缩分组键"><a href="#（1）压缩分组键" class="headerlink" title="（1）压缩分组键"></a>（1）压缩分组键</h3><p>不显示分组的键：</p>
<p><code>df.groupby(&#39;key1&#39;,group_keys=False)</code></p>
<h3 id="（2）分位数与桶分析"><a href="#（2）分位数与桶分析" class="headerlink" title="（2）分位数与桶分析"></a>（2）分位数与桶分析</h3><p>cut后的对象可直接传入groupby方法。</p>
<p><img src="image/image-20190707165346518-2489626-1934894.png" alt="image-20190707165346518"></p>
<p><img src="image/image-20190707165403700-2489643-1934894.png" alt="image-20190707165403700"></p>
<p><img src="image/image-20190707165456115-2489696-1934894.png" alt="image-20190707165456115"></p>
<h2 id="4-数据透视表与交叉表"><a href="#4-数据透视表与交叉表" class="headerlink" title="4.数据透视表与交叉表"></a>4.数据透视表与交叉表</h2><p><code>df.pivot_table(index=[&#39;day&#39;,&#39;smoker&#39;])</code></p>
<p>如果只想在tip_pct和size上聚合，并根据time分组。把day放入行，smoker放入列。</p>
<p><code>df.pivot_table([&#39;tip_pct&#39;,&#39;size&#39;],index=[&#39;time&#39;,&#39;day&#39;],columns=&#39;smoker&#39;)</code></p>
<p>添加margins=True会添加All行和列表标签，这会返回单层中所有数据的分组统计值。All为均值</p>
<p>可以添加aggfunc参数：</p>
<p><img src="image/image-20190707172634853-2491594-1934894.png" alt="image-20190707172634853"></p>
<p>参数：</p>
<p><img src="image/image-20190707172657002-2491617-1934894.png" alt="image-20190707172657002"></p>
<h3 id="（1）交叉表"><a href="#（1）交叉表" class="headerlink" title="（1）交叉表"></a><strong>（1）交叉表</strong></h3><p>计算的是分组中的数据出现的次数。</p>
<p><code>pd.crosstab([df.time,df.dat],tips.smoker,margins=True)</code></p>
<p>参数依次为：index，columms，</p>
<h1 id="八、时间序列"><a href="#八、时间序列" class="headerlink" title="八、时间序列"></a>八、时间序列</h1><p><code>pd.read_csv(filename,parse_dates=True,index_col=0)</code></p>
<h3 id="1-日期和时间数据的类型及工具"><a href="#1-日期和时间数据的类型及工具" class="headerlink" title="1.日期和时间数据的类型及工具"></a>1.日期和时间数据的类型及工具</h3><p>常用的python库：<code>time,datetime,calendar</code></p>
<p><img src="image/image-20190707190118479-2497278-1934894.png" alt="image-20190707190118479"></p>
<h3 id="1-字符串与datetime的转化"><a href="#1-字符串与datetime的转化" class="headerlink" title="(1)字符串与datetime的转化"></a>(1)字符串与datetime的转化</h3><p>str方法和strftime方法</p>
<p><img src="image/image-20190707190313148-2497393-1934894.png" alt="image-20190707190313148"></p>
<p>datetime格式</p>
<p><img src="image/image-20190707190438413-2497478-1934894.png" alt="image-20190707190438413"></p>
<p><img src="image/image-20190707190453233-2497493-1934894.png" alt="image-20190707190453233"></p>
<p>使用相同的方法可以将str转换为datetime格式</p>
<p><img src="image/image-20190707190558121-2497558-1934894.png" alt="image-20190707190558121"></p>
<p>dateutil库能够自动解析日期并转换为datetime格式（日期在月份前可以使用dayfirst=True参数）：</p>
<p><img src="image/image-20190707190808858-2497688-1934894.png" alt="image-20190707190808858"></p>
<p>pandas中的日期：</p>
<p><img src="image/image-20190707191141642-2497901-1934894.png" alt="image-20190707191141642"></p>
<h2 id="2-时间序列基础"><a href="#2-时间序列基础" class="headerlink" title="2.时间序列基础"></a>2.时间序列基础</h2><p>不同索引的时间序列之间的算术运算在日期上自动对齐</p>
<p><img src="image/image-20190707191649370-2498209-1934894.png" alt="image-20190707191649370"></p>
<h3 id="（1）索引、选择、子集"><a href="#（1）索引、选择、子集" class="headerlink" title="（1）索引、选择、子集"></a>（1）索引、选择、子集</h3><p>索引：</p>
<p>1）基于标签索引</p>
<p><img src="image/image-20190707191748664-2498268-1934894.png" alt="image-20190707191748664"></p>
<p>2）使用能解释为日期的字符串</p>
<p><img src="image/image-20190707191838407-2498318-1934894.png" alt="image-20190707191838407"></p>
<p>3）使用切片：通过传递年份或年份加月份（可以使用不在索引中的时间戳进行切片）</p>
<p><img src="image/image-20190707191932392-2498372-1934894.png" alt="image-20190707191932392"></p>
<p><img src="image/image-20190707191957091-2498397-1934894.png" alt="image-20190707191957091"></p>
<p>​    使用truncate切片：</p>
<p><img src="image/image-20190707192308408-2498588-1934894.png" alt="image-20190707192308408"></p>
<h2 id="3-日期范围、频率和移位"><a href="#3-日期范围、频率和移位" class="headerlink" title="3.日期范围、频率和移位"></a>3.日期范围、频率和移位</h2><h3 id="（1）生成日期范围"><a href="#（1）生成日期范围" class="headerlink" title="（1）生成日期范围"></a>（1）生成日期范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.date_range(&#39;2012-04-01&#39;,&#39;2012-06-01&#39;)  #默认以天为间隔</span><br><span class="line">pd.date_range(start&#x3D;&#39;2012-04-01&#39;,periods&#x3D;20)  #生成20个时间</span><br><span class="line">pd.date_range(end&#x3D;&#39;2012-04-01&#39;,periods&#x3D;20)  #生成20个时间</span><br><span class="line">pd.date_range(&#39;2000-01-01&#39;,&#39;2000-12-01&#39;,freq&#x3D;&#39;BM&#39;) #在区间内按照频率生成</span><br><span class="line">pd.date_range(&#39;2012-05-06 12:56:31&#39;,periods&#x3D;5,normalize&#x3D;True) #生成的列表中不包含时刻，只有日期</span><br></pre></td></tr></table></figure>
<p><img src="image/image-20190707193307614-2499187.png" alt="image-20190707193307614"></p>
<h3 id="（2）频率和日期offset"><a href="#（2）频率和日期offset" class="headerlink" title="（2）频率和日期offset"></a>（2）频率和日期offset</h3><p><code>pandas.tseries.offsets</code>中有Hour，Minute等对象，大多数情况下不需要主动创建</p>
<p>可以传递的freq参数：‘4h‘，’1h30min‘</p>
<p><img src="image/image-20190707193811689-2499491.png" alt="image-20190707193811689"></p>
<p>offset可以通过加法结合：</p>
<p><img src="image/image-20190707193847245-2499527.png" alt="image-20190707193847245"></p>
<h3 id="3-移位"><a href="#3-移位" class="headerlink" title="(3)移位"></a>(3)移位</h3><p>将时间戳对应的数据前移或后移。</p>
<p><img src="image/image-20190707194308970-2499789.png" alt="image-20190707194308970"></p>
<p>指定freq后，将会改变时间戳，而不会改变数据</p>
<p><img src="image/image-20190707194657856-2500017.png" alt="image-20190707194657856"></p>
<p>使用offset：    <img src="image/image-20190707195000813-2500200.png" alt="image-20190707195000813"></p>
<p><img src="image/image-20190707195032012-2500232.png" alt="image-20190707195032012"></p>
<p>rowback和rollforward：</p>
<p><img src="image/image-20190707195118522-2500278.png" alt="image-20190707195118522"></p>
<p>offset与groupby结合</p>
<p><img src="image/image-20190707195140170-2500300.png" alt="image-20190707195140170"></p>
<h2 id="4-时区处理"><a href="#4-时区处理" class="headerlink" title="4.时区处理"></a>4.时区处理</h2><h3 id="（1）时区的本地化和转换"><a href="#（1）时区的本地化和转换" class="headerlink" title="（1）时区的本地化和转换"></a>（1）时区的本地化和转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.index.tz      查看当前的index的时区属性</span><br><span class="line">生成时直接设定</span><br><span class="line">rng &#x3D; pd.data_range(&#39;2012-01-01 12:01&#39;,period&#x3D;10,tz&#x3D;&#39;UTC&#39;)</span><br><span class="line">ts &#x3D; pd.Series(np.random.randn(len(rng)),index&#x3D;rng)</span><br><span class="line"></span><br><span class="line">将时区转化为本地化时区</span><br><span class="line">ts.tz_localize(&#39;UTC&#39;)</span><br><span class="line">ts_shanghai &#x3D; ts.tz_localize(&#39;Asia&#x2F;Shanghai&#39;)</span><br><span class="line">ts_shanghai.tz_convert(&#39;UTC&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="2-时区感知时间戳对象的操作"><a href="#2-时区感知时间戳对象的操作" class="headerlink" title="(2)时区感知时间戳对象的操作"></a>(2)时区感知时间戳对象的操作</h3><p>时间戳对象也可直接进行时区操作</p>
<p><img src="image/image-20190707200326507-2501006.png" alt="image-20190707200326507"></p>
<p><img src="image/image-20190707200340558-2501020.png" alt="image-20190707200340558"></p>
<h3 id="（3）不同时区间的操作"><a href="#（3）不同时区间的操作" class="headerlink" title="（3）不同时区间的操作"></a>（3）不同时区间的操作</h3><p>两个时区不同的时间序列联合时，结果为UTC时间</p>
<h2 id="5-时间区间和区间算数"><a href="#5-时间区间和区间算数" class="headerlink" title="5.时间区间和区间算数"></a>5.时间区间和区间算数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pandas区间：</span><br><span class="line">p &#x3D; pd.Period(2007,freq&#x3D;&#39;A-DEC&#39;)</span><br><span class="line">p+2</span><br><span class="line">p-5</span><br><span class="line">p - pd.Period(2005,freq&#x3D;&#39;A-DEC&#39;)  # 2</span><br><span class="line"></span><br><span class="line">pandas区间序列：</span><br><span class="line">pd.period_range(&#39;2000-01-01&#39;,&#39;2000-06-30&#39;,freq&#x3D;&#39;M&#39;)</span><br><span class="line">使用数组生成区间序列：</span><br><span class="line">pd.PeriodIndex([&#39;200103&#39;,&#39;200104&#39;],freq&#x3D;&#39;Q-DEC&#39;)</span><br><span class="line">pd.PeriodIndex(year&#x3D;yearlist,quarter&#x3D;quaterlist,freq&#x3D;&#39;Q-DEC&#39;)</span><br><span class="line"></span><br><span class="line">区间频率的转换</span><br><span class="line">p.asfreq(&#39;M&#39;,how&#x3D;&#39;start&#39;)  # 低频率向高频率转换</span><br><span class="line"># 高频率向低频率转换时，直接根据自区间所属决定父区间</span><br><span class="line"></span><br><span class="line"># 时间戳转化为区间</span><br><span class="line">pts &#x3D; ts.to_period(&#39;M&#39;)  #转换的频率可以不指定</span><br><span class="line"># 区间转换为时间戳</span><br><span class="line">ts &#x3D; pts.to_timestamp(how&#x3D;&#39;end&#39;)</span><br><span class="line"></span><br><span class="line"># 从数组生成PeriodIndex</span><br></pre></td></tr></table></figure>
<h2 id="6-重采样"><a href="#6-重采样" class="headerlink" title="6.重采样"></a>6.重采样</h2><p>从低频率转换到高频率：向上采样</p>
<p>从高频率转换到低频率：向下采样</p>
<p>resample方法的参数：</p>
<p><img src="image/image-20190707203721264-2503041.png" alt="image-20190707203721264"></p>
<h3 id="（1）下采样"><a href="#（1）下采样" class="headerlink" title="（1）下采样"></a>（1）下采样</h3><p><img src="image/image-20190707204059651-2503259.png" alt="image-20190707204059651"></p>
<h3 id="（2）开高低收"><a href="#（2）开高低收" class="headerlink" title="（2）开高低收"></a>（2）开高低收</h3><p><code>ts.resample(&#39;5min&#39;).ohlc()</code></p>
<h3 id="3-向上采样与差值"><a href="#3-向上采样与差值" class="headerlink" title="(3)向上采样与差值"></a>(3)向上采样与差值</h3><p>使用asfreq()在不聚合的情况下转到高频率</p>
<p><code>df.resample(&#39;D&#39;).asfreq()</code></p>
<p>差值或向前填充</p>
<p><code>df.resample(&#39;D&#39;).ffill()</code></p>
<h3 id="4-使用时间区间进行重采样"><a href="#4-使用时间区间进行重采样" class="headerlink" title="(4)使用时间区间进行重采样"></a>(4)使用时间区间进行重采样</h3><p>由于区间涉及时间范围：</p>
<ul>
<li>在向下采样中，目标频率必须是原频率的子区间</li>
<li>在向上采样中，目标频率必须是原频率的父区间</li>
</ul>
<h2 id="7-移动窗口函数"><a href="#7-移动窗口函数" class="headerlink" title="7.移动窗口函数"></a>7.移动窗口函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.COL1.rolling(250,min_periods&#x3D;10).mean()</span><br><span class="line">df.COL1.expanding().mean()</span><br><span class="line">df.COL1.ewm(span&#x3D;30).mean() #指数加权函数，给近期的观测值更高的权重,span为跨度</span><br><span class="line"></span><br><span class="line">二元移动窗口</span><br><span class="line">pd.COL2.rolling(125,min_period&#x3D;10).corr(pd.COL1)</span><br><span class="line">pd.rolling(125,min_period&#x3D;10).corr(pd.COL1)</span><br><span class="line"></span><br><span class="line">自定义窗口函数只要输入为一个序列返回一个单值即可</span><br></pre></td></tr></table></figure>
<h1 id="九、高阶Pandas"><a href="#九、高阶Pandas" class="headerlink" title="九、高阶Pandas"></a>九、高阶Pandas</h1><h2 id="1-分类数据"><a href="#1-分类数据" class="headerlink" title="1.分类数据"></a>1.分类数据</h2><h3 id="（1）Categorical对象"><a href="#（1）Categorical对象" class="headerlink" title="（1）Categorical对象"></a>（1）Categorical对象</h3><p><img src="image/image-20190707210848754-2504928.png" alt="image-20190707210848754"></p>
<p>Series转换为category类型的数据</p>
<p><img src="image/image-20190707210900725-2504940.png" alt="image-20190707210900725"></p>
<p>category.value对象有两个属性：codes和categories。</p>
<p><img src="image/image-20190707211003754-2505003.png" alt="image-20190707211003754"></p>
<p><img src="image/image-20190707211015462-2505015.png" alt="image-20190707211015462"></p>
<p>可以通过python序列直接创建pandas.Categorical对象</p>
<p><img src="image/image-20190707211320833-2505200.png" alt="image-20190707211320833"></p>
<p>通过codes和categories构建</p>
<p><img src="image/image-20190707211422094-2505262.png" alt="image-20190707211422094"></p>
<p>访问category对象的分类方法(通过cat)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df1.cat.codes</span><br><span class="line">df1.cat.categories</span><br><span class="line">df2.cat.set_categories([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])</span><br></pre></td></tr></table></figure>
<p>Categories方法</p>
<p><img src="image/image-20190707212549393-2505949.png" alt="image-20190707212549393"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Categorical(df[<span class="string">'thal'</span>]).cat.codes  <span class="comment">#Categorial对应的index值</span></span><br></pre></td></tr></table></figure>
<h2 id="2-GroupBy高阶应用"><a href="#2-GroupBy高阶应用" class="headerlink" title="2.GroupBy高阶应用"></a>2.GroupBy高阶应用</h2><h3 id="（1）分组转换和展开Groupby"><a href="#（1）分组转换和展开Groupby" class="headerlink" title="（1）分组转换和展开Groupby"></a>（1）分组转换和展开Groupby</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.DataFrame(&#123;&#39;key&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]*4,&#39;value&#39;:np.arange(12)&#125;)</span><br><span class="line">gdf &#x3D; df.groupby(&#39;key&#39;).value  #返回的是Series对象</span><br><span class="line">gdf.mean()  #	每一组的平均值</span><br><span class="line">gdf.transform(&#39;mean&#39;)  #将每一组的平均值赋值给该组每一个元素，然后返回</span><br><span class="line">gdf.transform(lambda x:x.mean())</span><br></pre></td></tr></table></figure>
<h3 id="（2）方法链技术"><a href="#（2）方法链技术" class="headerlink" title="（2）方法链技术"></a>（2）方法链技术</h3><p>方法链可以减少中间变量</p>
<p>两种等价的赋值方式</p>
<p><img src="image/image-20190707214825897-2507305.png" alt="image-20190707214825897"></p>
<h3 id="（3）pipe方法"><a href="#（3）pipe方法" class="headerlink" title="（3）pipe方法"></a>（3）pipe方法</h3><p>两种等价形式</p>
<p><img src="image/image-20190707215347390-2507627.png" alt="image-20190707215347390"></p>
<p><img src="image/image-20190707215409912-2507649.png" alt="image-20190707215409912"></p>
<h2 id="十、Python建模库"><a href="#十、Python建模库" class="headerlink" title="十、Python建模库"></a>十、Python建模库</h2><p>将pandas的DataFrame对象转换为numpy数组：df1.value</p>
<p>Patsy库</p>
<p>Statsmodels库</p>
<p>scikit-learn库</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划问题</title>
    <url>/2020/04/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>动态规划问题的关键在于记住已经求过的解，记住求解的方式有两种：①自顶向下的备忘录法 ②自底向上。<br>①自顶向下的备忘录法<br>即在计算过程中，将中间结果记录在数组中，为下次使用作准备。<br>②自底向上<br>先计算出子结果，再进行计算。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>利用python进行数据分析1（numpy和pandas基础）</title>
    <url>/2020/02/17/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%901%EF%BC%88numpy%E5%92%8Cpandas%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    <content><![CDATA[<p>ipynb案例：推荐使用<a href="https://github.com/sjtu-xx/scientific-packages-for-python/" target="_blank" rel="noopener">https://github.com/sjtu-xx/scientific-packages-for-python/</a></p>
<h1 id="一、numpy"><a href="#一、numpy" class="headerlink" title="一、numpy"></a>一、numpy</h1><a id="more"></a>
<h2 id="1-ndarray"><a href="#1-ndarray" class="headerlink" title="1.ndarray"></a>1.ndarray</h2><h3 id="（1）生成ndarray"><a href="#（1）生成ndarray" class="headerlink" title="（1）生成ndarray"></a>（1）生成ndarray</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array （将输入转换为ndarray，自动复制）</span><br><span class="line">np.asarray (输入转换为ndarray，已经为ndarray不再复制)</span><br><span class="line">np.arange  np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>)</span><br><span class="line">np.ones</span><br><span class="line">np.ones_like</span><br><span class="line">np.zeros</span><br><span class="line">np.zeros_like</span><br><span class="line">np.empty</span><br><span class="line">np.empty_like</span><br><span class="line">np.full</span><br><span class="line">np.full_like</span><br><span class="line">np.eye,np.identity (单位矩阵)</span><br><span class="line">np.random.randn(<span class="number">6</span>,<span class="number">3</span>) 	生成正态分布的<span class="number">6</span>*<span class="number">3</span>的数组</span><br></pre></td></tr></table></figure>
<h3 id="（2）数据类型和大小"><a href="#（2）数据类型和大小" class="headerlink" title="（2）数据类型和大小"></a>（2）数据类型和大小</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设定</span><br><span class="line">a&#x3D; np.array([1,2,3],dtype&#x3D;np.int32)</span><br><span class="line">查看</span><br><span class="line">a.dtype</span><br><span class="line">更改</span><br><span class="line">a.astype()</span><br><span class="line"></span><br><span class="line">a.shape 数组的尺寸</span><br><span class="line">a.ndim 数组的维度</span><br><span class="line"></span><br><span class="line">&gt; means ‘big-endian’</span><br></pre></td></tr></table></figure>
<p>删除：np.delete(a,[0,3])     删除索引处的值</p>
<p>插入：np.append(ndarray, elements, axis)\np.insert(ndarray, index, elements, axis)</p>
<h3 id="（3）数组算数"><a href="#（3）数组算数" class="headerlink" title="（3）数组算数"></a>（3）数组算数</h3><p>1.相同尺寸的数组操作：对应元素操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr + arr</span><br><span class="line">arr - arr</span><br><span class="line">arr * arr</span><br></pre></td></tr></table></figure>
<p>2.带有标量计算的操作：将参数传递给每个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>/arr</span><br><span class="line">arr**<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>3.同尺寸数组比较：产生同尺寸布尔数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2 &gt; arr1</span><br></pre></td></tr></table></figure>
<h3 id="（4）索引和切片"><a href="#（4）索引和切片" class="headerlink" title="（4）索引和切片"></a>（4）索引和切片</h3><p><strong>索引返回的是对象的视图（自己认为是返回对象的引用）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">索引与赋值：</span><br><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">arr[::<span class="number">2</span>] 从<span class="number">0</span>开始，步长为<span class="number">2</span></span><br><span class="line">索引数组的变化会体现在原数组上</span><br><span class="line">arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">arr_slice[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">复制：</span><br><span class="line">arr_copy = arr[<span class="number">5</span>:<span class="number">8</span>].copy()</span><br><span class="line"></span><br><span class="line">二维索引(两种方法等价)：</span><br><span class="line">arr[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">arr[<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">arr[:<span class="number">2</span>] 前两行</span><br><span class="line">arr[<span class="number">1</span>,:<span class="number">2</span>] 	第一行前两列</span><br><span class="line"></span><br><span class="line">布尔索引</span><br><span class="line">data == <span class="number">1</span> 	返回与data同尺寸的布尔数组</span><br><span class="line">data[data==<span class="number">1</span>]   </span><br><span class="line">类似的有 </span><br><span class="line">取反操作： ~(data==<span class="number">1</span>)   data!=<span class="number">1</span> </span><br><span class="line">或操作： (data==<span class="number">1</span>)|(data==<span class="number">2</span>)</span><br><span class="line">与操作： (data==<span class="number">1</span>)&amp;(data==<span class="number">2</span>)</span><br><span class="line">比较： data&lt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">data[name == <span class="string">'Bob'</span>] 若name是一维数组，且大小与data数组轴索引长度一致，则返回<span class="literal">True</span>对应的行</span><br><span class="line"></span><br><span class="line">神奇索引</span><br><span class="line">arr[[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]] 将依次返回对应的行</span><br><span class="line">arr[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]] 	将返回(<span class="number">4</span>，<span class="number">1</span>)，(<span class="number">2</span>，<span class="number">2</span>)，(<span class="number">3</span>，<span class="number">3</span>)对应的值</span><br><span class="line"></span><br><span class="line">查找：</span><br><span class="line">arr.searchsorted(<span class="number">0.5</span>) 在已经排序的数组中查找<span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<h3 id="（5）数组的转置和换轴"><a href="#（5）数组的转置和换轴" class="headerlink" title="（5）数组的转置和换轴"></a>（5）数组的转置和换轴</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.T 转置</span><br><span class="line">arr.transpose(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>) （<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>）轴替换为（<span class="number">1</span>，<span class="number">0</span>，<span class="number">2</span>）轴</span><br><span class="line">arr.swapaxes(<span class="number">1</span>,<span class="number">2</span>) 交换<span class="number">1</span>，<span class="number">2</span>轴，返回数组的视图，没有对原数组进行复制</span><br></pre></td></tr></table></figure>
<h2 id="2-通用函数：快速的逐元素数组函数"><a href="#2-通用函数：快速的逐元素数组函数" class="headerlink" title="2.通用函数：快速的逐元素数组函数"></a>2.通用函数：快速的逐元素数组函数</h2><h3 id="（1）一元ufunc"><a href="#（1）一元ufunc" class="headerlink" title="（1）一元ufunc"></a>（1）一元ufunc</h3><ol>
<li><p><code>abs、fabs</code>计算整数、浮点数或复数的绝对值。对于非复数值，可以使用更快的fabs。</p>
</li>
<li><p><code>log10，log2，log1p</code>，其底数分别为，10,2；以及log（1+ P)</p>
</li>
<li><p><code>singn</code> 计算个元素正负号，1（正数），0（零），-1（负数）</p>
</li>
<li><p><code>ceil</code>返回大于等于该值的最小整数。</p>
</li>
<li><p><code>floor</code> 返回小于等于该值的最大整数。</p>
</li>
<li><p><code>rint</code>四舍五入，保留dtype。</p>
</li>
<li><p><code>modf</code>将数组的小数和整数部分一两个独立数组的形式返回。</p>
</li>
<li><p><code>isnan</code>返回布尔型数组，表示哪些值是NaN（非数字）。</p>
</li>
<li><p><code>isfinite/isinf</code>返回布尔型数组，表示哪些元素是有穷的（非inf，非NaN）或那些是无穷的。</p>
</li>
<li><p><code>cos,cosh,sin,sinh,tan,tanh</code>普通型和双曲型三角函数。</p>
</li>
<li><p><code>arccos,arccosh,arcsin,arcsinh,asrtan,arctanh</code>反三角函数。</p>
</li>
<li><p><code>logical_not</code>计算个元素的not x的真值，相当于-arr。</p>
</li>
</ol>
<h3 id="（2）二元ufunc"><a href="#（2）二元ufunc" class="headerlink" title="（2）二元ufunc"></a>（2）二元ufunc</h3><ol>
<li><p><code>add</code>   元素对应相加。</p>
</li>
<li><p><code>subtract</code>   第一个数组元素减去第二个的元素。</p>
</li>
<li><p><code>multiply</code> 数组元素相乘。</p>
</li>
<li><p><code>divide,floor_divide</code>    除法，或向下整除（丢弃余数）。</p>
</li>
<li><p><code>power</code>第一个数组中的元素A，第二个数组中的元素B，返回A的B次方。</p>
</li>
<li><p><code>maximum,fmax</code>返回两个数组中较大值组成的数组。fmax忽略NaN。</p>
</li>
<li><p><code>minimum,fmin</code>同上。</p>
</li>
<li><p><code>mod</code>求模，即求余数。</p>
</li>
<li><p><code>copysign</code>第二个数组的符号，复制给第一个数组。</p>
</li>
<li><p><code>greater,greater_equal,less,less_equal,equal,not_euqal</code>元素级比较运算，最终产生布尔型数组，相当于&gt;,&gt;=,&lt;,&lt;=,==,!=。</p>
</li>
<li><p><code>logical_and,logical_or,logical_xor</code>元素级真值运算，相当于&amp;，|，^。</p>
</li>
</ol>
<h2 id="3-使用数组进行面向数组编程"><a href="#3-使用数组进行面向数组编程" class="headerlink" title="3.使用数组进行面向数组编程"></a>3.使用数组进行面向数组编程</h2><h3 id="（1）将条件逻辑作为数组操作"><a href="#（1）将条件逻辑作为数组操作" class="headerlink" title="（1）将条件逻辑作为数组操作"></a>（1）将条件逻辑作为数组操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.where(cond,xarr,yarr)  等价于 x <span class="keyword">if</span> condition <span class="keyword">else</span> y, cond布尔数组，xarr，yarr同大小数组</span><br><span class="line">np.where(a&gt;<span class="number">0</span>,<span class="number">2</span>,<span class="number">-2</span>) 大于<span class="number">0</span>填<span class="number">2</span>，否则<span class="number">-2</span></span><br></pre></td></tr></table></figure>
<h3 id="（2）数学和统计方法"><a href="#（2）数学和统计方法" class="headerlink" title="（2）数学和统计方法"></a>（2）数学和统计方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">均值</span><br><span class="line">np.mean(arr)</span><br><span class="line">arr.mean()</span><br><span class="line">arr.mean(axis=<span class="number">1</span>) 指定轴的操作</span><br><span class="line"></span><br><span class="line">sum 求和</span><br><span class="line">mean 平均</span><br><span class="line">std，var  标准差和方差</span><br><span class="line">min，max 最值</span><br><span class="line">argmin，argmax 最值的位置</span><br><span class="line">cumsum 累加和，可以对指定的轴进行累加</span><br><span class="line">cumprod 累乘，可以对指定的轴进行累乘</span><br></pre></td></tr></table></figure>
<h3 id="（3）布尔数组的方法"><a href="#（3）布尔数组的方法" class="headerlink" title="（3）布尔数组的方法"></a>（3）布尔数组的方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="literal">True</span>,<span class="literal">False</span>])</span><br><span class="line">a.sum()  计算<span class="literal">True</span>的个数</span><br><span class="line">a.any()   <span class="literal">True</span>，any可以接受axis参数</span><br><span class="line">a.all()   <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="（4）排序"><a href="#（4）排序" class="headerlink" title="（4）排序"></a>（4）排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.sort()</span><br><span class="line">arr.sort(<span class="number">1</span>) 对维度<span class="number">1</span>的数据进行排序</span><br></pre></td></tr></table></figure>
<h3 id="（5）唯一值与其他集合逻辑"><a href="#（5）唯一值与其他集合逻辑" class="headerlink" title="（5）唯一值与其他集合逻辑"></a>（5）唯一值与其他集合逻辑</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.unique(arr) 计算唯一值，并排序</span><br><span class="line">intersect1d(x,y) 计算交集并排序</span><br><span class="line">union1d(x,y)  计算并集并排序</span><br><span class="line">in1d(x,y) 计算在x中元素是否在y中，返回布尔数组</span><br><span class="line">setdiff1d(x,y) 计算在x但不在y中的元素</span><br><span class="line">setxor1d(x,y)  在x,y但不在交集中的元素</span><br></pre></td></tr></table></figure>
<h2 id="4-使用数组进行文件的输入和输出"><a href="#4-使用数组进行文件的输入和输出" class="headerlink" title="4.使用数组进行文件的输入和输出"></a>4.使用数组进行文件的输入和输出</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.save(<span class="string">'test.npy'</span>,arr)</span><br><span class="line">np.load(<span class="string">'test.npy'</span>)</span><br><span class="line">np.savez(<span class="string">'test.npz'</span>,a=arr1,b=arr2)</span><br></pre></td></tr></table></figure>
<h2 id="5-线性代数"><a href="#5-线性代数" class="headerlink" title="5. 线性代数"></a>5. 线性代数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">点乘：</span><br><span class="line">np.dot(x,y)</span><br><span class="line">x.dot(y)</span><br><span class="line">x @ y</span><br></pre></td></tr></table></figure>
<p><strong>np.linalg中的函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>diag</td>
<td>将对角元素作为一维数组返回</td>
</tr>
<tr>
<td>dot</td>
<td>点乘</td>
</tr>
<tr>
<td>trace</td>
<td>对角元素和</td>
</tr>
<tr>
<td>det</td>
<td>行列式</td>
</tr>
<tr>
<td>eig</td>
<td>特征值和特征向量</td>
</tr>
<tr>
<td>inv</td>
<td>逆矩阵</td>
</tr>
<tr>
<td>pinv</td>
<td>Moore-Penrose伪逆</td>
</tr>
<tr>
<td>qr</td>
<td>QR分解</td>
</tr>
<tr>
<td>svd</td>
<td>计算奇异值分解（SVD）</td>
</tr>
<tr>
<td>solve</td>
<td>求解Ax=b，其中A是方阵</td>
</tr>
<tr>
<td>lstsq</td>
<td>计算Ax=b的最小二乘解</td>
</tr>
</tbody>
</table>
</div>
<h2 id="6-伪随机数的生成"><a href="#6-伪随机数的生成" class="headerlink" title="6.伪随机数的生成"></a>6.伪随机数的生成</h2><p>np.random的数据生成函数公用了一个随机数种子 即，np.random.seed(1234)</p>
<p>可以生成一个自定义种子的随机数生成器，rng = np.random.RandomState(1234)   rng.randn(10)</p>
<p>np.random下的部分函数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>seed</td>
<td>随机数种子</td>
</tr>
<tr>
<td>permutation</td>
<td>返回一个序列的随机排列</td>
</tr>
<tr>
<td>shuffle</td>
<td>随机排列一个序列</td>
</tr>
<tr>
<td>rand</td>
<td>从均匀分布中抽取样本</td>
</tr>
<tr>
<td>randint</td>
<td>随机整数</td>
</tr>
<tr>
<td>randn</td>
<td>从均值0方差1的正态分布中抽取样本</td>
</tr>
<tr>
<td>binomial</td>
<td>从二项分布中抽取样本</td>
</tr>
<tr>
<td>normal</td>
<td>从正态分布中抽取样本</td>
</tr>
<tr>
<td>beta</td>
<td>从beta分布中抽取样本</td>
</tr>
<tr>
<td>chisquare</td>
<td>从卡方分布中抽取样本</td>
</tr>
<tr>
<td>gamma</td>
<td>从伽马分布中。。。。</td>
</tr>
<tr>
<td>uniform</td>
<td>从（0，1）中抽取样本</td>
</tr>
</tbody>
</table>
</div>
<h1 id="二、pandas"><a href="#二、pandas" class="headerlink" title="二、pandas"></a>二、pandas</h1><h2 id="1-pandas中的数据结构"><a href="#1-pandas中的数据结构" class="headerlink" title="1.pandas中的数据结构"></a>1.pandas中的数据结构</h2><h3 id="（1）Series"><a href="#（1）Series" class="headerlink" title="（1）Series"></a>（1）Series</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">obj.values 返回值</span><br><span class="line">obj.index 	返回索引</span><br><span class="line">obj.add(item,fill_value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">obj = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'x'</span>,<span class="string">'e'</span>])</span><br><span class="line">obj[<span class="string">'a'</span>]	可以使用标签索引</span><br><span class="line"></span><br><span class="line">obj = pd.Series(&#123;<span class="string">'a'</span>:<span class="number">12</span>,<span class="string">'b'</span>:<span class="number">1</span>&#125;)</span><br><span class="line">字典参数时，obj将按照value从大到小进行排列</span><br><span class="line">obj = pd.Series(&#123;<span class="string">'a'</span>:<span class="number">12</span>,<span class="string">'b'</span>:<span class="number">1</span>&#125;，index=[<span class="string">"a"</span>,<span class="string">"b"</span>])</span><br><span class="line">这样可以按照index中的键进行排序</span><br><span class="line"></span><br><span class="line">Series可以使用numpy中的函数</span><br><span class="line"></span><br><span class="line">obj.isnull() 返回布尔Series</span><br><span class="line">obj.notnull()</span><br><span class="line"></span><br><span class="line">Series对象和其索引都有name属性</span><br><span class="line">obj.name</span><br><span class="line">obj.index.name </span><br><span class="line"></span><br><span class="line">obj.index = [<span class="string">'b'</span>,<span class="string">'a'</span>] 	可以改变元素顺序</span><br></pre></td></tr></table></figure>
<h3 id="（2）DataFrame"><a href="#（2）DataFrame" class="headerlink" title="（2）DataFrame"></a>（2）DataFrame</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">构造：</span><br><span class="line">data = &#123;<span class="string">'a'</span>:[<span class="number">1</span>,<span class="number">312</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="string">'n'</span>:[<span class="number">23</span>,<span class="number">123</span>,<span class="number">4</span>,<span class="number">32</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br><span class="line">指定列顺序</span><br><span class="line">frame = pd.DataFrame(data,columns=[<span class="string">'n'</span>,<span class="string">'a'</span>])</span><br><span class="line">指定index</span><br><span class="line">frame = pd.DataFrame(data,columns=[<span class="string">'n'</span>,<span class="string">'a'</span>],index=[<span class="string">'asd'</span>,<span class="string">'asdf'</span>,<span class="string">'asdfasdf'</span>])</span><br><span class="line"></span><br><span class="line">frame.head() 前五行</span><br><span class="line">frame.tail()</span><br><span class="line"></span><br><span class="line">返回名为a的列:</span><br><span class="line">frame.a </span><br><span class="line">frame[<span class="string">'a'</span>] </span><br><span class="line"></span><br><span class="line">行的选取：</span><br><span class="line">frame.loc[<span class="string">'asd'</span>]</span><br><span class="line"></span><br><span class="line">返回所有的列名</span><br><span class="line">frame.column</span><br><span class="line"></span><br><span class="line">删除列</span><br><span class="line"><span class="keyword">del</span> frame[<span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">转置</span><br><span class="line">frame.T</span><br><span class="line"></span><br><span class="line">返回数据</span><br><span class="line">frame.values 以二维数组ndarray的方式返回</span><br></pre></td></tr></table></figure>
<p>注意：选取列/行返回的是列的索引。</p>
<h4 id="（3）索引对象"><a href="#（3）索引对象" class="headerlink" title="（3）索引对象"></a>（3）索引对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj.index 索引对象不可变，用户不可修改</span><br><span class="line">pd.Index([<span class="string">'a'</span>,<span class="string">'b'</span>])  创建索引对象</span><br></pre></td></tr></table></figure>
<p><strong>索引对象的方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>append</td>
<td></td>
</tr>
<tr>
<td>difference</td>
<td>差集</td>
</tr>
<tr>
<td>intersection</td>
<td>交集</td>
</tr>
<tr>
<td>union</td>
<td>并集</td>
</tr>
<tr>
<td>isin</td>
<td>表示每一个值是否在传值容器中的布尔数组</td>
</tr>
<tr>
<td>Delete</td>
<td>将位置i处的元素删除</td>
</tr>
<tr>
<td>delete</td>
<td></td>
</tr>
<tr>
<td>insert</td>
<td>在位置i处插入元素</td>
</tr>
<tr>
<td>is_monotonic</td>
<td>如果索引递增返回True</td>
</tr>
<tr>
<td>is_unique</td>
<td>如果索引序列唯一返回True</td>
</tr>
<tr>
<td>unique</td>
<td>计算索引的唯一值序列</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-基本功能"><a href="#2-基本功能" class="headerlink" title="2.基本功能"></a>2.基本功能</h2><h3 id="（1）重建索引"><a href="#（1）重建索引" class="headerlink" title="（1）重建索引"></a>（1）重建索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">行重建索引</span><br><span class="line">obj.reindex([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'x'</span>]) 不存在的索引会引入缺省值</span><br><span class="line">列重建索引</span><br><span class="line">obj.reindex(column=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">查看</span><br><span class="line">obj.loc[[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],[<span class="string">'aw'</span>,<span class="string">'qwer'</span>]]  行，列</span><br></pre></td></tr></table></figure>
<h3 id="（2）轴向上删除数据"><a href="#（2）轴向上删除数据" class="headerlink" title="（2）轴向上删除数据"></a>（2）轴向上删除数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop(<span class="string">'a'</span>)</span><br><span class="line">data.drop(<span class="string">'a'</span>,axis=<span class="number">1</span>)</span><br><span class="line">data.drop([<span class="string">'a'</span>,<span class="string">'b'</span>],axis=<span class="string">'column'</span>)</span><br></pre></td></tr></table></figure>
<p>注意：凡是会对原数组作出修改并返回一个新数组的，往往都有一个 inplace可选参数。如果手动设定为True（默认为False），那么原数组直接就被替换。也就是说，采用inplace=True之后，原数组名（如2和3情况所示）对应的内存值直接改变；</p>
<p>而采用inplace=False之后，原数组名对应的内存值并不改变，需要将新的结果赋给一个新的数组或者覆盖原数组的内存位置（如1情况所示）。</p>
<h3 id="（3）索引，选择，过滤"><a href="#（3）索引，选择，过滤" class="headerlink" title="（3）索引，选择，过滤"></a>（3）索引，选择，过滤</h3><p>注意：标签索引包含尾部，整数索引不包含尾部</p>
<p>索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Series</span><br><span class="line">obj = pd.Series([<span class="number">0</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">34</span>]，index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">obj[<span class="number">2</span>:<span class="number">3</span>] 不包含尾部</span><br><span class="line">obj[<span class="string">'b'</span>:<span class="string">'c'</span>]包含尾部</span><br><span class="line"></span><br><span class="line">DataFrame</span><br><span class="line">data[<span class="string">'a'</span>] 使用单个值或序列索引列</span><br><span class="line">data[[<span class="string">'a'</span>,<span class="string">'b'</span>]]</span><br><span class="line">data[:<span class="number">2</span>] 选择前两行</span><br><span class="line">data[data[<span class="string">'three'</span>]&gt;<span class="number">5</span>]选择three大于<span class="number">5</span>的行</span><br></pre></td></tr></table></figure>
<p>选择</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">轴标签loc,整数标签iloc</span><br><span class="line">data.loc[[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],[<span class="string">'as'</span>,<span class="string">'ear'</span>,<span class="string">'ear'</span>]]</span><br><span class="line">支持切片</span><br><span class="line"></span><br><span class="line">选择单个标签</span><br><span class="line">df.at[<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line">df.iat[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">get_value,set_value 根据标签设置单个值</span><br></pre></td></tr></table></figure>
<h3 id="（4）算数和数据对齐"><a href="#（4）算数和数据对齐" class="headerlink" title="（4）算数和数据对齐"></a>（4）算数和数据对齐</h3><p>两个Series或DataFrame运算时，不重叠的部分会产生缺省值NaN</p>
<p>r开头的方法有fill_value关键字参数</p>
<p>df1.radd(df2,fill_value=0)</p>
<h3 id="（5）DataFrame和Series数据之间的操作"><a href="#（5）DataFrame和Series数据之间的操作" class="headerlink" title="（5）DataFrame和Series数据之间的操作"></a>（5）DataFrame和Series数据之间的操作</h3><p>默认情况下，DataFrame和Series的数学操作会将Series的索引和DataFrame的列进行匹配并广播到各行。</p>
<p>如果要在列上广播，使用df.sub(series,axis=”index”)</p>
<h3 id="（6）函数应用和映射"><a href="#（6）函数应用和映射" class="headerlink" title="（6）函数应用和映射"></a>（6）函数应用和映射</h3><p>将函数应用到某一行或某一列的数组上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x:x.max()-x.min()</span><br><span class="line">frame.apply(f)  对每一列调用一次，有axis参数</span><br><span class="line"></span><br><span class="line">也可以返回序列</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(series)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> pd.Series([series.max(),series.min()],index=[<span class="string">'max'</span>,<span class="string">'min'</span>])</span><br></pre></td></tr></table></figure>
<h3 id="（7）排序和排名"><a href="#（7）排序和排名" class="headerlink" title="（7）排序和排名"></a>（7）排序和排名</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj.sort_index(axis=<span class="number">0</span>,ascending=<span class="literal">False</span>)  将对应的数据也进行排序，默认是升序</span><br><span class="line">obj.sort_values(by=[<span class="string">'a'</span>,<span class="string">'b'</span>],axis=<span class="number">0</span>)  按照a,b,两列进行排序</span><br><span class="line">obj.rank()  返回排名值，对并列的取平均</span><br><span class="line">obj.rank(method=<span class="string">'first'</span>)  返回排名，当时对并列的不取平均</span><br></pre></td></tr></table></figure>
<p>rank的方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>average</td>
<td>默认，平均值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>first</td>
<td>按照在数据中出现的次序进行排序</td>
</tr>
<tr>
<td>dense</td>
<td>类似于method=‘min’，但组间排名总是加一，而不是一个组中的相等元素的数量。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="（8）含有重复标签的轴索引"><a href="#（8）含有重复标签的轴索引" class="headerlink" title="（8）含有重复标签的轴索引"></a>（8）含有重复标签的轴索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.index.is_unique 	判断是否存在重复</span><br></pre></td></tr></table></figure>
<h2 id="3-描述性统计的概述与计算"><a href="#3-描述性统计的概述与计算" class="headerlink" title="3.描述性统计的概述与计算"></a>3.描述性统计的概述与计算</h2><p>skipna参数默认为True，</p>
<p>描述性统计和汇总统计</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>非NA值的个数</td>
</tr>
<tr>
<td>describe</td>
<td>计算Series或DataFrame各列的汇总统计集合</td>
</tr>
<tr>
<td>min，max</td>
<td>计算最小值，最大值</td>
</tr>
<tr>
<td>argmin，argmax</td>
<td>计算最大值，最小值的索引位置</td>
</tr>
<tr>
<td>idxmin，idxmax</td>
<td>计算最大值，最小值的索引</td>
</tr>
<tr>
<td>quantile</td>
<td>计算样本从0-1之间的分位数</td>
</tr>
<tr>
<td>sum</td>
<td></td>
</tr>
<tr>
<td>mean</td>
<td></td>
</tr>
<tr>
<td>median</td>
<td></td>
</tr>
<tr>
<td>mad</td>
<td>平均值的平均绝对偏差</td>
</tr>
<tr>
<td>prod</td>
<td>所有值的积</td>
</tr>
<tr>
<td>var</td>
<td>方差</td>
</tr>
<tr>
<td>std</td>
<td>标准差</td>
</tr>
<tr>
<td>skew</td>
<td>样本偏度值（第三时刻）</td>
</tr>
<tr>
<td>kurt</td>
<td>样本峰度值（第四时刻）</td>
</tr>
<tr>
<td>cumsum</td>
<td>累加</td>
</tr>
<tr>
<td>cummin，cummax</td>
<td>累计的最小，最大</td>
</tr>
<tr>
<td>cumprod</td>
<td>累乘</td>
</tr>
<tr>
<td>diff</td>
<td>计算第一个算数差值<br />将数据作某种移动后与原数据的差值</td>
</tr>
<tr>
<td>pct_change</td>
<td>计算百分比改变，相比前一项</td>
</tr>
</tbody>
</table>
</div>
<h3 id="（1）相关性和协方差"><a href="#（1）相关性和协方差" class="headerlink" title="（1）相关性和协方差"></a>（1）相关性和协方差</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'col1'</span>].corr(df1[<span class="string">'col2'</span>]) 	计算两个Series中重叠的，非NA的，按照索引对齐的值的相关性。</span><br><span class="line">df[<span class="string">'col1'</span>].cov(df1[<span class="string">'col2'</span>])</span><br><span class="line"></span><br><span class="line">返回所有列之间相互的相关性</span><br><span class="line">df1.corr()</span><br><span class="line">df1.cov()</span><br><span class="line"></span><br><span class="line">返回所有列和IBM列的相关性</span><br><span class="line">df1.corrwith(df1.IBM)</span><br></pre></td></tr></table></figure>
<h3 id="（2）唯一值，计数和成员属性检查"><a href="#（2）唯一值，计数和成员属性检查" class="headerlink" title="（2）唯一值，计数和成员属性检查"></a>（2）唯一值，计数和成员属性检查</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Series方法</span><br><span class="line">obj.unique() 返回唯一值</span><br><span class="line">obj.value_count() 数据计数</span><br><span class="line"></span><br><span class="line">pd.value_count(obj.values,sort=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">obj.isin([<span class="string">'a'</span>,<span class="string">'b'</span>]) 	成员属性检查</span><br></pre></td></tr></table></figure>
<h3 id="4-索引"><a href="#4-索引" class="headerlink" title="4.索引"></a>4.索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.reindex(columns&#x3D;&#39;xx&#39;,level&#x3D;&#39;ess&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="5-map"><a href="#5-map" class="headerlink" title="5.map"></a>5.map</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df[&#39;name&#39;].map(func) 对name列的对象执行func操作</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
        <tag>pandas</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>十种排序算法</title>
    <url>/2020/04/14/%E5%8D%81%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="0、算法概述"><a href="#0、算法概述" class="headerlink" title="0、算法概述"></a>0、算法概述</h1><a id="more"></a>
<h2 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类 "></a>0.1 算法分类<strong> </strong></h2><p>十种常见排序算法可以分为两大类：</p>
<ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li>
</ul>
<p><img src="1.png" alt="img"></p>
<h2 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h2><p><img src="2.png" alt="img"></p>
<p><strong>0.3 相关概念</strong></p>
<ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机</li>
</ul>
<p>内执行时所需存储空间的度量，它也是数据规模n的函数。 </p>
<h1 id="1、-冒泡排序"><a href="#1、-冒泡排序" class="headerlink" title="1、 冒泡排序"></a>1、 冒泡排序</h1><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p>
<h1 id="2、-选择排序"><a href="#2、-选择排序" class="headerlink" title="2、 选择排序"></a>2、 选择排序</h1><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O($n^2$)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<h1 id="3、-插入排序"><a href="#3、-插入排序" class="headerlink" title="3、 插入排序"></a>3、 插入排序</h1><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h1 id="4、-希尔排序"><a href="#4、-希尔排序" class="headerlink" title="4、 希尔排序"></a>4、 希尔排序</h1><p>它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>算法步骤：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h1 id="5、-归并排序"><a href="#5、-归并排序" class="headerlink" title="5、 归并排序"></a>5、 归并排序</h1><p>步骤：</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<h1 id="6、-快速排序"><a href="#6、-快速排序" class="headerlink" title="6、 快速排序"></a>6、 快速排序</h1><p>步骤：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<h1 id="7、-堆排序"><a href="#7、-堆排序" class="headerlink" title="7、 堆排序"></a>7、 堆排序</h1><p>通过大顶堆不断选出最大、次大、第三大。。。<br>步骤：</p>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<h1 id="8、-计数排序"><a href="#8、-计数排序" class="headerlink" title="8、 计数排序"></a>8、 计数排序</h1><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif" alt="img"></p>
<h1 id="9、-桶排序"><a href="#9、-桶排序" class="headerlink" title="9、 桶排序"></a>9、 桶排序</h1><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h1 id="10、-基数排序"><a href="#10、-基数排序" class="headerlink" title="10、 基数排序"></a>10、 基数排序</h1><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>口罩检测</title>
    <url>/2020/02/18/%E5%8F%A3%E7%BD%A9%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>口罩检测数据集来源：<a href="https://www.bilibili.com/video/av88696686?t=115" target="_blank" rel="noopener">https://www.bilibili.com/video/av88696686?t=115</a><br>口罩检测模型：<a href="https://github.com/zzh8829/yolov3-tf2" target="_blank" rel="noopener">https://github.com/zzh8829/yolov3-tf2</a><br><a id="more"></a><br>模型使用：</p>
<ol>
<li>数据集更改<br>将所有图片放到一个文件夹，重命名文件，修改xml文件中filename<br>修改./data/voc2012.names中的名称为have_mask和no_mask</li>
<li>模型修改<br>由于磁盘空间有限，在train.py中的modelcheckpoint中添加参数，save_best_only=True</li>
<li>数据集生成<br>分别生成train和val<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python tools/voc2012.py \</span><br><span class="line">  --data_dir './data/voc2012_raw/VOCdevkit/VOC2012' \</span><br><span class="line">  --split train \</span><br><span class="line">  --output_file ./data/voc2012_train.tfrecord</span><br><span class="line"></span><br><span class="line">python tools/voc2012.py \</span><br><span class="line">  --data_dir './data/voc2012_raw/VOCdevkit/VOC2012' \</span><br><span class="line">  --split val \</span><br><span class="line">  --output_file ./data/voc2012_val.tfrecord</span><br></pre></td></tr></table></figure></li>
<li>模型训练<br>迁移学习<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wget https://pjreddie.com/media/files/yolov3.weights -O data/yolov3.weights</span><br><span class="line">python <span class="built_in">convert</span>.py</span><br><span class="line">python detect.py --image ./data/meme.jpg # Sanity check</span><br><span class="line"></span><br><span class="line">python train.py \</span><br><span class="line">	--dataset ./data/voc2012_train.tfrecord \</span><br><span class="line">	--val_dataset ./data/voc2012_val.tfrecord \</span><br><span class="line">	--classes ./data/voc2012.names \</span><br><span class="line">	--num_classes <span class="number">2</span> \</span><br><span class="line">	--<span class="built_in">mode</span> fit --transfer darknet \</span><br><span class="line">	--batch_size <span class="number">16</span> \</span><br><span class="line">	--epochs <span class="number">10</span> \</span><br><span class="line">	--weights ./checkpoints/yolov3.tf \</span><br><span class="line">	--weights_num_classes <span class="number">80</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>随机初始化<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python train.py \</span><br><span class="line">	--dataset .&#x2F;data&#x2F;voc2012_train.tfrecord \</span><br><span class="line">	--val_dataset .&#x2F;data&#x2F;voc2012_val.tfrecord \</span><br><span class="line">	--classes .&#x2F;data&#x2F;voc2012.names \</span><br><span class="line">	--num_classes 2 \</span><br><span class="line">	--mode fit --transfer none \</span><br><span class="line">	--batch_size 16 \</span><br><span class="line">	--epochs 10 \</span><br></pre></td></tr></table></figure></p>
<p>可以在迁移学习冻结darknet主题部分之后，不冻结再次训练<br>batch_size要尽量小，不然会爆显存</p>
<ol>
<li>预测</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python detect.py --classes ./data/voc2012.names --num_classes <span class="number">2</span> --weights ./checkpoints/yolov3_train_2.tf --image ./data/street.jpg</span><br></pre></td></tr></table></figure>
<ol>
<li>实时检测</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践案例</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>口罩检测</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积操作动画</title>
    <url>/2020/03/10/%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>最近在看实例分割的相关算法，始终无法很好的理解反卷积的相关内容，在github上找到了大佬制作的卷积和反卷积动图，放在博客保存一波。<br>github：<a href="https://github.com/vdumoulin/conv_arithmetic" target="_blank" rel="noopener">https://github.com/vdumoulin/conv_arithmetic</a><br><a id="more"></a></p>
<h1 id="Convolution-animations"><a href="#Convolution-animations" class="headerlink" title="Convolution animations"></a>Convolution animations</h1><p><em>N.B.: Blue maps are inputs, and cyan maps are outputs.</em></p>
<table style="width:100%; table-layout:fixed;">
  <tr>
    <td><img width="150px" src="gif/no_padding_no_strides.gif"></td>
    <td><img width="150px" src="gif/arbitrary_padding_no_strides.gif"></td>
    <td><img width="150px" src="gif/same_padding_no_strides.gif"></td>
    <td><img width="150px" src="gif/full_padding_no_strides.gif"></td>
  </tr>
  <tr>
    <td>No padding, no strides</td>
    <td>Arbitrary padding, no strides</td>
    <td>Half padding, no strides</td>
    <td>Full padding, no strides</td>
  </tr>
  <tr>
    <td><img width="150px" src="gif/no_padding_strides.gif"></td>
    <td><img width="150px" src="gif/padding_strides.gif"></td>
    <td><img width="150px" src="gif/padding_strides_odd.gif"></td>
    <td></td>
  </tr>
  <tr>
    <td>No padding, strides</td>
    <td>Padding, strides</td>
    <td>Padding, strides (odd)</td>
    <td></td>
  </tr>
</table>

<h1 id="Transposed-convolution-animations"><a href="#Transposed-convolution-animations" class="headerlink" title="Transposed convolution animations"></a>Transposed convolution animations</h1><p><em>N.B.: Blue maps are inputs, and cyan maps are outputs.</em></p>
<table style="width:100%; table-layout:fixed;">
  <tr>
    <td><img width="150px" src="gif/no_padding_no_strides_transposed.gif"></td>
    <td><img width="150px" src="gif/arbitrary_padding_no_strides_transposed.gif"></td>
    <td><img width="150px" src="gif/same_padding_no_strides_transposed.gif"></td>
    <td><img width="150px" src="gif/full_padding_no_strides_transposed.gif"></td>
  </tr>
  <tr>
    <td>No padding, no strides, transposed</td>
    <td>Arbitrary padding, no strides, transposed</td>
    <td>Half padding, no strides, transposed</td>
    <td>Full padding, no strides, transposed</td>
  </tr>
  <tr>
    <td><img width="150px" src="gif/no_padding_strides_transposed.gif"></td>
    <td><img width="150px" src="gif/padding_strides_transposed.gif"></td>
    <td><img width="150px" src="gif/padding_strides_odd_transposed.gif"></td>
    <td></td>
  </tr>
  <tr>
    <td>No padding, strides, transposed</td>
    <td>Padding, strides, transposed</td>
    <td>Padding, strides, transposed (odd)</td>
    <td></td>
  </tr>
</table>

<h1 id="Dilated-convolution-animations"><a href="#Dilated-convolution-animations" class="headerlink" title="Dilated convolution animations"></a>Dilated convolution animations</h1><p><em>N.B.: Blue maps are inputs, and cyan maps are outputs.</em></p>
<table style="width:25%"; table-layout:fixed;>
  <tr>
    <td><img width="150px" src="gif/dilation.gif"></td>
  </tr>
  <tr>
    <td>No padding, no stride, dilation</td>
  </tr>
</table>
]]></content>
  </entry>
  <entry>
    <title>实例分割</title>
    <url>/2020/02/26/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><a id="more"></a>
<p><strong>物体检测</strong>：Fast/Faster R−CNNFast/Faster R−CNN<br>通常包含两个问题，一是判断属于某个特定类的物体是否出现在图中；二是对该物体进行定位（常用表征就是物体的边界框）可实现输入测试图片，输出检测到的物体类别和位置。<br><strong>语义分割</strong> Fully Convolutional Network (FCN)Fully Convolutional Network (FCN)<br>简单而言就是给定一张图片，对图片上的每一个像素点分类<br><strong>实例分割</strong><br>物体检测和语义分割的综合体。相对物体检测的边界框，实例分割可精确到物体的边缘；相对语义分割，实例分割可以标注出图上同一物体的不同个体<br><img src="0.png" alt=""></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实例分割</category>
      </categories>
  </entry>
  <entry>
    <title>实例分割综述(2020.3)【转载】</title>
    <url>/2020/04/08/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2%E7%BB%BC%E8%BF%B0-2020-3/</url>
    <content><![CDATA[<p>转载自：<a href="https://cloud.tencent.com/developer/article/1594081" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1594081</a><br><a id="more"></a></p>
<h1 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a><strong>前面的话</strong></h1><p>实例分割（Instance Segmentation）是视觉经典四个任务中相对最难的一个，它既具备语义分割（Semantic Segmentation）的特点，需要做到<strong>像素层面上的分类</strong>，也具备目标检测（Object Detection）的一部分特点，即<strong>需要定位出不同实例，即使它们是同一种类</strong>。因此，实例分割的研究长期以来都有着两条线，分别是自下而上的基于语义分割的方法和自上而下的基于检测的方法，这两种方法都属于两阶段的方法，下面将分别简单介绍。</p>
<p><strong>自上而下的实例分割方法</strong></p>
<p>思路是：首先通过目标检测的方法<strong>找出实例所在的区域</strong>（bounding box），再<strong>在检测框内进行语义分割</strong>，每个分割结果都作为一个不同的实例输出。</p>
<p>自上而下的密集实例分割的开山鼻祖是DeepMask，它通过滑动窗口的方法，在每个空间区域上都预测一个mask proposal。这个方法存在以下三个缺点：</p>
<ul>
<li><strong>mask与特征的联系（局部一致性）丢失了</strong>，如DeepMask中使用全连接网络去提取mask</li>
<li><strong>特征的提取表示是冗余的</strong>， 如DeepMask对每个前景特征都会去提取一次mask</li>
<li><strong>下采样</strong>（使用步长大于1的卷积）导致的位置信息丢失</li>
</ul>
<p><strong>自下而上的实例分割方法</strong></p>
<p>思路是：首先进行像素级别的语义分割，再通过聚类、度量学习等手段区分不同的实例。这种方法虽然保持了更好的低层特征（细节信息和位置信息），但也存在以下缺点：</p>
<ul>
<li>对密集分割的质量要求很高，<strong>会导致非最优的分割</strong></li>
<li><strong>泛化能力较差</strong>，无法应对类别多的复杂场景</li>
<li><strong>后处理</strong>方法繁琐</li>
</ul>
<p><strong>单阶段实例分割</strong>（Single Shot Instance Segmentation），这方面工作其实也是受到了单阶段目标检测研究的影响，因此也有两种思路，一种是<strong>受one-stage, anchor-based 检测模型如YOLO，RetinaNet启发，代表作有YOLACT和SOLO；一种是受anchor-free检测模型如 FCOS 启发，代表作有PolarMask和AdaptIS。</strong></p>
<p>下面是对其中一些方法在COCO数据集上的指标对比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Method</th>
<th style="text-align:left">AP</th>
<th style="text-align:left">AP50</th>
<th style="text-align:left">AP75</th>
<th style="text-align:left">APs</th>
<th style="text-align:left">APm</th>
<th style="text-align:left">APL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FCIS</td>
<td style="text-align:left">29.2</td>
<td style="text-align:left">49.5</td>
<td style="text-align:left"></td>
<td style="text-align:left">7.1</td>
<td style="text-align:left">31.3</td>
<td style="text-align:left">50.0</td>
</tr>
<tr>
<td style="text-align:left">Mask R-CNN</td>
<td style="text-align:left">37.1</td>
<td style="text-align:left">60.0</td>
<td style="text-align:left">39.4</td>
<td style="text-align:left">16.9</td>
<td style="text-align:left">39.9</td>
<td style="text-align:left">53.5</td>
</tr>
<tr>
<td style="text-align:left">YOLACT-700</td>
<td style="text-align:left">31.2</td>
<td style="text-align:left">50.6</td>
<td style="text-align:left">32.8</td>
<td style="text-align:left">12.1</td>
<td style="text-align:left">33.3</td>
<td style="text-align:left">47.1</td>
</tr>
<tr>
<td style="text-align:left">PolarMask</td>
<td style="text-align:left">32.9</td>
<td style="text-align:left">55.4</td>
<td style="text-align:left">33.8</td>
<td style="text-align:left">15.5</td>
<td style="text-align:left">35.1</td>
<td style="text-align:left">46.3</td>
</tr>
<tr>
<td style="text-align:left">SOLO</td>
<td style="text-align:left">40.4</td>
<td style="text-align:left">62.7</td>
<td style="text-align:left">43.3</td>
<td style="text-align:left">17.6</td>
<td style="text-align:left">43.3</td>
<td style="text-align:left">58.9</td>
</tr>
<tr>
<td style="text-align:left">PointRend</td>
<td style="text-align:left">40.9</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BlendMask</td>
<td style="text-align:left">41.3</td>
<td style="text-align:left">63.1</td>
<td style="text-align:left">44.6</td>
<td style="text-align:left">22.7</td>
<td style="text-align:left">44.1</td>
<td style="text-align:left">54.5</td>
</tr>
</tbody>
</table>
</div>
<p>下面详细介绍一下几个代表性方法：</p>
<h1 id="1-双阶段的-Mask-R-CNN-（2017-3）"><a href="#1-双阶段的-Mask-R-CNN-（2017-3）" class="headerlink" title="1.双阶段的 Mask R-CNN （2017.3）"></a><strong>1.双阶段的 Mask R-CNN （2017.3）</strong></h1><p>Mask-RCNN通过增加不同的分支可以完成目标分类，目标检测，语义分割，实例分割，人体姿态估计等多种任务。对于实例分割来讲，就是<strong>在Faster-RCNN的基础上(分类+回归分支)增加了一个分支用于语义分割</strong>，其抽象结构如下图所示：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/rvza6i2hrq.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>可以看到其结构与Faster RCNN非常类似，但有3点主要区别：</p>
<ul>
<li>在基础网络中采用了较为优秀的<strong>ResNet-FPN结构</strong>，多层特征图有利于多尺度物体及小物体的检测。原始的FPN会输出P2、P3、P4与P54个阶段的特征图，但在Mask RCNN中<strong>又增加了一个P6。将P5进行最大值池化即可得到P6，目的是获得更大感受野的特征，该阶段仅仅用在RPN网络中。</strong></li>
<li>提出了RoI Align方法来替代RoI Pooling，原因是<strong>RoI Pooling的取整做法损失了一些精度，而这对于分割任务来说较为致命。</strong>Maks RCNN提出的RoI Align取消了取整操作，而是<strong>保留所有的浮点</strong>，然后通过<strong>双线性插值的方法</strong>获得多个采样点的值，再将多个采样点进行最大值的池化，即可得到该点最终的值。</li>
<li>得到感兴趣区域的特征后，在原来分类与回归的基础上，<strong>增加了一个Mask分支来预测每一个像素的类别</strong>。具体实现时，采用了F<strong>CN（Fully Convolutional Network）的网络结构</strong>，利用卷积与反卷积构建端到端的网络，最后对每一个像素分类，实现了较好的分割效果。</li>
</ul>
<p>Mask R-CNN算法的主要步骤为：</p>
<ul>
<li>首先，将输入图片送入到特征提取网络得到特征图。</li>
<li>然后<strong>对特征图的每一个像素位置设定固定个数的ROI（也可以叫Anchor）</strong>，然后将ROI区域送入<strong>RPN网络</strong>进行二分类(前景和背景)以及坐标回归，以获得精炼后的ROI区域。</li>
<li>对上个步骤中获得的ROI区域执行论文提出的<strong>ROIAlign操作</strong>，即先将原图和feature map的pixel对应起来，然后将feature map和固定的feature对应起来。</li>
<li>最后对这些ROI区域进行多类别分类，候选框回归和引入FCN生成Mask，完成分割任务。</li>
</ul>
<p>总的来说，在Faster R-CNN和FPN的加持下，Mask R-CNN开启了R-CNN结构下多任务学习的序幕。它出现的时间比其他的一些实例分割方法（例如FCIS）要晚，但是依然让<strong>proposal-based instance segmentation的方式</strong>占据了主导地位（尽管<strong>先检测后分割</strong>的逻辑不是那么地自然）。</p>
<p>Mask R-CNN利用R-CNN得到的物体框来区分各个实例，然后针对各个物体框对其中的实例进行分割。显而易见的问题便是，<strong>如果框不准，分割结果也会不准</strong>。因此对于一些边缘精度要求高的任务而言，这不是一个较好的方案。同时由于依赖框的准确性，这也容易导致一些非方正的物体效果比较差。</p>
<h1 id="2-单阶段实例分割方法"><a href="#2-单阶段实例分割方法" class="headerlink" title="2. 单阶段实例分割方法"></a><strong>2. 单阶段实例分割方法</strong></h1><h1 id="2-1-Instance-sensitive-FCN（2016-3）"><a href="#2-1-Instance-sensitive-FCN（2016-3）" class="headerlink" title="2.1 Instance-sensitive FCN（2016.3）"></a><strong>2.1 Instance-sensitive FCN（2016.3）</strong></h1><p>该方法的思想是相对FCN在每个像素上输出语义的label，其需要输出<strong>是否在某个实例的相对位置上（以3x3的网格为例，即要确定像素点是在网格的哪个位置（9个位置对应9个通道））。</strong>虽然理解上不是特别直观，但其主要思想还是<strong>编码了位置信息（类似方向信息）以便区分同一语义下的实例。</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/8q27vk2rgr.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>当然在构造groundtruth时，也<strong>需要sliding window的方式把实例上各个像素分配到各个位置上去。</strong></p>
<p>在推理阶段，仅仅依靠sliding window去生成结果是不够的。在相近位置上会得到相似的结果，这就需要<strong>对物体本身进行整体的判别，以确定物体（中心）的准确位置</strong>。如下instance sensitive FCN增加了物体检测分支，通过物体的外接框以及得分，利用NMS得到最终无重复的实例分割结果。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/7o6f28rivv.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>虽然该方法效果在当时并不突出，但请先记住这样的思想，后续SOLO会进一步升华。下面要讲到的<strong>R-FCN同样利用了单个像素编码（附带）相对位置信息的思路</strong>，除了类别信息外，该像素还需要<strong>判断自己在物体区域的相对位置</strong>，相对位置通过固定的通道得以表征。</p>
<h1 id="2-2-FCIS（2017-4）"><a href="#2-2-FCIS（2017-4）" class="headerlink" title="2.2 FCIS（2017.4）"></a><strong>2.2 FCIS（2017.4）</strong></h1><p>FCN 最终输出的是类别的概率图，只有类别输出，没有单个对象输出，InstanceFCN输出3<em>3的位置信息图， <strong>只有单个对象输出，没有类别信息，需要单独的downstream网络完成类别信息。</strong>FCIS通过<em>*计算position-sensitive inside/outside score maps，同时输出 instance mask 和类别信息。</em></em></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/6yst50cy6z.jpeg?imageView2/2/w/1620" alt="img"></p>
<ul>
<li>InstanceFCN提出了positive-sensitive score map，每个score表示一个像素在某个相对位置上属于某个物体实例的似然得分。所以FCIS也<strong>采用position-sensitive score maps，只不过在物体实例中区分inside/outside，目的是想引入一点context信息。</strong></li>
<li>作者认为以往的SDS、Hypercolumn、CFM等算法，具有相似的结构：<strong>两个子网络分别用于对象分割和检测子任务，且两个网络的结构、参数、执行顺序随机。</strong>作者认为分离的网络没有真正挖掘到两个认为的联系，提出共同的 “position-sensitive score map” ，同时用于object segmentation and detection子任务。</li>
<li>除了加入背景部分的通道外，FCIS还<strong>基于ROI作了类别检测，而不是再引入另外一个分支作这项任务。</strong></li>
</ul>
<h1 id="2-3-YOLCAT（2019-4）"><a href="#2-3-YOLCAT（2019-4）" class="headerlink" title="2.3 YOLCAT（2019.4）"></a><strong>2.3 YOLCAT（2019.4）</strong></h1><p>原文：<a href="https://arxiv.org/abs/1904.02689" target="_blank" rel="noopener">https://arxiv.org/abs/1904.02689</a><br>代码（官方）：<a href="https://github.com/dbolya/yolact" target="_blank" rel="noopener">https://github.com/dbolya/yolact</a></p>
<ul>
<li>YOLACT<strong>将掩模分支添加到现有的一阶段（one-stage）目标检测模型</strong>，其方式与Mask R-CNN对 Faster-CNN 操作相同，但<strong>没有明确的定位步骤</strong>。 </li>
<li>YOLACT将实例分割任务拆分成两个并行的子任务：（1）通过一个Protonet网络， 为每张图片生成 k 个 原型mask;（2）对每个实例，<strong>预测k个的线性组合系数（Mask Coefficients）</strong>。最后<strong>通过线性组合</strong>，生成实例mask，在此过程中，网络学会了如何定位不同位置、颜色和语义实例的mask。</li>
<li>YOLACT将问题分解为两个并行的部分，利用 fc层（擅长产生语义向量）和 conv层（擅长产生空间相干掩模）来分别产生“掩模系数”和“原型掩模” 。然后，因为原型和掩模系数可以独立地计算，所以 <strong>backbone 检测器的计算开销主要来自合成（assembly）步骤</strong>，其可以实现为单个矩阵乘法。通过这种方式，我们可以在特征空间中保持空间一致性，同时仍然是一阶段和快速的。</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/o686tzsprj.jpeg?imageView2/2/w/1620" alt="img"></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/k3am7rdcd6.jpeg?imageView2/2/w/1620" alt="img"></p>
<p><strong>Backbone</strong>：Resnet 101+FPN，与RetinaNet相同；<strong>Protonet</strong>：接在FPN输出的后面，是一个FCN网络，预测得到针对原图的原型mask；<strong>Prediction Head</strong>：相比RetinaNet的Head，多了一个Mask Cofficient分支，预测Mask系数，因此输出是4*c+k。</p>
<p>可以看到head上<strong>增加了一支mask系数分支用于将prototypes进行组合得到mask的结果</strong>。当然按NMS的位置看，其同样需要有bbox的准确预测才行，并且该流程里不太适合用soft NMS进行替代。需要注意的是，<strong>在训练过程中，其用groundtruth bbox对组合后的全图分割结果进行截取，再与groundtruth mask计算损失。</strong>这同样需要bbox结果在前作为前提，以缓解前后景的像素不均衡情况。</p>
<p>至于后续的YOLCAT++，则主要是加入了mask rescoring的概念和DCN结构，进一步提升精度。（1）参考Mask Scoring RCNN，添加<strong>fast mask re-scoring分支</strong>，更好地评价实例mask的好坏；（2）Backbone网络中引入<strong>可变形卷积DCN</strong>；（3）优化了Prediction Head中的anchor设计。</p>
<h1 id="2-4-PolarMask（2019-10）"><a href="#2-4-PolarMask（2019-10）" class="headerlink" title="2.4 PolarMask（2019.10）"></a><strong>2.4 PolarMask（2019.10）</strong></h1><p>原文：<a href="https://arxiv.org/abs/1909.13226" target="_blank" rel="noopener">https://arxiv.org/abs/1909.13226</a></p>
<p>代码（官方）：<a href="https://github.com/xieenze/PolarMask" target="_blank" rel="noopener">https://github.com/xieenze/PolarMask</a></p>
<p>相比RetinaNet，<strong>FCOS</strong>将基于anchor的回归变成了<strong>中心点估计与上下左右四个边界距离的回归</strong>，而PolarMask则是<strong>进一步细化了边界的描述，使得其能够适应mask的问题。</strong>PolarMask最重要的特点是：(1) anchor free and bbox free，不需要出检测框；(2) fully convolutional network, 相比FCOS把4根射线散发到36根射线，<strong>将instance segmentation和object detection用同一种建模方式来表达。</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/8hunsi0wvv.jpeg?imageView2/2/w/1620" alt="img"></p>
<p><strong>两种实例分割的建模方式：</strong></p>
<p>1 像素级建模 类似于图b，在检测框中对每个pixel分类</p>
<p>2 轮廓建模 类似于图c和图d，其中，图c是基于直角坐标系建模轮廓，图d是基于极坐标系建模轮廓</p>
<p>PolarMask 基于极坐标系建模轮廓，把实例分割问题转化为<strong>实例中心点分类(instance center classification)问题和密集距离回归(dense distance regression)问题。</strong>同时，我们还提出了两个有效的方法，用来优化high-quality正样本采样和dense distance regression的损失函数优化，分别是<strong>Polar CenterNess和 Polar IoU Loss</strong>。没有使用任何trick(多尺度训练，延长训练时间等)，PolarMask 在ResNext 101的配置下 在coco test-dev上取得了32.9的mAP。 这是首次，证明了更复杂的实例分割问题，可以在网络设计和计算复杂度上，和anchor free物体检测一样简单。</p>
<p><strong>网络结构</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/fjonozzgbz.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>整个网络和FCOS一样简单，首先是标准的backbone + fpn模型，其次是head部分，我们把fcos的bbox分支替换为mask分支，仅仅是把channel=4替换为channel=n, 这里n=36，相当于36根射线的长度。同时我们提出了一种新的Polar Centerness 用来替换FCOS的bbox centerness。可以看到，在网络复杂度上，PolarMask和FCOS并无明显差别。</p>
<p><strong>建模方式</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/ze592sqf6n.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>首先，输入一张原图，经过网络可以得到中心点的位置和n(n=36 is best in our setting)根射线的距离，其次，根据角度和长度计算出轮廓上的这些点的坐标，从0°开始连接这些点，最后把联通区域内的区域当做实例分割的结果。</p>
<p><strong>实验结果</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/41t5gzt6px.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>从实验结果可以看到，PolarMask的精度并不是很高，而且<strong>速度上也没有优势，但是它的思路是非常巧妙的，对后面的研究有着很大的启发意义</strong>。具体细节可参考论文原文。</p>
<h1 id="2-5-SOLO（2019-12）"><a href="#2-5-SOLO（2019-12）" class="headerlink" title="2.5 SOLO（2019.12）"></a><strong>2.5 SOLO（2019.12）</strong></h1><p>原文：<a href="https://arxiv.org/abs/1912.04488" target="_blank" rel="noopener">https://arxiv.org/abs/1912.04488</a></p>
<p>代码：<a href="https://github.com/WXinlong/SOLO" target="_blank" rel="noopener">https://github.com/WXinlong/SOLO</a></p>
<p>和FCIS的类似，单个像素不是单纯输出类别，而是带有位置信息的类别，同时考虑到尺度的问题，借助网络结构来解决。</p>
<p>要理解SOLO的思想，重点就是要理解SOLO提出的<strong>实例类别（Instance Category）</strong>的概念。作者指出，实例类别就是<strong>量化后的物体中心位置（location）和物体的尺寸（size)</strong>。下面就解释一下这两个部分。</p>
<ul>
<li><strong>位置（location）</strong></li>
</ul>
<p>SOLO将一张图片划分S×S的网格，这就有了S<em>S个位置。不同于TensorMask和DeepMask将mask放在了特征图的channel维度上，SOLO参照语义分割，<em>*将定义的物体中心位置的类别放在了channel维度上，这样就保留了几何结构上的信息。</em></em></p>
<p>本质上来说，一个实例类别可以去近似一个实例的中心的位置。因此，<strong>通过将每个像素分类到对应的实例类别，就相当于逐像素地回归出物体的中心</strong>、这就将一个位置预测的问题从回归的问题转化成了分类的问题。这么做的意义是，分类问题能够更加直观和简单地用固定的channel数、同时不依赖后处理方法（如分组和学习像素嵌入embedding）对数量不定的实例进行建模。</p>
<ul>
<li><strong>尺寸（size）</strong></li>
</ul>
<p>对于尺寸的处理，SOLO<strong>使用了FPN来将不同尺寸的物体分配到不同层级的特征图上，依次作为物体的尺寸类别</strong>。这样，所有的实例都被分别开来，就可以去使用实例类别去分类物体了。</p>
<p><strong>网络实现</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/it6xx99xvf.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>SOLO将图片<strong>划分成S×S的网格</strong>，如果物体的中心（质心）落在了某个网格中，那么该网格就有了两个任务：（1）负责预测该物体语义类别（2）负责预测该物体的instance mask。这就对应了网络的<strong>两个分支Category Branch和Mask Branch</strong>。同时，SOLO在骨干网络后面使用了FPN，用来应对尺寸。FPN的每一层后都接上述两个并行的分支，进行类别和位置的预测，每个分支的网格数目也相应不同，小的实例对应更多的的网格。</p>
<p><strong>Category Branch</strong>：Category Branch负责预测物体的语义类别，每个网格预测类别S×S×C，这部分跟YOLO是类似的。输入为Align后的S×S×C的网格图像，输出为S×S×C的类别。这个分支使用的损失函数是<strong>focal loss</strong>。</p>
<p><strong>Mask Branch</strong>：预测instance mask的一个直观方法是类似语义分割使用FCN，但FCN是具有空间不变性（spatiallly invariant）的，而我们这边需要位置上的信息。因此，作者使用了<strong>CoordConv</strong>，将像素横纵坐标x，y（归一化到[-1,1]）与输入特征做了concat再输入网络中。这样输入的维度就是 H<em>W</em>(D+2）了。</p>
<p><strong>实验结果</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/rvhrym5tor.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>可以看到，SOLO的精度已经超越了Mask R-CNN，相较思路类似的PolarMask也有较大的优势。</p>
<h1 id="2-6-RDSNet-amp-PointRend（2019-12）"><a href="#2-6-RDSNet-amp-PointRend（2019-12）" class="headerlink" title="2.6 RDSNet &amp; PointRend（2019.12）"></a><strong>2.6 RDSNet &amp; PointRend（2019.12）</strong></h1><p><strong>RDSNet</strong>方法的出发点是<strong>检测阻碍不应该成为分割效果的阻碍，两种应该循环相互促进</strong>。有可能存在的情况是分割本身是比较准确的，但是因为定位不准，导致分割结果也比较差；这时候如果能提前知道分割的结果，那么检测的结果也会更好些。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/6ducr4hoj6.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>这里就有用到<strong>YOLCAT的方式，去获得提取获取分割结果</strong>。当然这里从embedding的角度出发，还<strong>结合了前后景的处理</strong>（实验中说明前后景correlation比单前景linear combination要好）。得到bbox预测结果后是需要进行NMS，以及expand操作的，以确保尽可能多的有效区域被选进来（训练时1.5，测试时1.2）。之后<strong>再通过Mask-based Boundary Refinement模块对物体的边框进行调整</strong>。为了使该过程可导，作者还设计了贝叶斯分布估计的方式，不太懂。</p>
<p><strong>PointRend</strong>借鉴了<strong>Render的思想</strong>，在尺度方式变化时由于采样的方式（不是连续坐标的设定吗），使得锯齿现象不会很明显。因此PointRend是利用一种<strong>非均匀采样的方式</strong>来确定在分辨率提高的情况下，<strong>如何确定边界上的点，并对这些点归属进行判别。</strong>本质上其实是一个<strong>新型上采样方法</strong>，<strong>针对物体边缘的图像分割进行优化</strong>，使其在难以分割的物体边缘部分有更好的表现。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/qtvnyrkp2g.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>PointRend 方法要点总结来说是一个<strong>迭代上采样的过程</strong>：</p>
<p>while 输出的分辨率 &lt; 图片分辨率：</p>
<ol>
<li>对输出结果进行2倍双线性插值上采样得到 coarse prediction_i。</li>
<li>挑选出 N 个“难点”，即结果很有可能和周围点不一样的点（例如物体边缘）。</li>
<li>对于每个难点，获取其“表征向量”，“表征向量”由两个部分组成，其一是低层特征（fine-grained features），通过使用点的坐标，在低层的特征图上进行双线性插值获得（类似 RoI Align），其二是高层特征（coarse prediction），由步骤 1 获得。</li>
<li>使用 MLP 对“表征向量”计算得到新的预测，更新 coarse prediction_i 得到 coarse prediction_i+1。这个 MLP 其实可以看做一个只对“难点”的“表征向量”进行运算的由多个 conv1x1 组成的小网络。</li>
</ol>
<h1 id="2-7-BlendMask（2020-1）"><a href="#2-7-BlendMask（2020-1）" class="headerlink" title="2.7 BlendMask（2020.1）"></a><strong>2.7</strong> <strong>BlendMask（2020.1）</strong></h1><p>原文：<a href="https://arxiv.org/abs/2001.00309" target="_blank" rel="noopener">https://arxiv.org/abs/2001.00309</a></p>
<p>代码：暂无（也不太需要）</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5457631/ljbn1t9oh2.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>BlendMask是一阶段的密集实例分割方法，结合了Top-down和Bottom-up的方法的思路。它通过在anchor-free检测模型<strong>FCOS的基础上增加了Bottom Module提取low-level的细节特征，并在instance-level上预测一个attention</strong>；借鉴<strong>FCIS和YOLACT的融合方法</strong>，提出了<strong>Blender模块来更好地融合这两种特征</strong>。最终，BlendMask在COCO上的精度（41.3AP）与速度（BlendMask-RT 34.2mAP, 25FPS on 1080ti）都超越了Mask R-CNN。</p>
<p>detector module直接用的FCOS，BlendMask模块则由三部分组成：<strong>bottom module</strong>用来对底层特征进行处理，生成的score map称为<strong>Base</strong>；<strong>top layer</strong>串接在检测器的box head上，生成Base对应的top level attention；最后是<strong>blender</strong>来对Base和attention进行融合。</p>
<p>BlendMask 的<strong>优势</strong>：</p>
<ul>
<li>计算量小：使用一阶段检测器FCOS，相比Mask R-CNN使用的RPN，省下了对positon-sensitive feature map及mask feature的计算，</li>
<li>还是计算量小：提出<strong>attention guided blender模块来计算全局特征（global map representation），</strong>相比FCN和FCIS中使用的较复杂的hard  alignment在相同分辨率的条件下，减少了十倍的计算量；</li>
<li>mask质量更高：BlendMask属于<strong>密集像素预测的方法，输出的分辨率不会受到 top-level 采样的限制</strong>。在Mask R-CNN中，如果要得到更准确的mask特征，就必须增加RoIPooler的分辨率，这样变回成倍增加head的计算时间和head的网络深度；</li>
<li>推理时间稳定：Mask R-CNN的推理时间随着检测的bbox数量增多而增多，BlendMask的推理速度更快且增加的时间可以忽略不计</li>
<li>Flexible：可以加到其他检测算法里面</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>综上所述，我们大致可以看出两个趋势：一个是YOLCAT，RDSNet，BlendMask（RetinaNet, FCOS，PolarMask发展而来）<strong>单阶段基于硬编码（embedding）的实例分割</strong>；另一个是<strong>SOLO(FCIS)区分位置信息的方式</strong>。</p>
<p>两者没有特别大的区别，特别当embedding的通道数等于位置数目时。剩下的PointRend其实可以引出一个计算资源分配的问题，如何在有限次计算的情况下提升分割边缘的准确性。以上这些还是针对检测目的的，所以分割精度上有时在意，有时也不在意。在精确分割方面仍然有值得探索的地方，除了目前很火的<strong>attention机制</strong>，其实我觉得依然得回头去<strong>关注下标注不那么精细的情况下如何去提升边缘的分割精度</strong>（当然这又可能是个ill问题，或者是个外插问题，不过从guided filter的角度看至少还有些图像结构信息可以作为先验知识利用起来）</p>
<p>参考：</p>
<p>1.<a href="https://blog.csdn.net/sanshibayuan/article/details/103642419" target="_blank" rel="noopener">https://blog.csdn.net/sanshibayuan/article/details/103642419</a></p>
<p>2.<a href="https://blog.csdn.net/sanshibayuan/article/details/104011910" target="_blank" rel="noopener">https://blog.csdn.net/sanshibayuan/article/details/104011910</a></p>
<p>3.<a href="https://zhuanlan.zhihu.com/p/102231853" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102231853</a></p>
<p>4.<a href="https://zhuanlan.zhihu.com/p/84890413" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84890413</a></p>
<p>5.<a href="https://zhuanlan.zhihu.com/p/98351269" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98351269</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实例分割</category>
      </categories>
  </entry>
  <entry>
    <title>图像预处理操作</title>
    <url>/2020/02/25/%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>在将图片输入到模型中进行训练之前，往往需要对图片数据集进行增强处理等一系列操作。本文对这些预处理操作进行一些总结。<br><a id="more"></a></p>
<h1 id="PIL和opencv格式的转换"><a href="#PIL和opencv格式的转换" class="headerlink" title="PIL和opencv格式的转换"></a>PIL和opencv格式的转换</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># OpenCV转换成PIL.Image格式</span></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy  </span><br><span class="line">  </span><br><span class="line">img = cv2.imread(<span class="string">"plane.jpg"</span>)  </span><br><span class="line">cv2.imshow(<span class="string">"OpenCV"</span>,img)  </span><br><span class="line">image = Image.fromarray(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))  </span><br><span class="line">image.show()  </span><br><span class="line">cv2.waitKey() </span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL.Image转换成OpenCV格式</span></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy  </span><br><span class="line">  </span><br><span class="line">image = Image.open(<span class="string">"plane.jpg"</span>)  </span><br><span class="line">image.show()  </span><br><span class="line">img = cv2.cvtColor(numpy.asarray(image),cv2.COLOR_RGB2BGR)  </span><br><span class="line">cv2.imshow(<span class="string">"OpenCV"</span>,img)  </span><br><span class="line">cv2.waitKey()</span><br></pre></td></tr></table></figure>
<h1 id="letter-box的添加"><a href="#letter-box的添加" class="headerlink" title="letter_box的添加"></a>letter_box的添加</h1><p>为了防止将图片resize到固定大小的时候的失真，往往需要在对图片进行缩放后添加白边。如下图所示。<br><img src="1.png" alt=""><br>图像添加letter box的代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterbox_image</span><span class="params">(image, size)</span>:</span></span><br><span class="line">    <span class="comment"># image为Image.open读入的图像</span></span><br><span class="line">    <span class="comment"># size为目标尺寸</span></span><br><span class="line">    iw, ih = image.size</span><br><span class="line">    w, h = size</span><br><span class="line">    scale = min(w/iw, h/ih)</span><br><span class="line">    nw = int(iw*scale)</span><br><span class="line">    nh = int(ih*scale)</span><br><span class="line"></span><br><span class="line">    image = image.resize((nw,nh), Image.BICUBIC) <span class="comment"># BICUBIC:双三次插值</span></span><br><span class="line">    new_image = Image.new(<span class="string">'RGB'</span>, size, (<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>))</span><br><span class="line">    new_image.paste(image, ((w-nw)//<span class="number">2</span>, (h-nh)//<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> new_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> cv2</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    pil_img = letterbox_image(Image.open(<span class="string">"1.png"</span>),(<span class="number">100</span>,<span class="number">200</span>))</span><br><span class="line">    cv2_img = cv2.cvtColor(np.array(pil_img),cv2.COLOR_RGB2BGR)</span><br><span class="line">    cv2.imshow(<span class="string">"xx"</span>,cv2_img)</span><br><span class="line">    cv2.waitKey() </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># import numpy as np</span></span><br><span class="line">    <span class="comment"># plt.imshow(letterbox_image(Image.open("1.png"),(100,200)))</span></span><br><span class="line">    <span class="comment"># plt.show()</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>将vim配制成顺手的python轻量IDE</title>
    <url>/2019/12/10/%E5%B0%86vim%E9%85%8D%E5%88%B6%E6%88%90%E9%A1%BA%E6%89%8B%E7%9A%84python%E8%BD%BB%E9%87%8FIDE/</url>
    <content><![CDATA[<p>原链接：<a href="https://www.jianshu.com/p/f0513d18742a" target="_blank" rel="noopener">https://www.jianshu.com/p/f0513d18742a</a><br><a id="more"></a></p>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>vim的配置在<code>~/vimrc</code>中完成<br>一些常见的配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;去掉vi的一致性&quot;</span><br><span class="line">set nocompatible</span><br><span class="line">&quot;显示行号&quot;</span><br><span class="line">set number</span><br><span class="line">&quot; 隐藏滚动条&quot;    </span><br><span class="line">set guioptions-&#x3D;r </span><br><span class="line">set guioptions-&#x3D;L</span><br><span class="line">set guioptions-&#x3D;b</span><br><span class="line">&quot;隐藏顶部标签栏&quot;</span><br><span class="line">set showtabline&#x3D;0</span><br><span class="line">&quot;设置字体&quot;</span><br><span class="line">set guifont&#x3D;Monaco:h13         </span><br><span class="line">syntax on   &quot;开启语法高亮&quot;</span><br><span class="line">let g:solarized_termcolors&#x3D;256  &quot;solarized主题设置在终端下的设置&quot;</span><br><span class="line">set background&#x3D;dark     &quot;设置背景色&quot;</span><br><span class="line">colorscheme solarized</span><br><span class="line">set nowrap  &quot;设置不折行&quot;</span><br><span class="line">set fileformat&#x3D;unix &quot;设置以unix的格式保存文件&quot;</span><br><span class="line">set cindent     &quot;设置C样式的缩进格式&quot;</span><br><span class="line">set tabstop&#x3D;4   &quot;设置table长度&quot;</span><br><span class="line">set shiftwidth&#x3D;4        &quot;同上&quot;</span><br><span class="line">set showmatch   &quot;显示匹配的括号&quot;</span><br><span class="line">set scrolloff&#x3D;5     &quot;距离顶部和底部5行&quot;</span><br><span class="line">set laststatus&#x3D;2    &quot;命令行为两行&quot;</span><br><span class="line">set fenc&#x3D;utf-8      &quot;文件编码&quot;</span><br><span class="line">set backspace&#x3D;2</span><br><span class="line">set mouse&#x3D;a     &quot;启用鼠标&quot;</span><br><span class="line">set selection&#x3D;exclusive</span><br><span class="line">set selectmode&#x3D;mouse,key</span><br><span class="line">set matchtime&#x3D;5</span><br><span class="line">set ignorecase      &quot;忽略大小写&quot;</span><br><span class="line">set incsearch</span><br><span class="line">set hlsearch        &quot;高亮搜索项&quot;</span><br><span class="line">set noexpandtab     &quot;不允许扩展table&quot;</span><br><span class="line">set whichwrap+&#x3D;&lt;,&gt;,h,l</span><br><span class="line">set autoread</span><br><span class="line">set cursorline      &quot;突出显示当前行&quot;</span><br><span class="line">set cursorcolumn        &quot;突出显示当前列&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h1><h2 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h2><ol>
<li>下载源码<br><code>git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</code></li>
<li>在vim中添加配置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">filetype off</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">Plugin 'VundleVim/Vundle.vim'</span><br><span class="line">Plugin '你的插件'</span><br><span class="line">call vundle#end()</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure></li>
<li>使用<br>vundle安装插件方法。现在<code>.vimrc</code>中添加plugin命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“这是安装Github上的插件”</span><br><span class="line">Plugin &#39;Lokaltog&#x2F;vim-powerline&#39;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="YCM的安装和使用"><a href="#YCM的安装和使用" class="headerlink" title="YCM的安装和使用"></a>YCM的安装和使用</h1><h2 id="YCM的安装"><a href="#YCM的安装" class="headerlink" title="YCM的安装"></a>YCM的安装</h2><ol>
<li><code>brew install cmake</code></li>
<li><code>cd ~/.vim/bundle</code></li>
<li><code>git clone https://github.com/Valloric/YouCompleteMe.git</code></li>
<li><code>cd ~/.vim/bundle/YouCompleteMe</code></li>
<li><code>git submodule update --init --recursive</code></li>
<li><code>/usr/local/Cellar/python/3.7.5/bin/python3.7 ./install.py --all</code></li>
</ol>
<h2 id="使得YCM支持第三方库"><a href="#使得YCM支持第三方库" class="headerlink" title="使得YCM支持第三方库"></a>使得YCM支持第三方库</h2><pre><code>由于vim不支持anaconda中的python，所以决定在系统python 环境中安装第三方库，并使得YCM支持安装的第三方库的自动补全。
</code></pre><ol>
<li>YCM使用的python解释器路径在<code>~/.vim/bundle/YouCompleteMe/third_party/ycmd/PYTHON_USED_DURING_BUILDING</code>下，我这里的文件内容为<code>/usr/local/opt/python/bin/python3.7</code></li>
<li><p>因为不确定系统的第三方库的安装位置，尝试进行安装：<br><code>sudo /usr/local/opt/python/bin/python3.7 -m pip install numpy</code><br>如果numpy已经安装则会出现提示：<br><code>Requirement already satisfied: python-dateutil&gt;=2.6.1 in /usr/local/lib/python3.7/site-packages (from pandas) (2.8.1)</code><br>所以我们就可以发现第三方库的安装路径为<code>/usr/local/lib/python3.7/site-packages</code></p>
</li>
<li><p>为了支持第三方库，在<code>vim ~/.vim/bundle/YouCompleteMe/.ycm_extra_conf.py</code>添加：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PythonSysPath</span><span class="params">( **kwargs )</span>:</span></span><br><span class="line">    .......</span><br><span class="line">    sys_path.insert(<span class="number">1</span>,<span class="string">'/usr/local/lib/python3.7/site-packages'</span>) <span class="comment"># 值为python安装第三方库的路径</span></span><br><span class="line">    <span class="keyword">return</span> sys_path</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>CODE工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>一些常用的tensorflow操作</title>
    <url>/2020/03/07/%E5%B8%B8%E7%94%A8tensorflow%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="特征层or图像处理"><a href="#特征层or图像处理" class="headerlink" title="特征层or图像处理"></a>特征层or图像处理</h1><a id="more"></a>
<h2 id="（1）tf-image-crop-and-resize"><a href="#（1）tf-image-crop-and-resize" class="headerlink" title="（1）tf.image.crop_and_resize"></a>（1）tf.image.crop_and_resize</h2><p>对特征层或图像进行裁剪，裁剪后再进行resize<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.image.crop_and_resize(</span><br><span class="line">    image,</span><br><span class="line">    boxes,</span><br><span class="line">    box_ind,</span><br><span class="line">    crop_size,</span><br><span class="line">    method=<span class="string">'bilinear'</span>,</span><br><span class="line">    extrapolation_value=<span class="number">0</span>,</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>参数：</p>
<ul>
<li>image：一个Tensor,必须是下列类型之一：uint8, uint16, int8, int16, int32, int64, half, float32, float64, 一个形状为[batch, image_height, image_width, depth]的四维张量,image_height和image_width需要为正值.</li>
<li>boxes：一个类型为float32的Tensor，是形状为[num_boxes, 4]的二维张量。张量的第i行指定box_ind[i]图像中框的坐标，并且在标准化坐标中指定[y1, x1, y2, x2]，四个坐标均是标准归一化后的结果；标准化的坐标值y被映射到图像坐标y * (image_height - 1)处，从而标准化图像高度的[0, 1]间隔被映射到[0, image_height - 1]的图像高度坐标中。我们允许y1&gt;y2,在这种情况下,采样的裁剪是原始图像的上下翻转版本，宽度维度的处理方式类似。[0,1]范围之外的标准化坐标是允许的,在这种情况下，我们使用extrapolation_value外推输入图像值。</li>
<li>box_ind：一个int32类型的Tensor；形状为[num_boxes]的1维张量,在[0, batch)中具有int32值，该box_ind[i]值指定第i个方框要引用的图像。</li>
<li>crop_size：一个int32类型的Tensor；一个2个元素的一维张量,size = [crop_height, crop_width]。所有裁剪的图像修补程序都调整为此大小.图像内容的宽高比不被保留；crop_height和crop_width需要为正值。</li>
<li>method：可选的string,其来自：“bilinear”；默认为”bilinear”；指定插值方法的字符串.现在只支持“双线性(bilinear)”.</li>
<li>extrapolation_value：可选的float,默认为0,用于推断的值(如果适用). name：操作的名称(可选).<br>返回值：<br>tf.image.crop_and_resize函数返回一个类型为float32的Tensor. 形状为[num_boxes, ,crop_height, crop_width, depth]<br>测试代码：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = np.array(Image.open(<span class="string">"img/street.jpg"</span>))</span><br><span class="line">shape = img.shape</span><br><span class="line">img = img.reshape([<span class="number">1</span>,shape[<span class="number">0</span>], shape[<span class="number">1</span>], shape[<span class="number">2</span>]])</span><br><span class="line">a = tf.image.crop_and_resize(img,[[<span class="number">0.5</span>,<span class="number">0.6</span>,<span class="number">0.9</span>,<span class="number">0.8</span>],[<span class="number">0.2</span>,<span class="number">0.6</span>,<span class="number">1.3</span>,<span class="number">0.9</span>]],box_ind=[<span class="number">0</span>,<span class="number">0</span>],crop_size=(<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line">sess = tf.Session()</span><br><span class="line">b = a.eval(session = sess)</span><br><span class="line">Image.fromarray(np.uint8(b[<span class="number">0</span>])).show()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="（2）tf-image-crop-and-resize"><a href="#（2）tf-image-crop-and-resize" class="headerlink" title="（2）tf.image.crop_and_resize"></a>（2）tf.image.crop_and_resize</h2><p>这是在对图像、特征层处理经常用到的函数，可以对特征层或者图像resize。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.image.resize_images(</span><br><span class="line">    images,</span><br><span class="line">    size,</span><br><span class="line">    method=ResizeMethod.BILINEAR,</span><br><span class="line">    align_corners=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>使用指定的method调整images为size。<br>调整大小的图像将失真，如果他们的原始纵横比与size不一样。</p>
<ul>
<li>images：形状为[batch, height, width, channels]的4-D张量或形状为[height, width, channels]的3-D张量。</li>
<li>size：2个元素(new_height, new_width)的1维int32张量,表示图像的新大小。</li>
<li>method：ResizeMethod,默认为ResizeMethod.BILINEAR。</li>
<li>align_corners：布尔型,如果为True,则输入和输出张量的4个拐角像素的中心对齐,并且保留角落像素处的值；默认为False。<br>如果images是四维,则返回一个形状为[batch, new_height, new_width, channels]的四维浮动张量；如果images是三维,则返回一个形状为[new_height, new_width, channels]的三维浮动张量.</li>
</ul>
<h2 id="（3）tf-transpose"><a href="#（3）tf-transpose" class="headerlink" title="（3）tf.transpose"></a>（3）tf.transpose</h2><p>可以对输入进行转置。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.transpose(</span><br><span class="line">    a,</span><br><span class="line">    perm=<span class="literal">None</span>,</span><br><span class="line">    name=<span class="string">'transpose'</span>,</span><br><span class="line">    conjugate=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>a：一个 Tensor。</li>
<li>perm：a 的维数的排列。</li>
<li>name：操作的名称(可选)。</li>
</ul>
<h1 id="获得特定位置的内容"><a href="#获得特定位置的内容" class="headerlink" title="获得特定位置的内容"></a>获得特定位置的内容</h1><h2 id="1-tf-gather"><a href="#1-tf-gather" class="headerlink" title="(1) tf.gather"></a>(1) tf.gather</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.gather(</span><br><span class="line">    params,</span><br><span class="line">    indices,</span><br><span class="line">    validate_indices=<span class="literal">None</span>,</span><br><span class="line">    name=<span class="literal">None</span>,</span><br><span class="line">    axis=<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>params：一个张量，这个张量是用来收集数值的.该张量的秩必须至少是 axis + 1。</li>
<li>indices：一个张量.必须是以下类型之一：int32,int64.索引张量必须在 [0, params.shape[axis]) 范围内。</li>
<li>axis：一个张量.必须是以下类型之一：int32，int64。在参数轴从中收集索引。默认为第一个维度.支持负索引。</li>
<li>name：操作的名称(可选)。</li>
</ul>
<p>测试代码:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"> </span><br><span class="line">a = tf.Variable([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>], [<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]])</span><br><span class="line">index_a = tf.Variable([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"> </span><br><span class="line">b = tf.Variable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">index_b = tf.Variable([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>])</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run(tf.gather(a, index_a)))</span><br><span class="line">    print(sess.run(tf.gather(a, index_a,axis = <span class="number">1</span>)))</span><br><span class="line">    print(sess.run(tf.gather(b, index_b)))</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]]</span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span>]]</span><br><span class="line">[<span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="2-tf-gather-nd"><a href="#2-tf-gather-nd" class="headerlink" title="(2) tf.gather_nd"></a>(2) tf.gather_nd</h2><p>获得特定位置的内容。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.gather_nd(</span><br><span class="line">    params,</span><br><span class="line">    indices,</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>params：张量，这个张量是用来收集数值的。</li>
<li>indices：张量，必须是以下类型之一：int32，int64；索引张量。</li>
<li>name：操作的名称(可选)。</li>
</ul>
<p>测试代码:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"> </span><br><span class="line">a = tf.Variable([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>], [<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]])</span><br><span class="line">index_a = tf.Variable([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">b = tf.Variable([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], [[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]], [[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>],[<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]]])</span><br><span class="line">index_b = tf.Variable([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line">index_c = tf.Variable([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run(tf.gather_nd(a, index_a)))</span><br><span class="line">    print(sess.run(tf.gather_nd(b, index_b)))</span><br><span class="line">    print(sess.run(tf.gather_nd(b, index_c)))</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">2</span>  <span class="number">1</span>  <span class="number">9</span> <span class="number">15</span>]</span><br><span class="line">[[ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]]</span><br><span class="line">[ <span class="number">5</span>  <span class="number">1</span> <span class="number">10</span>  <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="3-tf-where"><a href="#3-tf-where" class="headerlink" title="(3) tf.where"></a>(3) tf.where</h2><p>判断哪些位置符合这个表达式。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.where(</span><br><span class="line">    condition,</span><br><span class="line">    x=<span class="literal">None</span>,</span><br><span class="line">    y=<span class="literal">None</span>,</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>根据condition返回x或y中的元素。</p>
<p>如果x和y都为None,则该操作将返回condition中true元素的坐标，坐标以二维张量返回，其中第一维(行)表示真实元素的数量，第二维(列)表示真实元素的坐标。</p>
<p>如果两者都不是None。则x和y必须具有相同的形状。如果x和y是标量，则condition张量必须是标量，如果x和y是更高级别的矢量，则condition必须是大小与x的第一维度相匹配的矢量，或者必须具有与x相同的形状。</p>
<p>condition张量作为一个可以选择的掩码(mask)，它根据每个元素的值来判断输出中的相应元素/行是否应从 x (如果为 true) 或 y (如果为 false)中选择。</p>
<p>如果condition是向量，则x和y是更高级别的矩阵，那么它选择从x和y复制哪个行(外部维度)。如果condition与x和y具有相同的形状，那么它将选择从x和y复制哪个元素。</p>
<p>测试代码:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">sess=tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------#</span></span><br><span class="line"><span class="comment">#   用法1：</span></span><br><span class="line"><span class="comment">#   x，y没值的时候</span></span><br><span class="line"><span class="comment">#-------------------#</span></span><br><span class="line">a=[[[<span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">    [<span class="literal">True</span>, <span class="literal">False</span>]],</span><br><span class="line">   [[<span class="literal">False</span>, <span class="literal">True</span>],</span><br><span class="line">    [<span class="literal">False</span>, <span class="literal">True</span>]],</span><br><span class="line">   [[<span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">    [<span class="literal">False</span>, <span class="literal">True</span>]]]</span><br><span class="line">print(sess.run(tf.where(a)))</span><br><span class="line"><span class="comment">#-------------------#</span></span><br><span class="line"><span class="comment">#   用法2：</span></span><br><span class="line"><span class="comment">#   x，y有值的时候</span></span><br><span class="line"><span class="comment">#-------------------#</span></span><br><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]])</span><br><span class="line">a1=np.array([[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">print(sess.run(tf.equal(a,<span class="number">1</span>)))</span><br><span class="line">print(sess.run(tf.where(tf.equal(a,<span class="number">1</span>),a,a1)))</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">1</span> <span class="number">1</span>]]</span><br><span class="line">[[ <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span>]</span><br><span class="line"> [<span class="literal">False</span>  <span class="literal">True</span>  <span class="literal">True</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p>
<h1 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h1><h2 id="（1）tf-cast"><a href="#（1）tf-cast" class="headerlink" title="（1）tf.cast"></a>（1）tf.cast</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.cast(</span><br><span class="line">    x,</span><br><span class="line">    dtype,</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>tf.cast()函数的作用是执行 tensorflow 中张量数据类型转换，比如读入的图片如果是int8类型的，一般在要在训练前把图像的数据格式转换为float32。</p>
<ul>
<li>x：待转换的数据（张量）</li>
<li>dtype：目标数据类型</li>
<li>name：可选参数，定义操作的名称</li>
</ul>
<p>测试代码:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">t1 = tf.Variable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">t2 = tf.cast(t1,dtype=tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(<span class="string">'t1: &#123;&#125;'</span>.format(t1))</span><br><span class="line">    print(<span class="string">'t2: &#123;&#125;'</span>.format(t2))</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    sess.run(t2)</span><br><span class="line">    print(t2.eval())</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="（2）tf-stack"><a href="#（2）tf-stack" class="headerlink" title="（2）tf.stack"></a>（2）tf.stack</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.stack(</span><br><span class="line">    values,</span><br><span class="line">    axis=<span class="number">0</span>,</span><br><span class="line">    name=<span class="string">'stack'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>将秩为 R 的张量列表堆叠成一个秩为 (R+1) 的张量.</p>
<ul>
<li>values：具有相同形状和类型的 Tensor 对象列表.</li>
<li>axis：一个 int，要一起堆叠的轴，默认为第一维，负值环绕，所以有效范围是[-(R+1), R+1)</li>
<li>name：此操作的名称(可选)。</li>
</ul>
<p>测试代码:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = tf.constant([<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line">y = tf.constant([<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line">z = tf.constant([<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">s0 = tf.stack([x, y, z])  <span class="comment"># [[1, 4], [2, 5], [3, 6]] (Pack along first dim.)</span></span><br><span class="line">s1 = tf.stack([x, y, z], axis=<span class="number">1</span>)  <span class="comment"># [[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(s0))</span><br><span class="line">    print(sess.run(s1))</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">6</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure></p>
<h2 id="（3）tf-concat"><a href="#（3）tf-concat" class="headerlink" title="（3）tf.concat"></a>（3）tf.concat</h2><p>用于对张量进行拼接：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.concat(</span><br><span class="line">	[tensor1, tensor2, tensor3,...], </span><br><span class="line">	axis</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>测试代码:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = tf.constant([<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line">y = tf.constant([<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line">z = tf.constant([<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">s0 = tf.concat([x, y, z], axis=<span class="number">0</span>)  <span class="comment"># [[1, 4], [2, 5], [3, 6]] (Pack along first dim.)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = tf.constant([[<span class="number">1</span>], </span><br><span class="line">                 [<span class="number">4</span>]])</span><br><span class="line">y = tf.constant([[<span class="number">2</span>], </span><br><span class="line">                 [<span class="number">5</span>]])</span><br><span class="line">z = tf.constant([[<span class="number">3</span>], </span><br><span class="line">                 [<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">s1 = tf.concat([x, y, z], axis=<span class="number">0</span>) </span><br><span class="line">s2 = tf.concat([x, y, z], axis=<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(s0))</span><br><span class="line">    print(sess.run(s1))</span><br><span class="line">    print(sess.run(s2))</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span>]</span><br><span class="line">[[<span class="number">1</span>]</span><br><span class="line"> [<span class="number">4</span>]</span><br><span class="line"> [<span class="number">2</span>]</span><br><span class="line"> [<span class="number">5</span>]</span><br><span class="line"> [<span class="number">3</span>]</span><br><span class="line"> [<span class="number">6</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure></p>
<h2 id="（3）tf-reduce-max"><a href="#（3）tf-reduce-max" class="headerlink" title="（3）tf.reduce_max"></a>（3）tf.reduce_max</h2><p>用于求取某个维度最大值：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.reduce_max(</span><br><span class="line">    input_tensor,</span><br><span class="line">    axis=<span class="literal">None</span>,</span><br><span class="line">    keep_dims=<span class="literal">False</span>,</span><br><span class="line">    name=<span class="literal">None</span>,</span><br><span class="line">    reduction_indices=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>计算一个张量的各个维度上元素的最大值.<br>按照axis给定的维度减少input_tensor。除非 keep_dims 是true，否则张量的秩将在axis的每个条目中减少1。如果keep_dims为true，则减小的维度将保留为长度1。</p>
<ul>
<li>input_tensor：要使用的张量。。</li>
<li>axis：要减小的尺寸。如果为，None(默认),则减少所有维度.必须在[-rank(input_tensor), rank(input_tensor))范围内。</li>
<li>keep_dims：如果为true,则保留长度为1的减少维度。</li>
<li>name：操作的名称(可选)。</li>
<li>reduction_indices：axis的废弃的名称。</li>
</ul>
<p>测试代码:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a=np.array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">5</span>, <span class="number">3</span>],</span><br><span class="line">            [<span class="number">2</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">b = tf.Variable(a)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run(tf.reduce_max(b)))</span><br><span class="line">    print(sess.run(tf.reduce_max(b, axis=<span class="number">1</span>, keepdims=<span class="literal">False</span>)))</span><br><span class="line">    print(sess.run(tf.reduce_max(b, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)))</span><br><span class="line">    print(sess.run(tf.reduce_max(b, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)))</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">[<span class="number">2</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">[[<span class="number">2</span>]</span><br><span class="line"> [<span class="number">5</span>]</span><br><span class="line"> [<span class="number">6</span>]]</span><br><span class="line">[[<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>常见的目标检测算法(RCNN,SSD,YOLO)</title>
    <url>/2020/03/10/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/v_JULY_v/article/details/80170182" target="_blank" rel="noopener">参考链接</a><br><a id="more"></a></p>
<h1 id="常见的目标检测算法"><a href="#常见的目标检测算法" class="headerlink" title="常见的目标检测算法"></a>常见的目标检测算法</h1><p>object detection，就是在给定的图片中精确找到物体所在位置，并标注出物体的类别。所以，object detection要解决的问题就是物体在哪里以及是什么的整个流程问题。<br>然而，这个问题可不是那么容易解决的，物体的尺寸变化范围很大，摆放物体的角度，姿态不定，而且可以出现在图片的任何地方，更何况物体还可以是多个类别。</p>
<p><strong>目前学术和工业界出现的目标检测算法分成3类：</strong></p>
<ol>
<li>传统的目标检测算法：Cascade + HOG/DPM + Haar/SVM以及上述方法的诸多改进、优化；</li>
<li>候选区域/窗 + 深度学习分类：通过提取候选区域，并对相应区域进行以深度学习方法为主的分类的方案，如：<br>R-CNN（Selective Search + CNN + SVM）<br>SPP-net（ROI Pooling）<br>Fast R-CNN（Selective Search + CNN + ROI）<br>Faster R-CNN（RPN + CNN + ROI）<br>R-FCN<br>等系列方法；</li>
<li>基于深度学习的回归方法：YOLO/SSD/DenseBox 等方法；以及最近出现的结合RNN算法的RRC detection；结合DPM的Deformable CNN等<br><img src="2.png" alt=""><br><strong>传统目标检测流程：</strong><br>1）区域选择（穷举策略：采用滑动窗口，且设置不同的大小，不同的长宽比对图像进行遍历，时间复杂度高）<br>2）特征提取（SIFT、HOG等；形态多样性、光照变化多样性、背景多样性使得特征鲁棒性差）<br>3）分类器分类（主要有SVM、Adaboost等）</li>
</ol>
<p>传统目标检测的主要问题是：<br>1）基于滑动窗口的区域选择策略没有针对性，时间复杂度高，窗口冗余<br>2）手工设计的特征对于多样性的变化没有很好的鲁棒性</p>
<h1 id="候选区域-窗-深度学习分类"><a href="#候选区域-窗-深度学习分类" class="headerlink" title="候选区域/窗 + 深度学习分类"></a>候选区域/窗 + 深度学习分类</h1><h2 id="R-CNN横空出世"><a href="#R-CNN横空出世" class="headerlink" title="R-CNN横空出世"></a>R-CNN横空出世</h2><p>预先找出图中目标可能出现的位置，即候选区域（Region Proposal）。利用图像中的纹理、边缘、颜色等信息，可以保证在选取较少窗口(几千甚至几百）的情况下保持较高的召回率（Recall）。<br>所以，问题就转变成找出可能含有物体的区域/框（也就是候选区域/框，比如选2000个候选框），这些框之间是可以互相重叠互相包含的，这样我们就可以避免暴力枚举的所有框了。<br>大牛们发明好多选定候选框Region Proposal的方法，比如Selective Search和EdgeBoxes。那提取候选框用到的算法“选择性搜索”到底怎么选出这些候选框的呢？具体可以看一下PAMI2015的“What makes for effective detection proposals？”<br>2014年，RBG（Ross B. Girshick）使用Region Proposal + CNN代替传统目标检测使用的滑动窗口+手工设计特征，设计了R-CNN框架，使得目标检测取得巨大突破，并开启了基于深度学习目标检测的热潮。</p>
<h2 id="RCNN算法分为4个步骤"><a href="#RCNN算法分为4个步骤" class="headerlink" title="RCNN算法分为4个步骤"></a>RCNN算法分为4个步骤</h2><p>R-CNN的简要步骤如下<br>(1) 输入测试图像<br>(2) 利用选择性搜索Selective Search算法在图像中从下到上提取2000个左右的可能包含物体的候选区域Region Proposal<br>(3) 因为取出的区域大小各自不同，所以需要将每个Region Proposal缩放（warp）成统一的227x227的大小并输入到CNN，将CNN的fc7层的输出作为特征<br>(4) 将每个Region Proposal提取到的CNN特征输入到SVM进行分类<br>(5) 使用回归器精细修正候选框位置：对于每一个类，训练一个线性回归模型去判定这个框是否框得完美。</p>
<p><strong>Selective Search 主要思想:</strong><br>使用一种过分割手段，将图像分割成小区域 (1k~2k 个),查看现有小区域，按照合并规则合并可能性最高的相邻两个区域。重复直到整张图像合并成一个区域位置,输出所有曾经存在过的区域，所谓候选区域<br>其中合并规则如下： 优先合并以下四种区域：</p>
<ul>
<li>颜色（颜色直方图）相近的</li>
<li>纹理（梯度直方图）相近的</li>
<li>合并后总面积小的： 保证合并操作的尺度较为均匀，避免一个大区域陆续“吃掉”其他小区域 （例：设有区域a-b-c-d-e-f-g-h。较好的合并方式是：ab-cd-ef-gh -&gt; abcd-efgh -&gt; abcdefgh。 不好的合并方法是：ab-c-d-e-f-g-h -&gt;abcd-e-f-g-h -&gt;abcdef-gh -&gt; abcdefgh）</li>
<li>合并后，总面积在其BBOX中所占比例大的： 保证合并后形状规则。</li>
</ul>
<h2 id="SPP-Net"><a href="#SPP-Net" class="headerlink" title="SPP Net"></a>SPP Net</h2><p>SPP：Spatial Pyramid Pooling（空间金字塔池化）<br>SPP-Net是出自2015年发表在IEEE上的论文-《Spatial Pyramid Pooling in Deep ConvolutionalNetworks for Visual Recognition》。<br>众所周知，CNN一般都含有卷积部分和全连接部分，其中，卷积层不需要固定尺寸的图像，而全连接层是需要固定大小的输入。<br><img src="3.png" alt=""><br>所以当全连接层面对各种尺寸的输入数据时，就需要对输入数据进行crop（crop就是从一个大图扣出网络输入大小的patch，比如227×227），或warp（把一个边界框bounding box的内容resize成227×227）等一系列操作以统一图片的尺寸大小，比如224<em>224（ImageNet）、32</em>32(LenNet)、96<em>96等。<br><img src="4.png" alt=""><br>但warp/crop这种预处理，导致的问题要么被拉伸变形、要么物体不全，限制了识别精确度。SPP Net的作者Kaiming He等人逆向思考，既然由于全连接FC层的存在，普通的CNN需要通过固定输入图片的大小来使得全连接层的输入固定。那借鉴卷积层可以适应任何尺寸，为何不能在卷积层的最后加入某种结构，使得后面全连接层得到的输入变成固定的呢？<br>这个“化腐朽为神奇”的结构就是spatial pyramid pooling layer。下图便是R-CNN和SPP Net检测流程的比较：<br><strong><img src="5.png" alt=""><br>它的特点有两个:</strong><br>1.结合空间金字塔方法实现CNNs的多尺度输入。<br>SPP Net的第一个贡献就是在最后一个卷积层后，接入了金字塔池化层，保证传到下一层全连接层的输入固定。<br>换句话说，在普通的CNN机构中，输入图像的尺寸往往是固定的（比如224</em>224像素），输出则是一个固定维数的向量。SPP Net在普通的CNN结构中加入了ROI池化层（ROI Pooling），使得网络的输入图像可以是任意尺寸的，输出则不变，同样是一个固定维数的向量。<br>简言之，CNN原本只能固定输入、固定输出，CNN加上SSP之后，便能任意输入、固定输出。神奇吧？<br>ROI池化层一般跟在卷积层后面，此时网络的输入可以是任意尺度的，在SPP layer中每一个pooling的filter会根据输入调整大小，而SPP的输出则是固定维数的向量，然后给到全连接FC层。<br>2.只对原图提取一次卷积特征<br>在R-CNN中，每个候选框先resize到统一大小，然后分别作为CNN的输入，这样是很低效的。<br>而SPP Net根据这个缺点做了优化：只对原图进行一次卷积计算，便得到整张图的卷积特征feature map，然后找到每个候选框在feature map上的映射patch，将此patch作为每个候选框的卷积特征输入到SPP layer和之后的层，完成特征提取工作。<br>如此这般，R-CNN要对每个区域计算卷积，而SPPNet只需要计算一次卷积，从而节省了大量的计算时间，比R-CNN有一百倍左右的提速。</p>
<h2 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h2><p>SPP Net真是个好方法，R-CNN的进阶版Fast R-CNN就是在R-CNN的基础上采纳了SPP Net方法，对R-CNN作了改进，使得性能进一步提高。<br><strong>R-CNN与Fast R-CNN的区别有哪些呢？</strong><br>先说R-CNN的缺点：即使使用了Selective Search等预处理步骤来提取潜在的bounding box作为输入，但是R-CNN仍会有严重的速度瓶颈，原因也很明显，就是计算机对所有region进行特征提取时会有重复计算，Fast-RCNN正是为了解决这个问题诞生的。<br>与R-CNN框架图对比，可以发现主要有两处不同：一是最后一个卷积层后加了一个ROI pooling layer，二是损失函数使用了多任务损失函数(multi-task loss)，将边框回归Bounding Box Regression(先验框尺寸和位置的调整)直接加入到CNN网络中训练<br>(1) ROI pooling layer实际上是SPP-NET的一个精简版，SPP-NET对每个proposal使用了不同大小的金字塔映射，而ROI pooling layer只需要下采样到一个7x7的特征图。对于VGG16网络conv5_3有512个特征图，这样所有region proposal对应了一个7<em>7</em>512维度的特征向量作为全连接层的输入。<br>换言之，这个网络层可以把不同大小的输入映射到一个固定尺度的特征向量，而我们知道，conv、pooling、relu等操作都不需要固定size的输入，因此，在原始图片上执行这些操作后，虽然输入图片size不同导致得到的feature map尺寸也不同，不能直接接到一个全连接层进行分类，但是可以加入这个神奇的ROI Pooling层，对每个region都提取一个固定维度的特征表示，再通过正常的softmax进行类型识别。<br>(2) R-CNN训练过程分为了三个阶段，而Fast R-CNN直接使用softmax替代SVM分类，同时利用多任务损失函数边框回归也加入到了网络中，这样整个的训练过程是端到端的(除去Region Proposal提取阶段)。<br>也就是说，之前R-CNN的处理流程是先提proposal，然后CNN提取特征，之后用SVM分类器，最后再做bbox regression，而在Fast R-CNN中，作者巧妙的把bbox regression放进了神经网络内部，与region分类和并成为了一个multi-task模型，实际实验也证明，这两个任务能够共享卷积特征，并相互促进。</p>
<p>所以，Fast-RCNN很重要的一个贡献是成功的让人们看到了Region Proposal + CNN这一框架实时检测的希望，原来多类检测真的可以在保证准确率的同时提升处理速度，也为后来的Faster R-CNN做下了铺垫。</p>
<blockquote>
<p><strong>画一画重点：</strong><br>R-CNN有一些相当大的缺点（把这些缺点都改掉了，就成了Fast R-CNN）。<br>大缺点：由于每一个候选框都要独自经过CNN，这使得花费的时间非常多。<br>解决：共享卷积层，现在不是每一个候选框都当做输入进入CNN了，而是输入一张完整的图片，在第五个卷积层再得到每个候选框的特征</p>
<p>原来的方法：许多候选框（比如两千个）—&gt;CNN—&gt;得到每个候选框的特征—&gt;分类+回归<br>现在的方法：一张完整图片—&gt;CNN—&gt;得到每张候选框的特征—&gt;分类+回归</p>
<p>所以容易看见，Fast R-CNN相对于R-CNN的提速原因就在于：不过不像R-CNN把每个候选区域给深度网络提特征，而是整张图提一次特征，再把候选框映射到conv5上，而SPP只需要计算一次特征，剩下的只需要在conv5层上操作就可以了。</p>
</blockquote>
<h2 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h2><p>Fast R-CNN存在的问题：存在瓶颈：选择性搜索，找出所有的候选框，这个也非常耗时。那我们能不能找出一个更加高效的方法来求出这些候选框呢？<br><strong>解决：</strong>加入一个提取边缘的神经网络，也就说找到候选框的工作也交给神经网络来做了。<br>所以，rgbd在Fast R-CNN中引入Region Proposal Network(RPN)替代Selective Search，同时引入anchor box应对目标形状的变化问题（anchor就是位置和大小固定的box，可以理解成事先设置好的固定的proposal）。<br>具体做法：<br>　　• 将RPN放在最后一个卷积层的后面<br>　　• RPN直接训练得到候选区域<br><img src="6.png" alt=""><br><img src="7.png" alt=""></p>
<p>一种网络，四个损失函数;<br>　　• RPN calssification(anchor good.bad)<br>　　• RPN regression(anchor-&gt;propoasal)<br>　　• Fast R-CNN classification(over classes)<br>　　• Fast R-CNN regression(proposal -&gt;box)<br><img src="8.png" alt=""></p>
<p>Faster R-CNN的主要贡献就是设计了提取候选区域的网络RPN，代替了费时的选择性搜索selective search，使得检测速度大幅提高。</p>
<p>最后总结一下各大算法的步骤：<br>RCNN<br>1.在图像中确定约1000-2000个候选框 (使用选择性搜索Selective Search)<br>2.每个候选框内图像块缩放至相同大小，并输入到CNN内进行特征提取<br>3.对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>4.对于属于某一类别的候选框，用回归器进一步调整其位置</p>
<p>Fast R-CNN<br>1.在图像中确定约1000-2000个候选框 (使用选择性搜索Selective Search)<br>2.对整张图片输进CNN，得到feature map<br>3.找到每个候选框在feature map上的映射patch，将此patch作为每个候选框的卷积特征输入到SPP layer和之后的层<br>4.对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>5.对于属于某一类别的候选框，用回归器进一步调整其位置</p>
<p>Faster R-CNN<br>1.对整张图片输进CNN，得到feature map<br>2.卷积特征输入到RPN，得到候选框的特征信息<br>3.对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>4.对于属于某一类别的候选框，用回归器进一步调整其位置</p>
<p><img src="9.png" alt=""></p>
<h1 id="基于深度学习的回归算法"><a href="#基于深度学习的回归算法" class="headerlink" title="基于深度学习的回归算法"></a>基于深度学习的回归算法</h1><p>TOLO和SSD算法可以参看我的其他博文</p>
<h2 id="YOLO-CVPR2016-oral"><a href="#YOLO-CVPR2016-oral" class="headerlink" title="YOLO (CVPR2016, oral)"></a>YOLO (CVPR2016, oral)</h2><p>(You Only Look Once: Unified, Real-Time Object Detection)<br>Faster R-CNN的方法目前是主流的目标检测方法，但是速度上并不能满足实时的要求。YOLO一类的方法慢慢显现出其重要性，这类方法使用了回归的思想，利用整张图作为网络的输入，直接在图像的多个位置上回归出这个位置的目标边框，以及目标所属的类别。</p>
<h2 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h2><p>首先SSD获取目标位置和类别的方法跟YOLO一样，都是使用回归，但是YOLO预测某个位置使用的是全图的特征，SSD预测某个位置使用的是这个位置周围的特征（感觉更合理一些）。</p>
<p>那么如何建立某个位置和其特征的对应关系呢？可能你已经想到了，使用Faster R-CNN的anchor机制。如SSD的框架图所示，假如某一层特征图(图b)大小是8<em>8，那么就使用3</em>3的滑窗提取每个位置的特征，然后这个特征回归得到目标的坐标信息和类别信息(图c)。</p>
<p>不同于Faster R-CNN，这个anchor是在多个feature map上，这样可以利用多层的特征并且自然的达到多尺度（不同层的feature map 3*3滑窗感受野不同）。</p>
<p>小结：SSD结合了YOLO中的回归思想和Faster R-CNN中的anchor机制，使用全图各个位置的多尺度区域特征进行回归，既保持了YOLO速度快的特性，也保证了窗口预测的跟Faster R-CNN一样比较精准。SSD在VOC2007上mAP可以达到72.1%，速度在GPU上达到58帧每秒。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
  </entry>
  <entry>
    <title>弹性力学</title>
    <url>/2020/08/26/%E5%BC%B9%E6%80%A7%E5%8A%9B%E5%AD%A6/</url>
    <content><![CDATA[<p>三钱之一钱伟长的书，书中的证明详细，没有丝毫的跳跃，值得一读。<br><a id="more"></a></p>
<h2 id="固体的近代物理概念"><a href="#固体的近代物理概念" class="headerlink" title="固体的近代物理概念"></a>固体的近代物理概念</h2><p>许多脆性材料在除去载荷，重复载荷的过程中，并不是沿着一条直线进行，而是沿着一种回路进行，经过回路需要作工，因此发生弹性滞后现象。滞后现象是材料振动时破坏的主要因素。</p>
<p><b>泊松比</b></p>
$$\frac{\epsilon_y}{\epsilon_z}=-\nu$$
<p><b>剪切模量</b></p>
$$\frac{\tau}{\gamma}=\mu$$
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><iframe src="弹性力学-钱伟长（读书笔记）.pdf"  width="100%" height="800px"></iframe>

]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>弹性力学</tag>
        <tag>有限元</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><a id="more"></a>
<h1 id="数据库的简介"><a href="#数据库的简介" class="headerlink" title="数据库的简介"></a>数据库的简介</h1><h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><p>数据库（database，DB）是指长期存储在计算机内的，有组织，可共享的数据的集合。数据库中的数据按一定的数学模型组织、描述和存储，具有较小的冗余，较高的数据独立性和易扩展性，并可为各种用户共享。</p>
<h2 id="数据库管理系统软件"><a href="#数据库管理系统软件" class="headerlink" title="数据库管理系统软件"></a>数据库管理系统软件</h2><p>数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过DBMS访问数据库中的数据，数据库管理员也通过dbms进行数据库的维护工作。它可使多个应用程序和用户用不同的方法在同时或不同时刻去建立，修改和询问数据库。大部分DBMS提供数据定义语言DDL（Data Definition Language）和数据操作语言DML（Data Manipulation Language），供用户定义数据库的模式结构与权限约束，实现对数据的追加、删除等操作。</p>
<p>数据库管理系统是数据库系统的核心，是管理数据库的软件。数据库管理系统就是实现把用户意义下抽象的逻辑数据处理，转换成为计算机中具体的物理数据处理的软件。有了数据库管理系统，用户就可以在抽象意义下处理数据，而不必顾及这些数据在计算机中的布局和物理位置。</p>
<p>常见的数据库管理软件：甲骨文的oracle,IBM的db2，sql server, Access,Mysql(开源，免费，跨平台).</p>
<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p>数据库系统DBS（Data Base System，简称DBS）通常由软件、数据库和数据管理员组成。其软件主要包括操作系统、各种宿主语言、实用程序以及数据库管理系统。数据库由数据库管理系统统一管理，数据的插入、修改和检索均要通过数据库管理系统进行。数据管理员负责创建、监控和维护整个数据库，使数据能被任何有权使用的人有效使用。</p>
<p>​                        <img src="image/877318-20170205222624323-946460904.png" alt="img"></p>
<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="mysql的管理"><a href="#mysql的管理" class="headerlink" title="mysql的管理"></a>mysql的管理</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>mac：</strong></p>
<p><a href="https://www.jianshu.com/p/07a9826898c0" target="_blank" rel="noopener">https://www.jianshu.com/p/07a9826898c0</a></p>
<p><strong>linux:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--yum -y install mariadb mariadb-server</span><br><span class="line">OR</span><br><span class="line">--yum -y install mysql mysql-server</span><br></pre></td></tr></table></figure>
<p><strong>win:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--http:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a><strong>启动</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--service mysqld start  #开启</span><br><span class="line">--chkconfig mysqld on   #设置开机自启</span><br><span class="line">OR</span><br><span class="line">--systemctl start mariadb</span><br><span class="line">--systemctl enable mariadb</span><br></pre></td></tr></table></figure>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- ps aux |grep mysqld    #查看进程</span><br><span class="line">-- netstat -an |grep 3306 #查看端口</span><br></pre></td></tr></table></figure>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- mysqladmin -uroot password &#39;123&#39;   #设置初始密码，初始密码为空因此-p选项没有用</span><br><span class="line">-- mysqladmin -u root -p123 password &#39;1234&#39; #修改root用户密码</span><br></pre></td></tr></table></figure>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- mysql               #本地登录，默认用户root，空密码，用户为root@127.0.0.1</span><br><span class="line">-- mysql -uroot -p1234 #本地登录，指定用户名和密码，用户为root@127.0.0.1</span><br><span class="line">-- mysql -uroot -p1234 -h 192.168.31.95 #远程登录，用户为root@192.168.31.95</span><br></pre></td></tr></table></figure>
<h2 id="mysql的常用命令"><a href="#mysql的常用命令" class="headerlink" title="mysql的常用命令"></a>mysql的常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- </span><br><span class="line">-- 启动mysql服务与停止mysql服务命令：</span><br><span class="line">-- </span><br><span class="line">-- net start mysql</span><br><span class="line">-- net stop  mysql</span><br><span class="line">-- </span><br><span class="line">-- </span><br><span class="line">-- 登陆与退出命令：</span><br><span class="line">-- </span><br><span class="line">--    mysql －h 服务器IP -P 端口号 -u  用户名 -p 密码 －－prompt 命令提示符  －－delimiter 指定分隔符</span><br><span class="line">--    mysql －h 127.0.0.1 -P 3306 -uroot -p123</span><br><span class="line">--    quit------exit----\q;</span><br><span class="line">-- </span><br><span class="line">-- </span><br><span class="line">-- \s;   ------my.ini文件：[mysql] default-character-set&#x3D;gbk [mysqld] character-set-server&#x3D;gbk</span><br><span class="line">-- </span><br><span class="line">-- prompt 命令提示符（\D:当前日期 \d:当前数据库  \u:当前用户）</span><br><span class="line">-- </span><br><span class="line">-- \T(开始日志) \t(结束日志)</span><br><span class="line">-- </span><br><span class="line">-- show warnings;</span><br><span class="line">-- </span><br><span class="line">-- help() ? \h</span><br><span class="line">-- </span><br><span class="line">-- \G；</span><br><span class="line">-- </span><br><span class="line">-- select now();</span><br><span class="line">-- select version();</span><br><span class="line">-- select user;</span><br><span class="line">-- </span><br><span class="line">-- \c 取消命令</span><br><span class="line">-- </span><br><span class="line">-- delimiter 指定分隔符</span><br></pre></td></tr></table></figure>
<h2 id="忘记密码怎么办？"><a href="#忘记密码怎么办？" class="headerlink" title="忘记密码怎么办？"></a>忘记密码怎么办？</h2><h3 id="方法1：启动mysql时，跳过授权表"><a href="#方法1：启动mysql时，跳过授权表" class="headerlink" title="方法1：启动mysql时，跳过授权表"></a>方法1：启动mysql时，跳过授权表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@controller ~]# service mysqld stop</span><br><span class="line">[root@controller ~]# mysqld_safe --skip-grant-table &amp;</span><br><span class="line">[root@controller ~]# mysql</span><br><span class="line">mysql&gt; select user,host,password from mysql.user;</span><br><span class="line">+----------+-----------------------+-------------------------------------------+</span><br><span class="line">| user     | host                  | password                                  |</span><br><span class="line">+----------+-----------------------+-------------------------------------------+</span><br><span class="line">| root     | localhost             | *A4B6157319038724E3560894F7F932C8886EBFCF |</span><br><span class="line">| root     | localhost.localdomain |                                           |</span><br><span class="line">| root     | 127.0.0.1             |                                           |</span><br><span class="line">| root     | ::1                   |                                           |</span><br><span class="line">|          | localhost             |                                           |</span><br><span class="line">|          | localhost.localdomain |                                           |</span><br><span class="line">| root     | %                     | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |</span><br><span class="line">+----------+-----------------------+-------------------------------------------+</span><br><span class="line">mysql&gt; update mysql.user set password&#x3D;password(&quot;123&quot;) where user&#x3D;&quot;root&quot; and host&#x3D;&quot;localhost&quot;;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; exit</span><br><span class="line">[root@controller ~]# service mysqld restart</span><br><span class="line">[root@controller ~]# mysql -uroot -p123</span><br></pre></td></tr></table></figure>
<h3 id="方法2-删库"><a href="#方法2-删库" class="headerlink" title="方法2(删库):"></a>方法2(删库):</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除与权限相关的库mysql，所有的授权信息都丢失，主要用于测试数据库或者刚刚建库不久没有授权数据的情况（从删库到跑路）</span><br><span class="line">[root@controller ~]# rm -rf &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql</span><br><span class="line">[root@controller ~]# service mysqld restart</span><br><span class="line">[root@controller ~]# mysql</span><br></pre></td></tr></table></figure>
<h2 id="sql及其规范"><a href="#sql及其规范" class="headerlink" title="sql及其规范"></a>sql及其规范</h2><p>sql是Structured Query Language(结构化查询语言)的缩写。SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。</p>
<p>在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。SQL功能强大、简单易学、使用方便，已经成为了数据库操作的基础，并且现在几乎所有的数据库均支持sql。</p>
<p><1> 在数据库系统中，SQL语句<strong>不区分大小写(建议用大写)</strong> 。但字符串常量区分大小写。建议命令大写，表名库名小写；</p>
<p><2> SQL语句可单行或多行书写，<strong>以“;”结尾</strong>。<strong>关键词不能跨多行或简写</strong>。</p>
<p><3> 用空格和缩进来提高语句的可读性。子句通常位于独立行，便于编辑，提高可读性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_table</span><br><span class="line">            WHERE NAME&#x3D;&quot;YUAN&quot;;</span><br></pre></td></tr></table></figure>
<p><4> 注释：单行注释：—</p>
<p>​               多行注释：/*……*/</p>
<p><5>sql语句可以折行操作</p>
<p><6> DDL,DML和DCL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- --SQL中 DML、DDL、DCL区别 .</span><br><span class="line">-- </span><br><span class="line">-- </span><br><span class="line">-- -- DML（data manipulation language）：</span><br><span class="line">--    它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的</span><br><span class="line">--    数据进行操作的语言</span><br><span class="line">-- </span><br><span class="line">-- -- DDL（data definition language）：</span><br><span class="line">--    DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）</span><br><span class="line">--    的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用</span><br><span class="line">-- </span><br><span class="line">-- -- DCL（Data Control Language）：</span><br><span class="line">--    是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）</span><br><span class="line">--    语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权</span><br><span class="line">--    力执行DCL</span><br></pre></td></tr></table></figure>
<h2 id="数据库操作-DDL"><a href="#数据库操作-DDL" class="headerlink" title="数据库操作(DDL)"></a>数据库操作(DDL)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1.创建数据库（在磁盘上创建一个对应的文件夹）</span><br><span class="line">    create database [if not exists] db_name [character set xxx]; character set gbk设置编码方式</span><br><span class="line">    </span><br><span class="line">-- 2.查看数据库</span><br><span class="line">    show databases;查看所有数据库</span><br><span class="line">    show create database db_name; 查看数据库的创建方式</span><br><span class="line">    show warnings; 查看警告信息</span><br><span class="line"></span><br><span class="line">-- 3.修改数据库</span><br><span class="line">    alter database db_name [character set xxx] </span><br><span class="line"></span><br><span class="line">-- 4.删除数据库</span><br><span class="line">    drop database [if exists] db_name;</span><br><span class="line">    </span><br><span class="line">-- 5.使用数据库</span><br><span class="line">    切换数据库 use db_name; -- 注意：进入到某个数据库后没办法再退回之前状态，但可以通过use进行切换</span><br><span class="line">    查看当前使用的数据库 select database();</span><br></pre></td></tr></table></figure>
<h2 id="mysql数据类型"><a href="#mysql数据类型" class="headerlink" title="mysql数据类型"></a>mysql数据类型</h2><p>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BIT 位类型</span><br><span class="line">BOOLEAN  ---&gt;自动转换为tinyint(1)</span><br><span class="line">BOOL</span><br></pre></td></tr></table></figure>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>下面的表显示了需要的每个整数类型的存储和范围。</p>
<p><img src="image/877318-20170129165834706-1279238667.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float(4,2) &#x2F;*共4位，小数点后2位，99.99*&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p>
<p><img src="image/877318-20170129165909409-310855737.png" alt="img"></p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<p><img src="image/877318-20170129170151472-2101364934.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char(10) &#x2F;*定长字符串，10字节*&#x2F;</span><br><span class="line">varchar(20) &#x2F;*变长字符串，0～20字节*&#x2F;</span><br></pre></td></tr></table></figure>
<p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。</p>
<p>BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。</p>
<p>有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。</p>
<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1.创建表（类似于一个excel表）</span><br><span class="line"></span><br><span class="line">        create table tab_name(</span><br><span class="line">            field1 type[完整性约束条件], </span><br><span class="line">            field2 type,</span><br><span class="line">            ...</span><br><span class="line">            fieldn type</span><br><span class="line">        )[character set xxx];</span><br><span class="line"></span><br><span class="line">         -- 创建一个员工表employee</span><br><span class="line"></span><br><span class="line">         create table employee(</span><br><span class="line">            id int primary key auto_increment ,</span><br><span class="line">            name varchar(20),</span><br><span class="line">            gender bit default 1,   -- gender char(1)  default 1   -----    或者 TINYINT(1) </span><br><span class="line">            birthday date,</span><br><span class="line">            entry_date date,</span><br><span class="line">            job varchar(20),</span><br><span class="line">            salary double(4,2) unsigned,</span><br><span class="line">            resume text    -- 注意，这里作为最后一个字段不加逗号</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;* 约束:</span><br><span class="line">       primary key (非空且唯一)  :能够唯一区分出当前记录的字段称为主键！ 为索引</span><br><span class="line">       unique</span><br><span class="line">       not null</span><br><span class="line">       auto_increment 主键字段必须是数字类型。</span><br><span class="line">       外键约束 foreign key  *&#x2F;</span><br><span class="line"></span><br><span class="line">-- 2.查看表信息</span><br><span class="line">    desc tab_name 查看表结构</span><br><span class="line">    show columns from tab_name  查看表结构</span><br><span class="line">    show tables 查看当前数据库中的所有的表</span><br><span class="line">    show create table tab_name    查看当前数据库表建表语句 </span><br><span class="line"></span><br><span class="line">-- 3.修改表结构</span><br><span class="line">   -- (1)增加列(字段)</span><br><span class="line">      alter table tab_name add [column] 列名 类型［完整性约束条件］［first｜after 字段名］;</span><br><span class="line">      alter table user add addr varchar(20) not null unique first&#x2F;after username;</span><br><span class="line">      #添加多个字段</span><br><span class="line">      alter table users2 </span><br><span class="line">            add addr varchar(20),</span><br><span class="line">            add age  int first,</span><br><span class="line">            add birth varchar(20) after name;</span><br><span class="line"></span><br><span class="line">   -- (2)修改一列类型</span><br><span class="line">      alter table tab_name modify 列名 类型 [完整性约束条件]［first｜after 字段名］;</span><br><span class="line">      alter table test_table modify test_col tinyint not null after id; #after调整顺序</span><br><span class="line">      alter table users2 modify age tinyint default 20;</span><br><span class="line">      alter table users2 modify age int  after id;</span><br><span class="line">   </span><br><span class="line">   -- (3)修改列名</span><br><span class="line">      alter table tab_name change [column] 列名 新列名 类型 [完整性约束条件]［first｜after 字段名］;</span><br><span class="line">      alter table users2 change age Age int default 28 first;</span><br><span class="line"></span><br><span class="line">   -- (4)删除一列</span><br><span class="line">      alter table tab_name drop [column] 列名;</span><br><span class="line">      -- 思考：删除多列呢？删一个填一个呢？</span><br><span class="line">      alter table users2 </span><br><span class="line">            add salary float(6,2) unsigned not null after name,</span><br><span class="line">            drop addr;    </span><br><span class="line"></span><br><span class="line">   -- (5)修改表名</span><br><span class="line">      rename table 表名 to 新表名;</span><br><span class="line">   -- (6)修该表所用的字符集    </span><br><span class="line">      alter table student character set utf8;</span><br><span class="line"></span><br><span class="line">-- 4.删除表</span><br><span class="line">    drop table tab_name;</span><br><span class="line"></span><br><span class="line">-- 5 添加主键，删除主键</span><br><span class="line">    alter table tab_name add primary key(字段名称,...) </span><br><span class="line">    alter table users drop primary key;</span><br><span class="line"></span><br><span class="line">    eg:</span><br><span class="line">    mysql&gt; create table test5(num int auto_increment);</span><br><span class="line">    ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key</span><br><span class="line">    create table test(num int primary key auto_increment);</span><br><span class="line">    -- 思考，如何删除主键？</span><br><span class="line">    alter table test modify id int;   -- auto_increment没了，但这样写主键依然存在，所以还要加上下面这句</span><br><span class="line">    alter table test drop primary key;-- 仅仅用这句也无法直接删除主键</span><br><span class="line"></span><br><span class="line">-- 唯一索引</span><br><span class="line">    alter table tab_name add unique [index|key] [索引名称](字段名称,...) </span><br><span class="line"></span><br><span class="line">    alter table users add unique(name)-- 索引值默认为字段名show create table users;</span><br><span class="line">    alter table users add unique key user_name(name);-- 索引值为user_name</span><br><span class="line"></span><br><span class="line">    -- 添加联合索引</span><br><span class="line">    alter table users add unique index name_age(name,age);#show create table users;</span><br><span class="line"></span><br><span class="line">    -- 删除唯一索引</span><br><span class="line">    alter table tab_name drop &#123;index|key&#125; index_name</span><br></pre></td></tr></table></figure>
<p><strong>创建文章表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="完整性约束条件之主键约束"><a href="#完整性约束条件之主键约束" class="headerlink" title="完整性约束条件之主键约束"></a>完整性约束条件之主键约束</h3><p><strong>单字段主键</strong></p>
<p>主键字段特点：非空且唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table users(</span><br><span class="line">           id INT primary key,</span><br><span class="line">           name varchar(20),</span><br><span class="line">           city varchar(20)</span><br><span class="line">         );</span><br></pre></td></tr></table></figure>
<p><strong>多字段联合主键</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table users2(</span><br><span class="line">           id INT,</span><br><span class="line">           name varchar(20),</span><br><span class="line">           city varchar(20),</span><br><span class="line">           primary key(name,id)</span><br><span class="line">         );</span><br></pre></td></tr></table></figure>
<p><1> 一张表只能有一个主键</p>
<p><2> 主键类型不一定非是整型</p>
<h2 id="表纪录操作"><a href="#表纪录操作" class="headerlink" title="表纪录操作"></a>表纪录操作</h2><h3 id="表纪录之增，删，改"><a href="#表纪录之增，删，改" class="headerlink" title="表纪录之增，删，改"></a>表纪录之增，删，改</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1.增加一条记录insert</span><br><span class="line"></span><br><span class="line">      &#x2F;*insert ［into］ tab_name (field1,filed2,.......) values (value1,value2,.......);*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      create table employee_new(</span><br><span class="line">                 id int primary key auto_increment,</span><br><span class="line">                 name varchar(20) not null unique,</span><br><span class="line">                 birthday varchar(20),</span><br><span class="line">                 salary float(7,2)</span><br><span class="line">                             );</span><br><span class="line"></span><br><span class="line">       insert into employee_new (id,name,birthday,salary) values</span><br><span class="line">                     (1,&#39;yuan&#39;,&#39;1990-09-09&#39;,9000);</span><br><span class="line"></span><br><span class="line">       insert into employee_new values</span><br><span class="line">       (2,&#39;alex&#39;,&#39;1989-08-08&#39;,3000);</span><br><span class="line"></span><br><span class="line">       insert into employee_new (name,salary) values</span><br><span class="line">       (&#39;xialv&#39;,1000);</span><br><span class="line"></span><br><span class="line">      -- 插入多条数据</span><br><span class="line">       insert into employee_new values</span><br><span class="line">       (4,&#39;alvin1&#39;,&#39;1993-04-20&#39;,3000),</span><br><span class="line">       (5,&#39;alvin2&#39;,&#39;1995-05-12&#39;,5000);</span><br><span class="line"></span><br><span class="line">      -- set插入: insert ［into］ tab_name set 字段名&#x3D;值</span><br><span class="line"></span><br><span class="line">      insert into employee_new set id&#x3D;12,name&#x3D;&quot;alvin3&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 2.修改表记录  update tab_name set field1&#x3D;value1,field2&#x3D;value2,......[where 语句]</span><br><span class="line"></span><br><span class="line">    &#x2F;*      UPDATE语法可以用新值更新原有表行中的各列。</span><br><span class="line">            SET子句指示要修改哪些列和要给予哪些值。</span><br><span class="line">            WHERE子句指定应更新哪些行。如没有WHERE子句，则更新所有的行。*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    update employee_new set birthday&#x3D;&quot;1989-10-24&quot; WHERE id&#x3D;1;</span><br><span class="line"></span><br><span class="line">    --- 将yuan的薪水在原有基础上增加1000元。</span><br><span class="line">    update employee_new set salary&#x3D;salary+4000 where name&#x3D;&#39;yuan&#39;;</span><br><span class="line"></span><br><span class="line">-- 3.删除表纪录</span><br><span class="line"></span><br><span class="line">     delete from tab_name [where ....]</span><br><span class="line"></span><br><span class="line">        &#x2F;*    如果不跟where语句则删除整张表中的数据</span><br><span class="line">            delete只能用来删除一行记录</span><br><span class="line">            delete语句只能删除表中的内容，不能删除表本身，想要删除表，用drop</span><br><span class="line">            TRUNCATE TABLE也可以删除表中的所有数据，词语句首先摧毁表，再新建表。此种方式删除的数据不能在事务中恢复。*&#x2F;</span><br><span class="line"></span><br><span class="line">                -- 删除表中名称为’alex’的记录。</span><br><span class="line">                delete from employee_new where name&#x3D;&#39;alex&#39;;</span><br><span class="line">                -- 删除表中所有记录。（一条一条删除）</span><br><span class="line">                delete from employee_new;-- 注意auto_increment没有被重置:alter table employee auto_increment&#x3D;1;</span><br><span class="line">                -- 使用truncate删除表中记录。(直接删除表)</span><br><span class="line">                truncate table emp_new;</span><br></pre></td></tr></table></figure>
<p><strong>思考：</strong></p>
<p>​    <strong><1>  存储时间用varchar可不可以呢？它与date数据类型又有什么区别呢？</strong>（只用来显示时，可以用varchar，如果要计算用date）</p>
<p>​    <strong><2>  表中数据三条，id分别为1，2，3，突然插入一个id＝7，那么下次作为主键的字增长的id会从几开始增长呢？(从7开始)</strong></p>
<h3 id="表纪录之查-单表查询"><a href="#表纪录之查-单表查询" class="headerlink" title="表纪录之查(单表查询)"></a>表纪录之查(单表查询)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询表达式</span><br><span class="line"></span><br><span class="line">   SELECT *|field1,filed2 ...   FROM tab_name</span><br><span class="line">                  WHERE 条件</span><br><span class="line">                  GROUP BY field</span><br><span class="line">                  HAVING 筛选</span><br><span class="line">                  ORDER BY field</span><br><span class="line">                  LIMIT 限制条数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ---准备表</span><br><span class="line"></span><br><span class="line">   CREATE TABLE ExamResult(</span><br><span class="line"></span><br><span class="line">   id INT PRIMARY KEY  auto_increment,</span><br><span class="line">   name VARCHAR (20),</span><br><span class="line">   JS DOUBLE ,</span><br><span class="line">   Django DOUBLE ,</span><br><span class="line">   OpenStack DOUBLE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO ExamResult VALUES  (1,&quot;yuan&quot;,98,98,98),</span><br><span class="line">                               (2,&quot;xialv&quot;,35,98,67),</span><br><span class="line">                               (3,&quot;alex&quot;,59,59,62),</span><br><span class="line">                               (4,&quot;wusir&quot;,88,89,82),</span><br><span class="line">                               (5,&quot;alvin&quot;,88,98,67),</span><br><span class="line">                               (6,&quot;yuan&quot;,86,100,55);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- （1）select [distinct] *|field1，field2，......   from tab_name</span><br><span class="line">            -- 其中from指定从哪张表筛选，*表示查找所有列，也可以指定一个列</span><br><span class="line">            -- 表明确指定要查找的列，distinct用来剔除重复行。</span><br><span class="line"></span><br><span class="line">                    -- 查询表中所有学生的信息。</span><br><span class="line">                    select * from ExamResult;</span><br><span class="line">                    -- 查询表中所有学生的姓名和对应的英语成绩。</span><br><span class="line">                    select name,JS from ExamResult;</span><br><span class="line">                    -- 过滤表中重复数据。</span><br><span class="line">                    select distinct JS ,name from ExamResult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- （2）select 也可以使用表达式，并且可以使用: 字段 as 别名或者:字段 别名</span><br><span class="line"></span><br><span class="line">                -- 在所有学生分数上加10分特长分显示。</span><br><span class="line"></span><br><span class="line">                select name,JS+10,Django+10,OpenStack+10 from ExamResult;</span><br><span class="line">                -- 统计每个学生的总分。</span><br><span class="line">                select name,JS+Django+OpenStack from ExamResult;</span><br><span class="line">                -- 使用别名表示学生总分。</span><br><span class="line">                select name as 姓名,JS+Django+OpenStack as 总成绩 from ExamResult;</span><br><span class="line">                select name,JS+Django+OpenStack 总成绩 from ExamResult;</span><br><span class="line"></span><br><span class="line">                select name JS from ExamResult; -- what will happen?----&gt;记得加逗号</span><br><span class="line"></span><br><span class="line">-- （3）使用where子句，进行过滤查询。</span><br><span class="line"></span><br><span class="line">            -- 查询姓名为XXX的学生成绩</span><br><span class="line">            select * from ExamResult where name&#x3D;&#39;yuan&#39;;</span><br><span class="line">            -- 查询英语成绩大于90分的同学</span><br><span class="line">            select id,name,JS from ExamResult where JS&gt;90;</span><br><span class="line">            -- 查询总分大于200分的所有同学</span><br><span class="line">            select name,JS+Django+OpenStack as 总成绩 from</span><br><span class="line">                        ExamResult where JS+Django+OpenStack&gt;200 ;</span><br><span class="line">            -- where字句中可以使用：</span><br><span class="line">                     -- 比较运算符：</span><br><span class="line">                        &gt; &lt; &gt;&#x3D; &lt;&#x3D; &lt;&gt; !&#x3D;</span><br><span class="line">                        between 80 and 100 值在10到20之间</span><br><span class="line">                        in(80,90,100) 值是10或20或30</span><br><span class="line">                        like &#39;yuan%&#39;</span><br><span class="line">                        &#x2F;*</span><br><span class="line">                        pattern可以是%或者_，</span><br><span class="line">                        如果是%则表示任意多字符，此例如唐僧,唐国强</span><br><span class="line">                        如果是_则表示一个字符唐_，只有唐僧符合。两个_则表示两个字符：__</span><br><span class="line">                        *&#x2F;</span><br><span class="line"></span><br><span class="line">                    -- 逻辑运算符</span><br><span class="line">                        在多个条件直接可以使用逻辑运算符 and or not</span><br><span class="line">            -- 练习</span><br><span class="line">                -- 查询JS分数在 70－100之间的同学。</span><br><span class="line">                select name ,JS from ExamResult where JS between 80 and 100;</span><br><span class="line">                -- 查询Django分数为75,76,77的同学。</span><br><span class="line">                select name ,Django from ExamResult where Django in (75,98,77);</span><br><span class="line">                -- 查询所有姓王的学生成绩。</span><br><span class="line">                select * from ExamResult where name like &#39;王%&#39;;</span><br><span class="line">                -- 查询JS分&gt;90，Django分&gt;90的同学。</span><br><span class="line">                select id,name from ExamResult where JS&gt;90 and Django &gt;90;</span><br><span class="line">                -- 查找缺考数学的学生的姓名</span><br><span class="line">                select name from ExamResult where Database is null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- （4）Order by 指定排序的列，排序的列即可是表中的列名，也可以是select 语句后指定的别名。</span><br><span class="line"></span><br><span class="line">              -- select *|field1,field2... from tab_name order by field [Asc|Desc]</span><br><span class="line"></span><br><span class="line">              -- Asc 升序、Desc 降序，其中asc为默认值 ORDER BY 子句应位于SELECT语句的结尾。</span><br><span class="line">              -- 练习：</span><br><span class="line">              -- 对JS成绩排序后输出。</span><br><span class="line">              select * from ExamResult order by JS;</span><br><span class="line">              -- 对总分排序按从高到低的顺序输出</span><br><span class="line">              select name ,(ifnull(JS,0)+ifnull(Django,0)+ifnull(Database,0))</span><br><span class="line">                   总成绩 from ExamResult order by 总成绩 desc;</span><br><span class="line">              -- 对姓李的学生成绩排序输出</span><br><span class="line">              select name ,(ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0))</span><br><span class="line">                   总成绩 from ExamResult where name like &#39;a%&#39;</span><br><span class="line">                                         order by 总成绩 desc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- （5）group by 分组查询：</span><br><span class="line">        CREATE TABLE order_menu(</span><br><span class="line">             id INT PRIMARY KEY auto_increment,</span><br><span class="line">             product_name VARCHAR (20),</span><br><span class="line">             price FLOAT(6,2),</span><br><span class="line">             born_date DATE,</span><br><span class="line">             class VARCHAR (20)</span><br><span class="line">                                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         INSERT INTO order_menu (product_name,price,born_date,class) VALUES</span><br><span class="line">                                             (&quot;苹果&quot;,20,20170612,&quot;水果&quot;),</span><br><span class="line">                                             (&quot;香蕉&quot;,80,20170602,&quot;水果&quot;),</span><br><span class="line">                                             (&quot;水壶&quot;,120,20170612,&quot;电器&quot;),</span><br><span class="line">                                             (&quot;被罩&quot;,70,20170612,&quot;床上用品&quot;),</span><br><span class="line">                                             (&quot;音响&quot;,420,20170612,&quot;电器&quot;),</span><br><span class="line">                                             (&quot;床单&quot;,55,20170612,&quot;床上用品&quot;),</span><br><span class="line">                                             (&quot;草莓&quot;,34,20170612,&quot;水果&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            -- 注意,按分组条件分组后每一组只会显示第一条记录</span><br><span class="line"></span><br><span class="line">            -- group by字句，其后可以接多个列名，也可以跟having子句,对group by 的结果进行筛选。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    -- 按位置字段筛选</span><br><span class="line">                       select * from order_menu group by 5;</span><br><span class="line"></span><br><span class="line">                    -- 练习：对购物表按类名分组后显示每一组商品的价格总和</span><br><span class="line">                       select class,SUM(price)from order_menu group by class;</span><br><span class="line"></span><br><span class="line">                    -- 练习：对购物表按类名分组后显示每一组商品价格总和超过150的商品</span><br><span class="line">                       select class,SUM(price)from order_menu group by class</span><br><span class="line">                                                        HAVING SUM(price)&gt;150;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                   &#x2F;*</span><br><span class="line">                   having 和 where两者都可以对查询结果进行进一步的过滤，差别有：</span><br><span class="line">                     &lt;1&gt;where语句只能用在分组之前的筛选，having可以用在分组之后的筛选；</span><br><span class="line">                     &lt;2&gt;使用where语句的地方都可以用having进行替换</span><br><span class="line">                     &lt;3&gt;having中可以用聚合函数，where中就不行。</span><br><span class="line">                   *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            -- GROUP_CONCAT() 函数</span><br><span class="line">            SELECT id,GROUP_CONCAT(name),GROUP_CONCAT(JS) from ExamResult GROUP BY id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- （6）聚合函数： 先不要管聚合函数要干嘛，先把要求的内容查出来再包上聚合函数即可。</span><br><span class="line">                 --   (一般和分组查询配合使用)</span><br><span class="line"></span><br><span class="line">        --&lt;1&gt; 统计表中所有记录</span><br><span class="line"></span><br><span class="line">            -- COUNT(列名)：统计行的个数</span><br><span class="line">                    -- 统计一个班级共有多少学生？先查出所有的学生，再用count包上</span><br><span class="line">                     select count(*) from ExamResult;</span><br><span class="line">                    -- 统计JS成绩大于70的学生有多少个？</span><br><span class="line">                     select count(JS) from ExamResult where JS&gt;70;</span><br><span class="line">                    -- 统计总分大于280的人数有多少？</span><br><span class="line">                     select count(name) from ExamResult</span><br><span class="line">                           where (ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0))&gt;280;</span><br><span class="line">                    -- 注意:count(*)统计所有行;     count(字段)不统计null值.</span><br><span class="line"></span><br><span class="line">            -- SUM(列名)：统计满足条件的行的内容和</span><br><span class="line">                    -- 统计一个班级JS总成绩？先查出所有的JS成绩，再用sum包上</span><br><span class="line">                        select JS as JS总成绩 from ExamResult;</span><br><span class="line">                        select sum(JS) as JS总成绩 from ExamResult;</span><br><span class="line">                    -- 统计一个班级各科分别的总成绩</span><br><span class="line">                        select sum(JS) as JS总成绩,</span><br><span class="line">                               sum(Django) as Django总成绩,</span><br><span class="line">                               sum(OpenStack) as OpenStack from ExamResult;</span><br><span class="line"></span><br><span class="line">                    -- 统计一个班级各科的成绩总和</span><br><span class="line">                        select sum(ifnull(JS,0)+ifnull(Django,0)+ifnull(Database,0))</span><br><span class="line">                                                    as 总成绩 from ExamResult;</span><br><span class="line">                    -- 统计一个班级JS成绩平均分</span><br><span class="line">                        select sum(JS)&#x2F;count(*) from ExamResult ;</span><br><span class="line">                    -- 注意：sum仅对数值起作用，否则会报错。</span><br><span class="line"></span><br><span class="line">            -- AVG(列名)：</span><br><span class="line">                            -- 求一个班级JS平均分？先查出所有的JS分，然后用avg包上。</span><br><span class="line">                                select avg(ifnull(JS,0)) from ExamResult;</span><br><span class="line">                            -- 求一个班级总分平均分</span><br><span class="line">                                select avg((ifnull(JS,0)+ifnull(Django,0)+ifnull(Database,0)))</span><br><span class="line">                                                         from ExamResult ;</span><br><span class="line">            -- Max、Min</span><br><span class="line">                            -- 求班级最高分和最低分（数值范围在统计中特别有用）</span><br><span class="line">                              select Max((ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0)))</span><br><span class="line">                              最高分 from ExamResult;</span><br><span class="line">                              select Min((ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0)))</span><br><span class="line">                              最低分 from ExamResult;</span><br><span class="line">                            -- 求购物表中单价最高的商品名称及价格</span><br><span class="line">                              ---SELECT id, MAX(price) FROM order_menu;--id和最高价商品是一个商品吗?</span><br><span class="line">                              </span><br><span class="line">                              SELECT MAX(price) FROM order_menu; </span><br><span class="line"></span><br><span class="line">                            -- 注意：null 和所有的数计算都是null，所以需要用ifnull将null转换为0！</span><br><span class="line">                            --      -----ifnull(JS,0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                -- with rollup的使用</span><br><span class="line"></span><br><span class="line">            --&lt;2&gt; 统计分组后的组记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- （7） 重点：Select from where group by having order by</span><br><span class="line">                -- Mysql在执行sql语句时的执行顺序：</span><br><span class="line">                -- from  where  select group by  having order by</span><br><span class="line">                -- 分析:</span><br><span class="line">                select JS as JS成绩 from ExamResult where JS成绩 &gt;70; ---- 不成功</span><br><span class="line">                select JS as JS成绩 from ExamResult having JS成绩 &gt;90; --- 成功</span><br><span class="line"></span><br><span class="line">--  (8) limit  </span><br><span class="line">                SELECT * from ExamResult limit 1; --显示第一条</span><br><span class="line">                SELECT * from ExamResult limit 2,5;  --跳过前两条显示接下来的五条纪录</span><br><span class="line">                SELECT * from ExamResult limit 2,2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- (9) 使用正则表达式查询</span><br><span class="line">        SELECT * FROM employee WHERE emp_name REGEXP &#39;^yu&#39;;</span><br><span class="line"></span><br><span class="line">        SELECT * FROM employee WHERE emp_name REGEXP &#39;yun$&#39;;</span><br><span class="line"></span><br><span class="line">        SELECT * FROM employee WHERE emp_name REGEXP &#39;m&#123;2&#125;&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="创建外键"><a href="#创建外键" class="headerlink" title="创建外键"></a>创建外键</h3><p><strong>外键一定要和关联主键的数据类型保持一致</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---  每一个班主任会对应多个学生 , 而每个学生只能对应一个班主任</span><br><span class="line"></span><br><span class="line">----主表</span><br><span class="line"></span><br><span class="line">CREATE TABLE ClassCharger(</span><br><span class="line"></span><br><span class="line">       id TINYINT PRIMARY KEY auto_increment,</span><br><span class="line">       name VARCHAR (20),</span><br><span class="line">       age INT ,</span><br><span class="line">       is_marriged boolean  -- show create table ClassCharger: tinyint(1)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO ClassCharger (name,age,is_marriged) VALUES (&quot;冰冰&quot;,12,0),</span><br><span class="line">                                                       (&quot;丹丹&quot;,14,0),</span><br><span class="line">                                                       (&quot;歪歪&quot;,22,0),</span><br><span class="line">                                                       (&quot;姗姗&quot;,20,0),</span><br><span class="line">                                                       (&quot;小雨&quot;,21,0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----子表</span><br><span class="line"></span><br><span class="line">CREATE TABLE Student(</span><br><span class="line"></span><br><span class="line">       id INT PRIMARY KEY auto_increment,</span><br><span class="line">       name VARCHAR (20),</span><br><span class="line">       charger_id TINYINT,     --切记:作为外键一定要和关联主键的数据类型保持一致</span><br><span class="line">       -- [ADD CONSTRAINT charger_fk_stu]FOREIGN KEY (charger_id) REFERENCES ClassCharger(id)</span><br><span class="line"></span><br><span class="line">) ENGINE&#x3D;INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO Student(name,charger_id) VALUES (&quot;alvin1&quot;,2),</span><br><span class="line">                                            (&quot;alvin2&quot;,4),</span><br><span class="line">                                            (&quot;alvin3&quot;,1),</span><br><span class="line">                                            (&quot;alvin4&quot;,3),</span><br><span class="line">                                            (&quot;alvin5&quot;,1),</span><br><span class="line">                                            (&quot;alvin6&quot;,3),</span><br><span class="line">                                            (&quot;alvin7&quot;,2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM ClassCharger WHERE name&#x3D;&quot;冰冰&quot;;</span><br><span class="line">INSERT student (name,charger_id) VALUES (&quot;yuan&quot;,1);</span><br><span class="line">-- 删除居然成功,可是 alvin3显示还是有班主任id&#x3D;1的冰冰的;</span><br><span class="line"></span><br><span class="line">-----------增加外键和删除外键---------</span><br><span class="line"></span><br><span class="line">ALTER TABLE student  ADD CONSTRAINT abc</span><br><span class="line">                     FOREIGN KEY(charger_id)</span><br><span class="line">                     REFERENCES  classcharger(id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALTER TABLE student DROP FOREIGN KEY abc;</span><br></pre></td></tr></table></figure>
<h3 id="INNODB支持的ON语句"><a href="#INNODB支持的ON语句" class="headerlink" title="INNODB支持的ON语句"></a>INNODB支持的ON语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--外键约束对子表的含义:   如果在父表中找不到候选键,则不允许在子表上进行insert&#x2F;update</span><br><span class="line"></span><br><span class="line">--外键约束对父表的含义:    在父表上进行update&#x2F;delete以更新或删除在子表中有一条或多条对</span><br><span class="line">                    -- 应匹配行的候选键时,父表的行为取决于：在定义子表的外键时指定的</span><br><span class="line">                    -- on update&#x2F;on delete子句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------innodb支持的四种方式---------------------------------------</span><br><span class="line"></span><br><span class="line">-----cascade方式 在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录</span><br><span class="line">-----外键的级联删除：如果父表中的记录被删除，则子表中对应的记录自动被删除--------</span><br><span class="line"></span><br><span class="line">     FOREIGN KEY (charger_id) REFERENCES ClassCharger(id)</span><br><span class="line">                              ON DELETE CASCADE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------set null方式 在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null</span><br><span class="line">   -- 要注意子表的外键列不能为not null</span><br><span class="line"></span><br><span class="line">     FOREIGN KEY (charger_id) REFERENCES ClassCharger(id)</span><br><span class="line">                              ON DELETE SET NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------Restrict方式 :拒绝对父表进行删除更新操作(了解)</span><br><span class="line"></span><br><span class="line">------No action方式 在mysql中同Restrict,如果子表中有匹配的记录,则不允许对父表对应候选键</span><br><span class="line">   -- 进行update&#x2F;delete操作（了解）</span><br></pre></td></tr></table></figure>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="准备表"><a href="#准备表" class="headerlink" title="准备表"></a>准备表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 准备两张表</span><br><span class="line">-- company.employee</span><br><span class="line">-- company.department</span><br><span class="line"></span><br><span class="line">      create table employee(</span><br><span class="line">      emp_id int auto_increment primary key not null,</span><br><span class="line">      emp_name varchar(50),</span><br><span class="line">      age int,</span><br><span class="line">      dept_id int</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      insert into employee(emp_name,age,dept_id) values</span><br><span class="line">        (&#39;A&#39;,19,200),</span><br><span class="line">        (&#39;B&#39;,26,201),</span><br><span class="line">        (&#39;C&#39;,30,201),</span><br><span class="line">        (&#39;D&#39;,24,202),</span><br><span class="line">        (&#39;E&#39;,20,200),</span><br><span class="line">        (&#39;F&#39;,38,204);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    create table department(</span><br><span class="line">       dept_id int,</span><br><span class="line">       dept_name varchar(100)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    insert into department values</span><br><span class="line">      (200,&#39;人事部&#39;),</span><br><span class="line">      (201,&#39;技术部&#39;),</span><br><span class="line">      (202,&#39;销售部&#39;),</span><br><span class="line">      (203,&#39;财政部&#39;);</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from employee;</span><br><span class="line">+--------+----------+------+---------+</span><br><span class="line">| emp_id | emp_name | age  | dept_id |</span><br><span class="line">+--------+----------+------+---------+</span><br><span class="line">|      1 | A        |   19 |     200 |</span><br><span class="line">|      2 | B        |   26 |     201 |</span><br><span class="line">|      3 | C        |   30 |     201 |</span><br><span class="line">|      4 | D        |   24 |     202 |</span><br><span class="line">|      5 | E        |   20 |     200 |</span><br><span class="line">|      6 | F        |   38 |     204 |</span><br><span class="line">+--------+----------+------+---------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from department;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| dept_id | dept_name |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|     200 | 人事部    |</span><br><span class="line">|     201 | 技术部    |</span><br><span class="line">|     202 | 销售部    |</span><br><span class="line">|     203 | 财政部    |</span><br><span class="line">+---------+-----------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<h3 id="多表查询之连接查询"><a href="#多表查询之连接查询" class="headerlink" title="多表查询之连接查询"></a>多表查询之连接查询</h3><h4 id="1-笛卡尔积查询"><a href="#1-笛卡尔积查询" class="headerlink" title="1.笛卡尔积查询"></a>1.笛卡尔积查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM employee,department;</span><br><span class="line"></span><br><span class="line">--        select employee.emp_id,employee.emp_name,employee.age,</span><br><span class="line">--        department.dept_name from employee,department;</span><br><span class="line"></span><br><span class="line">+--------+----------+------+---------+---------+-----------+</span><br><span class="line">| emp_id | emp_name | age  | dept_id | dept_id | dept_name |</span><br><span class="line">+--------+----------+------+---------+---------+-----------+</span><br><span class="line">|      1 | A        |   19 |     200 |     200 | 人事部    |</span><br><span class="line">|      1 | A        |   19 |     200 |     201 | 技术部    |</span><br><span class="line">|      1 | A        |   19 |     200 |     202 | 销售部    |</span><br><span class="line">|      1 | A        |   19 |     200 |     203 | 财政部    |</span><br><span class="line">|      2 | B        |   26 |     201 |     200 | 人事部    |</span><br><span class="line">|      2 | B        |   26 |     201 |     201 | 技术部    |</span><br><span class="line">|      2 | B        |   26 |     201 |     202 | 销售部    |</span><br><span class="line">|      2 | B        |   26 |     201 |     203 | 财政部    |</span><br><span class="line">|      3 | C        |   30 |     201 |     200 | 人事部    |</span><br><span class="line">|      3 | C        |   30 |     201 |     201 | 技术部    |</span><br><span class="line">|      3 | C        |   30 |     201 |     202 | 销售部    |</span><br><span class="line">|      3 | C        |   30 |     201 |     203 | 财政部    |</span><br><span class="line">|      4 | D        |   24 |     202 |     200 | 人事部    |</span><br><span class="line">|      4 | D        |   24 |     202 |     201 | 技术部    |</span><br><span class="line">|      4 | D        |   24 |     202 |     202 | 销售部    |</span><br><span class="line">|      4 | D        |   24 |     202 |     203 | 财政部    |</span><br><span class="line">|      5 | E        |   20 |     200 |     200 | 人事部    |</span><br><span class="line">|      5 | E        |   20 |     200 |     201 | 技术部    |</span><br><span class="line">|      5 | E        |   20 |     200 |     202 | 销售部    |</span><br><span class="line">|      5 | E        |   20 |     200 |     203 | 财政部    |</span><br><span class="line">|      6 | F        |   38 |     204 |     200 | 人事部    |</span><br><span class="line">|      6 | F        |   38 |     204 |     201 | 技术部    |</span><br><span class="line">|      6 | F        |   38 |     204 |     202 | 销售部    |</span><br><span class="line">|      6 | F        |   38 |     204 |     203 | 财政部    |</span><br><span class="line">+--------+----------+------+---------+---------+-----------+</span><br></pre></td></tr></table></figure>
<h4 id="2-内连接"><a href="#2-内连接" class="headerlink" title="2.内连接"></a>2.内连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询两张表中都有的关联数据,相当于利用条件从笛卡尔积结果中筛选出了正确的结果。</span><br><span class="line"></span><br><span class="line">  select * from employee,department where employee.dept_id &#x3D; department.dept_id;</span><br><span class="line">--select * from employee inner join department on employee.dept_id &#x3D; department.dept_id;</span><br><span class="line"></span><br><span class="line">      +--------+----------+------+---------+---------+-----------+</span><br><span class="line">      | emp_id | emp_name | age  | dept_id | dept_id | dept_name |</span><br><span class="line">      +--------+----------+------+---------+---------+-----------+</span><br><span class="line">      |      1 | A        |   19 |     200 |     200 | 人事部    |</span><br><span class="line">      |      2 | B        |   26 |     201 |     201 | 技术部    |</span><br><span class="line">      |      3 | C        |   30 |     201 |     201 | 技术部    |</span><br><span class="line">      |      4 | D        |   24 |     202 |     202 | 销售部    |</span><br><span class="line">      |      5 | E        |   20 |     200 |     200 | 人事部    |</span><br><span class="line">      +--------+----------+------+---------+---------+-----------+</span><br></pre></td></tr></table></figure>
<h4 id="3-外连接"><a href="#3-外连接" class="headerlink" title="3.外连接"></a>3.外连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--（1）左外连接：在内连接的基础上增加左边有右边没有的结果</span><br><span class="line">left join可以连续使用</span><br><span class="line"> select * from employee left join department on employee.dept_id &#x3D; department.dept_id;</span><br><span class="line"></span><br><span class="line">     +--------+----------+------+---------+---------+-----------+</span><br><span class="line">    | emp_id | emp_name | age  | dept_id | dept_id | dept_name |</span><br><span class="line">    +--------+----------+------+---------+---------+-----------+</span><br><span class="line">    |      1 | A        |   19 |     200 |     200 | 人事部    |</span><br><span class="line">    |      5 | E        |   20 |     200 |     200 | 人事部    |</span><br><span class="line">    |      2 | B        |   26 |     201 |     201 | 技术部    |</span><br><span class="line">    |      3 | C        |   30 |     201 |     201 | 技术部    |</span><br><span class="line">    |      4 | D        |   24 |     202 |     202 | 销售部    |</span><br><span class="line">    |      6 | F        |   38 |     204 |    NULL | NULL      |</span><br><span class="line">    +--------+----------+------+---------+---------+-----------+</span><br><span class="line"></span><br><span class="line"> --（2）右外连接：在内连接的基础上增加右边有左边没有的结果</span><br><span class="line"></span><br><span class="line"> select * from employee RIGHT JOIN department on employee.dept_id &#x3D; department.dept_id;</span><br><span class="line"></span><br><span class="line">        +--------+----------+------+---------+---------+-----------+</span><br><span class="line">        | emp_id | emp_name | age  | dept_id | dept_id | dept_name |</span><br><span class="line">        +--------+----------+------+---------+---------+-----------+</span><br><span class="line">        |      1 | A        |   19 |     200 |     200 | 人事部    |</span><br><span class="line">        |      2 | B        |   26 |     201 |     201 | 技术部    |</span><br><span class="line">        |      3 | C        |   30 |     201 |     201 | 技术部    |</span><br><span class="line">        |      4 | D        |   24 |     202 |     202 | 销售部    |</span><br><span class="line">        |      5 | E        |   20 |     200 |     200 | 人事部    |</span><br><span class="line">        |   NULL | NULL     | NULL |    NULL |     203 | 财政部    |</span><br><span class="line">        +--------+----------+------+---------+---------+-----------+</span><br><span class="line"></span><br><span class="line"> --（3）全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果</span><br><span class="line"></span><br><span class="line">    -- mysql不支持全外连接 full JOIN</span><br><span class="line">    -- mysql可以使用此种方式间接实现全外连接</span><br><span class="line">    </span><br><span class="line">   select * from employee RIGHT JOIN department on employee.dept_id &#x3D; department.dept_id</span><br><span class="line">   UNION</span><br><span class="line">   select * from employee LEFT JOIN department on employee.dept_id &#x3D; department.dept_id;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        +--------+----------+------+---------+---------+-----------+</span><br><span class="line">        | emp_id | emp_name | age  | dept_id | dept_id | dept_name |</span><br><span class="line">        +--------+----------+------+---------+---------+-----------+</span><br><span class="line">        |      1 | A        |   19 |     200 |     200 | 人事部    |</span><br><span class="line">        |      2 | B        |   26 |     201 |     201 | 技术部    |</span><br><span class="line">        |      3 | C        |   30 |     201 |     201 | 技术部    |</span><br><span class="line">        |      4 | D        |   24 |     202 |     202 | 销售部    |</span><br><span class="line">        |      5 | E        |   20 |     200 |     200 | 人事部    |</span><br><span class="line">        |   NULL | NULL     | NULL |    NULL |     203 | 财政部    |</span><br><span class="line">        |      6 | F        |   38 |     204 |    NULL | NULL      |</span><br><span class="line">        +--------+----------+------+---------+---------+-----------+</span><br><span class="line"></span><br><span class="line">      -- 注意 union与union all的区别：union会去掉相同的纪录</span><br></pre></td></tr></table></figure>
<h3 id="多表查询之复合条件连接查询"><a href="#多表查询之复合条件连接查询" class="headerlink" title="多表查询之复合条件连接查询"></a>多表查询之复合条件连接查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询员工年龄大于等于25岁的部门</span><br><span class="line"></span><br><span class="line">    SELECT DISTINCT department.dept_name</span><br><span class="line">    FROM employee,department</span><br><span class="line">    WHERE employee.dept_id &#x3D; department.dept_id</span><br><span class="line">    AND age&gt;25;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--以内连接的方式查询employee和department表，并且以age字段的升序方式显示</span><br><span class="line"></span><br><span class="line">    select employee.emp_id,employee.emp_name,employee.age,department.dept_name</span><br><span class="line">    from employee,department</span><br><span class="line">    where employee.dept_id &#x3D; department.dept_id</span><br><span class="line">    order by age asc;</span><br></pre></td></tr></table></figure>
<h3 id="多表查询之子查询"><a href="#多表查询之子查询" class="headerlink" title="多表查询之子查询"></a>多表查询之子查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 子查询是将一个查询语句嵌套在另一个查询语句中。</span><br><span class="line">-- 内层查询语句的查询结果，可以为外层查询语句提供查询条件。</span><br><span class="line">-- 子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字</span><br><span class="line">-- 还可以包含比较运算符：&#x3D; 、 !&#x3D;、&gt; 、&lt;等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 1. 带IN关键字的子查询</span><br><span class="line"></span><br><span class="line">   ---查询employee表，但dept_id必须在department表中出现过</span><br><span class="line"></span><br><span class="line">   select * from employee</span><br><span class="line">            where dept_id IN</span><br><span class="line">            (select dept_id from department);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------+----------+------+---------+</span><br><span class="line">| emp_id | emp_name | age  | dept_id |</span><br><span class="line">+--------+----------+------+---------+</span><br><span class="line">|      1 | A        |   19 |     200 |</span><br><span class="line">|      2 | B        |   26 |     201 |</span><br><span class="line">|      3 | C        |   30 |     201 |</span><br><span class="line">|      4 | D        |   24 |     202 |</span><br><span class="line">|      5 | E        |   20 |     200 |</span><br><span class="line">+--------+----------+------+---------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 2. 带比较运算符的子查询</span><br><span class="line">      --      &#x3D;、!&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt;</span><br><span class="line"></span><br><span class="line">     -- 查询员工年龄大于等于25岁的部门</span><br><span class="line">     select dept_id,dept_name from department</span><br><span class="line">           where dept_id IN</span><br><span class="line">          (select DISTINCT dept_id from employee where age&gt;&#x3D;25);</span><br><span class="line"></span><br><span class="line">-- 3. 带EXISTS关键字的子查询</span><br><span class="line"></span><br><span class="line">-- EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。</span><br><span class="line">-- 而是返回一个真假值。Ture或False</span><br><span class="line">-- 当返回Ture时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询</span><br><span class="line"></span><br><span class="line">     select * from employee</span><br><span class="line">              WHERE EXISTS</span><br><span class="line">              (SELECT dept_name from department where dept_id&#x3D;203);</span><br><span class="line"></span><br><span class="line">      --department表中存在dept_id&#x3D;203，Ture</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     select * from employee</span><br><span class="line">                WHERE EXISTS</span><br><span class="line">              (SELECT dept_name from department where dept_id&#x3D;205);</span><br><span class="line"></span><br><span class="line">     -- Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ps:  create table t1(select * from t2);</span><br></pre></td></tr></table></figure>
<p>补充：any/some/all</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【4】any&#x2F;some&#x2F;all</span><br><span class="line">① any，in，some，all分别是子查询关键词之一</span><br><span class="line"></span><br><span class="line">any 可以与&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt;结合起来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的任意一个数据。</span><br><span class="line"></span><br><span class="line">all可以与&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据。</span><br><span class="line"></span><br><span class="line">② any关键词可以理解为“对于子查询返回的列中的任一数值，如果比较结果为true，则返回true”。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">select age from t_user where  age &gt; any (select age from t_user_copy);</span><br><span class="line">假设表t_user 中有一行包含(10)，t_user_copy包含(21,14,6),则表达式为true；如果t_user_copy包含（20,10），或者表t_user_copy为空表，则表达式为false。如果表t_user_copy包含（null，null，null），则表达式为unkonwn。</span><br><span class="line"></span><br><span class="line">all的意思是“对于子查询返回的列中的所有值，如果比较结果为true，则返回true”</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">select age from t_user where  age &gt; all (select age from t_user_copy);</span><br><span class="line"></span><br><span class="line">假设表t_user 中有一行包含（10）。如果表t_user_copy包含（-5,0，+5），则表达式为true，因为10比t_user_copy中的查出的所有三个值大。如果表t_user_copy包含（12,6，null，-100），则表达式为false，因为t_user_copy中有一个值12大于10。如果表t_user_copy包含（0，null，1），则表达式为unknown。如果t_user_copy为空表，则结果为true。</span><br><span class="line"></span><br><span class="line">③ not in &#x2F;in</span><br><span class="line"></span><br><span class="line">not in 是 “&lt;&gt;all”的别名，用法相同。</span><br><span class="line"></span><br><span class="line">语句in 与“&#x3D;any”是相同的。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">select s1 from t1 where s1 &#x3D; any (select s1 from t2);</span><br><span class="line">select s1 from t1 where s1 in (select s1 from t2);</span><br><span class="line"></span><br><span class="line">语句some是any的别名，用法相同。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">select s1 from t1 where s1 &lt;&gt; any (select s1 from t2);</span><br><span class="line">select s1 from t1 where s1 &lt;&gt; some (select s1 from t2);</span><br><span class="line"></span><br><span class="line">在上述查询中some理解上就容易了“表t1中有部分s1与t2表中的s1不相等”，这种语句用any理解就有错了。</span><br><span class="line">--------------------- </span><br><span class="line">作者：流烟默 </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https:&#x2F;&#x2F;blog.csdn.net&#x2F;J080624&#x2F;article&#x2F;details&#x2F;72910548 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure>
<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p>
<p>打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。</p>
<p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p>
<p>创建索引时，你需要确保该索引是应用在    SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p>
<p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>
<p>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
<p>建立索引会占用磁盘空间的索引文件。</p>
<hr>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX indexName ON mytable(username(length));</span><br></pre></td></tr></table></figure>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<h3 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br></pre></td></tr></table></figure>
<h3 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">INDEX [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="删除索引的语法"><a href="#删除索引的语法" class="headerlink" title="删除索引的语法"></a>删除索引的语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<h3 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</span><br></pre></td></tr></table></figure>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER table mytable ADD UNIQUE [indexName] (username(length))</span><br></pre></td></tr></table></figure>
<h3 id="创建表的时候直接指定-1"><a href="#创建表的时候直接指定-1" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">UNIQUE [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">	id int,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  salary double(7,2),</span><br><span class="line">  text varchar(100000),</span><br><span class="line">  FULLTEXT INDEX text_index (text)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">	id int,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  salary double(7,2),</span><br><span class="line">  text varchar(100000),</span><br><span class="line">  INDEX index_name_salary (name,salary)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h2><p>有四种方式来添加数据表的索引：</p>
<ul>
<li>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</li>
</ul>
<p>  该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</p>
<ul>
<li><p><strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</p>
</li>
<li><p><strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> 添加普通索引，索引值可出现多次。</p>
</li>
<li><p><strong>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):</strong>该语句指定了索引为 FULLTEXT ，用于全文索引。</p>
</li>
</ul>
<p>以下实例为在表中添加索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);</span><br></pre></td></tr></table></figure>
<p>你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="使用-ALTER-命令添加和删除主键"><a href="#使用-ALTER-命令添加和删除主键" class="headerlink" title="使用 ALTER 命令添加和删除主键"></a>使用 ALTER 命令添加和删除主键</h2><p>主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;</span><br><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);</span><br></pre></td></tr></table></figure>
<p>你也可以使用 ALTER 命令删除主键：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>
<p>删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p>
<hr>
<h2 id="显示索引信息"><a href="#显示索引信息" class="headerlink" title="显示索引信息"></a>显示索引信息</h2><p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p>
<p>尝试以下实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM table_name; \G</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<p>练习：</p>
<p><a href="https://www.cnblogs.com/yuanchenqi/articles/6424245.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanchenqi/articles/6424245.html</a></p>
<p>答案：<a href="https://www.cnblogs.com/wupeiqi/articles/5748496.html" target="_blank" rel="noopener">https://www.cnblogs.com/wupeiqi/articles/5748496.html</a></p>
<p>查询每门课程前3名的几种方法<a href="https://blog.csdn.net/iteye_8331/article/details/81655117" target="_blank" rel="noopener">https://blog.csdn.net/iteye_8331/article/details/81655117</a></p>
<p>CASE用法1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select A,B </span><br><span class="line">case</span><br><span class="line">when case1 then result1</span><br><span class="line">when case2 then result2</span><br><span class="line">else result3</span><br><span class="line">end</span><br><span class="line">from</span><br></pre></td></tr></table></figure>
<p>CASE用法2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case A</span><br><span class="line">when case1 then result1</span><br><span class="line">when case2 then result2</span><br><span class="line">else result3</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case when A&gt;2 then result1</span><br><span class="line">when A&lt;2 then result2</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>group by sid 则结果中sid一定只会出现一次。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据库进阶</title>
    <url>/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="数据库进阶"><a href="#数据库进阶" class="headerlink" title="数据库进阶"></a><a href="https://www.cnblogs.com/yuanchenqi/articles/6437362.html" target="_blank" rel="noopener">数据库进阶</a></h1><a id="more"></a>
<p><em>知识预览</em></p>
<ul>
<li><a href="https://www.cnblogs.com/yuanchenqi/articles/6437362.html#_label0" target="_blank" rel="noopener">python关于mysql的API－－pymysql模块</a></li>
<li><a href="https://www.cnblogs.com/yuanchenqi/articles/6437362.html#_label1" target="_blank" rel="noopener">事务</a></li>
<li><a href="https://www.cnblogs.com/yuanchenqi/articles/6437362.html#_label2" target="_blank" rel="noopener">索引</a></li>
</ul>
<h1 id="python关于mysql的API－－pymysql模块"><a href="#python关于mysql的API－－pymysql模块" class="headerlink" title="python关于mysql的API－－pymysql模块"></a>python关于mysql的API－－pymysql模块</h1><p>pymsql是Python中操作MySQL的模块，其使用方法和py2的MySQLdb几乎相同。</p>
<h3 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a><strong>模块安装</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;pip install pymysql&#96;</span><br></pre></td></tr></table></figure>
<h3 id="执行sql语句"><a href="#执行sql语句" class="headerlink" title="执行sql语句"></a>执行sql语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加数据</span></span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">''</span>, db=<span class="string">'yyy'</span>)</span><br><span class="line"></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"><span class="comment"># cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)  #显示key value</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sql = """CREATE TABLE EMPLOYEE (</span></span><br><span class="line"><span class="comment">#          FIRST_NAME  CHAR(20) NOT NULL,</span></span><br><span class="line"><span class="comment">#          LAST_NAME  CHAR(20),</span></span><br><span class="line"><span class="comment">#          AGE INT,</span></span><br><span class="line"><span class="comment">#          SEX CHAR(1),</span></span><br><span class="line"><span class="comment">#          INCOME FLOAT )"""</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># cursor.execute(sql)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#row_affected = cursor.execute("create table t1(id INT ,name VARCHAR(20))")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#row_affected=cursor.execute("INSERT INTO t1(id,name) values (1,'alvin'),(2,'xialv')")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cursor.execute("update t1 set name = 'silv2' where id=2")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询数据</span></span><br><span class="line">row_affected=cursor.execute(<span class="string">"select * from t1"</span>)</span><br><span class="line">one=cursor.fetchone()   <span class="comment">#执行的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># many=cursor.fetchmany(2)</span></span><br><span class="line"><span class="comment"># all=cursor.fetchall()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#scroll</span></span><br><span class="line"><span class="comment">#cursor.scroll(-1,mode='relative')  # 相对当前位置移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cursor.scroll(2,mode='absolute') # 相对绝对位置移动</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更改获取数据结果的数据类型,默认是元组,可以改为字典等:conn.cursor(cursor=pymysql.cursors.DictCursor)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h2><p>事务指逻辑上的一组操作，组成这组操作的各个单元，要不全部成功，要不全部不成功。</p>
<p>数据库开启事务命令     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--        start transaction 开启事务</span><br><span class="line">--        Rollback 回滚事务,即撤销指定的sql语句(只能回退insert delete update语句)，回滚到上一次commit的位置</span><br><span class="line">--        Commit 提交事务，提交未存储的事务</span><br><span class="line">-- </span><br><span class="line">--        savepoint 保留点 ，事务处理中设置的临时占位符 你可以对它发布回退(与整个事务回退不同)</span><br></pre></td></tr></table></figure>
<p>转账实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE account set balance&#x3D;balance-5000 WHERE name&#x3D;”yuan”;</span><br><span class="line">UPDATE account set balance&#x3D;balance+5000 WHERE name&#x3D;”xialv”;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test2(id int PRIMARY KEY auto_increment,name VARCHAR(20)) engine&#x3D;innodb;</span><br><span class="line">INSERT INTO test2(name) VALUE (&quot;alvin&quot;),</span><br><span class="line">                              (&quot;yuan&quot;),</span><br><span class="line">                              (&quot;xialv&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">insert into test2 (name)values(&#39;silv&#39;);</span><br><span class="line">select * from test2;</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 保留点</span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">insert into test2 (name)values(&#39;wu&#39;);</span><br><span class="line">savepoint insert_wu;</span><br><span class="line">select * from test2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete from test2 where id&#x3D;4;</span><br><span class="line">savepoint delete1;</span><br><span class="line">select * from test2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete from test2 where id&#x3D;1;</span><br><span class="line">savepoint delete2;</span><br><span class="line">select * from test2;</span><br><span class="line"></span><br><span class="line">rollback to delete1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from test2;</span><br></pre></td></tr></table></figure>
<p>python中调用数据库启动事务的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加数据</span></span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">''</span>, db=<span class="string">'yyy'</span>)</span><br><span class="line"></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    insertSQL0=<span class="string">"INSERT INTO ACCOUNT2 (name,balance) VALUES ('oldboy',4000)"</span></span><br><span class="line">    insertSQL1=<span class="string">"UPDATE account2 set balance=balance-30 WHERE name='yuan'"</span></span><br><span class="line">    insertSQL2=<span class="string">"UPDATE account2 set balance=balance+30 WHERE name='xialv'"</span></span><br><span class="line"></span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">    cursor.execute(insertSQL0)</span><br><span class="line">    conn.commit()</span><br><span class="line"></span><br><span class="line">    cursor.execute(insertSQL1)</span><br><span class="line">    <span class="keyword">raise</span> Exception</span><br><span class="line">    cursor.execute(insertSQL2)</span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">    conn.rollback()</span><br><span class="line">    conn.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><p><1> 原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p><2> 一致性（Consistency）：事务前后数据的完整性必须保持一致。在事务执行之前数据库是符合数据完整性约束的，无论事务是否执行成功，事务结束后的数据库中的数据也应该是符合完整性约束的。在某一时间点，如果数据库中的所有记录都能保证满足当前数据库中的所有约束，则可以说当前的数据库是符合数据完整性约束的。<br>比如删部门表前应该删掉关联员工（已经建立外键），如果数据库服务器发生错误，有一个员工没删掉，那么此时员工的部门表已经删除，那么就不符合完整性约束了，所以这样的数据库也就性能太差啦！</p>
<p><3>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</p>
<p><4>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p>
<p>三、隔离性：<br>将数据库设计为串行化程的数据库，让一张表在同一时间内只能有一个线程来操作。如果将数据库设计为这样，那数据库的效率太低了。所以数据库的设计这没有直接将数据库设计为串行化，而是为数据库提供多个隔离级别选项，使数据库的使用者可以根据使用情况自己定义到底需要什么样的隔离级别。</p>
<p>不考虑隔离性可能出现的问题：</p>
<p><strong>脏读</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--一个事务读取到了另一个事务未提交的数据,这是特别危险的，要尽力防止。</span><br><span class="line">        a 1000</span><br><span class="line">        b 1000</span><br><span class="line">        a:</span><br><span class="line">            start transaction；</span><br><span class="line">            update set money&#x3D;money+100 where name&#x3D;b;</span><br><span class="line">        b:</span><br><span class="line">            start transaction;</span><br><span class="line">            select * from account where name&#x3D;b;--1100</span><br><span class="line">            commit;</span><br><span class="line">        a:</span><br><span class="line">            rollback;</span><br><span class="line">        b:  start transaction;</span><br><span class="line">            select * from account where name&#x3D;b;--1000</span><br></pre></td></tr></table></figure>
<p><strong>不可重复读</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--在一个事务内读取表中的某一行数据，多次读取结果不同。（一个事务读取到了另一个事务已经提交</span><br><span class="line">-- 的数据--增加记录、删除记录、修改记录），在某写情况下并不是问题，在另一些情况下就是问题。</span><br><span class="line"></span><br><span class="line">a:</span><br><span class="line">start transaction;</span><br><span class="line">select 活期账户 from account where name&#x3D;b;--1000    活期账户：1000</span><br><span class="line">select 定期账户 from account where name&#x3D;b；--1000   定期账户:1000</span><br><span class="line">select 固定资产 from account where name&#x3D;b；--1000   固定资产：1000</span><br><span class="line">------------------------------</span><br><span class="line">b:</span><br><span class="line">start transaction;</span><br><span class="line">update set money&#x3D;0 where name&#x3D;b;</span><br><span class="line">commit;</span><br><span class="line">------------------------------</span><br><span class="line">select 活期+定期+固定 from account where name&#x3D;b; --2000 总资产： 2000</span><br></pre></td></tr></table></figure>
<p><strong>虚读</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。（一个事务读取到了另一个事务已经提交的数据---增加记录、删除记录），在某写情况下并不是问题，在另一些情况下就是问题。</span><br><span class="line"></span><br><span class="line">b 1000</span><br><span class="line">c 2000</span><br><span class="line">d 3000</span><br><span class="line">a:</span><br><span class="line">start transaction</span><br><span class="line">select sum(money) from account;---3000       3000</span><br><span class="line">-------------------</span><br><span class="line">d:start transaction;</span><br><span class="line">insert into account values(d,3000);</span><br><span class="line">commit;</span><br><span class="line">-------------------</span><br><span class="line">select count(*)from account;---3                         3</span><br><span class="line">3000&#x2F;3 &#x3D; 1000                                            1000</span><br></pre></td></tr></table></figure>
<p>四个隔离级别：<br>Serializable：可避免脏读、不可重复读、虚读情况的发生。（串行化）<br>Repeatable read：可避免脏读、不可重复读情况的发生。（可重复读）不可以避免虚读<br>Read committed：可避免脏读情况发生（读已提交）<br>Read uncommitted：最低级别，以上情况均无法保证。(读未提交)</p>
<p>安全性考虑：Serializable&gt;Repeatable read&gt;Read committed&gt;Read uncommitted<br>数据库效率：Read uncommitted&gt;Read committed&gt;Repeatable read&gt;Serializable</p>
<p>一般情况下，我们会使用Repeatable read、Read committed mysql数据库默认的数据库隔离级别Repeatable read</p>
<p>mysql中设置数据库的隔离级别语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;set&#96; &#96;[&#96;&#96;global&#96;&#96;&#x2F;session] &#96;&#96;transaction&#96; &#96;isolation&#96; &#96;level&#96; &#96;xxxx;&#96;</span><br></pre></td></tr></table></figure>
<p>如果使用global则修改的是数据库的默认隔离级别，所有新开的窗口的隔离级别继承自这个默认隔离级别如果使用session修改，则修改的是当前客户端的隔离级别，和数据库默认隔离级别无关。当前的客户端是什么隔离级别，就能防止什么隔离级别问题，和其他客户端是什么隔离级别无关。<br>mysql中设置数据库的隔离级别语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;select&#96; &#96;@@tx_isolation;&#96;</span><br></pre></td></tr></table></figure>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="一-索引简介"><a href="#一-索引简介" class="headerlink" title="一 索引简介"></a>一 索引简介</h2><p>索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。</p>
<p>索引优化应该是对查询性能优化最有效的手段了。<br>索引能够轻易将查询性能提高好几个数量级。<br>索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。</p>
<p><strong>索引特点：创建与维护索引会消耗很多时间与磁盘空间，但查询速度大大提高！</strong></p>
<h2 id="二-索引语法"><a href="#二-索引语法" class="headerlink" title="二 索引语法"></a>二 索引语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--创建表时</span><br><span class="line">--语法：</span><br><span class="line">    CREATE TABLE 表名 (</span><br><span class="line">                字段名1  数据类型 [完整性约束条件…],</span><br><span class="line">                字段名2  数据类型 [完整性约束条件…],</span><br><span class="line">                [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY</span><br><span class="line">                [索引名]  (字段名[(长度)]  [ASC |DESC])</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line"></span><br><span class="line">--创建普通索引示例：</span><br><span class="line"></span><br><span class="line">    CREATE TABLE emp1 (</span><br><span class="line">        id INT,</span><br><span class="line">        name VARCHAR(30) ,</span><br><span class="line">        resume VARCHAR(50),</span><br><span class="line">        INDEX index_emp_name (name)</span><br><span class="line">    --KEY index_dept_name (dept_name)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--创建唯一索引示例：</span><br><span class="line"></span><br><span class="line">    CREATE TABLE emp2 (</span><br><span class="line">        id INT,</span><br><span class="line">        name VARCHAR(30) ,</span><br><span class="line">        bank_num CHAR(18) UNIQUE ,</span><br><span class="line">        resume VARCHAR(50),</span><br><span class="line">        UNIQUE INDEX index_emp_name (name)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">--创建全文索引示例：</span><br><span class="line"></span><br><span class="line">    CREATE TABLE emp3 (</span><br><span class="line">        id INT,</span><br><span class="line">        name VARCHAR(30) ,</span><br><span class="line">        resume VARCHAR(50),</span><br><span class="line">        FULLTEXT INDEX index_resume (resume)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">--创建多列索引示例：</span><br><span class="line"></span><br><span class="line">    CREATE TABLE emp4 (</span><br><span class="line">        id INT,</span><br><span class="line">        name VARCHAR(30) ,</span><br><span class="line">        resume VARCHAR(50),</span><br><span class="line">        INDEX index_name_resume (name, resume)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">---添加索引</span><br><span class="line"></span><br><span class="line">    ---CREATE在已存在的表上创建索引</span><br><span class="line">      CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名</span><br><span class="line">              ON 表名 (字段名[(长度)]  [ASC |DESC]) ;</span><br><span class="line">    </span><br><span class="line">    ---ALTER TABLE在已存在的表上创建索引</span><br><span class="line">    </span><br><span class="line">      ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX</span><br><span class="line">                    索引名 (字段名[(长度)]  [ASC |DESC]) ;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     CREATE INDEX index_emp_name on emp1(name);</span><br><span class="line">     ALTER TABLE emp2 ADD UNIQUE INDEX index_bank_num(band_num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">    </span><br><span class="line">    语法：DROP INDEX 索引名 on 表名</span><br><span class="line">    </span><br><span class="line">    DROP INDEX index_emp_name on emp1;</span><br><span class="line">    DROP INDEX bank_num on emp2;</span><br></pre></td></tr></table></figure>
<h2 id="三-索引测试实验"><a href="#三-索引测试实验" class="headerlink" title="三 索引测试实验"></a>三 索引测试实验</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--创建表</span><br><span class="line">create table Indexdb.t1(id int,name varchar(20));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--存储过程</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure autoinsert() </span><br><span class="line">BEGIN</span><br><span class="line">declare i int default 1;</span><br><span class="line">while(i&lt;500000)do</span><br><span class="line">insert into Indexdb.t1 values(i,&#39;yuan&#39;);</span><br><span class="line">set i&#x3D;i+1;</span><br><span class="line">end while;</span><br><span class="line">END$$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">--调用函数</span><br><span class="line">call autoinsert();</span><br><span class="line"></span><br><span class="line">-- 花费时间比较：</span><br><span class="line">-- 创建索引前</span><br><span class="line">   select * from Indexdb.t1 where id&#x3D;300000;--0.32s</span><br><span class="line">-- 添加索引 </span><br><span class="line">   create index index_id on Indexdb.t1(id);</span><br><span class="line">-- 创建索引后</span><br><span class="line">   select * from Indexdb.t1 where id&#x3D;300000;--0.00s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据库基础</title>
    <url>/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>最近组里要求做一个材料数据库，因此对之前数据库的知识进行复习，简单记录。</p>
<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><a id="more"></a>
<ul>
<li>更小通常更好<ul>
<li>一般来说，要试着使用正确地存储和表示数据的最小类型。更小的数据类型通常更快，因为它们使用了更少的磁盘空间、内存和CPU缓存，而且需要的CPU周期也更少。</li>
</ul>
</li>
<li>简单就好 <ul>
<li>越简单的数据类型，需要的CPU周期就越少。例如：比较整数的代价小于比较字符，因为字符集和排序规则使字符比较更复杂。 </li>
</ul>
</li>
<li>尽量避免空<ul>
<li>要尽可地把字段定义为NOT NULL 。即使应用程序无须保存NULL，也有许多表包含了可为空的列，这仅仅是因为它为默认选项，除非真的要保存NULL，否则就把列定义为NOT NULL。 </li>
<li>需要注意：虽然把NULL列改为NOT NULL 带来的性能提升很小，所以除非确定它引入了问题，否则就不要把它当成优先的优化措施。但如果计划对列进行索引，就要尽量避免把它设置为可为空（NULL） </li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul>
<li><p>TINYINT——这个类型最多可容纳三位数。</p>
</li>
<li><p>SMALLINT——最多可容纳五位数。</p>
</li>
<li><p>MEDIUMINT——最多可容纳八位数。</p>
</li>
<li><p>INT——可以容纳十位数。</p>
</li>
<li><p>BIGINT——最多可容纳二十位数。</p>
</li>
</ul>
<blockquote>
<p>整数类型有可选的unsigned（无符号）属性，它表示不允许为负数，并大致把正上限提高了一倍，例如：tinyint unsigned保存的翻围为0到255，而不是-127到128。 </p>
</blockquote>
<h3 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h3><blockquote>
<p>由于需要额外的空间和计算开销，<strong><em>\</em>只有在需要对小数进行精确的时候才使用decimal**</strong>，比如保存金融数据。 </p>
<p>DECIMAL最适合保存那些将被用于计算的数据。在MySQL中，我们可以指定保存一些正当的数字。还可以指定是否允许存在负值。</p>
<p>指定DECIMAL类型的长度会有些棘手。例如，如果你需要在小数点前面保存五位数，且小数点后只保留三位，那么在数据库中其适当的长度将是：Decimal(5+3,3)或 Decimal(8,3)，可以使用的数据包括：12345.678，56872.690，11.6和12.568等。而这些数字则会引发出错信息：128781.1，8972865.231。</p>
</blockquote>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><strong>varchar：保存了可变长度的字符串，是使用得最多的字符串类型，它能比固定类型占用更少的存储空间，因为它只占用了自已需要的空间（也就是说较短的值占用的空间更小）。</strong>它使用额外的1-2个字节来存储值的长度。Varchar能节约空间，所以对性能有帮助。然而，由于行的长度是可变的，它们在更新的时候可能会发生变化，这会引起额外的工作。当最大长度远大于平均长度，并且很少发生更新的时候，通常适合用varchar。这时候碎片就不会成为问题，还有你使用复杂的字符集，如utf-8时，它的每个字符都可能会占用不同的存储空间。Varchar存取值时候，MySQL不会去掉字符串末尾的空格。</li>
<li><strong>char：固定长度，char存取值时候，MySQL会去掉末尾的空格。</strong>Char在存储很短的字符串或长度近似相同的字符的时候很有用。例如,char适用于存储密码的MD5哈希值，它的长度总是一样的。对于经常改变的值，char也好于varchar，因为固定长度的行不容易产生碎片，对于很短的列，char的效率也高于varchar。Char(1)字符串对于单字节字符集只会占用1个字节，而varchar(1)则会占用2个字节，因为有一个字节用来存储其长度。</li>
<li>Char和varchar的兄弟类型为binary和varbinary，它们用于保存二进制的字符串，二进制字符串的传统的字符串很类似，但是它们保存的是字节而不是字符。填充也有所不同，MySQL使用\0（0字节）填充binary值，而不是空格，并且不会在获取数据的时候把填充的值截掉。 </li>
</ul>
<h3 id="BLOB和TEXT类型"><a href="#BLOB和TEXT类型" class="headerlink" title="BLOB和TEXT类型"></a>BLOB和TEXT类型</h3><ul>
<li>BLOB和TEXT分别用二进制和字符形式保存大量数据。 </li>
</ul>
<h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>DATETIME 和 TIMESTAMP的区别：</p>
<p>MySQL提供两种相似的数据类型：DATETIME 和 TIMESTAMP，对于很多应用程序，它们都能正常工作，但是在某些情况下，一种会好于另外一种。</p>
<ul>
<li><p><strong>DATETIME：能够保存大范围的值，从1001年到9999年，精度为秒，它把日期和时间封装到一个格式为yyyy:MM:dd:HH:mm:ss的整数当中，与时区无关。</strong>它使用了8个字节存储空间。</p>
</li>
<li><p><strong>TIMESTAMP：保持了自1970年1月1日午夜（格林尼治标准时间）以来的秒数，它和Unix的时间戳相同。</strong>它只使用了4个字节存储空间。因此它比DATETIME的范围小得多。它表示自能从1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。</p>
</li>
</ul>
<p>但是，TIMESTAMP显示的值依赖于时区，MySQL服务器、操作系统及客户端连接都有时区设置。因此，保存0值的TIMESTAMP实际显示的时间是美国东部的时间1969-12-31 19:00:00，与格林尼治标准时间（GMT）相差5小时。</p>
<h2 id="MYSQL数据库命名与其设计规范"><a href="#MYSQL数据库命名与其设计规范" class="headerlink" title="MYSQL数据库命名与其设计规范"></a>MYSQL数据库命名与其设计规范</h2><h3 id="标准化和规范化"><a href="#标准化和规范化" class="headerlink" title="标准化和规范化"></a>标准化和规范化</h3><p>数据的标准化有助于消除数据库中的数据冗余。标准化有好几种形式，但Third Normal Form（3NF）通常被认为在性能、扩展性和数据完整性方面达到了最好平衡。简单来说，遵守3NF 标准的数据库的表设计原则是：</p>
<p>“One Fact in One Place”即某个表只包括其本身基本的属性，当不是它们本身所具有的属性时需进行分解。表之间的关系通过外键相连接。它具有以下特点：有一组表专门存放通过键连接起来的关联数据。</p>
<p>举例：某个存放客户及其有关定单的3NF 数据库就可能有两个表：Customer和Order。Order表不包含定单关联客户的任何信息，但表内会存放一个键值，该键指向Customer表里包含该客户信息的那一行。</p>
<p>事实上，为了效率的缘故，对表不进行标准化有时也是必要的。</p>
<h3 id="数据库涉及字符规范"><a href="#数据库涉及字符规范" class="headerlink" title="数据库涉及字符规范"></a>数据库涉及字符规范</h3><p> 采用26个英文字母(区分大小写)和0-9这十个自然数,加上下划线’_’组成,共63个字符.不能出现其他字符(注释除外). </p>
<p>注意事项:</p>
<p>1) 以上MYSQL数据库命名都不得超过30个字符的系统限制.变量名的长度限制为29(不包括标识字符@).</p>
<p>2) 数据对象、变量的命名都采用英文字符,禁止使用中文命名.<strong>绝对不要在对象名的字符之间留空格.</strong></p>
<p>3) 小心保留词,要保证你的字段名没有和保留词、数据库系统或者常用访问方法冲突</p>
<p>5) 保持字段名和类型的一致性,在命名字段并为其指定数据类型的时候一定要保证一致性.假如数据类型在一个表里是整数,那在另一个表里可就别变成字符型了.<br><strong>命名规范</strong></p>
<ul>
<li><p>数据表名使用小写英文以及下划线组成,尽量说明是那个应用或者系统在使用的.  相关应用的数据表使用同一前缀,如论坛的表使用cdb<em>前缀,博客的数据表使用supe</em>前缀,前缀名称一般不超过5字 。备份数据表名使用正式表名加上备份时间组成 </p>
</li>
<li><p>字段名称使用单词组合完成,首字母小写,后面单词的首字母大写,最好是带表名前缀.</p>
<p>如 web_user 表的字段:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. userId  </span><br><span class="line">2. userName  </span><br><span class="line">3. userPassword</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="索引使用原则"><a href="#索引使用原则" class="headerlink" title="索引使用原则"></a>索引使用原则</h2><p>1) 逻辑主键使用唯一的成组索引,对系统键(作为存储过程)采用唯一的非成组索引,对任何外键列采用非成组索引.考虑数据库的空间有多大,表如何进行访问,还有这些访问是否主要用作读写.</p>
<p>2) 大多数数据库都索引自动创建的主键字段,但是可别忘了索引外键,它们也是经常使用的键,比如运行查询显示主表和所有关联表的某条记录就用得上.</p>
<p>3) 不要索引blob/text等字段,不要索引大型字段(有很多字符),这样作会让索引占用太多的存储空间.</p>
<p>4) 不要索引常用的小型表</p>
<p>不要为小型数据表设置任何键,假如它们经常有插入和删除操作就更别这样作了.对这些插入和删除操作的索引维护可能比扫描表空间消耗更多的时间.</p>
<h2 id="多对多的关系"><a href="#多对多的关系" class="headerlink" title="多对多的关系"></a>多对多的关系</h2><p>若两个实体之间存在多对多的关系，则应消除这种关系。消除的办法是，在两者之间增加第三个实体。这样，原来一个多对多的关系，现在变为两个一对多的关系。要将原来两个实体的属性合理地分配到三个实体中去。这里的第三个实体，实质上是一个较复杂的关系，它对应一张基本表。一般来讲，数据库设计工具不能识别多对多的关系，但能处理多对多的关系。</p>
<h2 id="主键与外键在多表中的重复出现-不属于数据冗余"><a href="#主键与外键在多表中的重复出现-不属于数据冗余" class="headerlink" title="主键与外键在多表中的重复出现, 不属于数据冗余"></a>主键与外键在多表中的重复出现, 不属于数据冗余</h2><p>非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的重复出现，而是字段的派生出现。<br>〖例4〗：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。因此，我们提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。</p>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><ul>
<li><p>选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。 </p>
</li>
<li><p>常见的可作为<code>id</code>字段的类型有：</p>
</li>
</ul>
<ol>
<li><p>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</p>
</li>
<li><p>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</p>
</li>
</ol>
<ul>
<li>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。 </li>
</ul>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="SQL语句规范"><a href="#SQL语句规范" class="headerlink" title="SQL语句规范"></a>SQL语句规范</h2><p>所有sql关键词全部大写,比如SELECT,UPDATE,FROM,ORDER,BY等,所有的表名和库名都要用包含</p>
<p>如:</p>
<p>SELECT COUNT(*) FROM <code>cdb_members</code> WHERE <code>userName</code> = ‘aeolus’;</p>
<h2 id="基本表的定义删除与修改"><a href="#基本表的定义删除与修改" class="headerlink" title="基本表的定义删除与修改"></a>基本表的定义删除与修改</h2><h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><h2 id="空值的处理"><a href="#空值的处理" class="headerlink" title="空值的处理"></a>空值的处理</h2><p>空值NULL</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构复习</title>
    <url>/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>数据结构相关的东西忘的差不多了，临时抱佛脚准备一波。<br><a id="more"></a></p>
<h1 id="左堆"><a href="#左堆" class="headerlink" title="左堆"></a>左堆</h1><p><strong>空路径长度</strong>：如果定义节点的空路径长度npl(x)为节点x到不满两个儿子的节点的最短路径，具有0个或1个儿子的节点的npl为0，空节点为-1，2个节点为1。</p>
<p><strong>左堆</strong>：对堆中的每个节点x，左儿子的npl大于等于右儿子的npl。</p>
<h1 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h1><ul>
<li>顺序查找</li>
<li>二分查找</li>
<li>差值查找</li>
<li>分块查找</li>
</ul>
<h1 id="查找树"><a href="#查找树" class="headerlink" title="查找树"></a>查找树</h1><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>左子树的所有元素的键值都比根节点小。右子树所有元素的键值都比根节点大。</p>
<p>最坏的情况退化为单链表。</p>
<p>平均查找的时间复杂度是O（logN）</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>节点的平衡度：节点的左子树的高度减去右子树的高度。</p>
<p>AVL树：满足每个节点平衡度都为0，-1，+1的二叉查找树</p>
<p>LL或RR情况：单旋转；LR或RL情况：双旋转；</p>
<p>所有操作在最坏情况都是对数级的</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树时间代价也是对数级的。</p>
<p>红黑树是满足如下条件的二叉查找树：</p>
<ul>
<li>每个节点为黑色或红色。</li>
<li>根节点为黑色。</li>
<li>如果一个节点为红色，子节点必须是黑色。</li>
<li>从任何一个节点出发到空节点的路径上必须包含相同数目的黑节点。</li>
</ul>
<h2 id="AA树"><a href="#AA树" class="headerlink" title="AA树"></a>AA树</h2><p>左儿子不能为红色的红黑树</p>
<h2 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h2><p>伸展树：将访问的节点向根节点旋转</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><a href="https://juejin.im/post/5d8194b5e51d4561e6237214" target="_blank" rel="noopener">https://juejin.im/post/5d8194b5e51d4561e6237214</a></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。<br>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。<br>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。<br>父节点存有右孩子的第一个元素的索引。</p>
<p>B+树相对于B树有一些自己的优势，可以归结为下面几点。</p>
<p>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。<br>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。<br>所有的叶子节点形成了一个有序链表，更加便于查找。</p>
<blockquote>
<p>文件索引使用B树，B+树而不使用二叉树的原因：</p>
<p>索引存放在磁盘中，访问慢</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据挖掘复习</title>
    <url>/2020/04/21/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<p><strong>PCA</strong>实际上选择最大的特征向量，进行PCA时，不考虑label，即为非监督的。这就可能会导致进行PCA后，将原本可分的数据变的不可分。这时需要进行<strong>LDA</strong>（线性判别分析）<br><a id="more"></a><br><strong>SVM</strong>常用的核函数：多项式（映射到$m_2$维度）、高斯（映射到无穷维）、双曲正切函数</p>
<p><strong>聚类</strong>结果好坏的判定：J（越小越好），直观的看见silhouette</p>
<p><strong>Sequential leader clustering</strong></p>
<p><strong>高斯混合算法</strong>，多个高斯分布，概率和为1。经典EM算法：期望最大,初值很重要，最后得到局部最优<br><img src="1.png" alt="EM算法"></p>
<p>基于密度的算法：<strong>DBSCAN</strong>（density-based spatial cluster of application with noise） 不用事先确定k，连通性（朋友的朋友）</p>
<p>层次聚类</p>
<h1 id="关联规则："><a href="#关联规则：" class="headerlink" title="关联规则："></a>关联规则：</h1><p>频繁集（Frequent itemsets）：两个同时被购买<br>关联规则（association rule）：买了一本书会买另一本<br>序列模式（Sequential pattern）</p>
<p>支持度（support）：即频率，即多少个transactions（itemset）中包含了该item或itemset<br>置信度（confidence）：简单来说就是条件概率，即P（Y｜X）：num（包含itemset的transaction）/num（包含itemset中的某个item的transaction）</p>
<p>关联规则的挖掘：找到所有满足支持度大于阈值，置信度大于阈值的规则</p>
<p>误区：<br>1.求的的置信度很大时，也有可能小于原始事件本身发生的概率<br>2.当两个item出现概率差别很大时，会误认为出现概率高的item一定会是的概率低的item发生。<br>3.两个时间相关，不代表两者之间有因果关系</p>
<p><strong>The Apriori Method</strong><br>key idea：1.频繁集的子集必定频繁； 2.一个item不频繁则其超集不频繁；</p>
<p>步骤：<br>1.生成确定大小的itemset<br>2.扫描数据库，看看哪些是频繁的<br>3.将已知频繁的itemset组合<br>4.进行2</p>
<p>比如对于大小为2的频繁集，如果要生成大小为3的频繁集，不需要将大小为1的频繁集加到2中，只需要将大小为2的频繁集加上其中的频繁item。如{(2,3),(2,5),(3,5),(1,3)} -&gt; {(2,3,5)}</p>
<h1 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h1><h2 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><p>TF（term frequency）：单词在特定文档中出现的频率<br>IDF（inverse document frequency）：log（所有文档个数/包含特定词的个数）<br>TF-IDF = TF*IDF</p>
<h2 id="Vector-Space-Model"><a href="#Vector-Space-Model" class="headerlink" title="Vector Space Model"></a>Vector Space Model</h2><p>每一位表示一个单词<br>比较相似度：$cos(\theta)=\frac{p·q}{|p|·|q|}$</p>
<h2 id="Latent-Semantic-Analysis"><a href="#Latent-Semantic-Analysis" class="headerlink" title="Latent Semantic Analysis"></a>Latent Semantic Analysis</h2><p>类似PCA的降维</p>
<h2 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h2><p>指向别的网页少，指向其的网页PageRank的和</p>
<h2 id="Collaborative-filtering（协同过滤）"><a href="#Collaborative-filtering（协同过滤）" class="headerlink" title="Collaborative filtering（协同过滤）"></a>Collaborative filtering（协同过滤）</h2><p><strong>User-based CF</strong><br>找类似的item做参考<br>需要用到平均值作为基值<br><strong>Model-based CF</strong><br>将表格转换为分类问题，再训练</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="集成学习（ensemble）—-用于监督学习中的分类问题"><a href="#集成学习（ensemble）—-用于监督学习中的分类问题" class="headerlink" title="集成学习（ensemble）—-用于监督学习中的分类问题"></a>集成学习（ensemble）—-用于监督学习中的分类问题</h2><p>包含bagging和boosting</p>
<p>均值<br>投票（可以加权）<br>学习combiner</p>
<h2 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h2><p>基于bootstrap的分类器：训练多个分类器，来个样本，多个分类器投票。如随机森林<br><strong>bootstrap sample</strong><br>有放回的采样</p>
<p><strong>stacking</strong><br>学习分类器的权重</p>
<h2 id="boosting"><a href="#boosting" class="headerlink" title="boosting"></a>boosting</h2><p>串行的，根据生成的分类器，再生成第二个分类器，让后面的分类器学习第一个分类器分错的样本（或权重大的样本），第三个分类器学习前两个分类器分类不一致的样本。</p>
<h3 id="adaboost"><a href="#adaboost" class="headerlink" title="adaboost"></a>adaboost</h3><p>修改权重</p>
<h3 id="regionboost"><a href="#regionboost" class="headerlink" title="regionboost"></a>regionboost</h3><p>给权重增加了与输入的关联性</p>
<h1 id="进化算法"><a href="#进化算法" class="headerlink" title="进化算法"></a>进化算法</h1><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><p><a href="https://blog.csdn.net/u010451580/article/details/51178225" target="_blank" rel="noopener">https://blog.csdn.net/u010451580/article/details/51178225</a><br>所以我们总结出遗传算法的一般步骤：<br>开始循环直至找到满意的解。</p>
<p>1.评估每条染色体所对应个体的适应度。</p>
<p>2.遵照适应度越高，选择概率越大的原则，从种群中选择两个个体作为父方和母方。</p>
<p>3.抽取父母双方的染色体，进行交叉，产生子代。</p>
<p>4.对子代的染色体进行变异。</p>
<p>5.重复2，3，4步骤，直到新种群的产生。</p>
<p>结束循环。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>显卡</title>
    <url>/2020/09/05/%E6%98%BE%E5%8D%A1/</url>
    <content><![CDATA[<p>显卡中的多个核心可以同时进行多个计算。但是单个核心的功能单一，部分语句如if等在gpu核心中的计算非常缓慢。<br><a id="more"></a></p>
<p>对显卡的编程大致分为两类：</p>
<ul>
<li>通用的并行计算编程<br>cuda，openCL，openACC</li>
<li>图形编程<br>openGL，directX，vulkan</li>
</ul>
<p>计算机图形渲染：三角形渲染</p>
<p><b>shader程序</b>：绘制物体的形状、颜色。OpenGL（GLSL），DirectX（Gg/HLSL），SPIR-V（二进制码）</p>
]]></content>
      <categories>
        <category>高性能计算</category>
      </categories>
  </entry>
  <entry>
    <title>材料科学基础拾遗</title>
    <url>/2020/07/31/%E6%9D%90%E6%96%99%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<h2 id="材料科学基础拾遗"><a href="#材料科学基础拾遗" class="headerlink" title="材料科学基础拾遗"></a>材料科学基础拾遗</h2><a id="more"></a>
<ol>
<li><p>弹性模量是材料刚度的度量。弹性模量越大，刚度越大。</p>
</li>
<li><p>合金的成分越远离<em>共晶</em>点，结晶温度范围越宽，其流动性越差。因此在满足使用<em>性能</em>的前提下，<em>铸造</em>合金应尽量选用<em>共晶</em>合金或接近共品成分的合金。</p>
</li>
<li>固溶体合金流动性差，不如共晶和纯金属，且结晶温度范围越大，树枝晶易粗大，偏析严重。</li>
<li>压力加工性能好的合金通常是单相固溶体，因为固溶体强度低、塑性好、变形均匀。</li>
<li><p>光的干涉分为：双光波干涉, 多光波干涉, 偏振光的干涉</p>
</li>
<li><p>GPC:凝胶色谱法。测量分子量。</p>
</li>
<li>SEC：依据分子尺寸大小差异，利用多孔凝胶分离。</li>
<li>微波通常是指频率介于300MHz到300Ghz，波长介于1m到1mm之间的电磁波。</li>
<li>FTIR：官能团测定。无法测定分子量。</li>
<li>衡量微波介质陶瓷主要有三个性能指标：介电常数，谐振频率温度系数，品质因子。</li>
<li>XRD可以用来测定分子量。</li>
<li><strong>XRF</strong>指的是<strong>X射线荧光光谱仪</strong>，可以快速同时对多元素进行测定的仪器。在X射线激发下，被测元素原子的内层电子发生能级跃迁而发出次级X射线（X-荧光）。从不同的角度来观察描述X射线，可将XRF分为<strong>能量散射型</strong>X射线荧光光谱仪，缩写为<strong>EDXRF或EDX</strong>和<strong>波长散射型</strong>X射线荧光光谱仪，可缩写为<strong>WDXRF或WDX</strong>，但市面上用的较多的为EDX。WDX用晶体分光而后由探测器接收经过衍射的特征X射线信号。</li>
<li>ICP是电感耦合等离子谱仪。能测元素周期表中的绝大部分元素</li>
<li>EDS是能量色散X射线谱仪，简称能谱仪，常用作扫描电镜或透射电镜的微区成分分析。</li>
<li>晶体都是长程有序，非晶体是短程有序。对于晶体说的长程有序指的是元素的有序性。此时，长程有序指的是某个原子周围的原子确定，短程有序指的是原子周围的原子某个比例范围或者指偏聚。</li>
</ol>
<h2 id="物理拾遗"><a href="#物理拾遗" class="headerlink" title="物理拾遗"></a>物理拾遗</h2><ol>
<li>放大镜的放大倍数</li>
</ol>
<script type="math/tex; mode=display">\frac{1}{p}+\frac{1}{q}=\frac1f</script><p>实像距离为+，虚像距离为－。</p>
<p>对显微镜，物体位于物镜略大于一倍焦距处，在镜筒成倒立放大的实像。该像位于目镜一倍焦距内，呈正立放大的虚像。</p>
<p>对物镜，p固定，pqf为正，则f越大，q越大。</p>
<p>对目镜，p固定，pf为正，q为负，则f越小，q越大。</p>
<p>还有一种说法：显微镜为视角放大率：$M=-\frac{S<em>D}{F_o</em>F_e}$ 。 S为明视距离，D为物方焦点到像方焦点的距离，即筒长。Fo和Fe分别为物镜和目镜的焦距。</p>
<ol>
<li><p>单缝衍射</p>
<script type="math/tex; mode=display">I=I_0\frac{sin^2u}{u^2}</script><p>其中，$u=\frac{\pi asin\theta}{\lambda}$，a为缝宽，$\theta$为与光轴的角度。</p>
<p>$\theta$为0时，中央亮条纹。$k\pi$暗条纹，即$k\lambda=a\theta$</p>
</li>
<li><p>双缝干涉</p>
</li>
</ol>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>材料</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中的优化方法</title>
    <url>/2020/02/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_14845119/article/details/86491430" target="_blank" rel="noopener">梯度下降优化方法</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>注意力机制概念详解与其在LSTM中的使用</title>
    <url>/2020/02/21/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>csdn: <a href="https://blog.csdn.net/weixin_44791964/article/details/104000722" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/104000722</a></p>
<h1 id="什么是注意力机制"><a href="#什么是注意力机制" class="headerlink" title="什么是注意力机制"></a>什么是注意力机制</h1><a id="more"></a>
<p>利用神经网络找到输入进来的特征，哪一部分更有用。</p>
<p>假设我们要翻译一句话：<br>打电脑游戏。<br>也就是play computer game。<br><img src="1.png" alt=""><br>如果不引入注意力机制，那么我们从Encoder获得语义编码c之后，这个语义编码在Decoder中传递，其内容就和Encoder无关了。</p>
<p>但是事实上我们希望在翻译打电脑游戏中的打的时候，我们更注意打-&gt;play的转换，此时我们希望Decoder更加注意Encoder从打中提取出来的特征。</p>
<p>这就是注意力机制的概念，它的本意是让神经网络模型在做特定的事的时候可以注意到它需要注意的地方。</p>
<p>由于神经网络是一堆数字的传递，每个事物的特征也是由一堆数字组成的，比如打字的特征也是一堆数字，电脑的特征也是一堆数字，游戏的特征也是一堆数字，语义编码c就是这么多特征的组合。</p>
<p>那么如何使得神经网络模型对某个内容进行注意呢？其实就是将改变不同内容的权重，当我们需要神经网络注意到打的时候，我们只需要提高打字的特征的权重就可以了。<br>假设函数 f 可以用于提取特征，函数 g 可以实现解码。那么如果我们要神经网络注意到打，可以通过如下方式进行。</p>
<script type="math/tex; mode=display">C_{play}=g(0.8∗f(打),0.1∗f(电脑),0.1∗f(游戏))</script><h1 id="注意力机制的通俗解释"><a href="#注意力机制的通俗解释" class="headerlink" title="注意力机制的通俗解释"></a>注意力机制的通俗解释</h1><p><img src="2.png" alt=""><br>在mobelnet中注意力机制的应用如上，将图片通过全局均匀池化层变成一个长条，变成短条，恢复长条，恢复大小。长条变短条再变长条的过程就是重要特征提取的过程。短条中给了重要特征更高的权重。</p>
<p>总的来说类似自编码器，中间的全连接层用来将重要的特征进行提取（重要的特征给高的权重）。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>注意力机制</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中的损失函数</title>
    <url>/2020/02/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>损失函数汇总：<br><a href="https://blog.csdn.net/qq_14845119/article/details/80787753" target="_blank" rel="noopener">csdn博客</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>损失函数</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中的激活函数</title>
    <url>/2020/02/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u014595019/article/details/52562159" target="_blank" rel="noopener">常见的激活函数</a></p>
<p>激活函数对于提高模型鲁棒性，非线性表达能力，缓解梯度消失问题，将特征图映射到新的特征空间从何更有利于训练，加速模型收敛等问题都有很好的帮助</p>
<p>激活函数，一般情况下。我们会放在pooling 之后，但有时候pooling 以后会有batch normalization，激活函数又会放在batch normalization 以后</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫</title>
    <url>/2020/06/29/%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<p>爬虫：<a href="https://www.cnblogs.com/wupeiqi/articles/5354900.html" target="_blank" rel="noopener">https://www.cnblogs.com/wupeiqi/articles/5354900.html</a><br>详细连接:<a href="https://www.cnblogs.com/wupeiqi/articles/6283017.html" target="_blank" rel="noopener">https://www.cnblogs.com/wupeiqi/articles/6283017.html</a></p>
<a id="more"></a>
<h3 id="一、爬虫基本操作"><a href="#一、爬虫基本操作" class="headerlink" title="一、爬虫基本操作"></a>一、爬虫基本操作</h3><h4 id="1-1-爬虫"><a href="#1-1-爬虫" class="headerlink" title="1.1 爬虫"></a>1.1 爬虫</h4><ul>
<li>定向</li>
<li>非定向</li>
</ul>
<h4 id="1-2-步骤"><a href="#1-2-步骤" class="headerlink" title="1.2 步骤"></a>1.2 步骤</h4><ul>
<li>下载页面</li>
<li>筛选：正则表达式</li>
</ul>
<h4 id="1-3-开源模块"><a href="#1-3-开源模块" class="headerlink" title="1.3 开源模块"></a>1.3 开源模块</h4><ul>
<li>requests<ul>
<li>response = request.get()</li>
<li>response.txt</li>
</ul>
</li>
<li>beautifulsoup<ul>
<li>bs = Beautifulsoup(request.txt)</li>
<li>bs.find(id = “”)</li>
</ul>
</li>
</ul>
<h3 id="二、requests库"><a href="#二、requests库" class="headerlink" title="二、requests库"></a>二、requests库</h3><p>Requests 是使用 Apache2 Licensed 许可证的 基于Python开发的HTTP 库，其在Python内置模块的基础上进行了高度的封装，从而使得Pythoner进行网络请求时，变得美好了许多，使用Requests可以轻而易举的完成浏览器可有的任何操作。</p>
<h4 id="1-Get请求"><a href="#1-Get请求" class="headerlink" title="1.Get请求"></a>1.Get请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、无参数实例</span><br><span class="line">  </span><br><span class="line">import requests</span><br><span class="line">  </span><br><span class="line">ret &#x3D; requests.get(&#39;https:&#x2F;&#x2F;github.com&#x2F;timeline.json&#39;)</span><br><span class="line">  </span><br><span class="line">print ret.url</span><br><span class="line">print ret.text</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"># 2、有参数实例</span><br><span class="line">  </span><br><span class="line">import requests</span><br><span class="line">  </span><br><span class="line">payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;</span><br><span class="line">ret &#x3D; requests.get(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;, params&#x3D;payload)</span><br><span class="line">  </span><br><span class="line">print ret.url</span><br><span class="line">print ret.text</span><br></pre></td></tr></table></figure>
<h4 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、基本POST实例</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">ret = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> ret.text</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 2、发送请求头和数据实例</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">  </span><br><span class="line">url = <span class="string">'https://api.github.com/some/endpoint'</span></span><br><span class="line">payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</span><br><span class="line">headers = &#123;<span class="string">'content-type'</span>: <span class="string">'application/json'</span>&#125;</span><br><span class="line">  </span><br><span class="line">ret = requests.post(url, data=json.dumps(payload), headers=headers)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> ret.text</span><br><span class="line"><span class="keyword">print</span> ret.cookies</span><br></pre></td></tr></table></figure>
<p>总结</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response =resquests.get(url = <span class="string">""</span>)</span><br><span class="line">response = requests.post(url = <span class="string">""</span>,data=&#123;<span class="string">""</span>:<span class="string">""</span>&#125;,cookies=&#123;<span class="string">"asdf"</span>:<span class="string">"asfdasdf"</span>&#125;)</span><br><span class="line"></span><br><span class="line">response.content <span class="comment">#字节内容</span></span><br><span class="line">response.encoding <span class="comment">#编码方式</span></span><br><span class="line">response.apparent_encoding</span><br><span class="line">response.text <span class="comment">#文本内容</span></span><br><span class="line">response.status_code  <span class="comment"># 200,300........</span></span><br><span class="line">response.cookies <span class="comment"># cookies对象</span></span><br><span class="line">response.cookies.get_dict() <span class="comment">#cookies字典</span></span><br></pre></td></tr></table></figure>
<p>详细</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_method_url</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># requests.request(method='get', url='http://127.0.0.1:8000/test/')</span></span><br><span class="line">    <span class="comment"># requests.request(method='post', url='http://127.0.0.1:8000/test/')</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_param</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># - 可以是字典</span></span><br><span class="line">    <span class="comment"># - 可以是字符串</span></span><br><span class="line">    <span class="comment"># - 可以是字节（ascii编码以内）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># requests.request(method='get',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># params=&#123;'k1': 'v1', 'k2': '水电费'&#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># requests.request(method='get',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># params="k1=v1&amp;k2=水电费&amp;k3=v3&amp;k3=vv3")</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># requests.request(method='get',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># params=bytes("k1=v1&amp;k2=k2&amp;k3=v3&amp;k3=vv3", encoding='utf8'))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 错误</span></span><br><span class="line">    <span class="comment"># requests.request(method='get',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># params=bytes("k1=v1&amp;k2=水电费&amp;k3=v3&amp;k3=vv3", encoding='utf8'))</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 可以是字典</span></span><br><span class="line">    <span class="comment"># 可以是字符串</span></span><br><span class="line">    <span class="comment"># 可以是字节</span></span><br><span class="line">    <span class="comment"># 可以是文件对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># requests.request(method='POST',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># data=&#123;'k1': 'v1', 'k2': '水电费'&#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># requests.request(method='POST',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># data="k1=v1; k2=v2; k3=v3; k3=v4"</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># requests.request(method='POST',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># data="k1=v1;k2=v2;k3=v3;k3=v4",</span></span><br><span class="line">    <span class="comment"># headers=&#123;'Content-Type': 'application/x-www-form-urlencoded'&#125;</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># requests.request(method='POST',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># data=open('data_file.py', mode='r', encoding='utf-8'), # 文件内容是：k1=v1;k2=v2;k3=v3;k3=v4</span></span><br><span class="line">    <span class="comment"># headers=&#123;'Content-Type': 'application/x-www-form-urlencoded'&#125;</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_json</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 将json中对应的数据进行序列化成一个字符串，json.dumps(...)</span></span><br><span class="line">    <span class="comment"># 然后发送到服务器端的body中，并且Content-Type是 &#123;'Content-Type': 'application/json'&#125;</span></span><br><span class="line">    requests.request(method=<span class="string">'POST'</span>,</span><br><span class="line">                     url=<span class="string">'http://127.0.0.1:8000/test/'</span>,</span><br><span class="line">                     json=&#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>, <span class="string">'k2'</span>: <span class="string">'水电费'</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_headers</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 发送请求头到服务器端</span></span><br><span class="line">    requests.request(method=<span class="string">'POST'</span>,</span><br><span class="line">                     url=<span class="string">'http://127.0.0.1:8000/test/'</span>,</span><br><span class="line">                     json=&#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>, <span class="string">'k2'</span>: <span class="string">'水电费'</span>&#125;,</span><br><span class="line">                     headers=&#123;<span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>&#125;</span><br><span class="line">                     )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_cookies</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 发送Cookie到服务器端</span></span><br><span class="line">    requests.request(method=<span class="string">'POST'</span>,</span><br><span class="line">                     url=<span class="string">'http://127.0.0.1:8000/test/'</span>,</span><br><span class="line">                     data=&#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>, <span class="string">'k2'</span>: <span class="string">'v2'</span>&#125;,</span><br><span class="line">                     cookies=&#123;<span class="string">'cook1'</span>: <span class="string">'value1'</span>&#125;,</span><br><span class="line">                     )</span><br><span class="line">    <span class="comment"># 也可以使用CookieJar（字典形式就是在此基础上封装）</span></span><br><span class="line">    <span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> CookieJar</span><br><span class="line">    <span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> Cookie</span><br><span class="line"></span><br><span class="line">    obj = CookieJar()</span><br><span class="line">    obj.set_cookie(Cookie(version=<span class="number">0</span>, name=<span class="string">'c1'</span>, value=<span class="string">'v1'</span>, port=<span class="literal">None</span>, domain=<span class="string">''</span>, path=<span class="string">'/'</span>, secure=<span class="literal">False</span>, expires=<span class="literal">None</span>,</span><br><span class="line">                          discard=<span class="literal">True</span>, comment=<span class="literal">None</span>, comment_url=<span class="literal">None</span>, rest=&#123;<span class="string">'HttpOnly'</span>: <span class="literal">None</span>&#125;, rfc2109=<span class="literal">False</span>,</span><br><span class="line">                          port_specified=<span class="literal">False</span>, domain_specified=<span class="literal">False</span>, domain_initial_dot=<span class="literal">False</span>, path_specified=<span class="literal">False</span>)</span><br><span class="line">                   )</span><br><span class="line">    requests.request(method=<span class="string">'POST'</span>,</span><br><span class="line">                     url=<span class="string">'http://127.0.0.1:8000/test/'</span>,</span><br><span class="line">                     data=&#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>, <span class="string">'k2'</span>: <span class="string">'v2'</span>&#125;,</span><br><span class="line">                     cookies=obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_files</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 发送文件（字典）</span></span><br><span class="line">    <span class="comment"># file_dict = &#123;</span></span><br><span class="line">    <span class="comment"># 'f1': open('readme', 'rb')</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="comment"># requests.request(method='POST',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># files=file_dict)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送文件，定制文件名（以元组作为值）</span></span><br><span class="line">    <span class="comment"># file_dict = &#123;</span></span><br><span class="line">    <span class="comment"># 'f1': ('test.txt', open('readme', 'rb'))</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="comment"># requests.request(method='POST',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># files=file_dict)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送文件，定制文件名（文件内容通过自己输入）</span></span><br><span class="line">    <span class="comment"># file_dict = &#123;</span></span><br><span class="line">    <span class="comment"># 'f1': ('test.txt', "hahsfaksfa9kasdjflaksdjf")</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="comment"># requests.request(method='POST',</span></span><br><span class="line">    <span class="comment"># url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment"># files=file_dict)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送文件，定制文件名</span></span><br><span class="line">    <span class="comment"># file_dict = &#123;</span></span><br><span class="line">    <span class="comment">#     'f1': ('test.txt', "hahsfaksfa9kasdjflaksdjf", 'application/text', &#123;'k1': '0'&#125;)</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="comment"># requests.request(method='POST',</span></span><br><span class="line">    <span class="comment">#                  url='http://127.0.0.1:8000/test/',</span></span><br><span class="line">    <span class="comment">#                  files=file_dict)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_auth</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth, HTTPDigestAuth</span><br><span class="line"></span><br><span class="line">    ret = requests.get(<span class="string">'https://api.github.com/user'</span>, auth=HTTPBasicAuth(<span class="string">'wupeiqi'</span>, <span class="string">'sdfasdfasdf'</span>))</span><br><span class="line">    print(ret.text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret = requests.get('http://192.168.1.1',</span></span><br><span class="line">    <span class="comment"># auth=HTTPBasicAuth('admin', 'admin'))   ##用户名和密码进行BASIC64认证，一般用不到</span></span><br><span class="line">    <span class="comment"># ret.encoding = 'gbk'</span></span><br><span class="line">    <span class="comment"># print(ret.text)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret = requests.get('http://httpbin.org/digest-auth/auth/user/pass', auth=HTTPDigestAuth('user', 'pass'))</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_timeout</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ret = requests.get('http://google.com/', timeout=1)</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret = requests.get('http://google.com/', timeout=(5, 1))</span></span><br><span class="line">    <span class="comment"># print(ret)</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_allow_redirects</span><span class="params">()</span>:</span></span><br><span class="line">    ret = requests.get(<span class="string">'http://127.0.0.1:8000/test/'</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">    print(ret.text)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># http是指通过socket.直接发消息没有加密</span></span><br><span class="line"><span class="comment"># https有ssl加密。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># verify=False忽略证书的存在</span></span><br><span class="line"><span class="comment"># cert = 证书文件  发送证书</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_proxies</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># proxies = &#123;</span></span><br><span class="line">    <span class="comment"># "http": "61.172.249.96:80",</span></span><br><span class="line">    <span class="comment"># "https": "http://61.185.219.126:3128",</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxies = &#123;'http://10.20.1.128': 'http://10.10.1.10:5323'&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ret = requests.get("http://www.proxy360.cn/Proxy", proxies=proxies)</span></span><br><span class="line">    <span class="comment"># print(ret.headers)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># from requests.auth import HTTPProxyAuth</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># proxyDict = &#123;</span></span><br><span class="line">    <span class="comment"># 'http': '77.75.105.165',</span></span><br><span class="line">    <span class="comment"># 'https': '77.75.105.165'</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="comment"># auth = HTTPProxyAuth('username', 'mypassword')</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># r = requests.get("http://www.google.com", proxies=proxyDict, auth=auth)</span></span><br><span class="line">    <span class="comment"># print(r.text)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_stream</span><span class="params">()</span>:</span></span><br><span class="line">    ret = requests.get(<span class="string">'http://127.0.0.1:8000/test/'</span>, stream=<span class="literal">True</span>)</span><br><span class="line">    print(ret.content)</span><br><span class="line">    ret.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># from contextlib import closing</span></span><br><span class="line">    <span class="comment"># with closing(requests.get('http://httpbin.org/get', stream=True)) as r:</span></span><br><span class="line">    <span class="comment"># # 在此处理响应。为True时分段传输</span></span><br><span class="line">    <span class="comment"># for i in r.iter_content():</span></span><br><span class="line">    <span class="comment"># print(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#session自动对cookie，请求头等进行处理，（保存客户端历史访问信息）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requests_session</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">    session = requests.Session()</span><br><span class="line"></span><br><span class="line">    <span class="comment">### 1、首先登陆任何页面，获取cookie</span></span><br><span class="line"></span><br><span class="line">    i1 = session.get(url=<span class="string">"http://dig.chouti.com/help/service"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">### 2、用户登陆，携带上一次的cookie，后台对cookie中的 gpsd 进行授权</span></span><br><span class="line">    i2 = session.post(</span><br><span class="line">        url=<span class="string">"http://dig.chouti.com/login"</span>,</span><br><span class="line">        data=&#123;</span><br><span class="line">            <span class="string">'phone'</span>: <span class="string">"8615131255089"</span>,</span><br><span class="line">            <span class="string">'password'</span>: <span class="string">"xxxxxx"</span>,</span><br><span class="line">            <span class="string">'oneMonth'</span>: <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    i3 = session.post(</span><br><span class="line">        url=<span class="string">"http://dig.chouti.com/link/vote?linksId=8589623"</span>,</span><br><span class="line">    )</span><br><span class="line">    print(i3.text)</span><br><span class="line"></span><br><span class="line">参数示例</span><br></pre></td></tr></table></figure>
<h3 id="三、beautifulsoup4库"><a href="#三、beautifulsoup4库" class="headerlink" title="三、beautifulsoup4库"></a>三、beautifulsoup4库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(response.text,feature = <span class="string">"html.parser"</span>)</span><br><span class="line"><span class="comment">## feature解析引擎，html.parser为python自带引擎</span></span><br><span class="line"><span class="comment">## lxml为第三方引擎，需要安装第三方库</span></span><br><span class="line">target = soup.find(id=<span class="string">"auto-channel-lazyload-article"</span>)</span><br><span class="line"></span><br><span class="line">li_list = target.find_all(<span class="string">"li"</span>) <span class="comment">#根据标签查找所有的li，，， find查找第一个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> li_item <span class="keyword">in</span> li_list:</span><br><span class="line">    a_item = li_item.find(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">if</span> a_item:</span><br><span class="line">        href_item = <span class="string">"https:"</span> + a_item.attrs.get(<span class="string">"href"</span>)</span><br><span class="line">        <span class="comment"># attrs 获得标签属性字典</span></span><br><span class="line">        <span class="comment"># get获得标签的某个属性</span></span><br><span class="line">        print(href_item)</span><br><span class="line"></span><br><span class="line">        txt = a_item.find(<span class="string">"h3"</span>).text  <span class="comment"># a_item.find("img")得到的对象为tag对象，得到text需要 a_item.find("img").text</span></span><br><span class="line">        img_url = <span class="string">"https:"</span> + a_item.find(<span class="string">"img"</span>).attrs.get(<span class="string">"src"</span>)</span><br><span class="line">        print(img_url)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> re</span><br><span class="line">        <span class="comment"># 将网址中的www3等替换为www</span></span><br><span class="line">        mod = re.compile(<span class="string">"^https://www\d"</span>)</span><br><span class="line">        img_url = re.sub(mod, <span class="string">"https://www"</span>, img_url)</span><br><span class="line">        <span class="comment"># 下载并保存图片</span></span><br><span class="line">        img = requests.get(url=img_url)</span><br><span class="line">        <span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">        file_name = str(uuid.uuid4()) + <span class="string">".png"</span></span><br><span class="line">        <span class="keyword">with</span> open(file_name, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(img.content)  <span class="comment"># .content 是以字节储存的内容</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(response.text,feature = <span class="string">"html.parser"</span>)</span><br><span class="line"><span class="comment">#查询一个</span></span><br><span class="line">v1 = soup.find(<span class="string">"div"</span>) <span class="comment">#标签查询</span></span><br><span class="line">v1 = soup.find(id = <span class="string">"test"</span>) <span class="comment">#属性查询</span></span><br><span class="line">v1 = soup.find(<span class="string">"div"</span>，id =<span class="string">"test"</span>) <span class="comment"># 组合查询</span></span><br><span class="line"><span class="comment">#查询所有</span></span><br><span class="line">v2 = soup.find_all(<span class="string">"div"</span>)</span><br><span class="line"></span><br><span class="line">obj = v1</span><br><span class="line">obj = v2[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">obj.text <span class="comment">#内容</span></span><br><span class="line">obj.attrs <span class="comment">#属性</span></span><br></pre></td></tr></table></figure>
<h3 id="自动登录"><a href="#自动登录" class="headerlink" title="自动登录"></a>自动登录</h3><p>点击登录，若页面刷新，以form表单提交，若为刷新，以ajax提交</p>
<p>form提交和ajax提交<a href="https://blog.csdn.net/gghh2015/article/details/79116718" target="_blank" rel="noopener">https://blog.csdn.net/gghh2015/article/details/79116718</a></p>
<h3 id="模块详细"><a href="#模块详细" class="headerlink" title="模块详细"></a>模块详细</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">post_dict = &#123;<span class="string">"phone"</span>: <span class="number">1231234124</span>,</span><br><span class="line">             <span class="string">"password"</span>: <span class="string">"asdfasdf"</span>,</span><br><span class="line">             <span class="string">"loginType"</span>: <span class="number">2</span>,</span><br><span class="line">             &#125;</span><br><span class="line">response = requests.post(</span><br><span class="line">    url=<span class="string">"https://dig.chouti.com/login"</span>,</span><br><span class="line">    data=post_dict</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response.text</span><br><span class="line">cookies_dict = response.cookies.get_dict()</span><br><span class="line"><span class="comment">## 一般情况只需要将url和cookies发过去</span></span><br><span class="line">requests.get(url=<span class="string">"asfdasf"</span>, cookies=cookies_dict)</span><br><span class="line"><span class="comment">## 查看操作时的request头</span></span><br></pre></td></tr></table></figure>
<pre><code>c. 模块详细使用
    requests

    - 方法关系
        requests.get(.....)
        requests.post(.....)
        requests.put(.....)
        requests.delete(.....)
        ...

        requests.request(&#39;POST&#39;...)
    - 参数
        request.request
        - method:  提交方式
        - url:     提交地址
        - params:  在URL中传递的参数,GET 
            requests.request(
                method=&#39;GET&#39;,
                url= &#39;http://www.oldboyedu.com&#39;,
                params = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;}
            )
            # http://www.oldboyedu.com?k1=v1&amp;k2=v2
        - data:    在请求体里传递的数据

            requests.request(
                method=&#39;POST&#39;,
                url= &#39;http://www.oldboyedu.com&#39;,
                params = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;},
                data = {&#39;use&#39;:&#39;alex&#39;,&#39;pwd&#39;: &#39;123&#39;,&#39;x&#39;:[11,2,3]}  #data中不能有字典
            )
               #如果以data形式传递，request将数据封装为请求头和请求体
            请求头:
                content-type: application/url-form-encod..... 
            请求体:
                use=alex&amp;pwd=123

                 - json   在请求体里传递的数据
            requests.request(
                method=&#39;POST&#39;,
                url= &#39;http://www.oldboyedu.com&#39;,
                params = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;},
                json = {&#39;use&#39;:&#39;alex&#39;,&#39;pwd&#39;: &#39;123&#39;}
            )
            请求头:
                content-type: application/json
            请求体:
                &quot;{&#39;use&#39;:&#39;alex&#39;,&#39;pwd&#39;: &#39;123&#39;}&quot;
            PS: 字典中嵌套字典时使用json，如果没有嵌套，用data即可

        - headers   请求头

            requests.request(
                method=&#39;POST&#39;,
                url= &#39;http://www.oldboyedu.com&#39;,
                params = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;},
                json = {&#39;use&#39;:&#39;alex&#39;,&#39;pwd&#39;: &#39;123&#39;},
                headers={
                    &#39;Referer&#39;: &#39;http://dig.chouti.com/&#39;,  ##上一次访问的网站
                    &#39;User-Agent&#39;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot;   ##客户端
                }
            )
         - cookies  Cookies 放到header中发送

         - files    上传文件

         - auth      基本认知(headers中加入加密的用户名和密码)

         - timeout  请求和响应的超市时间

         - allow_redirects  是否允许重定向

         - proxies  代理

         - verify   是否忽略证书

         - cert      证书文件

         - stream   村长下大片

             - session: 用于保存客户端历史访问信息
</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>第三方库</category>
      </categories>
  </entry>
  <entry>
    <title>生成tensorflow的docset</title>
    <url>/2020/02/23/%E7%94%9F%E6%88%90tensorflow%E7%9A%84docset/</url>
    <content><![CDATA[<p>为dash.app生成tensorflow的docset来查找api<br>github；<a href="https://github.com/m3hrdadfi/dash-tf-docset" target="_blank" rel="noopener">https://github.com/m3hrdadfi/dash-tf-docset</a></p>
]]></content>
      <categories>
        <category>其他工具</category>
      </categories>
  </entry>
  <entry>
    <title>有限元</title>
    <url>/2020/06/06/%E6%9C%89%E9%99%90%E5%85%83/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="力学的分类"><a href="#力学的分类" class="headerlink" title="力学的分类"></a>力学的分类</h2><a id="more"></a>
<p>描述航天器：</p>
<ul>
<li>刚体：描述姿态</li>
<li>变形体：对姿态的耦合和影响</li>
<li>质点：描述轨道</li>
</ul>
<p>力学的分类：</p>
<ul>
<li>质点力学：使用牛顿三大定律求解</li>
<li>刚体力学（理论力学）：牛顿三大定律；刚体转动的牛顿方程（动量矩方程）</li>
</ul>
<p>简单形状变形体：</p>
<ul>
<li>几何变形</li>
<li>力的平衡</li>
<li>物理本构方程</li>
</ul>
<p>复杂形状变形体（弹性力学）：</p>
<ul>
<li>几何变形</li>
<li>力的平衡</li>
<li>物理本构方程（材料行为）</li>
</ul>
<p>弹塑性力学：</p>
<ul>
<li>几何变形</li>
<li>力的平衡</li>
<li>物理本构方程（材料行为）</li>
</ul>
<h2 id="微分方程的求解"><a href="#微分方程的求解" class="headerlink" title="微分方程的求解"></a>微分方程的求解</h2><h3 id="解析法"><a href="#解析法" class="headerlink" title="解析法"></a>解析法</h3><h3 id="差分法"><a href="#差分法" class="headerlink" title="差分法"></a>差分法</h3><p>使用差分代替微分</p>
<script type="math/tex; mode=display">\frac{d^2u}{dx^2}=\frac{u_{i-1}-2u_i+u_{i+1}}{\Delta l^2}</script><h3 id="试函数法"><a href="#试函数法" class="headerlink" title="试函数法"></a>试函数法</h3><ul>
<li>选择试函数使其满足边界条件</li>
<li>带入控制方程使试函数残差最小</li>
</ul>
<h2 id="函数逼近问题"><a href="#函数逼近问题" class="headerlink" title="函数逼近问题"></a>函数逼近问题</h2><ul>
<li><strong>基于全域</strong>，使用傅里叶级数逼近。这种方法对于3D问题很难求解。</li>
<li><strong>基于子域</strong>，分段展开。分片函数逼近：几何-&gt;几何离散-&gt;基本构件（单元）</li>
</ul>
<h1 id="弹性力学"><a href="#弹性力学" class="headerlink" title="弹性力学"></a>弹性力学</h1><h2 id="弹簧的力学分析原理"><a href="#弹簧的力学分析原理" class="headerlink" title="弹簧的力学分析原理"></a>弹簧的力学分析原理</h2><p><img src="1.png" alt=""><br>
$$
\left[\begin{matrix}k & -k \\ -k & k\end{matrix}\right]
\left[\begin{matrix}u_1 \\u_2\end{matrix}\right]
=
\left[\begin{matrix}F_1 \\F_2\end{matrix}\right]
\tag{1}
$$
</p>
<h1 id="弹性力学-1"><a href="#弹性力学-1" class="headerlink" title="弹性力学"></a>弹性力学</h1><blockquote>
<p>弹性力学平面问题<br>为了保持边界位移的连续性，假设单元内任意一点的位移为其坐标的线性函数，这样边界的变化就是线性的。<br>形函数：任意一点的位移可以用单元节点的位移表示，系数称为形函数。<br>单元的应力和应变都是常数。</p>
</blockquote>
<h2 id="弹性力学的变形体假设"><a href="#弹性力学的变形体假设" class="headerlink" title="弹性力学的变形体假设"></a>弹性力学的变形体假设</h2><p>连续、均匀、各向同性、线弹性、小变形</p>
<h2 id="指标记法"><a href="#指标记法" class="headerlink" title="指标记法"></a>指标记法</h2><script type="math/tex; mode=display">F_i = [F_1,F_2,F_3]</script><script type="math/tex; mode=display">\sum_{j=1}^{i}a_{ij}x_j=b_i\ \Rightarrow\ a_{ij}x_j=b_i</script><p><strong>Voigt标记</strong>（将高阶自由指标张量写成低阶张量）<br>
$$\sigma_{ij}=\left[\begin{matrix}\sigma_{11} & \sigma_{12}\\ \sigma{21} & \sigma_{22}\end{matrix}\right]\ 
\Rightarrow对称张量写一半
\Rightarrow\ \sigma=\left[\begin{matrix}\sigma_{11} \\ \sigma_{22} \\ \sigma_{12}\end{matrix}\right]$$
</p>

$$\sigma_{ij}=\left[\begin{matrix}\sigma_{11} & \sigma_{12} & \sigma_{13}\\ \sigma_{21} & \sigma_{22} & \sigma_{23}\\
\sigma_{31} & \sigma_{32} & \sigma_{33}\\\end{matrix}\right]\ 
\Rightarrow对称张量写一半
\Rightarrow\ \sigma=\left[\begin{matrix}\sigma_{11} \\ \sigma_{22} \\ \sigma_{33} \\ \sigma_{23} \\ \sigma_{13} \\ \sigma_{12}\end{matrix}\right]$$

<h2 id="三大类变量和三大类方程"><a href="#三大类变量和三大类方程" class="headerlink" title="三大类变量和三大类方程"></a>三大类变量和三大类方程</h2><p>三大类变量：位移、应力、应变</p>
<p>三大类方程：几何方程、平衡方程、无理方程</p>
<h2 id="平面问题的平衡方程"><a href="#平面问题的平衡方程" class="headerlink" title="平面问题的平衡方程"></a>平面问题的平衡方程</h2><h3 id="力平衡方程"><a href="#力平衡方程" class="headerlink" title="力平衡方程"></a>力平衡方程</h3><ul>
<li>力平衡</li>
<li>力矩平衡</li>
</ul>

$$
\left\{
\begin{array}{lr}
\frac{\partial{\sigma_{xx}}}{\partial{x}}+\frac{\partial{\tau_{xy}}}{\partial{y}}+\bar{b_x}=0 & \\
\frac{\partial{\sigma_{xx}}}{\partial{x}}+\frac{\partial{\tau_{xy}}}{\partial{y}}+\bar{b_x}=0
\end{array}
\right.
\Rightarrow
指标形式：\sigma_{ij,j}+\bar{b_i}=0
$$

<h3 id="几何方程"><a href="#几何方程" class="headerlink" title="几何方程"></a>几何方程</h3>
$$\left\{\begin{array}{lr}\epsilon_{xx}=\frac{\partial{u}}{\partial{x}}&\\ \epsilon_{yy}=\frac{\partial{u}}{\partial{y}} &\\ \gamma_{xy} = \frac{\partial u}{\partial y}+\frac{\partial u}{\partial x}\end{array}\right.\Rightarrow 指标形式（约定\epsilon_{ij}=\frac12\gamma_{ij}\ (i\neq j)）：\epsilon_{ij}=\frac12(u_{i,j}+u_{j,i})$$

<h3 id="物理方程"><a href="#物理方程" class="headerlink" title="物理方程"></a>物理方程</h3>
$$
\left\{\begin{array}{lr}
\epsilon_{xx}=\frac1E(\sigma_{xx}-\mu\sigma_{yy}) \\
\epsilon_{yy}=\frac1E(\sigma_{yy}-\mu\sigma_{xx}) \\
\gamma_{xy}=\frac1G\tau_{xy}
\end{array}
\right.
\Rightarrow
指标形式: \epsilon_{ij}=C_{ijkl}\sigma_{kl}
$$

<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul>
<li>位移边界$S_u$</li>
<li>力边界$S_p$</li>
</ul>
<blockquote>
<p>无边界区域对应（力为0的边界）</p>
</blockquote>
<h1 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h1><h2 id="平面纯弯梁的描述"><a href="#平面纯弯梁的描述" class="headerlink" title="平面纯弯梁的描述"></a>平面纯弯梁的描述</h2><p>3D问题<br>
$$
\left\{\begin{array}{lr}
位移（3个）\\应力（9个）\\应变（9个）
\end{array}
\right.
\stackrel{}{\Rightarrow}
\left\{\begin{array}{lr}
位移（3个）\\应力（6个）\\应变（6个）
\end{array}
\right.
(三组剪应力应变互等)
$$
</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>维度</th>
<th>1D</th>
<th>2D</th>
<th>3D</th>
</tr>
</thead>
<tbody>
<tr>
<td>平衡方程</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>几何方程</td>
<td>1</td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>物理方程</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>边界条件（几何）</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>边界条件（外力）</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p>坐标变换<br>
$$
\left[\begin{matrix}x^{(2)} \\ y^{(2)}\end{matrix}\right]=
\left[\begin{matrix}cos(x^{(2)},x^{(2)}) & cos(x^{(2)},y^{(1)}) \\  cos(y^{(2)},x^{(1)}) & cos(y^{(2)},y^{(1)}))\end{matrix}\right]
\left[\begin{matrix}x^{(1)} \\ y^{(1)}\end{matrix}\right]
= \left[\begin{matrix}cos\alpha & sin\alpha \\  -sin\alpha & cos\alpha)\end{matrix}\right]
\left[\begin{matrix}x^{(1)} \\ y^{(1)}\end{matrix}\right]
$$
<br>$\alpha$为两坐标系转动夹角,T为转置矩阵$\left[\begin{matrix}cos\alpha & sin\alpha \\  -sin\alpha & cos\alpha)\end{matrix}\right]$</p>
<p>张量存在不变量，不随坐标系的变化而变化，这些变量是重要的分析对象<br>二阶张量$\sigma^{(2)}=T\sigma^{(1)}T^T$</p>
<h1 id="虚功原理和最小势能原理"><a href="#虚功原理和最小势能原理" class="headerlink" title="虚功原理和最小势能原理"></a>虚功原理和最小势能原理</h1><h2 id="弹性变形体力学方程的求解方法"><a href="#弹性变形体力学方程的求解方法" class="headerlink" title="弹性变形体力学方程的求解方法"></a>弹性变形体力学方程的求解方法</h2><ul>
<li><strong>直接求解</strong>：解析法、半解析、差分</li>
<li><strong>间接求解</strong><ul>
<li>加权残值法（伽辽金加权残值、残值最小二乘法）</li>
<li>虚功原理</li>
<li>最小势能原理</li>
<li>变分方法</li>
</ul>
</li>
</ul>
<blockquote>
<p>简介求解的关键是1.试函数的选择，2.试函数带入原方程求误差</p>
</blockquote>
<h3 id="伽辽金加权残值法"><a href="#伽辽金加权残值法" class="headerlink" title="伽辽金加权残值法"></a>伽辽金加权残值法</h3><p>试函数：将满足边界条件的试函数$\phi_i(x)$组合为新的试函数$\hat{v}(x)=c_1\phi_1(x)+…+c_n\phi_n(x)$,$c_i$为待定系数</p>
<p>伽辽金法的权值为试函数<br>残值: $\int<em>\Omega{w</em>{t<em>i}R(x,y,z)d\Omega}$<br>$w</em>{t_i}=\phi_i$</p>
<p>残值最小二乘法的权值为$w_{t_i}=1$</p>
<h2 id="如何降低试函数对高阶导数及边界条件的要求"><a href="#如何降低试函数对高阶导数及边界条件的要求" class="headerlink" title="如何降低试函数对高阶导数及边界条件的要求"></a>如何降低试函数对高阶导数及边界条件的要求</h2><p>将三大类变量（位移、应力、应变）代换为一类变量（位移）</p>
<p>弹性问题加权残值法的难点：</p>
<ul>
<li>试函数要满足所有边界条件 -&gt; 只满足位移边界</li>
<li>试函数最高阶导数较高（梁弯曲问题要求4阶导数存在，一般弹性问题要求2阶导数存在）-&gt; 虚功原理和最小势能原理可以将最高阶导数降低一半</li>
</ul>
<h2 id="虚功原理"><a href="#虚功原理" class="headerlink" title="虚功原理"></a>虚功原理</h2><p>虚功原理：虚功总和为0</p>
<script type="math/tex; mode=display">\delta W-\delta U =0（W外力虚功，U内力虚功）</script><p>截面惯性矩$I=\int{y^2dA}$</p>
<p>若试函数为$\hat{v}(x)=C_1sin(\frac{\pi x}{l})$，虚位移场为$\delta\hat{v}(x)=\delta C_1sin(\frac{\pi x}{l})$</p>
<p>最小势能原理：$min(U-W)$</p>
<h2 id="能量原理"><a href="#能量原理" class="headerlink" title="能量原理"></a>能量原理</h2><p>加权残值法的试函数满足位移边界条件和力边界条件，最终加权残值满足控制方程。</p>
<p>能量方法的试函数只满足位移边界条件，但可以证明<strong>其最终的求解结果也满足力边界条件和控制方程</strong></p>
<h1 id="有限元方法"><a href="#有限元方法" class="headerlink" title="有限元方法"></a>有限元方法</h1><h2 id="基于试函数的经典方法与有限元方法"><a href="#基于试函数的经典方法与有限元方法" class="headerlink" title="基于试函数的经典方法与有限元方法"></a>基于试函数的经典方法与有限元方法</h2><p>有限元方法的思路：几何→几何离散→基本构件→集成→几何</p>
<h2 id="离散方法"><a href="#离散方法" class="headerlink" title="离散方法"></a>离散方法</h2><ul>
<li>自然离散→规则桁架</li>
<li>逼近离散→连续体</li>
<li>混合离散</li>
</ul>
<h2 id="有限元方法的步骤"><a href="#有限元方法的步骤" class="headerlink" title="有限元方法的步骤"></a>有限元方法的步骤</h2><ol>
<li>几何离散</li>
<li>单元研究</li>
<li>单元继承</li>
<li>边界条件处理</li>
<li>计算支反力</li>
<li>计算其他物理量</li>
</ol>
<p>单元研究：</p>
<ul>
<li>节点<ul>
<li>节点基本变量：坐标、位移、力</li>
</ul>
</li>
<li>单元<ul>
<li>三大类变量描述：刚度方程→多项式从低阶到高阶，待定系数个数与节点自由度对应</li>
<li>位移场：$u(x)=Nq^{e}$</li>
<li>应变场：$\epsilon(x)=B(x)q^{e}$</li>
<li>应力场：$\sigma=DB(x)q^{e}$</li>
<li>应变能：$U=\frac12q^{e^T}K^eq^e$</li>
<li>外力功：$W=p^{e^T}q^e$</li>
</ul>
</li>
</ul>
<p><img src="2.png" alt=""></p>
<h2 id="形函数的计算"><a href="#形函数的计算" class="headerlink" title="形函数的计算"></a>形函数的计算</h2><p>单元节点的自由度为4<br>位移场函数$v(x)=a_0+a_1x+a_2x^2+a_3x^3$<br>单元节点条件<br>
$$
\left\{
\begin{array}{lr}
v(0)=v_1 & v^{'}(0)=\theta_1 \\
v(l)=v_2 & v^{'}(l)=\theta_2
\end{array}
\right.
$$
</p>
<p>$v(x)=N(\xi)q^e$</p>
<blockquote>
<p>分布力转换为节点处的等效载荷</p>
</blockquote>
<h1 id="常见平面单元"><a href="#常见平面单元" class="headerlink" title="常见平面单元"></a>常见平面单元</h1><h2 id="平面三节点单元"><a href="#平面三节点单元" class="headerlink" title="平面三节点单元"></a>平面三节点单元</h2><p>应变场为常数<br>应力场为常数<br>位移场为完全线性函数($u(x,y)=a_0+a_1x+a_2y$,$v(x,y)=b_0+b_1x+b_2y$)</p>
<p>基于整体坐标建立节点位移，没有坐标变换问题</p>
<p>对于应变梯度大的区域，加密或高阶单元</p>
<h2 id="平面四节点单元"><a href="#平面四节点单元" class="headerlink" title="平面四节点单元"></a>平面四节点单元</h2><p>位移场为完全线性+交叉项函数（$u(x,y)=a_0+a_1x+a_2y+a_3xy$）<br>应变场为不完全线性:<br>
$$
\epsilon = \left[\begin{matrix}a_1+a_3y\\ b_2+b_3x \\ a_2+b_1+a_3x+b_3y \end{matrix}\right]
$$
</p>
<p>应力场：$\sigma=D\epsilon$</p>
<h1 id="空间单元"><a href="#空间单元" class="headerlink" title="空间单元"></a>空间单元</h1><h2 id="空间四节点单元（与平面三节点单元类似）"><a href="#空间四节点单元（与平面三节点单元类似）" class="headerlink" title="空间四节点单元（与平面三节点单元类似）"></a>空间四节点单元（与平面三节点单元类似）</h2><p>应变场为常数<br>应力场为常数<br>没有坐标变换问题</p>
<h2 id="空间8节点正六面体单元与平面4节点单元类似"><a href="#空间8节点正六面体单元与平面4节点单元类似" class="headerlink" title="空间8节点正六面体单元与平面4节点单元类似"></a>空间8节点正六面体单元与平面4节点单元类似</h2><h2 id="参数单元"><a href="#参数单元" class="headerlink" title="参数单元"></a>参数单元</h2><p><strong>基准单元</strong>：基准坐标系；     <strong>物理单元</strong>：物理坐标系<br>需要进行几种映射：坐标函数映射、偏导数映射、面积（体积）映射</p>
<h2 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h2><p>亚参元和等参数单元保证收敛；超参数单元不保证收敛</p>
<blockquote>
<p><strong>亚参元</strong>：几何形状插值函数阶次&lt;位移插值函数阶次<br><strong>等参数单元</strong>：几何形状插值函数阶次=位移插值函数阶次</p>
</blockquote>
<h2 id="形函数和刚度矩阵的性质"><a href="#形函数和刚度矩阵的性质" class="headerlink" title="形函数和刚度矩阵的性质"></a>形函数和刚度矩阵的性质</h2><p><strong>形函数</strong></p>
<ul>
<li>$N_i$表示i节点位移为1，其他节点位移为0时的单元位移场函数</li>
<li>$\sum_{i=0}^{n}N_i(x)=1$表明其能描述刚体位移</li>
</ul>
<p><strong>刚度矩阵</strong></p>
<ul>
<li>对角元素$k_{ii}$表示要使i节点产生单位位移($u_i=1$)，其他节点位移为0时，需要在节点i施加的力</li>
<li>非对角元素$k_{ij}$表示要使j节点产生单位位移($u_j=1$)，而其他节点位移为0时，需要在节点i施加的力</li>
<li>单元刚度矩阵是对称的</li>
<li>单元刚度矩阵是半正定的</li>
<li>单元刚度矩阵奇异（行列式=0）</li>
</ul>
<p><strong>总体刚度矩阵</strong></p>
<ul>
<li>对称</li>
<li>奇异</li>
<li>半正定</li>
<li>稀疏</li>
<li>非零元素带状分布</li>
</ul>
<h2 id="边界条件的处理与支反力的计算"><a href="#边界条件的处理与支反力的计算" class="headerlink" title="边界条件的处理与支反力的计算"></a>边界条件的处理与支反力的计算</h2><ul>
<li>直接法</li>
<li>置一法（针对($\bar{q_r}=0$)）</li>
<li>乘大数法（针对($\bar{q_r}=\bar{u}$)）</li>
<li>罚函数法（大刚度的弹簧）</li>
</ul>
<h2 id="位移函数的构造与收敛性要求"><a href="#位移函数的构造与收敛性要求" class="headerlink" title="位移函数的构造与收敛性要求"></a>位移函数的构造与收敛性要求</h2><p>收敛性准则：</p>
<ul>
<li><strong>完备性要求</strong>（针对单元内部:常应变项与常位移项）。如果在势能泛函中所出现的位移函数的最高阶导数是m阶，则有限元解答收敛的条件之一是单元内位移场函数的试函数至少是m阶多项式。</li>
<li><strong>协调性要求</strong>。如果势能泛函中位移函数最高阶是m阶，则位移势函数在单元交界面上必须具有直至m-1阶连续倒数</li>
</ul>
<p>位移函数参数个数与节点自由度（DOF）相等。 -》 唯一性</p>
<h2 id="C0与C1单元"><a href="#C0与C1单元" class="headerlink" title="C0与C1单元"></a>C0与C1单元</h2><p><strong>C0单元</strong>：势能泛函中位移函数出现的最高阶导数是1阶，在单元交界面上具有0阶连续导数，只要求位移连续</p>
<p>一般杆单元，平面问题单元，空间问题单元都是C0单元。</p>
<p><strong>C1单元</strong>：势能泛函中位移函数出现的最高阶导数是2阶，在单元交界面上具有1阶连续导数</p>
<p>梁单元，板单元，壳单元都是C1单元。</p>
<h2 id="单元拼片实验"><a href="#单元拼片实验" class="headerlink" title="单元拼片实验"></a>单元拼片实验</h2><p>单元位移函数满足完备性要求-&gt;单元是完备的（容易满足）<br>单元位移函数满足协调性要求-&gt;单元是协调的（C1型单元不容易满足）<br>单元位移函数满足完整性和协调性要求-&gt;协调单元</p>
<p>非协调单元：某些情况下，可以放松对协调性的要求，只要单元通过拼片试验，解答仍收敛于正确解，这种单元称为非协调单元</p>
<p>近似解$|q_{appr}|&lt;|q_exact|$精确解</p>
<h2 id="控制误差和提高精度的h方法和p方法"><a href="#控制误差和提高精度的h方法和p方法" class="headerlink" title="控制误差和提高精度的h方法和p方法"></a>控制误差和提高精度的h方法和p方法</h2><p><strong>h方法</strong>（high density）加密单元。数值稳定性和可靠性好，但收敛较慢，效率低</p>
<p><strong>p方法</strong>（polynomial）增加单元基地函数阶次。收敛性优于h方法，但数值稳定性差。</p>
<p><strong>自适应方法</strong>：利用上一步计算结果修改有限元模型，计算量小，精度高。对给定自由度求最有玩咯</p>
<blockquote>
<p><strong>子结构与超级单元</strong><br>结构的重复性：几何空间上，采用子结构；计算时间上，采用超级单元</p>
</blockquote>
<h1 id="非线性分析"><a href="#非线性分析" class="headerlink" title="非线性分析"></a>非线性分析</h1><h2 id="结构振动的有限元分析"><a href="#结构振动的有限元分析" class="headerlink" title="结构振动的有限元分析"></a>结构振动的有限元分析</h2><p><strong>基本原理</strong>：变形体存在固有频率和振动模态</p>
<p><strong>三大类变量</strong>：位移$u_i(\xi,t)$、应变$\epsilon_{ij}(\xi,t)$、应力$\sigma_{ij}(\xi,t)$</p>
<p><strong>基本方程</strong>：<br><strong>平衡方程</strong>：由DAlembert原理$\sigma_{ij,j}(t)+\bar{b_i}(t)-\rho\ddot{u_i}(t)-v\dot{u_i}=0$</p>
<p><strong>几何方程</strong>：与普通分析一致</p>
<p><strong>物理方程</strong>：与普通分析一致</p>
<p><strong>边界条件</strong>：与普通分析一致</p>
<p><strong>初始条件</strong>：<br>$u_i(\xi,t=0)=u_i(\xi)$</p>
<p>$\dot{u_i}(\xi,t=0)=\dot{u_i}(\xi)$</p>
<p><strong>单元的节点位移矩阵</strong>：$q_t^e(t)=\left[\begin{array}{lr}u_1(t) &amp; v_1(t) &amp; w_1(t)&amp;… &amp; u_n(t) &amp; v_n(t) &amp; w_n(t)\end{array}\right]^T$</p>
<p><strong>位移插值函数</strong>：$u^e(\xi,t)=N(\xi)q_i^e(t)$</p>
<p>$\dot{u}^e(\xi,t)=N(\xi)\dot{q}_i^e(t)$</p>
<p>$\ddot{u}^e(\xi,t)=N(\xi)\ddot{q}_i^e(t)$</p>
<p><strong>方程</strong>：$M^e\ddot{q}_i^e(t)+C^e\dot{q}_i^e(t)+K^eq_i^e(t)=P_t^e(t)$</p>
<p>单元质量矩阵：$M^e=\int_\Omega\rho N^TNd\Omega$</p>
<p>单元阻尼矩阵：$C^e=\int_\Omega v N^TNd\Omega$</p>
<p>单元刚度矩阵：$K^e=\int_\Omega B^T DBd\Omega$</p>
<p>力矩阵：$P<em>t^e=\int</em>\Omega N^T\bar{b}d\Omega+\int_{S_p}N^T\bar{p}dA$</p>
<p>对于无阻尼(v=0)自由(p=0)振动:$M\ddot{q}+Kq=0$，这个方程的解的形式为$q_t=\hat{q}e^{iwt}$。带入到方程中得到：$(-w^2M\hat{q}+K\hat{q})e^{iwt}=0$，即$(K-w^2M)\hat{q}=0$。方程由非零解的条件为$|K-w^2M|=0$。</p>
<p><strong>质量矩阵</strong>：一致质量矩阵；集中质量矩阵（将一直质量矩阵行/列集中到对角线）</p>
<h2 id="非线性方程的求解"><a href="#非线性方程的求解" class="headerlink" title="非线性方程的求解"></a>非线性方程的求解</h2><ul>
<li>直接迭代</li>
<li>Newton-Raphson(NR)迭代。分步逼近，在每个载荷段内进行非线性方程的迭代，特点：在迭代中，非线性方程变为线性方程</li>
<li>改进的NR方法</li>
</ul>
<h1 id="传热问题"><a href="#传热问题" class="headerlink" title="传热问题"></a>传热问题</h1><h2 id="传热问题的控制方程"><a href="#传热问题的控制方程" class="headerlink" title="传热问题的控制方程"></a>传热问题的控制方程</h2><p>Fourier传热定律、能量守恒定律</p>
<h2 id="三类边界条件"><a href="#三类边界条件" class="headerlink" title="三类边界条件"></a>三类边界条件</h2><p>给定的温度分布（第一类）、给定热流密度（第二类）、给定对流换热系数（第三类）</p>
<h1 id="几个常见的问题"><a href="#几个常见的问题" class="headerlink" title="几个常见的问题"></a>几个常见的问题</h1><h2 id="线性分析与非线性分析"><a href="#线性分析与非线性分析" class="headerlink" title="线性分析与非线性分析"></a>线性分析与非线性分析</h2><p><strong>线性分析：</strong>若K为常数矩阵，则外载荷与系统响应之间为线性关系<br><strong>非线性：</strong>K变化</p>
<p><strong>非线性：</strong>材料非线性、几何非线性（大变形、大转动）、边界条件非线性（接触）</p>
<p><strong>求解方法：</strong></p>
<ul>
<li>隐式求解。将分析过程分为一系列增量步，在每个增量步迭代至合理解。</li>
<li>显式求解。显式地从上一个增量步推算动力学平衡方程</li>
</ul>
<h2 id="一阶-二阶-完全-减缩"><a href="#一阶-二阶-完全-减缩" class="headerlink" title="一阶/二阶 完全/减缩"></a>一阶/二阶 完全/减缩</h2><p><img src=3.png></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>线性单元</strong>仅在角点处布置节点，在各方向采用线性插值。</p>
<p><strong>二次单元</strong>不仅在节点处，在每边的中点也有节点，在各方向采用二次插值</p>
<p><strong>完全积分</strong>：当单元具有规则形状时，所用高斯积分点数目足以对单元刚度矩阵多项式进行精确积分。</p>
<p><strong>减缩积分</strong>：比完全积分每个方向少一个积分点（只有四边形和六面体单元才能使用减缩积分）。</p>
<h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><p><strong>剪力自锁</strong>：存在于所有的线性完全积分单元中</p>
<p>原因：线性单元的边无法弯曲，使得应变作用下产生剪切变形而无法弯曲变形，单元过于刚硬。</p>
<p>改进:使用二次单元</p>
<p><strong>沙漏</strong>：线性减缩积分单元由于沙漏问题，过于柔软</p>
<p>原因：在单元变形时，积分点处应力分量也可能为0，没有产生应变能，即这种弯曲是零能模式。这种零能模式会在网络中扩展。</p>
<p>二次减缩积分也存在沙漏，但在正常网格中不会扩展。</p>
<p><strong>体积锁死</strong>：本应产生体积变化，却未变化</p>
<p>条件：完全积分，材料几乎不可压缩（v=0.5）</p>
<p>改进：细化网格</p>
<blockquote>
<p><strong>注意事项</strong></p>
<ul>
<li>线性完全积分单元容易出现剪切自锁和体积自锁，一般不使用</li>
<li>如果存在应力集中，需要计算较精确的应力，建议使用二阶完全积分单元</li>
<li>二阶减缩积分单元既可以较精确的模拟应力，又可以较准确的模拟小变形，因而是应力/位移模拟的最佳选择</li>
<li>如需要模拟大变形或接触分析，采用线性减缩积分是最好的选择。但应细化网络来避免沙漏，在厚度方向应大于4个单元</li>
<li>静力结构分析使用二阶完全积分单元。非线性分析/接触分析使用线性减缩积分单元</li>
<li>只有确信载荷只会在模型中产生很小的弯曲时，才能使用线性完全积分单元</li>
<li>在受轴向和剪切载荷时，线性完全积分单元表现很好</li>
<li>线性减缩积分单元能很好地承受扭曲变形</li>
<li>受弯：二次单元优于线性单元；； 受扭：线性单元优于二次单元</li>
</ul>
</blockquote>
<p>完全各向异性材料：$C_{ij}$，21个独立分量<br>各向同性材料的刚度系数：<br>
$$
\left[
    \begin{matrix}
    C_{11} & C_{12} & C_{12} & 0 & 0 &0\\
    C_{12}  & C_{11} & C_{12} & 0 & 0 &0\\
    C_{12}  & C_{12} & C_{11} & 0 & 0 &0\\
    0      &      0 & 0 & \frac{C_{11}-C_{12}}2 & 0 &0\\
    0      &      0 & 0 &0 & \frac{C_{11}-C_{12}}2 & 0\\
    0      &      0 & 0 &0&0 & \frac{C_{11}-C_{12}}2\\
    \end{matrix}
\right]
$$
</p>
<h1 id="广义变分原理"><a href="#广义变分原理" class="headerlink" title="广义变分原理"></a>广义变分原理</h1><h2 id="约束变分原理"><a href="#约束变分原理" class="headerlink" title="约束变分原理"></a>约束变分原理</h2><h3 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h3><p>对于一个使泛函$\Pi(\textbf{u})$取驻值的问题，如果其场函数$\textbf{u}$需满足的附加条件为：</p>
<script type="math/tex; mode=display">\{C(\textbf{u})\}=\{0\}\ (在域\Omega内)</script><p>则将其引用泛函$\Pi(\textbf{u})$得到一修正的泛函：<br>
$$\Pi^{*}(\textbf{u,}\lambda)=\Pi(\textbf{u})+\int_{\Omega}\{\lambda\}^T\{C(\textbf{u})\}d\Omega$$
<br>$\lambda$为一组独立的坐标函数，称为拉格朗日乘子。</p>
<p>拉格朗日乘子会导致待定系数的增加，从而增加了计算量。</p>
<h3 id="罚函数法"><a href="#罚函数法" class="headerlink" title="罚函数法"></a>罚函数法</h3><p>罚函数法与拉格朗日的区别是引入附加条件的形式不同，拉格朗日乘子法引入是附加条件的原型，即${C(\textbf{u})}={0}$，而罚函数法则是附加条件乘积的形式。<br>
$$\{C(\textbf{u})\}^T\{C(\textbf{u})\}=\{C_1^2(\textbf{u})\}+\{C_2^2(\textbf{u})\}+...+\{C_n^2(\textbf{u})\}$$
</p>
<p>当附加条件得到满足时，上式为0，否则它大于0.显然上式的变分在满足:$\delta({C(\textbf{u})}^T{C(\textbf{u})})=0$的条件下是最小的。因此，罚函数法利用一个充分大的系数将附加条件以乘积的形式引入泛函。<br>
$$\Pi^{**}(\textbf{u})=\Pi(\textbf{u})+\alpha\int_\Omega\{C(\textbf{u})\}^T\{C(\textbf{u})\}d\Omega$$
<br>$\alpha$被称为罚函数，若泛函本身是极小值问题，则$\alpha$取正数。<br>罚函数选择很重要，如何选择合适的$\alpha$不易。</p>
<h1 id="非线性问题的求解方法"><a href="#非线性问题的求解方法" class="headerlink" title="非线性问题的求解方法"></a>非线性问题的求解方法</h1><h2 id="直接迭代法"><a href="#直接迭代法" class="headerlink" title="直接迭代法"></a>直接迭代法</h2><p>每次迭代需要重新计算刚度矩阵并求逆，计算量较大。（割线刚度法）</p>
<p>收敛性：对刚度退化的系统，直接迭代法收敛。对刚度硬化的系统，直接迭代法不收敛。<br><img src="c1.jpg" alt=""></p>
<h2 id="牛顿-拉夫森方法"><a href="#牛顿-拉夫森方法" class="headerlink" title="牛顿-拉夫森方法"></a>牛顿-拉夫森方法</h2><p>每次迭代需要重新计算系数矩阵并求逆，计算量较大。（切线刚度法）<br><img src="c2.jpg" alt=""></p>
<h2 id="修正的牛顿-拉夫森方法"><a href="#修正的牛顿-拉夫森方法" class="headerlink" title="修正的牛顿-拉夫森方法"></a>修正的牛顿-拉夫森方法</h2><p>迭代过程不需要重新计算系数矩阵，只计算一次。<br><img src="c3.jpg" alt=""></p>
<h2 id="增量法"><a href="#增量法" class="headerlink" title="增量法"></a>增量法</h2><p><img src="c4.jpg" alt=""></p>
<h1 id="求解线性方程组的迭代法"><a href="#求解线性方程组的迭代法" class="headerlink" title="求解线性方程组的迭代法"></a>求解线性方程组的迭代法</h1><h2 id="雅可比迭代法"><a href="#雅可比迭代法" class="headerlink" title="雅可比迭代法"></a>雅可比迭代法</h2><p>每次迭代全部采用上次的迭代结果</p>
<h2 id="高斯-赛尔德迭代法"><a href="#高斯-赛尔德迭代法" class="headerlink" title="高斯-赛尔德迭代法"></a>高斯-赛尔德迭代法</h2><h2 id="超松弛迭代法"><a href="#超松弛迭代法" class="headerlink" title="超松弛迭代法"></a>超松弛迭代法</h2><p>改善了高斯-赛尔德迭代法的收敛性</p>
<h1 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h1><h2 id="一维单元"><a href="#一维单元" class="headerlink" title="一维单元"></a>一维单元</h2><h3 id="拉格朗日单元"><a href="#拉格朗日单元" class="headerlink" title="拉格朗日单元"></a>拉格朗日单元</h3><p>在n个节点上的函数值连续</p>
<h3 id="Hermite单元"><a href="#Hermite单元" class="headerlink" title="Hermite单元"></a>Hermite单元</h3><p>在节点上的函数值和导数都连续</p>
<h3 id="高阶Hermite单元"><a href="#高阶Hermite单元" class="headerlink" title="高阶Hermite单元"></a>高阶Hermite单元</h3><p>在节点上的函数值和高阶导数连续。</p>
<h1 id="求解算法中显式和隐式的区别"><a href="#求解算法中显式和隐式的区别" class="headerlink" title="求解算法中显式和隐式的区别"></a>求解算法中显式和隐式的区别</h1><p>隐式和显式有限元的最大区别在于是否迭代，所有的物理量是否在同一时刻获得。</p>
<p>采用隐式迭代求解平衡方程（位移、速度、加速度），不管是否采用隐式与显式的方式（前向、后向欧拉算法）求解本构方程（应力、应变），都叫做隐式有限元。</p>
<p>对于本构方程的求解，通常分为前向和后向欧拉算法。对于后向欧拉算法求解弹塑性问题，所有的物理量（包括等效塑性应变增量、N+1迭代步的应变和应力以及相关依赖于solution的状态变量）均是同时求解获得，因为涉及到多个物理量，而通常情况下他们是相互依赖、相互成为函数，所以必须通过牛顿迭代同时求解几个方程（如采用试应力方程、屈服函数径向返回算法（对于各向异性，也叫回映算法，最近点的投射算法）联合求解等效塑性应变增量）。对于前向欧拉，直接由N时刻的应力和应变求出N+1时刻的应力和应变，无需迭代。</p>
<blockquote>
<p><a href="https://blog.csdn.net/wu_nan_nan/article/details/53173302" target="_blank" rel="noopener">https://blog.csdn.net/wu_nan_nan/article/details/53173302</a></p>
<p>前向欧拉（显式欧拉）：条件稳定.后向欧拉（隐式欧拉）：无条件稳定。</p>
<p>实际应用中，隐式欧拉需要求解隐式方程，通常也是使用逼近的方法（例如，Newton-Raphson）求解，因此实际的隐式欧拉方法并不是无条件稳定的。</p>
</blockquote>
<p>对于平衡方程的求解，通常分为隐式和显式有限元算法。对于隐式有限元算法，由应力平衡方程+边界条件变分之后获得的刚度方程KU=F，隐式求解必须引入雅可比矩阵（二次收敛、只影响计算速率、不影响数值精度；K又称为雅可比），其是实时更新的，是N+1时刻的应力、应变以及状态变量（如损伤内变量）的函数，隐式求解是很robust的，确保了计算精度，但是不足之处在于计算非常expensive，每次迭代都要计算K的逆矩阵，也容易产生数值收敛性问题，目前解决的方法有弧长法、粘性阻尼法等，个人认为粘性阻尼法效果最好。 </p>
<p>对于显示算法，采用时间积分，用t+1时刻的积分点应力、应变，获得t+1时刻的节点位移，无需迭代求解，也不需要雅可比矩阵（应力对应变偏导数）；如果硬是要有，连续雅可比，基于本构模型而不是刚度方程推导近似的连续雅可比。对于显示算法，单元高斯积分点应力、应变的求解可用前向或者后向欧拉方法，然后通过时间积分求取节点位移。本质上，平衡方程中位移的迭代求解与本构方程中的应力、应变求解没有关联，这点很容易造成误解，很多时候将前、后欧拉算法视为显式和隐式的区别，大大错误。通常应用较广的显示算法纽马克法、威尔逊-sita法，其中改变纽马克法中的两个参数，可以实现隐式与显式求解，其中alpha=0.5和beta=0是中心差分法(二阶精度)。目前一个大的误区认为只有显示算法可以求解动力学问题，隐式只能求解准静态问题（如低速冲击），alpha=0.5和beta=0.25就是隐式，所有的物理量在t+1时刻同时求解，通常ABAQUS软件中所说的隐式动力学求解采用了斯坦福大学Hilber、HUGHES院士（现在德克萨斯大学奥斯丁分校）和加州大学伯克利分校Taylor院士提出的无条件稳定隐式差分算法，可以求解低速动力学问题，缺点是不适合含阻尼的求解、计算效率不高；alpha=0.5和beta=0时的纽马克法更适合求解动力学问题，主要原因在于比隐式求解计算效率更高，不足之处在于其是条件稳定，时间增量过大位移解容易震荡，根本原因是差分算法的条件稳定导致的，时间增量必须非常小（其值越大，一方面不稳定、另一方面计算误差也更大），其依赖于波速、弹性模量和最小单元网格尺寸，这是显式算法计算最耗时的地方。相对于隐式算法，显式算法的功能更强大，通常计算依赖于率的变形和应力，也可以求解稳态问题，如alpha=0.5和beta=0时，对于刚度方程中引入阻尼矩阵后，叫做动态松弛法，可以解决静力学问题的一些稳态问题（如重力、预应力引起的初始应力）。此外，一些准静态的剪切自锁问题，本质上有解，但是用牛顿法求解失效，中心差分引入质量矩阵后，可以获得正常的解。需要注意的是，时间积分算法通常采用Lumped集中对角质量矩阵而不是一致质量矩阵，以提高计算效率。总体来说，由于计算效率的问题，隐式时间积分算法ABAQUS-Standard特别适合于低速冲击问题；对于高速冲击问题，由于存在不连续非线性接触的动响应过程，隐式算法解决不好，使用显式时间算法ABAQUS-Explicit更好。此外，对于瞬态和稳态热传导问题，半离散的抛物线方程，中心差分法可以较好获得温度分布。</p>
<p> 对于依赖于率的粘塑性问题（对于本质上的粘性材料），与弹塑性材料的根本区别在于，一般来说是一致性条件不满足（排除弹塑性材料在高温下的软化问题，对于这种问题，屈服条件也可以满足），即屈服条件不满足，N+1时刻的物理量不用回映到N+1时刻的屈服面上，粘塑性模型成为过应力模型，显示和隐式算法都可以求解。对于依赖于率的本构模型，其可解决模拟高速冲击、爆炸、弹道射击问题时存在的动态应变局部化问题（对于动态问题，平衡方程丧失双曲线特性；对于静态问题，平衡方程失去椭圆性），解决网格尺寸效应，其实质上是引入了适当的阻尼迟滞效应。需要注意的是，对于大变形(又称为有限变形)问题，Cauchy应力率和速度梯度（包括客观和对称的扭曲张量率D、不客观和反对称的spin旋转张量W两个部分）均是不客观的，为解释刚体旋转（如纯剪切变形就包含刚体旋转），在共旋坐标系下面求解真实应力和应变，应力和应变积分求解的时候应首先求解客观性的Jaumann应力率(相对于真实应力，空间坐标系)，相对于Second Piola-Kirchhoff应力是Truesdell率（材料坐标系）。ABAQUS软件对于大变形问题已经做了旋转。</p>
<p>   对于一些耦合场问题，由于计算量非常大，同时要求解太多物理量，如热-流-固耦合，要求解位移、压力、温度，采用纯隐式算法或显式算法基本不太获得收敛或准确的解，这时候可采用混合的隐式与显式有限元格式mixed implicit-explicit partitoning方法，将刚度矩阵和阻尼矩阵分成两个部分，在同一区域采取不同算法，提高计算效率和精度、稳定性和收敛性。</p>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>有限元</tag>
      </tags>
  </entry>
  <entry>
    <title>疲劳强度理论</title>
    <url>/2020/08/14/%E7%96%B2%E5%8A%B3%E5%BC%BA%E5%BA%A6%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>《疲劳强度理论》尚德广———-读书笔记<br><a id="more"></a></p>
<h2 id="随机载荷的处理方法"><a href="#随机载荷的处理方法" class="headerlink" title="随机载荷的处理方法"></a>随机载荷的处理方法</h2><ul>
<li>循环计数法<ul>
<li>把连续载荷-时间历程离散呈一系列峰值和谷值后，再把载荷分成一定级数，然后计算峰值或振程等发生的频次、概率密度函数、概率分布函数等。</li>
</ul>
</li>
<li>功率谱法<ul>
<li>利用傅里叶变换将随即在和分解为无限多个具有各种频率的间歇变化之和，得到功率谱密度函数的方法。</li>
</ul>
</li>
</ul>
<h2 id="基于应力的疲劳分析理论"><a href="#基于应力的疲劳分析理论" class="headerlink" title="基于应力的疲劳分析理论"></a>基于应力的疲劳分析理论</h2><p>广泛应用于低应力作用下的工程零部件的强度和寿命设计中。</p>
<p>对于低周疲劳，由于所施加的载荷存在明显的塑性部分，在这种情况下使用基于应变的疲劳理论更为合适。</p>
<ul>
<li>应力-寿命（S-N）曲线</li>
<li><p>概率-应力-寿命（P-S-N）曲线</p>
</li>
<li><p>疲劳极限线图（将不同R（应力比）下的疲劳极限绘制在一张图上）</p>
<ul>
<li>以应力幅对平均应力，即$\sigma_a$和$\sigma_m$为坐标系得到的疲劳极限线图称为Haigh图。</li>
<li>以最大应力、最小应力、平均应力为坐标系得到的疲劳极限线图称为Smith图。</li>
</ul>
</li>
<li>疲劳极限方程<ul>
<li>Gerber抛物线方程、Goodman方程、Soderberg方程</li>
</ul>
</li>
</ul>
<h4 id="S-N曲线的使用"><a href="#S-N曲线的使用" class="headerlink" title="S-N曲线的使用"></a>S-N曲线的使用</h4><ul>
<li>由于机械零件存在应力集中，尺寸，几何形状，表面状态，残余应力，等的影响，S-N曲线修正后才能进行疲劳强度设计或寿命预测。<ul>
<li><strong>尺寸</strong>：尺寸越大疲劳极限越低；钢的强度越高，尺寸对疲劳强度影响越大；尺寸对疲劳强度的影响随着应力分布的不均匀的增大而增大。</li>
<li><strong>应力集中</strong></li>
<li><strong>表面状态</strong></li>
<li><strong>载荷</strong><ul>
<li>载荷类型：对于疲劳极限：弯曲&gt;拉压&gt;扭转</li>
<li>加载频率：多高的加载频率会使得样品升温</li>
<li>载荷变化</li>
</ul>
</li>
<li>温度</li>
</ul>
</li>
</ul>
<h4 id="基于应力的疲劳强度设计方法"><a href="#基于应力的疲劳强度设计方法" class="headerlink" title="基于应力的疲劳强度设计方法"></a>基于应力的疲劳强度设计方法</h4><h5 id="疲劳损伤累计理论"><a href="#疲劳损伤累计理论" class="headerlink" title="疲劳损伤累计理论"></a>疲劳损伤累计理论</h5><p>当材料或零件承受高于疲劳极限的应力时，每一个循环都会使材料产生一定的损伤，而且损伤能够累积，当累积到临界值时，材料将发生破坏，这就是疲劳损伤累积理论。</p>
<p>分为三类：</p>
<ul>
<li>线性累积损伤理论。如Miner定理</li>
<li>非线性累积损伤理论。如Macro-Starkey理论和Corten-Dolen理论</li>
<li>其他的各类累计损伤理论。多为经验半经验公式。</li>
</ul>
<h5 id="安全系数。"><a href="#安全系数。" class="headerlink" title="安全系数。"></a>安全系数。</h5><h3 id="基于应变的疲劳分析理论"><a href="#基于应变的疲劳分析理论" class="headerlink" title="基于应变的疲劳分析理论"></a>基于应变的疲劳分析理论</h3><h4 id="材料的应变寿命曲线"><a href="#材料的应变寿命曲线" class="headerlink" title="材料的应变寿命曲线"></a>材料的应变寿命曲线</h4><h3 id="多轴疲劳"><a href="#多轴疲劳" class="headerlink" title="多轴疲劳"></a>多轴疲劳</h3><h4 id="多轴循环应力应变关系"><a href="#多轴循环应力应变关系" class="headerlink" title="多轴循环应力应变关系"></a>多轴循环应力应变关系</h4>]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>疲劳</tag>
        <tag>强度</tag>
      </tags>
  </entry>
  <entry>
    <title>经典的卷积神经网络</title>
    <url>/2020/02/20/%E7%BB%8F%E5%85%B8%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>csdn链接：<a href="https://blog.csdn.net/weixin_44791964/article/details/102824592" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/details/102824592</a><br><a id="more"></a></p>
<h1 id="经典神经网络的改进点"><a href="#经典神经网络的改进点" class="headerlink" title="经典神经网络的改进点"></a>经典神经网络的改进点</h1><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>改进点</th>
</tr>
</thead>
<tbody>
<tr>
<td>VGG16</td>
<td>1、使用非常多的3*3卷积串联，利用小卷积代替大卷积，该操作使得其拥有更少的参数量，同时会比单独一个卷积层拥有更多的非线性变换。2、探索了卷积神经网络的深度与其性能之间的关系，成功构建16层网络（还有VGG19的19层网络）。</td>
</tr>
<tr>
<td>ResNet50</td>
<td>1、使用残差网络，其可以解决由于网络深度加深而产生的学习效率变低与准确率无法有效提升的问题。2、采用bottleneck design结构，在3x3网络结构前利用1x1卷积降维，在3x3网络结构后，利用1x1卷积升维，相比直接使用3x3网络卷积效果更好，参数更少。</td>
</tr>
<tr>
<td>InceptionV3</td>
<td>1、Inception系列通用的改进点是使用不同大小的卷积核，使得存在不同大小的感受野，最后实现拼接达到不同尺度特征的融合。2、利用1x7的卷积和7x1的卷积代替7x7的卷积，这样可以只使用约（1x7 + 7x1) / (7x7) = 28.6%的计算开销；利用1x3的卷积和3x1的卷积代替3x3的卷积，这样可以只使用约（1x3 + 3x1) / (3x3) = 67%的计算开销。</td>
</tr>
<tr>
<td>Xception</td>
<td>1、开始采用残差网络，其可以解决由于网络深度加深而产生的学习效率变低与准确率无法有效提升的问题。2、采用SeparableConv2D层，先进行1x1操作然后再进行滑动3x3操作，中间为了保证数据不被破坏，没有添加relu层。</td>
</tr>
<tr>
<td>MobileNet</td>
<td>1、是一种轻量级的深层神经网络，为一定设备设计。 2、采用depthwise separable convolution结构，3x3卷积核厚度只有一层，然后在输入张量上一层一层地滑动，所以一个卷积核就对应了一个输出通道，当卷积完成后，在利用1x1的卷积调整厚度，实现参数减少。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="1、VGG16"><a href="#1、VGG16" class="headerlink" title="1、VGG16"></a>1、VGG16</h1><p><img src="1.png" alt=""></p>
<p>1、一张原始图片被resize到(224,224,3)。<br>2、conv1两次[3,3]卷积网络，输出的特征层为64，输出为(224,224,64)，再2X2最大池化，输出net为(112,112,64)。<br>3、conv2两次[3,3]卷积网络，输出的特征层为128，输出net为(112,112,128)，再2X2最大池化，输出net为(56,56,128)。<br>4、conv3三次[3,3]卷积网络，输出的特征层为256，输出net为(56,56,256)，再2X2最大池化，输出net为(28,28,256)。<br>5、conv3三次[3,3]卷积网络，输出的特征层为256，输出net为(28,28,512)，再2X2最大池化，输出net为(14,14,512)。<br>6、conv3三次[3,3]卷积网络，输出的特征层为256，输出net为(14,14,512)，再2X2最大池化，输出net为(7,7,512)。<br>7、利用卷积的方式模拟全连接层，效果等同，输出net为(1,1,4096)。共进行两次。<br>8、利用卷积的方式模拟全连接层，效果等同，输出net为(1,1,1000)。<br>最后输出的就是每个类的预测。</p>
<p>具体实现代码可以看我的博文神经网络学习小记录16——VGG16模型的复现及其详解（包含如何预测）</p>
<h1 id="2、ResNet50"><a href="#2、ResNet50" class="headerlink" title="2、ResNet50"></a>2、ResNet50</h1><p>ResNet50最大的特点是使用了残差网络。<br>残差网络的特点是将靠前若干层的某一层数据输出直接跳过多层引入到后面数据层的输入部分。<br>意味着后面的特征层的内容会有一部分由其前面的某一层线性贡献。<br>其结构如下：</p>
<p><img src="2.png" alt=""></p>
<p>ResNet50有两个基本的块，分别名为Conv Block和Identity Block，其中Conv Block输入和输出的维度是不一样的，所以不能连续串联，它的作用是改变网络的维度；Identity Block输入维度和输出维度相同，可以串联，用于加深网络的。<br>Conv Block的结构如下：</p>
<p><img src="3.png" alt=""></p>
<p>Identity Block的结构如下：</p>
<p><img src="4.png" alt=""></p>
<p>这两个都是残差网络结构。<br>总的网络结构如下：</p>
<p><img src="5.png" alt=""></p>
<p>conv中存在<strong>瓶颈结构</strong>，(1,1)的卷积降维，（3，3）卷积，（1，1）升维</p>
<p>具体实现代码可以看我的博文神经网络学习小记录20——ResNet50模型的复现详解</p>
<h1 id="3、InceptionV3"><a href="#3、InceptionV3" class="headerlink" title="3、InceptionV3"></a>3、InceptionV3</h1><p>Inception系列的网络的特点是采用不同大小的卷积核，使得存在不同大小的感受野，最后实现拼接达到不同尺度特征的融合。</p>
<p>对于InceptionV3而言，其网络中存在着如下的结构。</p>
<p><img src="6.png" alt=""></p>
<p>这个结构使用不同大小的卷积核对输入进行卷积（这个结构主要在代码中的block1使用）。</p>
<p>还存在着这样的结构，利用1x7的卷积和7x1的卷积代替7x7的卷积，这样可以只使用约（1x7 + 7x1) / (7x7) = 28.6%的计算开销；利用1x3的卷积和3x1的卷积代替3x3的卷积，这样可以只使用约（1x3 + 3x1) / (3x3) = 67%的计算开销。</p>
<p><img src="7.png" alt=""></p>
<p>下图利用1x7的卷积和7x1的卷积代替7x7的卷积（这个结构主要在代码中的block2使用）。</p>
<p>下图利用1x3的卷积和3x1的卷积代替3x3的卷积（这个结构主要在代码中的block3使用）。</p>
<p>具体实现代码可以看我的博文神经网络学习小记录21——InceptionV3模型的复现详解</p>
<h1 id="4、Xception"><a href="#4、Xception" class="headerlink" title="4、Xception"></a>4、Xception</h1><p>其可以被叫做极致的Inception。<br>其特点是采用了残差网络和depthwise separable convolution。</p>
<p>depthwise separable convolution就是对于一个卷积点而言：<br><strong>假设有一个3×3大小的卷积层，其输入通道为16、输出通道为32。具体为，32个3×3大小的卷积核会遍历16个通道中的每个数据，最后可得到所需的32个输出通道，所需参数为16×32×3×3=4608个。</strong></p>
<p><strong>应用深度可分离卷积，用16个3×3大小的卷积核分别遍历16通道的数据，得到了16个特征图谱。在融合操作之前，接着用32个1×1大小的卷积核遍历这16个特征图谱，所需参数为16×3×3+16×32×1×1=656个。</strong><br><strong>可以看出来depthwise separable convolution可以减少模型的参数。</strong></p>
<p>通俗地理解就是卷积核厚度只有一层，然后在输入张量上一层一层地滑动，所以一个卷积核就对应了一个输出通道，当卷积完成后，在利用1x1的卷积调整厚度。</p>
<p>不过Xception模型中的depthwise separable convolution和普通的不太一样，普通的depthwise separable convolution是先进行3x3操作再进行1x1操作（就好像mobileNet中的一样），而Xception模型中则是先进行1x1操作然后再进行3x3操作，中间为了保证数据不被破坏，没有添加relu层，而mobileNet添加了relu层。在建立模型的时候，可以使用Keras中的SeparableConv2D层建立相应的功能。</p>
<p><img src="8.png" alt=""></p>
<p>对于Xception模型而言，其一共可以分为3个flow，分别是Entry flow、Middle flow、Exit flow；分为14个block，其中Entry flow中有4个、Middle flow中有8个、Exit flow中有2个。具体结构如下：</p>
<p><img src="9.png" alt=""></p>
<p>其内部主要结构就是残差卷积网络搭配SeparableConv2D层实现一个个block，在Xception模型中，常见的两个block的结构如下。<br>这个主要在Entry flow和Exit flow中：</p>
<p><img src="10.png" alt=""></p>
<p>这个主要在Middle flow中：</p>
<p><img src="11.png" alt=""></p>
<p>具体实现代码可以看我的博文神经网络学习小记录22——Xception模型的复现详解</p>
<h1 id="5、MobileNet"><a href="#5、MobileNet" class="headerlink" title="5、MobileNet"></a>5、MobileNet</h1><p>MobileNet模型是Google针对手机等嵌入式设备提出的一种轻量级的深层神经网络，其使用的核心思想便是depthwise separable convolution。</p>
<p>对于一个卷积点而言：<br>假设有一个3×3大小的卷积层，其输入通道为16、输出通道为32。具体为，32个3×3大小的卷积核会遍历16个通道中的每个数据，最后可得到所需的32个输出通道，所需参数为16×32×3×3=4608个。</p>
<p>应用深度可分离卷积，用16个3×3大小的卷积核分别遍历16通道的数据，得到了16个特征图谱。在融合操作之前，接着用32个1×1大小的卷积核遍历这16个特征图谱，所需参数为16×3×3+16×32×1×1=656个。<br>可以看出来depthwise separable convolution可以减少模型的参数。</p>
<p>如下这张图就是depthwise separable convolution的结构</p>
<p><img src="12.png" alt=""></p>
<p>在建立模型的时候，可以使用Keras中的DepthwiseConv2D层实现深度可分离卷积，然后再利用1x1卷积调整channels数。</p>
<p>通俗地理解就是3x3的卷积核厚度只有一层，然后在输入张量上一层一层地滑动，每一次卷积完生成一个输出通道，当卷积完成后，在利用1x1的卷积调整厚度。</p>
<p>如下就是MobileNet的结构，其中Conv dw就是分层卷积，在其之后都会接一个1x1的卷积进行通道处理，</p>
<p><img src="13.png" alt=""></p>
<p>具体实现代码可以看我的博文神经网络学习小记录23——MobileNet模型的复现详解</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法笔记</title>
    <url>/2019/12/31/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="感知机算法（P40）"><a href="#感知机算法（P40）" class="headerlink" title="感知机算法（P40）"></a>感知机算法（P40）</h1><a id="more"></a>
<p>算法的收敛性由Novikoff定理证明（P42）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 元素乘法：np.multiply(a,b)</span></span><br><span class="line"><span class="comment"># 矩阵乘法：np.dot(a,b) 或 np.matmul(a,b) 或 a.dot(b)</span></span><br><span class="line"><span class="comment"># 唯独注意：*，在 np.array 中重载为元素乘法，在 np.matrix 中重载为矩阵乘法!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 感知机（原始形式）</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">X = [np.matrix([<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]).T,</span><br><span class="line">     np.matrix([<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]).T,</span><br><span class="line">     np.matrix([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]).T]</span><br><span class="line">Y = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>]</span><br><span class="line">w = np.zeros(<span class="number">2</span>)</span><br><span class="line">w = np.r_[w,<span class="number">0</span>].reshape((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">l_r = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign_result</span><span class="params">(ww,xx,yy)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>  np.sum(w.T*x)*yy</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> zip(X,Y):</span><br><span class="line">        result = sign_result(w,x,y)</span><br><span class="line">        <span class="keyword">if</span> result&lt;=<span class="number">0</span>:</span><br><span class="line">            w = w + l_r * y * x</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(w)</span><br></pre></td></tr></table></figure>
<h1 id="朴素贝叶斯法"><a href="#朴素贝叶斯法" class="headerlink" title="朴素贝叶斯法"></a>朴素贝叶斯法</h1><p>先验概率：结果事件发生的概率<br>通过学习先验概率和条件概率分布，预测后验概率。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/linhaifeng/articles/5937962.html#_label4" target="_blank" rel="noopener">http://www.cnblogs.com/linhaifeng/articles/5937962.html#_label4</a><br><a id="more"></a></p>
<h1 id="一-操作系统基础"><a href="#一-操作系统基础" class="headerlink" title="一.操作系统基础"></a>一.操作系统基础</h1><p>  操作系统:(Operating System，简称OS)是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。</p>
<p>注：计算机(硬件)－&gt;os－&gt;应用软件</p>
<h1 id="二-网络通信原理"><a href="#二-网络通信原理" class="headerlink" title="二.网络通信原理"></a>二.网络通信原理</h1><h2 id="2-1-互联网的本质就是一系列的网络协议"><a href="#2-1-互联网的本质就是一系列的网络协议" class="headerlink" title="2.1 互联网的本质就是一系列的网络协议"></a>2.1 互联网的本质就是一系列的网络协议</h2><p>一台硬设有了操作系统，然后装上软件你就可以正常使用了，然而你也只能自己使用</p>
<p>像这样，每个人都拥有一台自己的机器，然而彼此孤立</p>
<p><img src="image/1036857-20161008115246442-867569611.png" alt="img"></p>
<p>如何能大家一起玩耍</p>
<p><img src="image/1036857-20161008115341598-934171433.png" alt="img"></p>
<p>然而internet为何物？</p>
<p>其实两台计算机之间通信与两个人打电话之间通信的原理是一样的（中国有很多地区，不同的地区有不同的方言，为了全中国人都可以听懂，大家统一讲普通话）</p>
<p><img src="image/1036857-20161008131010254-430615122.png" alt="img"></p>
<p>普通话属于中国国内人与人之间通信的标准，那如果是两个国家的人交流呢？</p>
<p><img src="image/1036857-20161008131301051-196580728.png" alt="img"></p>
<p>问题是，你不可能要求一个人／计算机掌握全世界的语言／标准，于是有了世界统一的通信标准：英语</p>
<p><img src="image/1036857-20161008131410957-1579746437.png" alt="img"></p>
<p>结论：英语成为世界上所有人通信的统一标准，如果把计算机看成分布于世界各地的人，那么连接两台计算机之间的internet实际上就是</p>
<p>一系列统一的标准，这些标准称之为互联网协议，互联网的本质就是一系列的协议，总称为‘互联网协议’（Internet Protocol Suite).</p>
<p>互联网协议的功能：定义计算机如何接入internet，以及接入internet的计算机通信的标准。</p>
<h2 id="2-2-osi七层协议"><a href="#2-2-osi七层协议" class="headerlink" title="2.2 osi七层协议"></a>2.2 osi七层协议</h2><p>互联网协议按照功能不同分为osi七层或tcp/ip五层或tcp/ip四层</p>
<p><img src="image/1036857-20161008145544426-736439132.png" alt="img"></p>
<p>每层运行常见物理设备</p>
<p><img src="image/1036857-20161008144925254-1398507493.png" alt="img"></p>
<h2 id="2-3-tcp-ip五层模型讲解"><a href="#2-3-tcp-ip五层模型讲解" class="headerlink" title="2.3 tcp/ip五层模型讲解"></a>2.3 tcp/ip五层模型讲解</h2><p>我们将应用层，表示层，会话层并作应用层，从tcp／ip五层协议的角度来阐述每层的由来与功能，搞清楚了每层的主要协议</p>
<p>就理解了整个互联网通信的原理。</p>
<p>首先，用户感知到的只是最上面一层应用层，自上而下每层都依赖于下一层，所以我们从最下一层开始切入，比较好理解</p>
<p>每层都运行特定的协议，越往上越靠近用户，越往下越靠近硬件</p>
<h3 id="2-3-1-物理层"><a href="#2-3-1-物理层" class="headerlink" title="2.3.1 物理层"></a>2.3.1 物理层</h3><p>物理层由来：上面提到，孤立的计算机之间要想一起玩，就必须接入internet，言外之意就是计算机之间必须完成组网</p>
<p><img src="image/1036857-20161008154500754-704720294.png" alt="img"></p>
<p>物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0</p>
<h3 id="2-3-2-数据链路层"><a href="#2-3-2-数据链路层" class="headerlink" title="2.3.2 数据链路层"></a>2.3.2 数据链路层</h3><p>数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思</p>
<p>数据链路层的功能：定义了电信号的分组方式</p>
<p><strong><em>以太网协议：</em></strong></p>
<p>早期的时候各个公司都有自己的分组方式，后来形成了统一的标准，即以太网协议ethernet</p>
<p>ethernet规定</p>
<ul>
<li>一组电信号构成一个数据包，叫做‘帧’</li>
<li>每一数据帧分成：报头head和数据data两部分</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>head</th>
<th>data</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>head包含：(固定18个字节)</p>
<ul>
<li>发送者／源地址，6个字节</li>
<li>接收者／目标地址，6个字节</li>
<li>数据类型，6个字节</li>
</ul>
<p>data包含：(最短46字节，最长1500字节)</p>
<ul>
<li>数据包的具体内容</li>
</ul>
<p>head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送</p>
<p><strong><em>mac地址：</em></strong></p>
<p>head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址</p>
<p>mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p>
<p><img src="image/1036857-20161008164852129-1597186542.png" alt="img"></p>
<p><strong>广播：</strong></p>
<p>有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址）</p>
<p>ethernet采用最原始的方式，广播的方式进行通信，即计算机通信基本靠吼</p>
<p><img src="image/1036857-20161008171118317-164674895.png" alt="img"></p>
<h3 id="2-3-3-网络层"><a href="#2-3-3-网络层" class="headerlink" title="2.3.3 网络层"></a>2.3.3 网络层</h3><p>网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机就可以彼此通信了，问题是世界范围的互联网是由</p>
<p>一个个彼此隔离的小的局域网组成的，那么如果所有的通信都采用以太网的广播方式，那么一台机器发送的包全世界都会收到，</p>
<p>这就不仅仅是效率低的问题了，这会是一种灾难</p>
<p><img src="image/1036857-20161008172732957-102296982.png" alt="img"></p>
<p>上图结论：必须找出一种方法来区分哪些计算机属于同一广播域，哪些不是，如果是就采用广播的方式发送，如果不是，</p>
<p>就采用路由的方式（向不同广播域／子网分发数据包），mac地址是无法区分的，它只跟厂商有关</p>
<p>网络层功能：引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址</p>
<p><strong><em>IP协议：</em></strong></p>
<ul>
<li>规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示</li>
<li>范围0.0.0.0-255.255.255.255</li>
<li>一个ip地址通常写成四段十进制数，例：172.16.10.1</li>
</ul>
<p><strong>ip地址分成两部分</strong></p>
<ul>
<li>网络部分：标识子网</li>
<li>主机部分：标识主机</li>
</ul>
<p>注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网</p>
<p>例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网</p>
<p><strong><em>子网掩码</em></strong></p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，</p>
<p>172.16.10.1：10101100.00010000.00001010.000000001</p>
<p>255255.255.255.0:11111111.11111111.11111111.00000000</p>
<p>AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p>
<p>172.16.10.2：10101100.00010000.00001010.000000010</p>
<p>255255.255.255.0:11111111.11111111.11111111.00000000</p>
<p>AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p>
<p>结果都是172.16.10.0，因此它们在同一个子网络。</p>
<p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p>
<p><strong><em>ip数据包</em></strong></p>
<p>ip数据包也分为head和data部分，无须为ip包定义单独的栏位，直接放入以太网包的data部分</p>
<p>head：长度为20到60字节</p>
<p>data：最长为65,515字节。</p>
<p>而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>以太网头</th>
<th>ip 头</th>
<th>ip数据</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p> <strong><em>ARP协议</em></strong></p>
<p>arp协议由来：计算机通信基本靠吼，即广播的方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送，在谈及以太网协议时候，我门了解到</p>
<p>通信是基于mac的广播方式实现，计算机在发包时，获取自身的mac是容易的，如何获取目标主机的mac，就需要通过arp协议</p>
<p>arp协议功能：广播的方式发送数据包，获取目标主机的mac地址</p>
<p>协议工作方式：每台主机ip都是已知的</p>
<p>例如：主机172.16.10.10/24访问172.16.10.11/24</p>
<p>一：首先通过ip地址和子网掩码区分出自己所处的子网</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>场景</th>
<th>数据包地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一子网</td>
<td>目标主机mac，目标主机ip</td>
</tr>
<tr>
<td>不同子网</td>
<td>网关mac，目标主机ip</td>
</tr>
</tbody>
</table>
</div>
<p>二：分析172.16.10.10/24与172.16.10.11/24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.1,通过arp获取的是网关的mac)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>源mac</th>
<th>目标mac</th>
<th>源ip</th>
<th>目标ip</th>
<th>数据部分</th>
</tr>
</thead>
<tbody>
<tr>
<td>发送端主机</td>
<td>发送端mac</td>
<td>FF:FF:FF:FF:FF:FF</td>
<td>172.16.10.10/24</td>
<td>172.16.10.11/24</td>
<td>数据</td>
</tr>
</tbody>
</table>
</div>
<p>三：这个包会以广播的方式在发送端所处的自网内传输，所有主机接收后拆开包，发现目标ip为自己的，就响应，返回自己的mac</p>
<h3 id="2-3-4-传输层"><a href="#2-3-4-传输层" class="headerlink" title="2.3.4 传输层"></a>2.3.4 传输层</h3><p>传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序，</p>
<p>那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。</p>
<p>传输层功能：建立端口到端口的通信</p>
<p>补充：端口范围0-65535，0-1023为系统占用端口</p>
<p>tcp协议：</p>
<p>可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>以太网头</th>
<th>ip 头</th>
<th>tcp头</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>udp协议：</p>
<p>不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>以太网头</th>
<th>ip头</th>
<th>udp头</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>tcp报文</p>
<p><img src="image/1036857-20161008185553973-1895926477.png" alt="img"></p>
<p>tcp三次握手和四次挥手</p>
<p><img src="image/1036857-20161008185648160-191189690.png" alt="img"></p>
<p>发送端接受到接收端的ack响应后才会清空发送端内核态的缓存。</p>
<h3 id="TCP协议与UDP协议的区别"><a href="#TCP协议与UDP协议的区别" class="headerlink" title="TCP协议与UDP协议的区别"></a><strong>TCP协议与UDP协议的区别</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先咱们弄清楚，TCP协议和UCP协议与TCP&#x2F;IP协议的联系，很多人犯糊涂了，</span><br><span class="line">一直都是说TCP协议与UDP协议的区别，我觉得这是没有从本质上弄清楚网络通信！</span><br></pre></td></tr></table></figure>
<p>TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。</p>
<p>TCP/IP协议集包括应用层,传输层，网络层，网络访问层。</p>
<h4 id="其中应用层包括"><a href="#其中应用层包括" class="headerlink" title="其中应用层包括:"></a>其中应用层包括:</h4><p>1、超文本传输协议（HTTP）:万维网的基本协议；<br>2、文件传输（TFTP简单文件传输协议）；<br>3、远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；<br>4、网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；<br>5、域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。</p>
<h4 id="其次网络层包括"><a href="#其次网络层包括" class="headerlink" title="其次网络层包括:"></a>其次网络层包括:</h4><p>1、Internet协议（IP）；<br>2、Internet控制信息协议（ICMP）；<br>3、地址解析协议（ARP）；<br>4、反向地址解析协议（RARP）。</p>
<h4 id="最后说网络访问层"><a href="#最后说网络访问层" class="headerlink" title="最后说网络访问层:"></a>最后说网络访问层:</h4><p>网络访问层又称作主机到网络层（host-to-network），网络访问层的功能包括IP地址与物理地址硬件的映射， 以及将IP封装成帧.基于不同硬件类型的网络接口，网络访问层定义了和物理介质的连接. 当然我这里说得不够完善，TCP/IP协议本来就是一门学问，每一个分支都是一个很复杂的流程， 但我相信每位学习软件开发的同学都有必要去仔细了解一番。</p>
<h2 id="下面着重讲解一下TCP协议和UDP协议的区别"><a href="#下面着重讲解一下TCP协议和UDP协议的区别" class="headerlink" title="下面着重讲解一下TCP协议和UDP协议的区别"></a><strong>下面着重讲解一下TCP协议和UDP协议的区别</strong></h2><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂， 只简单的描述下这三次对话的简单过程：</p>
<p>1）主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；</p>
<p>2）主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话；</p>
<p>3）主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。</p>
<p>三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。</p>
<h4 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a><strong>TCP三次握手过程</strong></h4><p>第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。</p>
<p>第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我</p>
<p>第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：”我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。</p>
<h4 id="3次握手的特点"><a href="#3次握手的特点" class="headerlink" title="3次握手的特点"></a><strong>3次握手的特点</strong></h4><p>没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。</p>
<p>、</p>
<h4 id="TCP建立连接要进行3次握手，而断开连接要进行4次"><a href="#TCP建立连接要进行3次握手，而断开连接要进行4次" class="headerlink" title="TCP建立连接要进行3次握手，而断开连接要进行4次"></a><strong>TCP建立连接要进行3次握手，而断开连接要进行4次</strong></h4><p>第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；</p>
<p>第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；</p>
<p>第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；</p>
<p>第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。</p>
<p>由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。</p>
<p>2、SYN 同步序列号，TCP建立连接时将这个位置1。</p>
<p>3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。</p>
<h4 id="TCP的包头结构："><a href="#TCP的包头结构：" class="headerlink" title="TCP的包头结构："></a>TCP的包头结构：</h4><p>源端口 16位；</p>
<p>目标端口 16位；</p>
<p>序列号 32位；</p>
<p>回应序号 32位；</p>
<p>TCP头长度 4位；</p>
<p>reserved 6位；</p>
<p>控制代码 6位；</p>
<p>窗口大小 16位；</p>
<p>偏移量 16位；</p>
<p>校验和 16位；</p>
<p>选项 32位(可选)；</p>
<p>这样我们得出了TCP包头的最小长度，为20字节。</p>
<h4 id="UDP（User-Data-Protocol，用户数据报协议）"><a href="#UDP（User-Data-Protocol，用户数据报协议）" class="headerlink" title="UDP（User Data Protocol，用户数据报协议）"></a><strong>UDP（User Data Protocol，用户数据报协议）</strong></h4><p>1、UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p>
<p>2、 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。</p>
<p>3、UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</p>
<p>4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。</p>
<p>5、UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。</p>
<p>6、UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。</p>
<p>我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</p>
<p><strong>ping命令</strong>是用来探测主机到主机之间是否可通信，如果不能<strong>ping</strong>到某台主机，表明不能和这台主机建立连接。<strong>ping命令</strong>是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机。</p>
<p>ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。</p>
<h4 id="UDP的包头结构："><a href="#UDP的包头结构：" class="headerlink" title="UDP的包头结构："></a><strong>UDP的包头结构：</strong></h4><p>源端口 16位</p>
<p>目的端口 16位</p>
<p>长度 16位</p>
<p>校验和 16位</p>
<h4 id="小结TCP与UDP的区别："><a href="#小结TCP与UDP的区别：" class="headerlink" title="小结TCP与UDP的区别："></a><strong>小结TCP与UDP的区别：</strong></h4><p>1、基于连接与无连接；</p>
<p>2、对系统资源的要求（TCP较多，UDP少）；</p>
<p>3、UDP程序结构较简单；</p>
<p>4、流模式与数据报模式 ；</p>
<p>5、TCP保证数据正确性，UDP可能丢包；</p>
<p>6、TCP保证数据顺序，UDP不保证。</p>
<h3 id="2-3-5-应用层"><a href="#2-3-5-应用层" class="headerlink" title="2.3.5 应用层"></a>2.3.5 应用层</h3><p>应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 </p>
<p>应用层功能：规定应用程序的数据格式。</p>
<p>例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p> <img src="image/1036857-20161008190023098-992049015.png" alt="img"></p>
<h3 id="2-3-6-socket"><a href="#2-3-6-socket" class="headerlink" title="2.3.6 socket"></a>2.3.6 socket</h3><p>我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。</p>
<p>能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p>
<p><img src="image/1036857-20161013091647484-1707663286.png" alt="img"></p>
<p>socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p>
<h1 id="三-网络通信实现"><a href="#三-网络通信实现" class="headerlink" title="三.网络通信实现"></a>三.网络通信实现</h1><p>想实现网络通信，每台主机需具备四要素</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
<p>获取这四要素分两种方式</p>
<p>1.静态获取</p>
<p>即手动配置</p>
<p>2.动态获取</p>
<p>通过dhcp获取</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>以太网头</th>
<th>ip头</th>
<th>udp头</th>
<th>dhcp数据包</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p>
<p>（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p>
<p>（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p>
<p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p>
<p> 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p>
<p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数</p>
<h1 id="四-网络通信流程"><a href="#四-网络通信流程" class="headerlink" title="四.网络通信流程"></a>四.网络通信流程</h1><p>1.本机获取</p>
<ul>
<li>本机的IP地址：192.168.1.100</li>
<li>子网掩码：255.255.255.0</li>
<li>网关的IP地址：192.168.1.1</li>
<li>DNS的IP地址：8.8.8.8</li>
</ul>
<p>2.打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。</p>
<p>3.dns协议(基于udp协议)</p>
<p><img src="image/1036857-20161008191742160-1888861499.png" alt="img"></p>
<p>13台根dns：</p>
<p>A.root-servers.net198.41.0.4美国<br>B.root-servers.net192.228.79.201美国（另支持<a href="https://www.baidu.com/s?wd=IPv6&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0" target="_blank" rel="noopener">IPv6</a>）<br>C.root-servers.net192.33.4.12法国<br>D.root-servers.net128.8.10.90美国<br>E.root-servers.net192.203.230.10美国<br>F.root-servers.net192.5.5.241美国（另支持<a href="https://www.baidu.com/s?wd=IPv6&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0" target="_blank" rel="noopener">IPv6</a>）<br>G.root-servers.net192.112.36.4美国<br>H.root-servers.net128.63.2.53美国（另支持<a href="https://www.baidu.com/s?wd=IPv6&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0" target="_blank" rel="noopener">IPv6</a>）<br>I.root-servers.net192.36.148.17瑞典<br>J.root-servers.net192.58.128.30美国<br>K.root-servers.net193.0.14.129英国（另支持IPv6）<br>L.root-servers.net198.32.64.12美国<br>M.root-servers.net202.12.27.33日本（另支持IPv6） </p>
<p>域名定义：<a href="http://jingyan.baidu.com/article/1974b289a649daf4b1f774cb.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/1974b289a649daf4b1f774cb.html</a></p>
<p>顶级域名：以.com,.net,.org,.cn等等属于国际顶级域名，根据目前的国际互联网域名体系，国际顶级域名分为两类：类别顶级域名(gTLD)和地理顶级域名(ccTLD)两种。类别顶级域名是　　　　　　　　            以”COM”、”NET”、”ORG”、”BIZ”、”INFO”等结尾的域名，均由国外公司负责管理。地理顶级域名是以国家或地区代码为结尾的域名，如”CN”代表中国，”UK”代表英国。地理顶级域名一般由各个国家或地区负责管理。</p>
<p>二级域名：二级域名是以顶级域名为基础的地理域名，比喻中国的二级域有，.com.cn,.net.cn,.org.cn,.gd.cn等.子域名是其父域名的子域名，比喻父域名是abc.com,子域名就是www.abc.com或者<em>.abc.com.<br>一般来说，二级域名是域名的一条记录，比如alidiedie.com是一个域名，www.alidiedie.com是其中比较常用的记录，一般默认是用这个，但是类似</em>.alidiedie.com的域名全部称作是alidiedie.com的二级</p>
<p>4.HTTP部分的内容，类似于下面这样：</p>
<blockquote>
<p>GET / HTTP/1.1<br>Host: www.google.com<br>Connection: keep-alive<br>User-Agent: Mozilla/5.0 (Windows NT 6.1) ……<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Encoding: gzip,deflate,sdch<br>Accept-Language: zh-CN,zh;q=0.8<br>Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3<br>Cookie: … …</p>
</blockquote>
<p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p>
<p>5 TCP协议</p>
<p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p>
<p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p>
<p>6 IP协议</p>
<p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p>
<p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p>
<p>7 以太网协议 </p>
<p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p>
<p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。 </p>
<p><img src="image/640.jpg" alt="img"></p>
<p>8 服务器端响应</p>
<p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p>
<p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p>
<p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>训练深层神经网络</title>
    <url>/2020/02/04/%E8%AE%AD%E7%BB%83%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="梯度消失-爆炸问题"><a href="#梯度消失-爆炸问题" class="headerlink" title="梯度消失/爆炸问题"></a>梯度消失/爆炸问题</h1><a id="more"></a>
<p>Sigmoid函数，当输入变大（负或正）时，函数饱和在 0 或 1，导数非常接近 0。因此，当反向传播开始时， 它几乎没有梯度通过网络传播回来，而且由于反向传播通过顶层向下传递，所以存在的小梯度不断地被稀释，因此较低层确实没有任何东西可用。<br>Glorot 和 Bengio 在他们的论文中提出了一种显著缓解这个问题的方法。 我们需要信号在两个方向上正确地流动：在进行预测时是正向的，在反向传播梯度时是反向的。 我们不希望信号消失，也不希望它爆炸并饱和。 为了使信号正确流动，作者认为，我们需要每层输出的方差等于其输入的方差。<br>Xavier初始化:<br>默认情况下，<code>dense()</code>函数使用 Xavier 初始化（具有统一的分布）。可以<code>variance_scaling_initializer()</code>函数来将其更改为 He 初始化。</p>
<h1 id="非饱和激活函数"><a href="#非饱和激活函数" class="headerlink" title="非饱和激活函数"></a>非饱和激活函数</h1><p>ELU &gt; leaky ReLU(及其变体) &gt; ReLU &gt; tanh &gt; sigmoid<br>如果您关心运行时性能，那么您可能喜欢 leaky ReLU超过ELU。 如果你不想调整另一个超参数，你可以使用前面提到的默认的<code>α</code>值（leaky ReLU 为 0.01，ELU 为 1）。 如果您有充足的时间和计算能力，您可以使用交叉验证来评估其他激活函数，特别是如果您的神经网络过拟合，则为RReLU; 如果您拥有庞大的训练数据集，则为 PReLU。</p>
<h1 id="批量标准化"><a href="#批量标准化" class="headerlink" title="批量标准化"></a>批量标准化</h1><p><code>batch_norm()</code><br>标准化：均值为0方差为1</p>
<h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><p>动量优化，Nesterov 加速梯度，AdaGrad，RMSProp，Adam 优化<br>总是应该使用<code>Adam_optimization</code></p>
<h1 id="正则化避免过拟合"><a href="#正则化避免过拟合" class="headerlink" title="正则化避免过拟合"></a>正则化避免过拟合</h1><h1 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h1><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><img src="t-11-2.png" alt=""></p>
<p>这个默认配置可能需要调整：</p>
<ul>
<li>如果你找不到一个好的学习率（收敛速度太慢，所以你增加了训练速度，现在收敛速度很快，但是网络的准确性不是最理想的），那么你可以尝试添加一个学习率调整，如指数衰减。</li>
<li>如果你的训练集太小，你可以实现数据增强。</li>
<li>如果你需要一个稀疏的模型，你可以添加 l1 正则化混合（并可以选择在训练后将微小的权重归零）。 如果您需要更稀疏的模型，您可以尝试使用 FTRL 而不是 Adam 优化以及 l1 正则化。</li>
<li>如果在运行时需要快速模型，则可能需要删除批量标准化，并可能用 leakyReLU 替换 ELU 激活函数。 有一个稀疏的模型也将有所帮助。</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>语义分割</title>
    <url>/2020/02/20/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h1><a id="more"></a>
<p>就是先对图片进行特征提取，然后进行decoder或者说是上采样后对每个像素点进行分类，判断每个像素点属于哪一个类别。</p>
<h2 id="Segnet模型"><a href="#Segnet模型" class="headerlink" title="Segnet模型"></a>Segnet模型</h2><p>Segnet模型是一个比较基础的语义分割模型，其结构比较简单，在说其结构之前，我们先讲一下convolutional Encoder-Decoder的结构。<br>其主要结构与自编码（Autoencoder）类似，通过编码解码复原图片上每一个点所属的类别。<br>下图主要是说明利用卷积层编码与解码的过程。<br><img src="1.png" alt=""></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>语义分割</tag>
      </tags>
  </entry>
  <entry>
    <title>调参建议</title>
    <url>/2020/02/26/%E8%B0%83%E5%8F%82%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>caffe及其他算法中常见参数调整建议，参数包括学习速率，正则化参数，批处理样本数量<br><a id="more"></a></p>
<h1 id="学习速率"><a href="#学习速率" class="headerlink" title="学习速率"></a>学习速率</h1><ol>
<li>运用梯度下降算法进行优化时，权重的更新规则中，在梯度项前会乘以一个系数，这个系数就叫学习速率η；</li>
<li>可以先把学习速率设置为0.01，然后观察training cost的走向，如果cost在减小，那可以逐步地调大学习速率；如果cost在增大，那就得减小学习速率，反复几次大概确定学习速率的合适值。<br>3.为什么是training cost而不是validation accuracy？<br>《Neural networks and deep learning》一书中有这样一段说明，大致意思是，（1）学习速率只影响寻求最优解的过程，而不像正则化参数和批处理的样本数量那样对最后的分类准确率造成影响，而这可以通过training cost来观察逼近局部最优解的过程中，step是不是大了；（2）训练前期，如果validation accuracy上升，那么training cost会一直减小，所以使用哪种标准判断是否要调整学习速率是没有关系的，这只是作者个人喜好；</li>
</ol>
<h1 id="正则化系数"><a href="#正则化系数" class="headerlink" title="正则化系数"></a>正则化系数</h1><p>正则项系数初始值也没有一个比较好的准则。建议一开始将正则项系数λ设置为0，先确定一个比较好的learning rate。然后固定该learning rate，给λ一个值（比如1.0），然后根据validation accuracy，将λ增大或者减小。</p>
<h1 id="批处理样本数量"><a href="#批处理样本数量" class="headerlink" title="批处理样本数量"></a>批处理样本数量</h1><p><a href="https://www.zhihu.com/question/61607442" target="_blank" rel="noopener">https://www.zhihu.com/question/61607442</a><br>当采用mini-batch时，一个batch里的所有样本被放在一个矩阵里，利用线性代数库来加速梯度的计算，这是工程实现中的一个优化方法。<br>batch越大，可以充分利用矩阵、线性代数库来进行计算的加速，batch越小，则加速效果可能越不明显。而batch越大，权重的更新就会不那么频繁，导致优化过程太漫长。所以mini-batch size需要根据数据集规模和设备计算能力去选。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
  </entry>
  <entry>
    <title>长短记忆神经网络</title>
    <url>/2020/02/17/%E9%95%BF%E7%9F%AD%E8%AE%B0%E5%BF%86%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>理解LSTM：<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">原文链接</a> <a href="https://www.jianshu.com/p/95d5c461924c" target="_blank" rel="noopener">中文链接</a><br><a id="more"></a></p>
<h1 id="循环神经网络（RNN）"><a href="#循环神经网络（RNN）" class="headerlink" title="循环神经网络（RNN）"></a>循环神经网络（RNN）</h1><p>循环神经网络通过将信息循环操作，保证信息持续存在。</p>
<h1 id="长依赖存在的问题"><a href="#长依赖存在的问题" class="headerlink" title="长依赖存在的问题"></a>长依赖存在的问题</h1><p>存在两个问题：</p>
<ul>
<li>预测”the cloud in the sky”中的sky，只需要短距离的信息。</li>
<li>预测”I grew up in France… I speak fluent French.”中的french就需要长距离的信息。</li>
</ul>
<p>理论上RNNs是能够处理这种“长依赖”问题的。通过调参来解决这种问题。但是在实践过程中RNNs无法学习到这种特征。Hochreiter (1991) [German] 和Bengio, et al. (1994)深入研究过为什么RNNs没法学习到这种特征。</p>
<h1 id="LSTM网络"><a href="#LSTM网络" class="headerlink" title="LSTM网络"></a>LSTM网络</h1><p>在标准的RNN中，该重复模块将具有非常简单的结构，例如单个tanh层。标准的RNN网络如下图所示<br><img src="LSTM3-SimpleRNN.png" alt=""><br>LSTMs也具有这种链式结构，但是它的重复单元不同于标准RNN网络里的单元只有一个网络层，它的内部有四个网络层。LSTMs的结构如下图所示。<br><img src="LSTM3-chain.png" alt=""><br>图中黄色类似于CNN里的激活函数操作，粉色圆圈表示点操作，单箭头表示数据流向，箭头合并表示向量的合并（concat）操作，箭头分叉表示向量的拷贝操作.</p>
<h1 id="LSTMs核心思想"><a href="#LSTMs核心思想" class="headerlink" title="LSTMs核心思想"></a>LSTMs核心思想</h1><p>LSTMs的核心是细胞状态，用贯穿细胞的水平线表示。<br>细胞状态像传送带一样。它贯穿整个细胞却只有很少的分支，这样能保证信息不变的流过整个RNNs。<br>LSTM网络能通过一种被称为门的结构对细胞状态进行删除或者添加信息。<br>门能够有选择性的决定让哪些信息通过。其实门的结构很简单，就是一个sigmoid层和一个点乘操作的组合。</p>
<h1 id="keras"><a href="#keras" class="headerlink" title="keras"></a>keras</h1><p>将LSTM层的数据整形为(number_of_sequences, number_of_steps,features)。<br>即：（样本个数，时间步，特征个数）<br>对每一个样本，需要有number_of_steps个时间步的样本，每个时间步都要满足特征个数。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>RNN</tag>
        <tag>LSTM</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>高分子材料强度及破坏行为</title>
    <url>/2020/08/14/%E9%AB%98%E5%88%86%E5%AD%90%E6%9D%90%E6%96%99%E5%BC%BA%E5%BA%A6%E5%8F%8A%E7%A0%B4%E5%9D%8F%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<p>《高分子材料强度及破坏行为》 傅政  —读书笔记</p>
<a id="more"></a>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="高分子材料的破坏特征"><a href="#高分子材料的破坏特征" class="headerlink" title="高分子材料的破坏特征"></a>高分子材料的破坏特征</h2><h3 id="破坏过程是宏观与微观相结合的多层次过程"><a href="#破坏过程是宏观与微观相结合的多层次过程" class="headerlink" title="破坏过程是宏观与微观相结合的多层次过程"></a>破坏过程是宏观与微观相结合的多层次过程</h3><p><b>微观损伤</b>($10^{-10}m$)</p>
<p>分子链末端的凝聚体、数根没有缠结分子链间的空穴、缠结的分子链、分子链束沿应力方向取向的部分等。</p>
<p><b>细观损伤</b>($10^{-6}m$)</p>
<ul>
<li>由微观损伤发展与汇合成的空隙、微裂纹。</li>
<li>多相材料中的异质界面损伤。</li>
<li>加工成型过程中由于工艺、机械、温度、湿度或各种物理化学作用形成的银纹、瑕疵、微孔、杂质和其他缺陷等。</li>
</ul>
<h3 id="破坏过程具有松弛特征，对时间（速度）、温度由强烈的依赖性。"><a href="#破坏过程具有松弛特征，对时间（速度）、温度由强烈的依赖性。" class="headerlink" title="破坏过程具有松弛特征，对时间（速度）、温度由强烈的依赖性。"></a>破坏过程具有松弛特征，对时间（速度）、温度由强烈的依赖性。</h3><h3 id="破坏过程是逐渐发展的、不可逆的耗能过程"><a href="#破坏过程是逐渐发展的、不可逆的耗能过程" class="headerlink" title="破坏过程是逐渐发展的、不可逆的耗能过程"></a>破坏过程是逐渐发展的、不可逆的耗能过程</h3><h3 id="破坏过程伴随物理化学现象"><a href="#破坏过程伴随物理化学现象" class="headerlink" title="破坏过程伴随物理化学现象"></a>破坏过程伴随物理化学现象</h3><ul>
<li><p><b>电子激励现象</b>。高分子材料在力、热、声、光的能量作用下，可以产生电场或磁场。如：在外力作用下，成后复合的高分子主链化学键具有亲电子的能力，在破坏过程中发生电子迁移运动而产生受激电子。</p>
</li>
<li><p><b>力化学反应</b>。 高分子材料在破坏过程中，由于化学键的断裂而产生的自由基和离子等活性中心，在空气、热、光等环境中将导致裂解或结构化反应。特别是在动态破坏过程中，比如橡胶的疲劳过程等。</p>
</li>
<li><p><b>银纹化</b>。 在较高的应变下，许多高聚物会由于“空化”而发生变形，形变区域呈现白色，称为应力白化（内部银纹化）。</p>
</li>
</ul>
<h1 id="高分子材料的应力-应变行为"><a href="#高分子材料的应力-应变行为" class="headerlink" title="高分子材料的应力-应变行为"></a>高分子材料的应力-应变行为</h1><h2 id="高分子材料的力学状态"><a href="#高分子材料的力学状态" class="headerlink" title="高分子材料的力学状态"></a>高分子材料的力学状态</h2><p>高分子材料的力学状态实际上是分子运动的宏观表现。</p>
<p>非晶态高聚物在不同的温度下呈现出不同的力学状态，玻璃态、橡胶态、黏流态。<br><img src="非晶态高聚物模量-温度曲线.jpg" alt=""></p>
<ul>
<li><b>玻璃态</b>：只有较小的运动单元（侧基、短支链等）可以运动。</li>
<li><b>橡胶态</b>：链段运动被激发。拉伸时，分子链从卷曲的线团构象变为伸展构象；外力去除时，分子链通过链段运动恢复到原来的卷曲构象，宏观表现为弹性回缩。（高弹性）</li>
<li><b>黏流态</b>：整个分子链运动，宏观表现为不可逆的黏性流动。</li>
</ul>
<p><img src="结晶高聚物模量-温度曲线.jpg" alt=""></p>
<p>处于玻璃态、橡胶态、结晶态的高分子材料可以视为弹性固体材料，可以利用固体力学的基本理论进行分析。</p>
<h2 id="屈服和银纹化"><a href="#屈服和银纹化" class="headerlink" title="屈服和银纹化"></a>屈服和银纹化</h2><p>对塑性材料，其使用极限是屈服强度。</p>
<p>高分子材料在载荷作用下会产生微开裂，但这种微开裂并不是真正的裂纹，其内部由高度取向的高聚物纤维束和空穴组成，并且有一定的稳定性，称为银纹化现象。</p>
<p>屈服和银纹化是材料破坏的前奏。</p>
<h3 id="屈服"><a href="#屈服" class="headerlink" title="屈服"></a>屈服</h3><p>高分子材料一般使用真应力-表观应变描述其屈服行为。（由于其屈服后变形很大。）</p>
<p>应变硬化：分子链取向引起模量和拉伸强度提高；对结晶高聚物可能是因为应变诱发再结晶。</p>
<p><b>屈服点的确定</b></p>
<ul>
<li>显而易见的屈服点</li>
<li>$\sigma_{0.2}$</li>
<li>Considere作图法（p25）</li>
</ul>
<h1 id="高分子材料的强度理论"><a href="#高分子材料的强度理论" class="headerlink" title="高分子材料的强度理论"></a>高分子材料的强度理论</h1><h2 id="影响高分子材料强度的因素"><a href="#影响高分子材料强度的因素" class="headerlink" title="影响高分子材料强度的因素"></a>影响高分子材料强度的因素</h2><blockquote>
<p>交联：通过化学反应使分子间的共价键相连接，形成网络结构，从而使材料的强度增加。<br>支化：高分子材料的支链</p>
</blockquote>
<ul>
<li>化学结构<ul>
<li>主链结构</li>
<li>取代基</li>
<li>支化和交联</li>
</ul>
</li>
<li>分子量及其分布</li>
<li>结晶和取向</li>
<li>温度和形变速率</li>
<li>填料和增塑剂</li>
<li>应力集中物</li>
<li>环境因素</li>
</ul>
<h1 id="高分子材料的断裂基础"><a href="#高分子材料的断裂基础" class="headerlink" title="高分子材料的断裂基础"></a>高分子材料的断裂基础</h1><p>断裂力学研究裂纹扩展的两种方法：应力法和能量法。</p>
<p>裂纹类型：张开型、滑开型、撕开型</p>
<h2 id="线弹性断裂"><a href="#线弹性断裂" class="headerlink" title="线弹性断裂"></a>线弹性断裂</h2><p>适用于应力-应变遵循胡克定律的断裂行为。如果高分子材料的裂纹尖端塑性区很小，且不改变整体材料的线弹性行为，也可以用线弹性断裂理论。</p>
<p>对一个确定的裂纹，裂纹尖端的应力场与应力场强度因子有关（$K_I=\sigma\sqrt{\pi a}y$）</p>
<p>裂纹开始扩展时的应力场强度因子为断裂韧性$K_{IC}$</p>
<h2 id="非线性断裂及表征"><a href="#非线性断裂及表征" class="headerlink" title="非线性断裂及表征"></a>非线性断裂及表征</h2><p>适合延性塑料、橡胶和热塑性弹性体等材料的应力-应变曲线是非线性行为。</p>
<h3 id="J积分"><a href="#J积分" class="headerlink" title="J积分"></a>J积分</h3><p>应变能积分。</p>
<h1 id="冲击破坏和塑性增韧"><a href="#冲击破坏和塑性增韧" class="headerlink" title="冲击破坏和塑性增韧"></a>冲击破坏和塑性增韧</h1><p><b>韧性</b>：材料破坏前吸收外加能量的能力。</p>
<h1 id="纤维增强高聚物的强度与破坏"><a href="#纤维增强高聚物的强度与破坏" class="headerlink" title="纤维增强高聚物的强度与破坏"></a>纤维增强高聚物的强度与破坏</h1><h2 id="纤维增强高聚物的结构与损伤特征"><a href="#纤维增强高聚物的结构与损伤特征" class="headerlink" title="纤维增强高聚物的结构与损伤特征"></a>纤维增强高聚物的结构与损伤特征</h2><p>纤维起到骨架作用，相当于混凝土中的钢筋的作用；高聚物是基体，把纤维粘接在一起，同时在纤维间传递和均匀载荷，从而充分发挥增强纤维的强度性能。</p>
<h2 id="短纤维增强材料的应力分布和增强机理"><a href="#短纤维增强材料的应力分布和增强机理" class="headerlink" title="短纤维增强材料的应力分布和增强机理"></a>短纤维增强材料的应力分布和增强机理</h2><h3 id="影响短纤维增强效果的因素"><a href="#影响短纤维增强效果的因素" class="headerlink" title="影响短纤维增强效果的因素"></a>影响短纤维增强效果的因素</h3><p>短纤维的长径比、用量、取向状态和表面预处理等</p>
<ol>
<li>长径比<br>临界长径比是指能够发挥短纤维最大强度所需的最小长径比。一般短纤维长径比60～120，长径比过大，纤维易缠结，影响复合效果。</li>
<li>取向程度</li>
<li><p>预处理</p>
<ul>
<li>偶联剂：连接基体和纤维</li>
<li>表面涂层：涂敷在纤维表面，改善纤维与基体界面的物理化学反应。</li>
<li>表面氧化：增加纤维比表面积</li>
<li>表面气相沉积：改善纤维形态</li>
<li><p>低温等离子处理</p>
</li>
<li></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>材料</category>
      </categories>
      <tags>
        <tag>材料</tag>
        <tag>强度</tag>
        <tag>高分子</tag>
        <tag>破坏行为</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-SE笔记3</title>
    <url>/2020/12/31/JAVA-SE%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<p>JAVA SE第三部分笔记</p>
<p>单元测试、正则表达式、加密与安全、多线程</p>
<a id="more"></a>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p><strong>测试驱动开发（TDD，Test-Driven Development）流程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    编写接口</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">    编写测试</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">┌─&gt; 编写实现</span><br><span class="line">│    │</span><br><span class="line">│ N  ▼</span><br><span class="line">└── 运行测试</span><br><span class="line">     │ Y</span><br><span class="line">     ▼</span><br><span class="line">    任务完成</span><br></pre></td></tr></table></figure>
<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>JUnit是开源的，是单元测试的标准框架。</p>
<p>JUnit会给出测试报告：包括成功率，代码覆盖率。</p>
<blockquote>
<p>测试覆盖率应该在80%以上。</p>
</blockquote>
<p>测试类的名称通常为<code>&lt;原名称&gt;Test.java</code>，测试方法加上<code>@Test</code>注解。</p>
<p>测试文件实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, Factorial.fact(<span class="number">1</span>));</span><br><span class="line">        assertEquals(<span class="number">2</span>, Factorial.fact(<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, Factorial.fact(<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="number">3628800</span>, Factorial.fact(<span class="number">10</span>));</span><br><span class="line">        assertEquals(<span class="number">2432902008176640000L</span>, Factorial.fact(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>assertEquals(expected, actual)</code></li>
<li><p><code>assertEquals(double expected, double actual, double delta)</code>由于浮点数无法精确比较，需要指定误差值</p>
</li>
<li><p><code>assertTrue()</code>: 期待结果为<code>true</code></p>
</li>
<li><code>assertFalse()</code>: 期待结果为<code>false</code></li>
<li><code>assertNotNull()</code>: 期待结果为非<code>null</code></li>
<li><code>assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li>
<li>…</li>
</ul>
<p>单元测试规范：</p>
<ol>
<li><p>单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p>
</li>
<li><p>每个单元测试应当互相独立，不依赖运行的顺序；</p>
</li>
<li><p>测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为<code>0</code>，<code>null</code>，空字符串<code>&quot;&quot;</code>等情况。</p>
</li>
</ol>
<h2 id="Fixture"><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h2><p>Fixture：编写测试前准备、测试后清理的代码部分。</p>
<ol>
<li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们在各个<code>@Test</code>方法中互不影响，因为是不同的实例；</li>
<li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">100</span>, <span class="keyword">this</span>.calculator.add(<span class="number">100</span>));</span><br><span class="line">        assertEquals(<span class="number">150</span>, <span class="keyword">this</span>.calculator.add(<span class="number">50</span>));</span><br><span class="line">        assertEquals(<span class="number">130</span>, <span class="keyword">this</span>.calculator.add(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(-<span class="number">100</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">100</span>));</span><br><span class="line">        assertEquals(-<span class="number">150</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">50</span>));</span><br><span class="line">        assertEquals(-<span class="number">130</span>, <span class="keyword">this</span>.calculator.sub(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般方法，Executable</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Executable</span>() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式编程</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException<span class="class">.<span class="keyword">class</span>, () -&gt; </span>&#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>对于需要跳过的方法使用<code>@Disabled</code>注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBug101</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个测试不会运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作系统判断</span></span><br><span class="line"><span class="meta">@EnabledOnOs</span>(OS.WINDOWS)</span><br><span class="line"><span class="meta">@EnabledOnOs</span>(&#123; OS.LINUX, OS.MAC &#125;)</span><br><span class="line"><span class="meta">@DisabledOnOs</span>(OS.WINDOWS)</span><br><span class="line"><span class="comment">// JRE</span></span><br><span class="line"><span class="meta">@DisabledOnJre</span>(JRE.JAVA_8)</span><br><span class="line"><span class="comment">// 64位</span></span><br><span class="line"><span class="meta">@EnabledIfSystemProperty</span>(named = <span class="string">"os.arch"</span>, matches = <span class="string">".*64.*"</span>)</span><br><span class="line"><span class="comment">// 环境变量</span></span><br><span class="line"><span class="meta">@EnabledIfEnvironmentVariable</span>(named = <span class="string">"DEBUG"</span>, matches = <span class="string">"true"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h3><p><code>@ParameterizedTest</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource</span>(ints = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参数传入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1 MethodSource注解</span></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title">testCapitalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">"abc"</span>, <span class="string">"Abc"</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">"APPLE"</span>, <span class="string">"Apple"</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">"gooD"</span>, <span class="string">"Good"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2 CsvSource</span></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource</span>(&#123; <span class="string">"abc, Abc"</span>, <span class="string">"APPLE, Apple"</span>, <span class="string">"gooD, Good"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3 CsvFileSource： 文件必须在classpath中，通常放在test文件夹中</span></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource</span>(resources = &#123; <span class="string">"/test-capitalize.csv"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String re = <span class="string">"java|php"</span>;</span><br><span class="line">        System.out.println(<span class="string">"java"</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">"php"</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">"go"</span>.matches(re));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><p><strong>特殊字符</strong><br><code>\\</code>、<code>\&amp;</code></p>
<p><strong>中文字符</strong><br>匹配非ASCII字符，例如中文，那就用<code>\u####</code>的十六进制表示，例如：<code>a\u548cc</code>匹配字符串<code>&quot;a和c&quot;</code>，中文字符<code>和</code>的Unicode编码是<code>548c</code>。</p>
<p><code>\\d{3,5}</code>可以匹配3～5个数字</p>
<p>单个字符的匹配规则如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">正则表达式</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>A</code></td>
<td style="text-align:left">指定字符</td>
<td style="text-align:left"><code>A</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\u548c</code></td>
<td style="text-align:left">指定Unicode字符</td>
<td style="text-align:left"><code>和</code></td>
</tr>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">任意字符</td>
<td style="text-align:left"><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\d</code></td>
<td style="text-align:left">数字0~9</td>
<td style="text-align:left"><code>0</code>~<code>9</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left">大小写字母，数字和下划线</td>
<td style="text-align:left"><code>a</code>~<code>z</code>，<code>A</code>~<code>Z</code>，<code>0</code>~<code>9</code>，<code>_</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left">空格、Tab键</td>
<td style="text-align:left">空格，Tab</td>
</tr>
<tr>
<td style="text-align:left"><code>\D</code></td>
<td style="text-align:left">非数字</td>
<td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left">非\w</td>
<td style="text-align:left"><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left">非\s</td>
<td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
</tbody>
</table>
</div>
<p>多个字符的匹配规则如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">正则表达式</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>A*</code></td>
<td style="text-align:left">任意个数字符</td>
<td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>A+</code></td>
<td style="text-align:left">至少1个字符</td>
<td style="text-align:left"><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>A?</code></td>
<td style="text-align:left">0个或1个字符</td>
<td style="text-align:left">空，<code>A</code></td>
</tr>
<tr>
<td style="text-align:left"><code>A{3}</code></td>
<td style="text-align:left">指定个数字符</td>
<td style="text-align:left"><code>AAA</code></td>
</tr>
<tr>
<td style="text-align:left"><code>A{2,3}</code></td>
<td style="text-align:left">指定范围个数字符</td>
<td style="text-align:left"><code>AA</code>，<code>AAA</code></td>
</tr>
<tr>
<td style="text-align:left"><code>A{2,}</code></td>
<td style="text-align:left">至少n个字符</td>
<td style="text-align:left"><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>A{0,3}</code></td>
<td style="text-align:left">最多n个字符</td>
<td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code></td>
</tr>
</tbody>
</table>
</div>
<p>复杂匹配规则主要有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">正则表达式</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">开头</td>
<td style="text-align:left">字符串开头</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">结尾</td>
<td style="text-align:left">字符串结束</td>
</tr>
<tr>
<td style="text-align:left">[ABC]</td>
<td style="text-align:left">[…]内任意字符</td>
<td style="text-align:left">A，B，C</td>
</tr>
<tr>
<td style="text-align:left">[A-F0-9xy]</td>
<td style="text-align:left">指定范围的字符</td>
<td style="text-align:left"><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td>
</tr>
<tr>
<td style="text-align:left"><sup><a href="#fn_A-F" id="reffn_A-F">A-F</a></sup></td>
<td style="text-align:left">指定范围外的任意字符</td>
<td style="text-align:left">非<code>A</code>~<code>F</code></td>
</tr>
<tr>
<td style="text-align:left">AB\</td>
<td style="text-align:left">CD\</td>
<td style="text-align:left">EF</td>
<td>AB或CD或EF</td>
<td><code>AB</code>，<code>CD</code>，<code>EF</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><p>用<code>(...)</code>把要提取的规则分组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)"</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="string">"010-12345678"</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            String g1 = m.group(<span class="number">1</span>);<span class="comment">// 0为整个匹配到的字符串</span></span><br><span class="line">            String g2 = m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"匹配失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>Matcher</code>时，必须首先调用<code>matches()</code>判断是否匹配成功，匹配成功后，才能调用<code>group()</code>提取子串。</p>
</blockquote>
<h2 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h2><p>给定一个匹配规则，加上<code>?</code>后就变成了非贪婪匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">"(\\d+?)(0*)"</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">"1230000"</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"group1="</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// "123"</span></span><br><span class="line">            System.out.println(<span class="string">"group2="</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// "0000"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>\d??</code>第一个<code>?</code>表示0个或1个，第二个<code>?</code>表示非贪婪匹配</p>
<h2 id="分割、搜索和替换"><a href="#分割、搜索和替换" class="headerlink" title="分割、搜索和替换"></a>分割、搜索和替换</h2><p><strong>分割字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"a b c"</span>.split(<span class="string">"\\s"</span>); <span class="comment">// &#123; "a", "b", "c" &#125;</span></span><br><span class="line"><span class="string">"a b  c"</span>.split(<span class="string">"\\s"</span>); <span class="comment">// &#123; "a", "b", "", "c" &#125;</span></span><br><span class="line"><span class="string">"a, b ;; c"</span>.split(<span class="string">"[\\,\\;\\s]+"</span>); <span class="comment">// &#123; "a", "b", "c" &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>搜索字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"the quick brown fox jumps over the lazy dog."</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"\\wo\\w"</span>);</span><br><span class="line">        Matcher m = p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            String sub = s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>替换字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"The     quick\t\t brown   fox  jumps   over the  lazy dog."</span>;</span><br><span class="line">        String r = s.replaceAll(<span class="string">"\\s+"</span>, <span class="string">" "</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// "The quick brown fox jumps over the lazy dog."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>反向引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $1、$2等可以用来表示匹配到的字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"the quick brown fox jumps over the lazy dog."</span>;</span><br><span class="line">        String r = s.replaceAll(<span class="string">"\\s([a-z]&#123;4&#125;)\\s"</span>, <span class="string">" &lt;b&gt;$1&lt;/b&gt; "</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="加密与安全"><a href="#加密与安全" class="headerlink" title="加密与安全"></a>加密与安全</h1><p>三防：</p>
<ul>
<li>防窃听</li>
<li>防篡改</li>
<li>防伪造</li>
</ul>
<h2 id="编码算法"><a href="#编码算法" class="headerlink" title="编码算法"></a>编码算法</h2><p><strong>URL编码</strong></p>
<p>出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p>
<ul>
<li>如果字符是<code>A</code>~<code>Z</code>，<code>a</code>~<code>z</code>，<code>0</code>~<code>9</code>以及<code>-</code>、<code>_</code>、<code>.</code>、<code>*</code>，则保持不变；</li>
<li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。</li>
</ul>
<p>Java标准库提供了一个<code>URLEncoder</code>类来对任意字符串进行URL编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String encoded = URLEncoder.encode(<span class="string">"中文"</span>,StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>和标准的URL编码稍有不同，URLEncoder把空格字符编码成<code>+</code>，而现在的URL编码标准要求空格被编码为<code>%20</code>，不过，服务器都可以处理这两种情况。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String decoded = URLDecoder.decode(<span class="string">"%E4%B8%AD%E6%96%87%21"</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Base64编码</strong></p>
<p>Base64对二进制数据进行编码。可以把任意长度的二进制数据变为纯文本，且只包含<code>A</code>~<code>Z</code>、<code>a</code>~<code>z</code>、<code>0</code>~<code>9</code>、<code>+</code>、<code>/</code>、<code>=</code>这些字符。</p>
<p>它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。（长度不足时补充0）</p>
<p>因为6位整数的范围总是<code>0</code>~<code>63</code>，所以，能用64个字符表示：字符<code>A</code>~<code>Z</code>对应索引<code>0</code>~<code>25</code>，字符<code>a</code>~<code>z</code>对应索引<code>26</code>~<code>51</code>，字符<code>0</code>~<code>9</code>对应索引<code>52</code>~<code>61</code>，最后两个索引<code>62</code>、<code>63</code>分别用字符<code>+</code>和<code>/</code>表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────────┬───────────────┬───────────────┐</span><br><span class="line">│      e4       │      b8       │      ad       │</span><br><span class="line">└───────────────┴───────────────┴───────────────┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌───────────┬───────────┬───────────┬───────────┐</span><br><span class="line">│    39     │    0b     │    22     │    2d     │</span><br><span class="line">└───────────┴───────────┴───────────┴───────────┘</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xb8</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span> &#125;;</span><br><span class="line">        <span class="comment">// 编码</span></span><br><span class="line">        String b64encoded = Base64.getEncoder().encodeToString(input);</span><br><span class="line">        String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input); <span class="comment">// 删除补充的0</span></span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getDecoder().decode(<span class="string">"5Lit"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(output)); <span class="comment">// [-28, -72, -83]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。</p>
<p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>java自带的哈希算法:<a href="https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms</a></p>
<p>哈希算法（Hash）又称摘要算法（Digest）：对输入计算，得到固定长度的输出。</p>
<p><strong>特点：</strong>输入相同则输出相同；输入不同大概率输出不同。</p>
<p>常用的哈希算法有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">输出长度（位）</th>
<th style="text-align:left">输出长度（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MD5</td>
<td style="text-align:left">128 bits</td>
<td style="text-align:left">16 bytes</td>
</tr>
<tr>
<td style="text-align:left">SHA-1</td>
<td style="text-align:left">160 bits</td>
<td style="text-align:left">20 bytes</td>
</tr>
<tr>
<td style="text-align:left">RipeMD-160</td>
<td style="text-align:left">160 bits</td>
<td style="text-align:left">20 bytes</td>
</tr>
<tr>
<td style="text-align:left">SHA-256</td>
<td style="text-align:left">256 bits</td>
<td style="text-align:left">32 bytes</td>
</tr>
<tr>
<td style="text-align:left">SHA-512</td>
<td style="text-align:left">512 bits</td>
<td style="text-align:left">64 bytes</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        md.update(<span class="string">"World"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest(); <span class="comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了抵御彩虹攻击（黑客持有大量常见字符串的MD5加密结果），可以使用加盐加密（Salt）：<code>digest = md5(salt+inputPassword)</code></p>
<blockquote>
<p>GetInstance与new区别：</p>
<p><strong>new的使用</strong><br>如Object object = new Object()，这时候，就必须要知道有第二个Object的存在，而第二个Object也常常是在当前的应用程序域中的，可以被直接调用的</p>
<p><strong>GetInstance的使用</strong><br>在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。</p>
</blockquote>
<h2 id="BouncyCastle"><a href="#BouncyCastle" class="headerlink" title="BouncyCastle"></a>BouncyCastle</h2><p><a href="https://www.bouncycastle.org/latest_releases.html" target="_blank" rel="noopener">BouncyCastle</a>是一个提供了很多哈希算法和加密算法的第三方库.</p>
<p><code>java.security</code>提供了一种机制，通过将BouncyCastle在启动时注册一下，就可以与原有的加密算法无缝接入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 注册BouncyCastle:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">        <span class="comment">// 按名称正常调用:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">"RipeMD160"</span>);</span><br><span class="line">        md.update(<span class="string">"HelloWorld"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hmac算法"><a href="#Hmac算法" class="headerlink" title="Hmac算法"></a>Hmac算法</h2><p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p>
<p>Hmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HmacMD5 ≈ md5(secure_random_key, input)</span><br></pre></td></tr></table></figure>
<p>使用HmacMD5而不是用MD5加salt，有如下好处：</p>
<ul>
<li>HmacMD5使用的key长度是64字节，更安全；</li>
<li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li>
<li>Hmac输出和原有的哈希算法长度一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">"HmacMD5"</span>);</span><br><span class="line">        SecretKey key = keyGen.generateKey();</span><br><span class="line">        <span class="comment">// 打印随机生成的key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] skey = key.getEncoded();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, skey).toString(<span class="number">16</span>));</span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">"HmacMD5"</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">"HelloWorld"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用HmacMD5的步骤是：</p>
<ol>
<li>通过名称<code>HmacMD5</code>获取<code>KeyGenerator</code>实例；</li>
<li>通过<code>KeyGenerator</code>创建一个<code>SecretKey</code>实例；</li>
<li>通过名称<code>HmacMD5</code>获取<code>Mac</code>实例；</li>
<li>用<code>SecretKey</code>初始化<code>Mac</code>实例；</li>
<li>对<code>Mac</code>实例反复调用<code>update(byte[])</code>输入数据；</li>
<li>调用<code>Mac</code>实例的<code>doFinal()</code>获取最终的哈希值。</li>
</ol>
<p>存储用户名和口令的数据库结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">username</th>
<th style="text-align:left">secret_key (64 bytes)</th>
<th style="text-align:left">password</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bob</td>
<td style="text-align:left">a8c06e05f92e…5e16</td>
<td style="text-align:left">7e0387872a57c85ef6dddbaa12f376de</td>
</tr>
<tr>
<td style="text-align:left">alice</td>
<td style="text-align:left">e6a343693985…f4be</td>
<td style="text-align:left">c1f929ac2552642b302e739bc0cdbaac</td>
</tr>
<tr>
<td style="text-align:left">tim</td>
<td style="text-align:left">f27a973dfdc0…6003</td>
<td style="text-align:left">af57651c3a8a73303515804d4af43790</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] hkey = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">106</span>, <span class="number">70</span>, -<span class="number">110</span>, <span class="number">125</span>, <span class="number">39</span>, -<span class="number">20</span>, <span class="number">52</span>, <span class="number">56</span>, <span class="number">85</span>, <span class="number">9</span>, -<span class="number">19</span>, -<span class="number">72</span>, <span class="number">52</span>, -<span class="number">53</span>, <span class="number">52</span>, -<span class="number">45</span>, -<span class="number">6</span>, <span class="number">119</span>, -<span class="number">63</span>,</span><br><span class="line">                <span class="number">30</span>, <span class="number">20</span>, -<span class="number">83</span>, -<span class="number">28</span>, <span class="number">77</span>, <span class="number">98</span>, <span class="number">109</span>, -<span class="number">32</span>, -<span class="number">76</span>, <span class="number">121</span>, -<span class="number">106</span>, <span class="number">0</span>, -<span class="number">74</span>, -<span class="number">107</span>, -<span class="number">114</span>, -<span class="number">45</span>, <span class="number">104</span>, -<span class="number">104</span>, -<span class="number">8</span>, <span class="number">2</span>, <span class="number">121</span>, <span class="number">6</span>,</span><br><span class="line">                <span class="number">97</span>, -<span class="number">18</span>, -<span class="number">13</span>, -<span class="number">63</span>, -<span class="number">30</span>, -<span class="number">125</span>, -<span class="number">103</span>, -<span class="number">80</span>, -<span class="number">46</span>, <span class="number">113</span>, -<span class="number">14</span>, <span class="number">68</span>, <span class="number">32</span>, -<span class="number">46</span>, <span class="number">101</span>, -<span class="number">116</span>, -<span class="number">104</span>, -<span class="number">81</span>, -<span class="number">108</span>, <span class="number">122</span>,</span><br><span class="line">                <span class="number">89</span>, -<span class="number">106</span>, -<span class="number">109</span> &#125;;</span><br><span class="line">		<span class="comment">// 恢复私钥</span></span><br><span class="line">        SecretKey key = <span class="keyword">new</span> SecretKeySpec(hkey, <span class="string">"HmacMD5"</span>);</span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">"HmacMD5"</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">"HelloWorld"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(Arrays.toString(result));</span><br><span class="line">        <span class="comment">// [126, 59, 37, 63, 73, 90, 111, -96, -77, 15, 82, -74, 122, -55, -67, 54]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>常用的对称加密算法有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">密钥长度</th>
<th style="text-align:left">工作模式</th>
<th style="text-align:left">填充模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DES</td>
<td style="text-align:left">56/64</td>
<td style="text-align:left">ECB/CBC/PCBC/CTR/…</td>
<td style="text-align:left">NoPadding/PKCS5Padding/…</td>
</tr>
<tr>
<td style="text-align:left">AES</td>
<td style="text-align:left">128/192/256</td>
<td style="text-align:left">ECB/CBC/PCBC/CTR/…</td>
<td style="text-align:left">NoPadding/PKCS5Padding/PKCS7Padding/…</td>
</tr>
<tr>
<td style="text-align:left">IDEA</td>
<td style="text-align:left">128</td>
<td style="text-align:left">ECB</td>
<td style="text-align:left">PKCS5Padding/PKCS7Padding/…</td>
</tr>
</tbody>
</table>
</div>
<h3 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h3><p><strong>ECB模式（简单）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">"Hello, world!"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Message: "</span> + message);</span><br><span class="line">        <span class="comment">// 128位密钥 = 16 bytes Key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] key = <span class="string">"1234567890abcdef"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">"Encrypted: "</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">"Decrypted: "</span> + <span class="keyword">new</span> String(decrypted, <span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES/ECB/PKCS5Padding"</span>);</span><br><span class="line">        SecretKey keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES/ECB/PKCS5Padding"</span>);</span><br><span class="line">        SecretKey keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CBC模式（安全性高）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">"Hello, world!"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Message: "</span> + message);</span><br><span class="line">        <span class="comment">// 256位密钥 = 32 bytes Key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] key = <span class="string">"1234567890abcdef1234567890abcdef"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">"Encrypted: "</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">"Decrypted: "</span> + <span class="keyword">new</span> String(decrypted, <span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5Padding"</span>);</span><br><span class="line">        SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="comment">// CBC模式需要生成一个16 bytes的initialization vector:</span></span><br><span class="line">        SecureRandom sr = SecureRandom.getInstanceStrong();</span><br><span class="line">        <span class="keyword">byte</span>[] iv = sr.generateSeed(<span class="number">16</span>);</span><br><span class="line">        IvParameterSpec ivps = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">byte</span>[] data = cipher.doFinal(input);</span><br><span class="line">        <span class="comment">// IV不需要保密，把IV和密文一起返回:</span></span><br><span class="line">        <span class="keyword">return</span> join(iv, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="comment">// 把input分割成IV和密文:</span></span><br><span class="line">        <span class="keyword">byte</span>[] iv = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[input.length - <span class="number">16</span>];</span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, iv, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        System.arraycopy(input, <span class="number">16</span>, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES/CBC/PKCS5Padding"</span>);</span><br><span class="line">        SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">"AES"</span>);</span><br><span class="line">        IvParameterSpec ivps = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] join(<span class="keyword">byte</span>[] bs1, <span class="keyword">byte</span>[] bs2) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] r = <span class="keyword">new</span> <span class="keyword">byte</span>[bs1.length + bs2.length];</span><br><span class="line">        System.arraycopy(bs1, <span class="number">0</span>, r, <span class="number">0</span>, bs1.length);</span><br><span class="line">        System.arraycopy(bs2, <span class="number">0</span>, r, bs1.length, bs2.length);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="口令加密算法"><a href="#口令加密算法" class="headerlink" title="口令加密算法"></a>口令加密算法</h2><p>对称加密算法的密钥长度固定。用户输入的口令一般要需要使用PBE算法，利用随机数杂凑计算出真正的密钥再进行加密。</p>
<p>PBE（PBE算法内部使用的仍然是标准对称加密算法（例如AES））就是Password Based Encryption的缩写，它的作用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key &#x3D; generate(userPassword, secureRandomPassword);</span><br></pre></td></tr></table></figure>
<p>我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 把BouncyCastle作为Provider添加到java.security:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">"Hello, world!"</span>;</span><br><span class="line">        <span class="comment">// 加密口令:</span></span><br><span class="line">        String password = <span class="string">"hello12345"</span>;</span><br><span class="line">        <span class="comment">// 16 bytes随机Salt:</span></span><br><span class="line">        <span class="keyword">byte</span>[] salt = SecureRandom.getInstanceStrong().generateSeed(<span class="number">16</span>);</span><br><span class="line">        System.out.printf(<span class="string">"salt: %032x\n"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, salt));</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(password, salt, data);</span><br><span class="line">        System.out.println(<span class="string">"encrypted: "</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(password, salt, encrypted);</span><br><span class="line">        System.out.println(<span class="string">"decrypted: "</span> + <span class="keyword">new</span> String(decrypted, <span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(String password, <span class="keyword">byte</span>[] salt, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        PBEKeySpec keySpec = <span class="keyword">new</span> PBEKeySpec(password.toCharArray());</span><br><span class="line">        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="string">"PBEwithSHA1and128bitAES-CBC-BC"</span>);</span><br><span class="line">        SecretKey skey = skeyFactory.generateSecret(keySpec);</span><br><span class="line">        PBEParameterSpec pbeps = <span class="keyword">new</span> PBEParameterSpec(salt, <span class="number">1000</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"PBEwithSHA1and128bitAES-CBC-BC"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(String password, <span class="keyword">byte</span>[] salt, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        PBEKeySpec keySpec = <span class="keyword">new</span> PBEKeySpec(password.toCharArray());</span><br><span class="line">        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="string">"PBEwithSHA1and128bitAES-CBC-BC"</span>);</span><br><span class="line">        SecretKey skey = skeyFactory.generateSecret(keySpec);</span><br><span class="line">        PBEParameterSpec pbeps = <span class="keyword">new</span> PBEParameterSpec(salt, <span class="number">1000</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"PBEwithSHA1and128bitAES-CBC-BC"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用PBE时，我们还需要引入BouncyCastle，并指定算法是<code>PBEwithSHA1and128bitAES-CBC-BC</code>。观察代码，实际上真正的AES密钥是调用<code>Cipher</code>的<code>init()</code>方法时同时传入<code>SecretKey</code>和<code>PBEParameterSpec</code>实现的。在创建<code>PBEParameterSpec</code>的时候，我们还指定了循环次数<code>1000</code>，循环次数越多，暴力破解需要的计算量就越大。</p>
<p>如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。</p>
<h2 id="密钥交换算法"><a href="#密钥交换算法" class="headerlink" title="密钥交换算法"></a>密钥交换算法</h2><p>密钥交换算法即DH算法：Diffie-Hellman算法</p>
<p>DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换。</p>
<p>DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：</p>
<ol>
<li>甲首选选择一个素数<code>p</code>，例如509，底数<code>g</code>，任选，例如5，随机数<code>a</code>，例如123，然后计算<code>A=g^a mod p</code>，结果是215，然后，甲发送<code>p＝509</code>，<code>g=5</code>，<code>A=215</code>给乙；</li>
<li>乙方收到后，也选择一个随机数<code>b</code>，例如，456，然后计算<code>B=g^b mod p</code>，结果是181，乙再同时计算<code>s=A^b mod p</code>，结果是121；</li>
<li>乙把计算的<code>B=181</code>发给甲，甲计算<code>s＝B^a mod p</code>的余数，计算结果与乙算出的结果一样，都是121。</li>
</ol>
<p>DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p>
<p><strong>使用Java实现DH算法的代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Bob和Alice:</span></span><br><span class="line">        Person bob = <span class="keyword">new</span> Person(<span class="string">"Bob"</span>);</span><br><span class="line">        Person alice = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各自生成KeyPair:</span></span><br><span class="line">        bob.generateKeyPair();</span><br><span class="line">        alice.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双方交换各自的PublicKey:</span></span><br><span class="line">        <span class="comment">// Bob根据Alice的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        bob.generateSecretKey(alice.publicKey.getEncoded());</span><br><span class="line">        <span class="comment">// Alice根据Bob的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        alice.generateSecretKey(bob.publicKey.getEncoded());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查双方的本地密钥是否相同:</span></span><br><span class="line">        bob.printKeys();</span><br><span class="line">        alice.printKeys();</span><br><span class="line">        <span class="comment">// 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地KeyPair:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateKeyPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">"DH"</span>);</span><br><span class="line">            kpGen.initialize(<span class="number">512</span>);</span><br><span class="line">            KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">            <span class="keyword">this</span>.privateKey = kp.getPrivate();</span><br><span class="line">            <span class="keyword">this</span>.publicKey = kp.getPublic();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSecretKey</span><span class="params">(<span class="keyword">byte</span>[] receivedPubKeyBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从byte[]恢复PublicKey:</span></span><br><span class="line">            X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(receivedPubKeyBytes);</span><br><span class="line">            KeyFactory kf = KeyFactory.getInstance(<span class="string">"DH"</span>);</span><br><span class="line">            PublicKey receivedPublicKey = kf.generatePublic(keySpec);</span><br><span class="line">            <span class="comment">// 生成本地密钥:</span></span><br><span class="line">            KeyAgreement keyAgreement = KeyAgreement.getInstance(<span class="string">"DH"</span>);</span><br><span class="line">            keyAgreement.init(<span class="keyword">this</span>.privateKey); <span class="comment">// 自己的PrivateKey</span></span><br><span class="line">            keyAgreement.doPhase(receivedPublicKey, <span class="keyword">true</span>); <span class="comment">// 对方的PublicKey</span></span><br><span class="line">            <span class="comment">// 生成SecretKey密钥:</span></span><br><span class="line">            <span class="keyword">this</span>.secretKey = keyAgreement.generateSecret();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Name: %s\n"</span>, <span class="keyword">this</span>.name);</span><br><span class="line">        System.out.printf(<span class="string">"Private key: %x\n"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.privateKey.getEncoded()));</span><br><span class="line">        System.out.printf(<span class="string">"Public key: %x\n"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.publicKey.getEncoded()));</span><br><span class="line">        System.out.printf(<span class="string">"Secret key: %x\n"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.secretKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。</p>
<p>非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要<code>N*(N-1)/2</code>个密钥，因此每个人需要管理<code>N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p>
<blockquote>
<p>非对称加密的缺点是运算速度非常慢，比对称加密要慢很多。</p>
</blockquote>
<p>在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：</p>
<ol>
<li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li>
<li>小红用自己的RSA私钥解密得到AES口令；</li>
<li>双方使用这个共享的AES口令用AES加密通信。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 明文:</span></span><br><span class="line">        <span class="keyword">byte</span>[] plain = <span class="string">"Hello, encrypt use RSA"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 创建公钥／私钥对:</span></span><br><span class="line">        Person alice = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>);</span><br><span class="line">        <span class="comment">// 用Alice的公钥加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] pk = alice.getPublicKey();</span><br><span class="line">        System.out.println(String.format(<span class="string">"public key: %x"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, pk)));</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = alice.encrypt(plain);</span><br><span class="line">        System.out.println(String.format(<span class="string">"encrypted: %x"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, encrypted)));</span><br><span class="line">        <span class="comment">// 用Alice的私钥解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] sk = alice.getPrivateKey();</span><br><span class="line">        System.out.println(String.format(<span class="string">"private key: %x"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, sk)));</span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = alice.decrypt(encrypted);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(decrypted, <span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 私钥:</span></span><br><span class="line">    PrivateKey sk;</span><br><span class="line">    <span class="comment">// 公钥:</span></span><br><span class="line">    PublicKey pk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 生成公钥／私钥对:</span></span><br><span class="line">        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">        <span class="keyword">this</span>.sk = kp.getPrivate();</span><br><span class="line">        <span class="keyword">this</span>.pk = kp.getPublic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把私钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPrivateKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把公钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPublicKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用公钥加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, <span class="keyword">this</span>.pk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用私钥解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, <span class="keyword">this</span>.sk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] pkData = ...</span><br><span class="line"><span class="keyword">byte</span>[] skData = ...</span><br><span class="line">KeyFactory kf = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line"><span class="comment">// 恢复公钥:</span></span><br><span class="line">X509EncodedKeySpec pkSpec = <span class="keyword">new</span> X509EncodedKeySpec(pkData);</span><br><span class="line">PublicKey pk = kf.generatePublic(pkSpec);</span><br><span class="line"><span class="comment">// 恢复私钥:</span></span><br><span class="line">PKCS8EncodedKeySpec skSpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(skData);</span><br><span class="line">PrivateKey sk = kf.generatePrivate(skSpec);</span><br></pre></td></tr></table></figure>
<h2 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h2><p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">signature = encrypt(privateKey, sha256(message))</span><br></pre></td></tr></table></figure>
<p>对签名进行验证实际上就是用公钥解密：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash = decrypt(publicKey, signature)</span><br></pre></td></tr></table></figure>
<p>常用数字签名算法有：</p>
<ul>
<li>MD5withRSA</li>
<li>SHA1withRSA</li>
<li>SHA256withRSA</li>
</ul>
<p>它们实际上就是指定某种哈希算法进行RSA签名的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="comment">// 生成RSA公钥/私钥:</span></span><br><span class="line">        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">        PrivateKey sk = kp.getPrivate();</span><br><span class="line">        PublicKey pk = kp.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待签名的消息:</span></span><br><span class="line">        <span class="keyword">byte</span>[] message = <span class="string">"Hello, I am Bob!"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用私钥签名:</span></span><br><span class="line">        Signature s = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">        s.initSign(sk);</span><br><span class="line">        s.update(message);</span><br><span class="line">        <span class="keyword">byte</span>[] signed = s.sign();</span><br><span class="line">        System.out.println(String.format(<span class="string">"signature: %x"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, signed)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用公钥验证:</span></span><br><span class="line">        Signature v = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">        v.initVerify(pk);</span><br><span class="line">        v.update(message);</span><br><span class="line">        <span class="keyword">boolean</span> valid = v.verify(signed);</span><br><span class="line">        System.out.println(<span class="string">"valid? "</span> + valid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DSA签名"><a href="#DSA签名" class="headerlink" title="DSA签名"></a>DSA签名</h3><p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p>
<p>DSA只能配合SHA使用，常用的算法有：</p>
<ul>
<li>SHA1withDSA</li>
<li>SHA256withDSA</li>
<li>SHA512withDSA</li>
</ul>
<p>和RSA数字签名相比，DSA的优点是更快。</p>
<h3 id="ECDSA签名"><a href="#ECDSA签名" class="headerlink" title="ECDSA签名"></a>ECDSA签名</h3><p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p>
<p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。HTTPS协议就是数字证书的应用</p>
<p>在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.keystore -dname "CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"</span><br></pre></td></tr></table></figure>
<p>几个主要的参数是：</p>
<ul>
<li>keyalg：指定RSA加密算法；</li>
<li>sigalg：指定SHA1withRSA签名算法；</li>
<li>validity：指定证书有效期3650天；</li>
<li>alias：指定证书在程序中引用的名称；</li>
<li>dname：最重要的<code>CN=www.sample.com</code>指定了<code>Common Name</code>，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li>
</ul>
<p>执行上述命令，JDK会在当前目录创建一个<code>my.keystore</code>文件，并存储创建成功的一个私钥和一个证书，它的别名是<code>mycert</code>。</p>
<p>有了key store存储的证书，我们就可以通过数字证书进行加解密和签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] message = <span class="string">"Hello, use X.509 cert!"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 读取KeyStore:</span></span><br><span class="line">        KeyStore ks = loadKeyStore(<span class="string">"/my.keystore"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">// 读取私钥:</span></span><br><span class="line">        PrivateKey privateKey = (PrivateKey) ks.getKey(<span class="string">"mycert"</span>, <span class="string">"123456"</span>.toCharArray());</span><br><span class="line">        <span class="comment">// 读取证书:</span></span><br><span class="line">        X509Certificate certificate = (X509Certificate) ks.getCertificate(<span class="string">"mycert"</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(certificate, message);</span><br><span class="line">        System.out.println(String.format(<span class="string">"encrypted: %x"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, encrypted)));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(privateKey, encrypted);</span><br><span class="line">        System.out.println(<span class="string">"decrypted: "</span> + <span class="keyword">new</span> String(decrypted, <span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="comment">// 签名:</span></span><br><span class="line">        <span class="keyword">byte</span>[] sign = sign(privateKey, certificate, message);</span><br><span class="line">        System.out.println(String.format(<span class="string">"signature: %x"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, sign)));</span><br><span class="line">        <span class="comment">// 验证签名:</span></span><br><span class="line">        <span class="keyword">boolean</span> verified = verify(certificate, message, sign);</span><br><span class="line">        System.out.println(<span class="string">"verify: "</span> + verified);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> KeyStore <span class="title">loadKeyStore</span><span class="params">(String keyStoreFile, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = Main<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">keyStoreFile</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"file not found in classpath: "</span> + keyStoreFile);</span><br><span class="line">            &#125;</span><br><span class="line">            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">            ks.load(input, password.toCharArray());</span><br><span class="line">            <span class="keyword">return</span> ks;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(X509Certificate certificate, <span class="keyword">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey());</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(PrivateKey privateKey, <span class="keyword">byte</span>[] data) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(PrivateKey privateKey, X509Certificate certificate, <span class="keyword">byte</span>[] message)</span><br><span class="line">            <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.sign();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(X509Certificate certificate, <span class="keyword">byte</span>[] message, <span class="keyword">byte</span>[] sig)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initVerify(certificate);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.verify(sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以<code>PrivateKey</code>实例表示，公钥以<code>X509Certificate</code>表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。</p>
<p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p>
<ol>
<li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li>
<li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li>
<li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li>
</ol>
<p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p>
<p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商<a href="https://en.wikipedia.org/wiki/DigiNotar" target="_blank" rel="noopener">DigiNotar</a>就发生过私钥泄漏导致公司破产的事故。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><p>方法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接调用<code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。</p>
</blockquote>
<p>方法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//method1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// method2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程暂停"><a href="#线程暂停" class="headerlink" title="线程暂停"></a>线程暂停</h2><p><code>Thread.sleep(10)</code>当前线程暂停10ms。</p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p><code>Thread.setPriority(int n) // 1~10, 默认值5</code></p>
<p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java线程的状态有以下几种：</p>
<ul>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ul>
<p>线程终止的原因有：</p>
<ul>
<li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li>
<li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li>
</ul>
<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行。</p>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>中断一个线程非常简单，只需要<strong>在其他线程</strong>中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>
<blockquote>
<p><code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于<code>t</code>线程是否能立刻响应，要看具体代码。</p>
</blockquote>
<p>目标线程只要捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>，就说明有其他线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread hello = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">" hello!"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断，而此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code>。由于我们在<code>t</code>线程中捕获了<code>InterruptedException</code>，因此，就可以准备结束该线程。在<code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现<code>hello</code>线程仍然会继续运行，且JVM不会退出。</p>
<blockquote>
<p>InterruptedException:</p>
<p>Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted</p>
</blockquote>
<p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p>
<blockquote>
<p>线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        HelloThread t = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">" hello!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程（Daemon Thread）是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<p><strong>创建守护线程</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
</blockquote>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p><strong>原子操作</strong>：某一个线程执行时，其他线程必须等待</p>
<p><strong>临界区：</strong>加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</p>
<p>Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="comment">// 无论有无异常，都会在此释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不需要synchronized的操作</strong></p>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>
</ul>
<p><code>long</code>和<code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</p>
<p>单条原子操作的语句不需要同步。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void set(int m) &#123;</span><br><span class="line">    synchronized(lock) &#123;</span><br><span class="line">        this.value &#x3D; m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就不需要同步。</p>
<blockquote>
<p>volatile只保证：</p>
<ol>
<li>读主内存到本地副本；</li>
<li>操作本地副本；</li>
<li>回写主内存。</li>
</ol>
<p>这3步多个线程可以同时进行。</p>
<p>volatile保证了时效性不是原子性</p>
</blockquote>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code>；</p>
<p>通过合理的设计和数据封装可以让一个类变为“线程安全”；</p>
<p>一个类没有特殊说明，默认不是thread-safe；</p>
<p>多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。</p>
<p>下面两种写法是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p>
<figure class="highlight plain"><figcaption><span>a</span></figcaption><table><tr><td class="code"><pre><span class="line">public void add(int m) &#123;</span><br><span class="line">    synchronized(lockA) &#123; &#x2F;&#x2F; 获得lockA的锁</span><br><span class="line">        this.value +&#x3D; m;</span><br><span class="line">        synchronized(lockB) &#123; &#x2F;&#x2F; 获得lockB的锁</span><br><span class="line">            this.another +&#x3D; m;</span><br><span class="line">        &#125; &#x2F;&#x2F; 释放lockB的锁</span><br><span class="line">    &#125; &#x2F;&#x2F; 释放lockA的锁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void dec(int m) &#123;</span><br><span class="line">    synchronized(lockB) &#123; &#x2F;&#x2F; 获得lockB的锁</span><br><span class="line">        this.another -&#x3D; m;</span><br><span class="line">        synchronized(lockA) &#123; &#x2F;&#x2F; 获得lockA的锁</span><br><span class="line">            this.value -&#x3D; m;</span><br><span class="line">        &#125; &#x2F;&#x2F; 释放lockA的锁</span><br><span class="line">    &#125; &#x2F;&#x2F; 释放lockB的锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Wait和notify"><a href="#Wait和notify" class="headerlink" title="Wait和notify"></a>Wait和notify</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> q = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        <span class="keyword">var</span> ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 执行task:</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String s = q.getTask();</span><br><span class="line">                            System.out.println(<span class="string">"execute task: "</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 放入task:</span></span><br><span class="line">                String s = <span class="string">"t-"</span> + Math.random();</span><br><span class="line">                System.out.println(<span class="string">"add task: "</span> + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add.start();</span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p>
</blockquote>
<h2 id="使用ReentrantLock"><a href="#使用ReentrantLock" class="headerlink" title="使用ReentrantLock"></a>使用ReentrantLock</h2><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常，而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p>
</blockquote>
<p>和<code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用condition</strong></p>
<p>condition类似wait和notify：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的:</p>
<ul>
<li><p><code>await()</code>会释放当前锁，进入等待状态；</p>
</li>
<li><p><code>signal()</code>会唤醒某个等待线程；</p>
</li>
<li><p><code>signalAll()</code>会唤醒所有等待线程；</p>
</li>
<li><p>唤醒线程从<code>await()</code>返回后需要重新获得锁。</p>
</li>
</ul>
<p>和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (condition.await(1, TimeUnit.SECOND)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 被其他线程唤醒</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 指定时间内没有被其他线程唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ReadWriteLock</strong></p>
<p>ReadWriteLock保证：</p>
<ul>
<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
<li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>StampedLock</strong></p>
<p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p>
<p>和<code>ReadWriteLock</code>相比，写入的加锁是完全一样的，不同的是读取。</p>
<blockquote>
<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>concurrent集合</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">interface</th>
<th style="text-align:left">non-thread-safe</th>
<th style="text-align:left">thread-safe</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">List</td>
<td style="text-align:left">ArrayList</td>
<td style="text-align:left">CopyOnWriteArrayList</td>
</tr>
<tr>
<td style="text-align:left">Map</td>
<td style="text-align:left">HashMap</td>
<td style="text-align:left">ConcurrentHashMap</td>
</tr>
<tr>
<td style="text-align:left">Set</td>
<td style="text-align:left">HashSet / TreeSet</td>
<td style="text-align:left">CopyOnWriteArraySet</td>
</tr>
<tr>
<td style="text-align:left">Queue</td>
<td style="text-align:left">ArrayDeque / LinkedList</td>
<td style="text-align:left">ArrayBlockingQueue / LinkedBlockingQueue</td>
</tr>
<tr>
<td style="text-align:left">Deque</td>
<td style="text-align:left">ArrayDeque / LinkedList</td>
<td style="text-align:left">LinkedBlockingDeque</td>
</tr>
</tbody>
</table>
</div>
<p>因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><code>java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器，可以这么用(不推荐，会降低性能)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map unsafeMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p><code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p>
<p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：<code>int addAndGet(int delta)</code></li>
<li>加1后返回新值：<code>int incrementAndGet()</code></li>
<li>获取当前值：<code>int get()</code></li>
<li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li>
</ul>
<p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p>
<h2 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h2><p>把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。</p>
<p>Java标准库提供了<code>ExecutorService</code>接口表示线程池，它的典型用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br><span class="line">executor.submit(task4);</span><br><span class="line">executor.submit(task5);</span><br></pre></td></tr></table></figure>
<p>因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Task(<span class="string">""</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池在程序结束的时候要关闭。使用<code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。<code>shutdownNow()</code>会立刻停止正在执行的任务，<code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</p>
<p><strong>ScheduledThreadPool</strong></p>
<p>定期反复执行的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">"one-time"</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">"fixed-rate"</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">"fixed-delay"</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>如果任务的任何执行遇到异常，则将<strong>禁止后续任务的执行。</strong></p>
<h2 id="使用Future"><a href="#使用Future" class="headerlink" title="使用Future"></a>使用Future</h2><p><code>Runnable</code>接口没有返回值。<code>Callable</code>接口相比之下多了返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>
<p>一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p>
<ul>
<li><code>get()</code>：获取结果（可能会等待）</li>
<li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li>
<li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li>
<li><code>isDone()</code>：判断任务是否已完成。</li>
</ul>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><code>CompletableFuture</code>相比<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        <span class="comment">// 创建一个CompletableFuture是通过CompletableFuture.supplyAsync()实现的，它需要一个实现了Supplier接口的对象</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"price: "</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"fetch price failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象：java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CompletableFuture</code>的优点是：</p>
<ul>
<li>异步任务结束时，会自动回调某个对象的方法；</li>
<li>异步任务出错时，会自动回调某个对象的方法；</li>
<li>主线程设置好回调后，不再关心异步任务的执行。</li>
</ul>
<p>多个<code>CompletableFuture</code>可以串行执行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个任务:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">"中国石油"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfQuery成功后继续执行下一个任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice(code);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfFetch成功后打印结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"price: "</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">queryCode</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"601857"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CompletableFuture</code>还可以并行执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">"中国石油"</span>, <span class="string">"https://finance.sina.com.cn/code/"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">"中国石油"</span>, <span class="string">"https://money.163.com/code/"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">"https://finance.sina.com.cn/price/"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">"https://money.163.com/price/"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"price: "</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">queryCode</span><span class="params">(String name, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"query code from "</span> + url + <span class="string">"..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"601857"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">(String code, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"query price from "</span> + url + <span class="string">"..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Fork-Join"><a href="#使用Fork-Join" class="headerlink" title="使用Fork/Join"></a>使用Fork/Join</h2><p>Fork/Join:将大任务拆分为小任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">long</span> expectedSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Expected sum: "</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> SumTask(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Long result = ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Fork/join sum: "</span> + result + <span class="string">" in "</span> + (endTime - startTime) + <span class="string">" ms."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">long</span>[] array;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="keyword">long</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="keyword">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">"split %d~%d ==&gt; %d~%d, %d~%d"</span>, start, end, start, middle, middle, end));</span><br><span class="line">        <span class="comment">// “分裂”子任务:</span></span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, start, middle);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, middle, end);</span><br><span class="line">        <span class="comment">// invokeAll会并行运行两个子任务:</span></span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="comment">// 获得子任务的结果:</span></span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        Long result = subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + subresult1 + <span class="string">" + "</span> + subresult2 + <span class="string">" ==&gt; "</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h2><p><code>Thread.currentThread()</code>获取当前线程</p>
<p>在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。</p>
<p>Java标准库提供了一个特殊的<code>ThreadLocal</code>，它可以在一个线程中传递同一个对象。</p>
<p><code>ThreadLocal</code>实例通常总是以静态字段初始化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>它的典型使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不删除，可能会影响下一次的状态</span></span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的<code>ThreadLocal</code>关联的实例互不干扰。</p>
<p>最后，特别注意<code>ThreadLocal</code>一定要在<code>finally</code>中清除。</p>
<p>为了保证能释放<code>ThreadLocal</code>关联的实例，我们可以通过<code>AutoCloseable</code>接口配合<code>try (resource) {...}</code>结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的<code>ThreadLocal</code>可以封装为一个<code>UserContext</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserContext</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，我们借助<code>try (resource) {...}</code>结构，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> ctx = <span class="keyword">new</span> UserContext(<span class="string">"Bob"</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser():</span></span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure>
<p>这样就在<code>UserContext</code>中完全封装了<code>ThreadLocal</code>，外部代码在<code>try (resource) {...}</code>内部可以随时调用<code>UserContext.currentUser()</code>获取当前线程绑定的用户名。</p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-SE笔记4</title>
    <url>/2021/01/14/JAVA-SE%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p>JAVA学习笔记第四部分:<br>Maven，网络编程，XML与JSON，JDBC，函数式编程，设计模式<br><a id="more"></a></p>
<h1 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h1><p>Maven是一个Java项目管理和构建工具。它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建。</p>
<h2 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h2><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>
<p>项目的根目录<code>a-maven-project</code>是项目名，它有一个项目描述文件<code>pom.xml</code>，存放Java源码的目录是<code>src/main/java</code>，存放资源文件的目录是<code>src/main/resources</code>，存放测试源码的目录是<code>src/test/java</code>，存放测试资源的目录是<code>src/test/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。这些就是一个Maven项目的标准目录结构。</p>
<p>项目描述文件<code>pom.xml</code>，它的内容长得像下面：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>groupId</code>类似于Java的包名，通常是公司或组织名称，<code>artifactId</code>类似于Java的类名，通常是项目名称，再加上<code>version</code>，一个Maven工程就是由<code>groupId</code>，<code>artifactId</code>和<code>version</code>作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖<code>commons-logging</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Maven使用groupId，artifactId和version唯一定位一个依赖。</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p>
<p><strong>安装Maven</strong></p>
<p>下载地址：<a href="https://maven.apache.org" target="_blank" rel="noopener">https://maven.apache.org</a></p>
<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>Maven定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">scope</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">compile</td>
<td style="text-align:left">编译时需要用到该jar包（默认）</td>
<td style="text-align:left">commons-logging</td>
</tr>
<tr>
<td style="text-align:left">test</td>
<td style="text-align:left">编译Test时需要用到该jar包</td>
<td style="text-align:left">junit</td>
</tr>
<tr>
<td style="text-align:left">runtime</td>
<td style="text-align:left">编译时不需要，但运行时需要用到</td>
<td style="text-align:left">mysql</td>
</tr>
<tr>
<td style="text-align:left">provided</td>
<td style="text-align:left">编译时需要用到，但运行时由JDK或某个服务器提供</td>
<td style="text-align:left">servlet-api</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h3><p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p>
<ul>
<li>groupId：属于组织的名称，类似Java的包名；</li>
<li>artifactId：该jar包自身的名称，类似Java的类名；</li>
<li>version：该jar包的版本。</li>
</ul>
<h3 id="Maven镜像"><a href="#Maven镜像" class="headerlink" title="Maven镜像"></a>Maven镜像</h3><p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入<code>.m2</code>目录，创建一个<code>settings.xml</code>配置文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="搜索第三方组件"><a href="#搜索第三方组件" class="headerlink" title="搜索第三方组件"></a>搜索第三方组件</h3><p>最后一个问题：如果我们要引用一个第三方组件，比如<code>okhttp</code>，如何确切地获得它的<code>groupId</code>、<code>artifactId</code>和<code>version</code>？方法是通过<a href="https://search.maven.org/" target="_blank" rel="noopener">search.maven.org</a>搜索关键字，找到对应的组件后，直接复制。</p>
<h3 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h3><p>在命令中，进入到<code>pom.xml</code>所在目录，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mvn clean package</span></span><br></pre></td></tr></table></figure>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，初学者容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是：</p>
<ul>
<li>Clean Lifecycle 在进行真正的构建之前进行一些清理工作。</li>
<li>Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。</li>
<li>Site Lifecycle 生成项目报告，站点，发布站点。</li>
</ul>
<h3 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h3><p>运行<strong>mvn clean</strong> ，这个的clean是Clean生命周期的一个阶段。有点绕？要知道有Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段：</p>
<ul>
<li>pre-clean 执行一些需要在clean之前完成的工作</li>
<li>clean 移除所有上一次构建生成的文件</li>
<li>post-clean 执行一些需要在clean之后立刻完成的工作</li>
</ul>
<p><strong>mvn clean</strong> 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，<strong>mvn clean</strong> 等同于 <strong>mvn pre-clean clean</strong> ，如果我们运行 <strong>mvn post-clean</strong> ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。</p>
<h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Site生命周期的各个阶段：</p>
<ul>
<li>pre-site   执行一些需要在生成站点文档之前完成的工作</li>
<li>site   生成项目的站点文档</li>
<li>post-site   执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li>
<li>site-deploy   将生成的站点文档部署到特定的服务器上</li>
</ul>
<h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h3><p>Maven的最重要的Default生命周期，绝大部分工作都发生在这个生命周期中，这里，我只解释一些比较重要和常用的阶段：</p>
<ul>
<li>validate</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources   复制并处理资源文件，至目标目录，准备打包。</li>
<li>compile   编译项目的源代码。</li>
<li>process-classes</li>
<li>generate-test-sources </li>
<li>process-test-sources </li>
<li>generate-test-resources</li>
<li>process-test-resources   复制并处理资源文件，至目标测试目录。</li>
<li>test-compile   编译测试源代码。</li>
<li>process-test-classes</li>
<li>test   使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</li>
<li>prepare-package</li>
<li>package   接受编译好的代码，打包成可发布的格式，如 JAR 。</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install   将包安装至本地仓库，以让其它项目依赖。</li>
<li>deploy   将最终的包复制到远程的仓库，以让其它开发人员与项目共享。</li>
</ul>
<h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>如果我们运行<code>mvn package</code>，Maven就会执行<code>default</code>生命周期，它会从开始一直运行到<code>package</code>这个phase为止。</p>
<p>Maven另一个常用的生命周期是<code>clean</code>，它会执行3个phase：</p>
<ul>
<li>pre-clean</li>
<li>clean （注意这个clean不是lifecycle而是phase）</li>
<li>post-clean</li>
</ul>
<p>经常使用的命令有：</p>
<p><code>mvn clean</code>：清理所有生成的class和jar；</p>
<p><code>mvn clean compile</code>：先清理，再执行到<code>compile</code>；</p>
<p><code>mvn clean test</code>：先清理，再执行到<code>test</code>，因为执行<code>test</code>前必须执行<code>compile</code>，所以这里不必指定<code>compile</code>；</p>
<p><code>mvn clean package</code>：先清理，再执行到<code>package</code>。</p>
<p>经常用到的phase：</p>
<ul>
<li>clean：清理</li>
<li>compile：编译</li>
<li>test：运行测试</li>
<li>package：打包</li>
</ul>
<h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><p>执行一个phase又会触发一个或多个goal：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">执行的Phase</th>
<th style="text-align:left">对应执行的Goal</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">compile</td>
<td style="text-align:left">compiler:compile</td>
</tr>
<tr>
<td style="text-align:left">test</td>
<td style="text-align:left">compiler:testCompile  surefire:test</td>
</tr>
</tbody>
</table>
</div>
<p>goal的命名总是<code>abc:xyz</code>这种形式。</p>
<p>其实我们类比一下就明白了：</p>
<ul>
<li>lifecycle相当于Java的package，它包含一个或多个phase；</li>
<li>phase相当于Java的class，它包含一个或多个goal；</li>
<li>goal相当于class的method，它其实才是真正干活的。</li>
</ul>
<p>大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn tomcat:run</span><br></pre></td></tr></table></figure>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>使用Maven实际上就是配置好需要使用的插件，然后通过phase调用它们。</p>
<p>Maven内置的插件：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">插件名称</th>
<th style="text-align:left">对应执行的phase</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">clean</td>
<td style="text-align:left">clean</td>
</tr>
<tr>
<td style="text-align:left">compiler</td>
<td style="text-align:left">compile</td>
</tr>
<tr>
<td style="text-align:left">surefire</td>
<td style="text-align:left">test</td>
</tr>
<tr>
<td style="text-align:left">jar</td>
<td style="text-align:left">package</td>
</tr>
</tbody>
</table>
</div>
<p>自定义插件，使用<code>maven-shade-plugin</code>可以创建一个可执行的jar，要使用这个插件，需要在<code>pom.xml</code>中声明它：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            ...</span><br><span class="line">						<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义插件往往需要一些配置，例如，<code>maven-shade-plugin</code>需要指定Java程序的入口，它的配置是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.itranswarp.learnjava.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，Maven自带的标准插件例如<code>compiler</code>是无需声明的，只有引入其它的插件才需要声明。</p>
<p>下面列举了一些常用的插件：</p>
<ul>
<li>maven-shade-plugin：打包所有依赖包并生成可执行jar；</li>
<li>cobertura-maven-plugin：生成单元测试覆盖率报告；</li>
<li>findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。</li>
</ul>
<h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><p>通常一个大的项目分为多个模块进行单独开发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutiple-project</span><br><span class="line">├── module-a</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── module-b</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── module-c</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure>
<p>Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的<code>pom.xml</code>。例如，模块A的<code>pom.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>模块B的<code>pom.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看出来，模块A和模块B的<code>pom.xml</code>高度相似，因此，我们可以提取出共同部分作为<code>parent</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到parent的<code>&lt;packaging&gt;</code>是<code>pom</code>而不是<code>jar</code>，因为<code>parent</code>本身不含任何Java代码。编写<code>parent</code>的<code>pom.xml</code>只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multiple-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── parent</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── module-a</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── module-b</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── module-c</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure>
<p>这样模块A就可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.itranswarp.learnjava&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&gt;..&#x2F;parent&#x2F;pom.xml&lt;&#x2F;relativePath&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;module-a&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line">    &lt;name&gt;module-a&lt;&#x2F;name&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<p>模块B、模块C都可以直接从<code>parent</code>继承，大幅简化了<code>pom.xml</code>的编写。</p>
<p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.itranswarp.learnjava&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;module-b&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>最后，在编译的时候，需要在根目录创建一个<code>pom.xml</code>统一编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;build&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span><br><span class="line">    &lt;name&gt;build&lt;&#x2F;name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;parent&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;module-a&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;module-b&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;module-c&lt;&#x2F;module&gt;</span><br><span class="line">    &lt;&#x2F;modules&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<p>这样，在根目录执行<code>mvn clean package</code>时，Maven根据根目录的<code>pom.xml</code>找到包括<code>parent</code>在内的共4个<code>&lt;module&gt;</code>，一次性全部编译。</p>
<h3 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h3><p>其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p>
<h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的<code>~/.m2/settings.xml</code>中配置好，使用方式和中央仓位没有任何区别。</p>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。</p>
<h2 id="使用mvnw"><a href="#使用mvnw" class="headerlink" title="使用mvnw"></a>使用mvnw</h2><p>使用特定版本的mvn：”Maven Wrapper”</p>
<p><strong>安装</strong></p>
<p>在项目的根目录运行安装命令：<code>mvn -N io.takari:maven:0.7.6:wrapper</code></p>
<p><strong>使用</strong></p>
<p>使用时，只需要把<code>mvn</code>替换为<code>mvnw</code>即可（linux或macos使用<code>./mvnw</code>）</p>
<h2 id="发布Artifact"><a href="#发布Artifact" class="headerlink" title="发布Artifact"></a>发布Artifact</h2><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1347981037010977" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1347981037010977</a></p>
<p>将自己的库发布到Maven的repo中：</p>
<p><strong>以静态文件发布</strong></p>
<p>现在生成到本地，然后上传到github，再制定repo</p>
<p><strong>使用Nexus发布到中央仓库</strong></p>
<p><strong>发布到私有仓库</strong></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><p>IPv4采用32位地址，类似<code>101.202.99.12</code>，而IPv6采用128位地址，类似<code>2001:0DA8:100A:0000:0000:1020:F2F3:1428</code>。</p>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────┐                                   ┌───────────┐</span><br><span class="line">│Application│                                   │Application│</span><br><span class="line">├───────────┤                                   ├───────────┤</span><br><span class="line">│  Socket   │                                   │  Socket   │</span><br><span class="line">├───────────┤                                   ├───────────┤</span><br><span class="line">│    TCP    │                                   │    TCP    │</span><br><span class="line">├───────────┤      ┌──────┐       ┌──────┐      ├───────────┤</span><br><span class="line">│    IP     │&lt;────&gt;│Router│&lt;─────&gt;│Router│&lt;────&gt;│    IP     │</span><br><span class="line">└───────────┘      └──────┘       └──────┘      └───────────┘</span><br></pre></td></tr></table></figure>
<p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p>
<p>服务器端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">"server is running..."</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Socket sock = ss.accept();</span><br><span class="line">            System.out.println(<span class="string">"connected from "</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            Thread t = <span class="keyword">new</span> Handler(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Socket sock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">this</span>.sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStream output = <span class="keyword">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"client disconnected."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input, StandardCharsets.UTF_8));</span><br><span class="line">        writer.write(<span class="string">"hello\n"</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            String s = reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">"bye"</span>)) &#123;</span><br><span class="line">                writer.write(<span class="string">"bye\n"</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(<span class="string">"ok: "</span> + s + <span class="string">"\n"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket sock = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line">        <span class="keyword">try</span> (InputStream input = sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStream output = sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.close();</span><br><span class="line">        System.out.println(<span class="string">"disconnected."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input, StandardCharsets.UTF_8));</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"[server] "</span> + reader.readLine());</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            System.out.print(<span class="string">"&gt;&gt;&gt; "</span>); <span class="comment">// 打印提示</span></span><br><span class="line">            String s = scanner.nextLine(); <span class="comment">// 读取一行输入</span></span><br><span class="line">            writer.write(s);</span><br><span class="line">            writer.newLine();</span><br><span class="line">            writer.flush(); <span class="comment">// 刷新缓冲区的数据</span></span><br><span class="line">            String resp = reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">"&lt;&lt;&lt; "</span> + resp);</span><br><span class="line">            <span class="keyword">if</span> (resp.equals(<span class="string">"bye"</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p><strong>服务器端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="comment">// 数据缓冲区:</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, buffer.length);</span><br><span class="line">    ds.receive(packet); <span class="comment">// 收取一个UDP数据包</span></span><br><span class="line">    <span class="comment">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度</span></span><br><span class="line">    <span class="comment">// 将其按UTF-8编码转换为String:</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="comment">// 发送数据:</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="string">"ACK"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    packet.setData(data);</span><br><span class="line">    ds.send(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">ds.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line">ds.connect(InetAddress.getByName(<span class="string">"localhost"</span>), <span class="number">6666</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line"><span class="comment">// 发送:</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="string">"Hello"</span>.getBytes();</span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data, data.length);</span><br><span class="line">ds.send(packet);</span><br><span class="line"><span class="comment">// 接收:</span></span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">packet = <span class="keyword">new</span> DatagramPacket(buffer, buffer.length);</span><br><span class="line">ds.receive(packet);</span><br><span class="line">String resp = <span class="keyword">new</span> String(packet.getData(), packet.getOffset(), packet.getLength());</span><br><span class="line">ds.disconnect();</span><br></pre></td></tr></table></figure>
<h2 id="发送Email"><a href="#发送Email" class="headerlink" title="发送Email"></a>发送Email</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             ┌─────────┐    ┌─────────┐    ┌─────────┐</span><br><span class="line">             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│</span><br><span class="line">┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐</span><br><span class="line">│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│</span><br><span class="line">├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤</span><br><span class="line">│       │───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│&lt;───│       │</span><br><span class="line">└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘</span><br><span class="line">   MUA           MTA            MTA            MDA           MUA</span><br></pre></td></tr></table></figure>
<p>类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。电子邮件一旦到达MDA，就不再动了。</p>
<p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。</p>
<p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，我们无需关心SMTP协议的底层原理，只需要使用JavaMail这个标准API就可以直接发送邮件。</p>
<p>首先，我们需要创建一个Maven工程，并把JavaMail相关的两个依赖加入进来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.mail&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javax.mail-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.sun.mail&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javax.mail&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>然后，我们通过JavaMail API连接到SMTP服务器上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务器地址:</span><br><span class="line">String smtp &#x3D; &quot;smtp.office365.com&quot;;</span><br><span class="line">&#x2F;&#x2F; 登录用户名:</span><br><span class="line">String username &#x3D; &quot;jxsmtp101@outlook.com&quot;;</span><br><span class="line">&#x2F;&#x2F; 登录口令:</span><br><span class="line">String password &#x3D; &quot;********&quot;;</span><br><span class="line">&#x2F;&#x2F; 连接到SMTP服务器587端口:</span><br><span class="line">Properties props &#x3D; new Properties();</span><br><span class="line">props.put(&quot;mail.smtp.host&quot;, smtp); &#x2F;&#x2F; SMTP主机名</span><br><span class="line">props.put(&quot;mail.smtp.port&quot;, &quot;587&quot;); &#x2F;&#x2F; 主机端口号</span><br><span class="line">props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;); &#x2F;&#x2F; 是否需要用户认证</span><br><span class="line">props.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;); &#x2F;&#x2F; 启用TLS加密</span><br><span class="line">&#x2F;&#x2F; 获取Session实例:</span><br><span class="line">Session session &#x3D; Session.getInstance(props, new Authenticator() &#123;</span><br><span class="line">    protected PasswordAuthentication getPasswordAuthentication() &#123;</span><br><span class="line">        return new PasswordAuthentication(username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 设置debug模式便于调试:</span><br><span class="line">session.setDebug(true);</span><br></pre></td></tr></table></figure>
<p>以587端口为例，连接SMTP服务器时，需要准备一个Properties对象，填入相关信息。最后获取Session实例时，如果服务器需要认证，还需要传入一个Authenticator对象，并返回指定的用户名和口令。</p>
<p>当我们获取到Session实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。</p>
<h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>发送邮件时，我们需要构造一个<code>Message</code>对象，然后调用<code>Transport.send(Message)</code>即可完成发送：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MimeMessage message &#x3D; new MimeMessage(session);</span><br><span class="line">&#x2F;&#x2F; 设置发送方地址:</span><br><span class="line">message.setFrom(new InternetAddress(&quot;me@example.com&quot;));</span><br><span class="line">&#x2F;&#x2F; 设置接收方地址:</span><br><span class="line">message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;xiaoming@somewhere.com&quot;));</span><br><span class="line">&#x2F;&#x2F; 设置邮件主题:</span><br><span class="line">message.setSubject(&quot;Hello&quot;, &quot;UTF-8&quot;);</span><br><span class="line">&#x2F;&#x2F; 设置邮件正文:</span><br><span class="line">message.setText(&quot;Hi Xiaoming...&quot;, &quot;UTF-8&quot;);</span><br><span class="line">&#x2F;&#x2F; 发送:</span><br><span class="line">Transport.send(message);</span><br></pre></td></tr></table></figure>
<p>绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。</p>
<h2 id="接收Email"><a href="#接收Email" class="headerlink" title="接收Email"></a>接收Email</h2><h2 id="HTTP编程"><a href="#HTTP编程" class="headerlink" title="HTTP编程"></a>HTTP编程</h2><h2 id="RMI远程调用-远程接口"><a href="#RMI远程调用-远程接口" class="headerlink" title="RMI远程调用(远程接口)"></a>RMI远程调用(远程接口)</h2><p>这部分内容使用时参见廖雪峰博客。</p>
<h1 id="XML与JSON"><a href="#XML与JSON" class="headerlink" title="XML与JSON"></a>XML与JSON</h1><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>由于使用了<code>&lt;</code>、<code>&gt;</code>以及引号等标识符，如果内容出现了特殊符号，需要使用<code>&amp;???;</code>表示转义。例如，<code>Java&lt;tm&gt;</code>必须写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;name&gt;Java&lt;tm&gt;&lt;&#x2F;name&gt;</span><br></pre></td></tr></table></figure>
<p>常见的特殊字符如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">&lt;</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">&gt;</td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">&amp;</td>
</tr>
<tr>
<td style="text-align:left">“</td>
<td style="text-align:left">&quot;</td>
</tr>
<tr>
<td style="text-align:left">‘</td>
<td style="text-align:left">&apos;</td>
</tr>
</tbody>
</table>
</div>
<p><strong>XML解析</strong></p>
<p>XML是一种树形结构的文档，它有两种标准的解析API：</p>
<ul>
<li>DOM：一次性读取XML，并在内存中表示为树形结构；</li>
<li>SAX：以流的形式读取XML，使用事件回调。</li>
</ul>
<p><strong>DOM</strong></p>
<p>Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容：</p>
<ul>
<li>Document：代表整个XML文档；</li>
<li>Element：代表一个XML元素；</li>
<li>Attribute：代表一个元素的某个属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = Main.class.getResourceAsStream("/book.xml");</span><br><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">Document doc = db.parse(input);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNode</span><span class="params">(Node n, <span class="keyword">int</span> indent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indent; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (n.getNodeType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> Node.DOCUMENT_NODE: <span class="comment">// Document节点</span></span><br><span class="line">        System.out.println(<span class="string">"Document: "</span> + n.getNodeName());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Node.ELEMENT_NODE: <span class="comment">// 元素节点</span></span><br><span class="line">        System.out.println(<span class="string">"Element: "</span> + n.getNodeName());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Node.TEXT_NODE: <span class="comment">// 文本</span></span><br><span class="line">        System.out.println(<span class="string">"Text: "</span> + n.getNodeName() + <span class="string">" = "</span> + n.getNodeValue());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Node.ATTRIBUTE_NODE: <span class="comment">// 属性</span></span><br><span class="line">        System.out.println(<span class="string">"Attr: "</span> + n.getNodeName() + <span class="string">" = "</span> + n.getNodeValue());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 其他</span></span><br><span class="line">        System.out.println(<span class="string">"NodeType: "</span> + n.getNodeType() + <span class="string">", NodeName: "</span> + n.getNodeName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node child = n.getFirstChild(); child != <span class="keyword">null</span>; child = child.getNextSibling()) &#123;</span><br><span class="line">        printNode(child, indent + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SAX</strong></p>
<p>SAX解析会触发一系列事件：</p>
<ul>
<li>startDocument：开始读取XML文档；</li>
<li>startElement：读取到了一个元素，例如<code>&lt;book&gt;</code>；</li>
<li>characters：读取到了字符；</li>
<li>endElement：读取到了一个结束的元素，例如<code>&lt;/book&gt;</code>；</li>
<li>endDocument：读取XML文档结束。</li>
</ul>
<p>如果我们用SAX API解析XML，Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = Main.class.getResourceAsStream("/book.xml");</span><br><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">SAXParser saxParser = spf.newSAXParser();</span><br><span class="line">saxParser.parse(input, <span class="keyword">new</span> MyHandler());</span><br></pre></td></tr></table></figure>
<p>关键代码<code>SAXParser.parse()</code>除了需要传入一个<code>InputStream</code>外，还需要传入一个回调对象，这个对象要继承自<code>DefaultHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">"start document"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">"end document"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">"start element:"</span>, localName, qName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">"end element:"</span>, localName, qName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">"characters:"</span>, <span class="keyword">new</span> String(ch, start, length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(SAXParseException e)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">"error:"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Object... objs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : objs) &#123;</span><br><span class="line">            System.out.print(obj);</span><br><span class="line">            System.out.print(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Jackson</strong></p>
<p>XML文档的结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;book id&#x3D;&quot;1&quot;&gt;</span><br><span class="line">    &lt;name&gt;Java核心技术&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;author&gt;Cay S. Horstmann&lt;&#x2F;author&gt;</span><br><span class="line">    &lt;isbn lang&#x3D;&quot;CN&quot;&gt;1234567&lt;&#x2F;isbn&gt;</span><br><span class="line">    &lt;tags&gt;</span><br><span class="line">        &lt;tag&gt;Java&lt;&#x2F;tag&gt;</span><br><span class="line">        &lt;tag&gt;Network&lt;&#x2F;tag&gt;</span><br><span class="line">    &lt;&#x2F;tags&gt;</span><br><span class="line">    &lt;pubDate&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;book&gt;</span><br></pre></td></tr></table></figure>
<p>我们发现，它完全可以对应到一个定义好的JavaBean中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String author;</span><br><span class="line">    <span class="keyword">public</span> String isbn;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; tags;</span><br><span class="line">    <span class="keyword">public</span> String pubDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Jackson的开源的第三方库可以轻松做到XML到JavaBean的转换。我们要使用Jackson，先添加两个Maven的依赖：</p>
<ul>
<li>com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.10.1</li>
<li>org.codehaus.woodstox:woodstox-core-asl:4.4.1</li>
</ul>
<p>然后，定义好JavaBean，就可以用下面几行代码解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = Main.class.getResourceAsStream("/book.xml");</span><br><span class="line">JacksonXmlModule <span class="keyword">module</span> = <span class="keyword">new</span> JacksonXmlModule();</span><br><span class="line">XmlMapper mapper = <span class="keyword">new</span> XmlMapper(<span class="keyword">module</span>);</span><br><span class="line">Book book = mapper.readValue(input, Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(book.id);</span><br><span class="line">System.out.println(book.name);</span><br><span class="line">System.out.println(book.author);</span><br><span class="line">System.out.println(book.isbn);</span><br><span class="line">System.out.println(book.tags);</span><br><span class="line">System.out.println(book.pubDate);</span><br></pre></td></tr></table></figure>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>一个典型的JSON如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Java核心技术"</span>,</span><br><span class="line">    <span class="attr">"author"</span>: &#123;</span><br><span class="line">        <span class="attr">"firstName"</span>: <span class="string">"Abc"</span>,</span><br><span class="line">        <span class="attr">"lastName"</span>: <span class="string">"Xyz"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"isbn"</span>: <span class="string">"1234567"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [<span class="string">"Java"</span>, <span class="string">"Network"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSON作为数据传输的格式，有几个显著的优点：</p>
<ul>
<li>JSON只允许使用UTF-8编码，不存在编码问题；</li>
<li>JSON只允许使用双引号作为key，特殊字符用<code>\</code>转义，格式简单；</li>
<li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li>
</ul>
<p>JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：</p>
<ul>
<li>键值对：<code>{&quot;key&quot;: value}</code></li>
<li>数组：<code>[1, 2, 3]</code></li>
<li>字符串：<code>&quot;abc&quot;</code></li>
<li>数值（整数和浮点数）：<code>12.34</code></li>
<li>布尔值：<code>true</code>或<code>false</code></li>
<li>空值：<code>null</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON string to JavaScript object:</span></span><br><span class="line">jsObj = JSON.parse(jsonStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript object to JSON string:</span></span><br><span class="line">jsonStr = JSON.stringify(jsObj);</span><br></pre></td></tr></table></figure>
<p>常用的用于解析JSON的第三方库有：</p>
<ul>
<li>Jackson</li>
<li>Gson</li>
<li>Fastjson</li>
<li>…</li>
</ul>
<p>只需要引入以下Maven依赖：</p>
<ul>
<li>com.fasterxml.jackson.core:jackson-databind:2.10.0</li>
</ul>
<p>就可以使用下面的代码解析一个JSON文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = Main.class.getResourceAsStream("/book.json");</span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">// 反序列化时忽略不存在的JavaBean属性:</span></span><br><span class="line">mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">Book book = mapper.readValue(input, Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>把JSON解析为JavaBean的过程称为反序列化。如果把JavaBean变为JSON，那就是序列化。要实现JavaBean到JSON的序列化，只需要一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json = mapper.writeValueAsString(book);</span><br></pre></td></tr></table></figure>
<p>要把JSON的某些值解析为特定的Java对象，例如<code>LocalDate</code>，也是完全可以的。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Java核心技术&quot;,</span><br><span class="line">    &quot;pubDate&quot;: &quot;2016-09-01&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要解析为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public LocalDate pubDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要引入标准的JSR 310关于JavaTime的数据格式定义至Maven：</p>
<ul>
<li>com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.10.0</li>
</ul>
<p>然后，在创建<code>ObjectMapper</code>时，注册一个新的<code>JavaTimeModule</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper().registerModule(new JavaTimeModule());</span><br></pre></td></tr></table></figure>
<p>有些时候，内置的解析规则和扩展的解析规则如果都不满足我们的需求，还可以自定义解析。</p>
<p>举个例子，假设<code>Book</code>类的<code>isbn</code>是一个<code>BigInteger</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">	public String name;</span><br><span class="line">	public BigInteger isbn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但JSON数据并不是标准的整形格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Java核心技术&quot;,</span><br><span class="line">    &quot;isbn&quot;: &quot;978-7-111-54742-6&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接解析，肯定报错。这时，我们需要自定义一个<code>IsbnDeserializer</code>，用于解析含有非数字的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsbnDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">BigInteger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">deserialize</span><span class="params">(JsonParser p, DeserializationContext ctxt)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">// 读取原始的JSON字符串内容:</span></span><br><span class="line">        String s = p.getValueAsString();</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(s.replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JsonParseException(p, s, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在<code>Book</code>类中使用注解标注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">// 表示反序列化isbn时使用自定义的IsbnDeserializer:</span></span><br><span class="line">    <span class="meta">@JsonDeserialize</span>(using = IsbnDeserializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">BigInteger</span> <span class="title">isbn</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，自定义序列化时我们需要自定义一个<code>IsbnSerializer</code>，然后在<code>Book</code>类中标注<code>@JsonSerialize(using = ...)</code>即可。</p>
<h1 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h1><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>函数式编程最早是数学家<a href="https://zh.wikipedia.org/wiki/阿隆佐·邱奇" target="_blank" rel="noopener">阿隆佐·邱奇</a>研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = <span class="keyword">new</span> String[] &#123; <span class="string">"Apple"</span>, <span class="string">"Orange"</span>, <span class="string">"Banana"</span>, <span class="string">"Lemon"</span> &#125;;</span><br><span class="line">        Arrays.sort(array, (s1, s2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(String.join(<span class="string">", "</span>, array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>FunctionalInterface</strong></p>
<p>只定义了单方法的接口称之为<code>FunctionalInterface</code>，用注解<code>@FunctionalInterface</code>标记。</p>
<blockquote>
<p>对于模板类，如果只有一个抽象方法，也可以用FunctionalInterface注解。</p>
</blockquote>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p><strong>方法引用</strong>：如果某个方法的签名和接口恰好一致，就可以直接传入方法引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = <span class="keyword">new</span> String[] &#123; <span class="string">"Apple"</span>, <span class="string">"Orange"</span>, <span class="string">"Banana"</span>, <span class="string">"Lemon"</span> &#125;;</span><br><span class="line">        Arrays.sort(array, Main::cmp);</span><br><span class="line">        System.out.println(String.join(<span class="string">", "</span>, array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造方法引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"Tim"</span>);</span><br><span class="line">        List&lt;Person&gt; persons = names.stream().map(Person::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person:"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用Stream</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">java.io</th>
<th style="text-align:left">java.util.stream</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">存储</td>
<td style="text-align:left">顺序读写的<code>byte</code>或<code>char</code></td>
<td style="text-align:left">顺序输出的任意Java对象实例</td>
</tr>
<tr>
<td style="text-align:left">用途</td>
<td style="text-align:left">序列化至文件或网络</td>
<td style="text-align:left">内存计算／业务逻辑</td>
</tr>
</tbody>
</table>
</div>
<p><code>List</code>的用途是操作一组已存在的Java对象，而<code>Stream</code>实现的是惰性计算，两者对比如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">java.util.List</th>
<th style="text-align:left">java.util.stream</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">元素</td>
<td style="text-align:left">已分配并存储在内存</td>
<td style="text-align:left">可能未分配，实时计算</td>
</tr>
<tr>
<td style="text-align:left">用途</td>
<td style="text-align:left">操作一组已存在的Java对象</td>
<td style="text-align:left">惰性计算</td>
</tr>
</tbody>
</table>
</div>
<p>Stream可以储存有限或无限个元素。</p>
<p>Stream API的基本用法就是：创建一个<code>Stream</code>，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result = createNaturalStream() <span class="comment">// 创建Stream</span></span><br><span class="line">             .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .map(n -&gt; n * n) <span class="comment">// 任意个转换</span></span><br><span class="line">             .limit(<span class="number">100</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .sum(); <span class="comment">// 最终计算结果</span></span><br></pre></td></tr></table></figure>
<h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><p><strong>Stream.of()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>);</span><br><span class="line"><span class="comment">// forEach()方法相当于内部循环调用，</span></span><br><span class="line"><span class="comment">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span></span><br><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><strong>基于数组或Collection</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream1 = Arrays.stream(<span class="keyword">new</span> String[] &#123; <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span> &#125;);</span><br><span class="line">Stream&lt;String&gt; stream2 = List.of(<span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span>).stream();</span><br><span class="line">stream1.forEach(System.out::println);</span><br><span class="line">stream2.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><strong>基于Supplier</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; natual = Stream.generate(<span class="keyword">new</span> NatualSupplier());</span><br><span class="line">        <span class="comment">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class="line">        natual.limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NatualSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其他方法</strong></p>
<p>使用API提供的接口，直接获得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"/path/to/file.tct"</span>)))&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"\\s+"</span>);</span><br><span class="line">Stream&lt;String&gt; s = p.splitAsStream(<span class="string">"The quick brown fox jumps over the lazy dog"</span>);</span><br><span class="line">s.forEach(...);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于java的范型不支持基本类型，如果使用Stream<Integer>就会产生频繁的装箱、拆箱操作。为了提高效率，java标准库提供了IntStream\LongStream\DoubleStream这三种使用基本类型的Stream。</p>
</blockquote>
<h3 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h3><p>Map:将一个Stream转换为另一个Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);</span><br></pre></td></tr></table></figure>
<h3 id="使用filter"><a href="#使用filter" class="headerlink" title="使用filter"></a>使用filter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">    .filter(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="使用reduce"><a href="#使用reduce" class="headerlink" title="使用reduce"></a>使用reduce</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>).reduce(<span class="number">0</span>, (acc, n) -&gt; acc + n);</span><br><span class="line">System.out.println(sum); <span class="comment">// 45</span></span><br></pre></td></tr></table></figure>
<p><strong>综合使用案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按行读取配置文件:</span></span><br><span class="line">        List&lt;String&gt; props = List.of(<span class="string">"profile=native"</span>, <span class="string">"debug=true"</span>, <span class="string">"logging=warn"</span>, <span class="string">"interval=500"</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = props.stream()</span><br><span class="line">                <span class="comment">// 把k=v转换为Map[k]=v:</span></span><br><span class="line">                .map(kv -&gt; &#123;</span><br><span class="line">                    String[] ss = kv.split(<span class="string">"\\="</span>, <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">return</span> Map.of(ss[<span class="number">0</span>], ss[<span class="number">1</span>]);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 把所有Map聚合到一个Map:</span></span><br><span class="line">                .reduce(<span class="keyword">new</span> HashMap&lt;String, String&gt;(), (m, kv) -&gt; &#123;</span><br><span class="line">                    m.putAll(kv);</span><br><span class="line">                    <span class="keyword">return</span> m;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 打印结果:</span></span><br><span class="line">        map.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">" = "</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出集合"><a href="#输出集合" class="headerlink" title="输出集合"></a>输出集合</h3><p><strong>输出为List</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Apple"</span>,<span class="string">""</span>,<span class="keyword">null</span>,<span class="string">"Pear"</span>,<span class="string">" "</span>,<span class="string">"Orange"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.filter(s -&gt; s!=<span class="keyword">null</span> &amp;&amp; !s.isBlank()).collect(Collections.toList());</span><br></pre></td></tr></table></figure>
<p><strong>输出为数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>);</span><br><span class="line">String[] array = list.stream().toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p><strong>输出为Map</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"APPL:Apple"</span>, <span class="string">"MSFT:Microsoft"</span>);</span><br><span class="line">Map&lt;String, String&gt; map = stream</span><br><span class="line">    .collect(Collectors.toMap(</span><br><span class="line">        <span class="comment">// 把元素s映射为key:</span></span><br><span class="line">        s -&gt; s.substring(<span class="number">0</span>, s.indexOf(<span class="string">':'</span>)),</span><br><span class="line">        <span class="comment">// 把元素s映射为value:</span></span><br><span class="line">        s -&gt; s.substring(s.indexOf(<span class="string">':'</span>) + <span class="number">1</span>)));</span><br></pre></td></tr></table></figure>
<p><strong>分组输出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Blackberry"</span>, <span class="string">"Coconut"</span>, <span class="string">"Avocado"</span>, <span class="string">"Cherry"</span>, <span class="string">"Apricots"</span>);</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>), Collectors.toList()));</span><br><span class="line">System.out.println(groups);</span><br></pre></td></tr></table></figure>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序</span></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">"Orange"</span>, <span class="string">"apple"</span>, <span class="string">"Banana"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">"Orange"</span>, <span class="string">"apple"</span>, <span class="string">"Banana"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted(String::compareToIgnoreCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//去重</span></span><br><span class="line">List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"D"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [A, B, C, D]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//截取</span></span><br><span class="line">List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .skip(<span class="number">2</span>) <span class="comment">// 跳过A, B</span></span><br><span class="line">    .limit(<span class="number">3</span>) <span class="comment">// 截取C, D, E</span></span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [C, D, E]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line">Stream&lt;String&gt; s1 = List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).stream();</span><br><span class="line">Stream&lt;String&gt; s2 = List.of(<span class="string">"D"</span>, <span class="string">"E"</span>).stream();</span><br><span class="line">Stream&lt;String&gt; s = Stream.concat(s1, s2);</span><br><span class="line">System.out.println(s.collect(Collectors.toList())); <span class="comment">// [A, B, C, D, E]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flatMap</span></span><br><span class="line">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</span><br><span class="line"></span><br><span class="line"><span class="comment">//并行</span></span><br><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">String[] result = s.parallel() <span class="comment">// 变成一个可以并行处理的Stream</span></span><br><span class="line">                   .sorted() <span class="comment">// 可以进行并行排序</span></span><br><span class="line">                   .toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<h3 id="其他聚合方法"><a href="#其他聚合方法" class="headerlink" title="其他聚合方法"></a>其他聚合方法</h3><p>除了<code>reduce()</code>和<code>collect()</code>外，<code>Stream</code>还有一些常用的聚合方法：</p>
<ul>
<li><code>count()</code>：用于返回元素个数；</li>
<li><code>max(Comparator&lt;? super T&gt; cp)</code>：找出最大元素；</li>
<li><code>min(Comparator&lt;? super T&gt; cp)</code>：找出最小元素。</li>
</ul>
<p>针对<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>，还额外提供了以下聚合方法：</p>
<ul>
<li><code>sum()</code>：对所有元素求和；</li>
<li><code>average()</code>：对所有元素求平均数。</li>
</ul>
<p>还有一些方法，用来测试<code>Stream</code>的元素是否满足以下条件：</p>
<ul>
<li><code>boolean allMatch(Predicate&lt;? super T&gt;)</code>：测试是否所有元素均满足测试条件；</li>
<li><code>boolean anyMatch(Predicate&lt;? super T&gt;)</code>：测试是否至少有一个元素满足测试条件。</li>
</ul>
<p>最后一个常用的方法是<code>forEach()</code>，它可以循环处理<code>Stream</code>的每个元素，我们经常传入<code>System.out::println</code>来打印<code>Stream</code>的元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s &#x3D; ...</span><br><span class="line">s.forEach(str -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;Hello, &quot; + str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式基于OOP编程提炼，基于以下几个原则：</p>
<ul>
<li><strong>开闭原则</strong>：软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</li>
<li><strong>里氏替换原则</strong>：如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</li>
</ul>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式包括：</p>
<ul>
<li>工厂方法：Factory Method</li>
<li>抽象工厂：Abstract Factory</li>
<li>建造者：Builder</li>
<li>原型：Prototype</li>
<li>单例：Singleton</li>
</ul>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p>
</blockquote>
<p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│   Product   │      │   Factory   │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br><span class="line">       ▲                    ▲</span><br><span class="line">       │                    │</span><br><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NumberFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建方法</span></span><br><span class="line">    <span class="function">Number <span class="title">parse</span><span class="params">(String s)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取工厂实例</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NumberFactory <span class="title">getFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> impl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> NumberFactory impl = <span class="keyword">new</span> NumberFactoryImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFactoryImpl</span> <span class="keyword">implements</span> <span class="title">NumberFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">parse</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种形式(静态工厂方法)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">parse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p>
</blockquote>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</blockquote>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeadingBuilder headingBuilder = <span class="keyword">new</span> HeadingBuilder();</span><br><span class="line">    <span class="keyword">private</span> HrBuilder hrBuilder = <span class="keyword">new</span> HrBuilder();</span><br><span class="line">    <span class="keyword">private</span> ParagraphBuilder paragraphBuilder = <span class="keyword">new</span> ParagraphBuilder();</span><br><span class="line">    <span class="keyword">private</span> QuoteBuilder quoteBuilder = <span class="keyword">new</span> QuoteBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHtml</span><span class="params">(String markdown)</span> </span>&#123;</span><br><span class="line">        StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        markdown.lines().forEach(line -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.startsWith(<span class="string">"#"</span>)) &#123;</span><br><span class="line">                buffer.append(headingBuilder.buildHeading(line)).append(<span class="string">'\n'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"&gt;"</span>)) &#123;</span><br><span class="line">                buffer.append(quoteBuilder.buildQuote(line)).append(<span class="string">'\n'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"---"</span>)) &#123;</span><br><span class="line">                buffer.append(hrBuilder.buildHr(line)).append(<span class="string">'\n'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer.append(paragraphBuilder.buildParagraph(line)).append(<span class="string">'\n'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote>
<p><em>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</em></p>
</blockquote>
<p>原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。</p>
<p>我们举个例子：如果我们已经有了一个<code>String[]</code>数组，想再创建一个一模一样的<code>String[]</code>数组，怎么写？</p>
<p>实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型:</span></span><br><span class="line">String[] original = &#123; <span class="string">"Apple"</span>, <span class="string">"Pear"</span>, <span class="string">"Banana"</span> &#125;;</span><br><span class="line"><span class="comment">// 新对象:</span></span><br><span class="line">String[] copy = Arrays.copyOf(original, original.length);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用原型模式更好的方式是定义一个copy()方法，返回明确的类型：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student std = <span class="keyword">new</span> Student();</span><br><span class="line">        std.id = <span class="keyword">this</span>.id;</span><br><span class="line">        std.name = <span class="keyword">this</span>.name;</span><br><span class="line">        std.score = <span class="keyword">this</span>.score;</span><br><span class="line">        <span class="keyword">return</span> std;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态方法返回实例:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种实现Singleton的方式是利用Java的<code>enum</code>，因为Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> World &#123;</span><br><span class="line">    <span class="comment">// 唯一枚举:</span></span><br><span class="line">	INSTANCE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String name = World.INSTANCE.getName();</span><br></pre></td></tr></table></figure>
<p>通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code>new</code>操作符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 表示一个单例组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>延迟加载</strong></p>
<p>延迟加载，即在调用方第一次调用<code>getInstance()</code>时才初始化全局唯一实例，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton INSTANCE &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">            INSTANCE &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遗憾的是，这种写法在多线程中是错误的，在竞争条件下会创建出多个实例。必须对整个方法进行加锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized static Singleton getInstance() &#123;</span><br><span class="line">    if (INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">        INSTANCE &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但加锁会严重影响并发性能。还有些童鞋听说过双重检查，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    if (INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (Singleton.class) &#123;</span><br><span class="line">            if (INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">                INSTANCE &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，由于Java的内存模型，双重检查在这里不成立。要真正实现延迟加载，只能通过Java的ClassLoader机制完成。如果没有特殊的需求，使用Singleton模式的时候，最好不要延迟加载，这样会使代码更简单。</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式有：</p>
<ul>
<li>适配器</li>
<li>桥接</li>
<li>组合</li>
<li>装饰器</li>
<li>外观</li>
<li>享元</li>
<li>代理</li>
</ul>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><blockquote>
<p><em>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用待转换接口:</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;?&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableAdapter</span><span class="params">(Callable&lt;?&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现指定接口:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将指定接口调用委托给转换接口调用:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callable.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><blockquote>
<p> <em>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</em></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ┌───────────┐</span><br><span class="line">       │    Car    │</span><br><span class="line">       └───────────┘</span><br><span class="line">             ▲</span><br><span class="line">             │</span><br><span class="line">       ┌───────────┐       ┌─────────┐</span><br><span class="line">       │RefinedCar │ ─ ─ ─&gt;│ Engine  │</span><br><span class="line">       └───────────┘       └─────────┘</span><br><span class="line">             ▲                  ▲</span><br><span class="line">    ┌────────┼────────┐         │ ┌──────────────┐</span><br><span class="line">    │        │        │         ├─│  FuelEngine  │</span><br><span class="line">┌───────┐┌───────┐┌───────┐     │ └──────────────┘</span><br><span class="line">│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐</span><br><span class="line">└───────┘└───────┘└───────┘     ├─│ElectricEngine│</span><br><span class="line">                                │ └──────────────┘</span><br><span class="line">                                │ ┌──────────────┐</span><br><span class="line">                                └─│ HybridEngine │</span><br><span class="line">                                  └──────────────┘</span><br></pre></td></tr></table></figure>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote>
<p><em>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</em></p>
</blockquote>
<p>使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │   Node    │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼────────────┐</span><br><span class="line">      │            │            │</span><br><span class="line">┌───────────┐┌───────────┐┌───────────┐</span><br><span class="line">│ElementNode││ TextNode  ││CommentNode│</span><br><span class="line">└───────────┘└───────────┘└───────────┘</span><br></pre></td></tr></table></figure>
<blockquote>
<p>组合模式一般用于层级结构</p>
</blockquote>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote>
<p><em>动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。</em></p>
</blockquote>
<p>给<code>FileInputStream</code>增加缓冲和解压缩功能，用Decorator模式写出来如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建原始的数据源:</span><br><span class="line">InputStream fis &#x3D; new FileInputStream(&quot;test.gz&quot;);</span><br><span class="line">&#x2F;&#x2F; 增加缓冲功能:</span><br><span class="line">InputStream bis &#x3D; new BufferedInputStream(fis);</span><br><span class="line">&#x2F;&#x2F; 增加解压缩功能:</span><br><span class="line">InputStream gis &#x3D; new GZIPInputStream(bis);</span><br></pre></td></tr></table></figure>
<p>或者一次性写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> GZIPInputStream( <span class="comment">// 第二层装饰</span></span><br><span class="line">                        <span class="keyword">new</span> BufferedInputStream( <span class="comment">// 第一层装饰</span></span><br><span class="line">                            <span class="keyword">new</span> FileInputStream(<span class="string">"test.gz"</span>) <span class="comment">// 核心功能</span></span><br><span class="line">                        ));</span><br></pre></td></tr></table></figure>
<p><strong>设计自己的装饰器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TextNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置text:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span>;</span><br><span class="line">    <span class="comment">// 获取text:</span></span><br><span class="line">    <span class="function">String <span class="title">getText</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeDecorator</span> <span class="keyword">implements</span> <span class="title">TextNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TextNode target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">NodeDecorator</span><span class="params">(TextNode target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target.setText(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoldDecorator</span> <span class="keyword">extends</span> <span class="title">NodeDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoldDecorator</span><span class="params">(TextNode target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;b&gt;"</span> + target.getText() + <span class="string">"&lt;/b&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><blockquote>
<p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<p>它的基本思想如下：</p>
<p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p>
<h3 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h3><blockquote>
<p><em>运用共享技术有效地支持大量细粒度的对象。</em></p>
</blockquote>
<p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有缓存:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Student&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">create</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        String key = id + <span class="string">"\n"</span> + name;</span><br><span class="line">        <span class="comment">// 先查找缓存:</span></span><br><span class="line">        Student std = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (std == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 未找到,创建新对象:</span></span><br><span class="line">            System.out.println(String.format(<span class="string">"create new Student(%s, %s)"</span>, id, name));</span><br><span class="line">            std = <span class="keyword">new</span> Student(id, name);</span><br><span class="line">            <span class="comment">// 放入缓存:</span></span><br><span class="line">            cache.put(key, std);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存中存在:</span></span><br><span class="line">            System.out.println(String.format(<span class="string">"return cached Student(%s, %s)"</span>, std.id, std.name));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><blockquote>
<p><em>为其他对象提供一种代理以控制对这个对象的访问。</em></p>
</blockquote>
<p>Adapter模式，它用于把A接口转换为B接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BAdapter implements B &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BAdapter</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AProxy implements A &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AProxy</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用Proxy实现权限检查，我们可以获得更清晰、更简洁的代码：</p>
<ul>
<li>A接口：只定义接口；</li>
<li>ABusiness类：只实现A接口的业务逻辑；</li>
<li>APermissionProxy类：只实现A接口的权限检查代理。</li>
</ul>
<p>如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。</p>
<p><strong>远程代理、虚代理、保护代理</strong></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p>
<p>行为型模式有：</p>
<ul>
<li>责任链</li>
<li>命令</li>
<li>解释器</li>
<li>迭代器</li>
<li>中介</li>
<li>备忘录</li>
<li>观察者</li>
<li>状态</li>
<li>策略</li>
<li>模板方法</li>
<li>访问者</li>
</ul>
<h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</blockquote>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><blockquote>
<p><em>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</em></p>
</blockquote>
<p>解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。举个例子，针对以下的匹配条件：</p>
<ul>
<li>以<code>+</code>开头的数字表示的区号和电话号码，如<code>+861012345678</code>；</li>
<li>以英文开头，后接英文和数字，并以.分隔的域名，如<code>www.liaoxuefeng.com</code>；</li>
<li>以<code>/</code>开头的文件路径，如<code>/path/to/file.txt</code>；</li>
<li>…</li>
</ul>
<p>因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p>
<p>实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; &quot;+861012345678&quot;;</span><br><span class="line">System.out.println(s.matches(&quot;^\\+\\d+$&quot;));</span><br></pre></td></tr></table></figure>
<p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><blockquote>
<p><em>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</em></p>
</blockquote>
<h3 id="中介"><a href="#中介" class="headerlink" title="中介"></a>中介</h3><blockquote>
<p><em>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</em></p>
</blockquote>
<p>例如可以用于多个界面控件。 </p>
<h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><blockquote>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
</blockquote>
<p>备忘录模式是为了保存对象的内部状态，并在将来恢复，大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。</p>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><blockquote>
<p>备忘录模式是为了保存对象的内部状态，并在将来恢复，大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。</p>
</blockquote>
<p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────┐      ┌───────────────┐</span><br><span class="line">│  Store  │─ ─ ─&gt;│ProductObserver│</span><br><span class="line">└─────────┘      └───────────────┘</span><br><span class="line">     │                   ▲</span><br><span class="line">                         │</span><br><span class="line">     │             ┌─────┴─────┐</span><br><span class="line">     ▼             │           │</span><br><span class="line">┌─────────┐   ┌─────────┐ ┌─────────┐</span><br><span class="line">│ Product │   │  Admin  │ │Customer │ ...</span><br><span class="line">└─────────┘   └─────────┘ └─────────┘</span><br></pre></td></tr></table></figure>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>状态模式的设计思想是把不同状态的逻辑分离到不同的状态类中，从而使得增加新状态更容易；</p>
<p>状态模式的实现关键在于状态转换。简单的状态转换可以直接由调用方指定，复杂的状态转换可以在内部根据条件触发完成。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><blockquote>
<p><em>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</em></p>
</blockquote>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><blockquote>
<p><em>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</em></p>
</blockquote>
<h3 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h3><blockquote>
<p><em>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</em></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2020/06/29/JavaScript/</url>
    <content><![CDATA[<h1 id="JavaScript-的基础"><a href="#JavaScript-的基础" class="headerlink" title="JavaScript 的基础"></a><a href="https://www.cnblogs.com/yuanchenqi/articles/5980312.html" target="_blank" rel="noopener">JavaScript 的基础</a></h1><a id="more"></a>
<p><em>知识预览</em></p>
<ul>
<li><a href="https://www.cnblogs.com/yuanchenqi/articles/5980312.html#_label0" target="_blank" rel="noopener">BOM对象</a></li>
<li><a href="https://www.cnblogs.com/yuanchenqi/articles/5980312.html#_label1" target="_blank" rel="noopener">DOM对象(DHTML)</a></li>
<li><a href="https://www.cnblogs.com/yuanchenqi/articles/5980312.html#_label2" target="_blank" rel="noopener">8 实例练习</a></li>
</ul>
<h2 id="JavaScript概述"><a href="#JavaScript概述" class="headerlink" title="JavaScript概述"></a>JavaScript概述</h2><h3 id="JavaScript的历史"><a href="#JavaScript的历史" class="headerlink" title="JavaScript的历史"></a><strong>JavaScript的历史</strong></h3><ul>
<li>1992年Nombas开发出C-minus-minus(C—)的嵌入式脚本语言(最初绑定在CEnvi软件中).后将其改名ScriptEase.(客户端执行的语言)</li>
<li>Netscape(网景)接收Nombas的理念,(Brendan Eich)在其Netscape Navigator 2.0产品中开发出一套livescript的脚本语言.Sun和Netscape共同完成.后改名叫Javascript</li>
<li>微软随后模仿在其IE3.0的产品中搭载了一个JavaScript的克隆版叫Jscript.</li>
<li>为了统一三家,ECMA(欧洲计算机制造协会)定义了ECMA-262规范.国际标准化组织及国际电工委员会（ISO/IEC）也采纳 ECMAScript 作为标准（ISO/IEC-16262）。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。EcmaScript是规范.</li>
</ul>
<h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a><strong>ECMAScript</strong></h3><p>尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：</p>
<ul>
<li>核心（ECMAScript） </li>
<li>文档对象模型（DOM） Document object model (整合js，css，html)</li>
<li>浏览器对象模型（BOM） Broswer object model（整合js和浏览器）</li>
<li>Javascript 在开发中绝大多数情况是基于对象的.也是面向对象的. </li>
</ul>
<p>​         <img src="image/877318-20161023211134529-32650400.png" alt="img"></p>
<p>简单地说，ECMAScript 描述了以下内容：</p>
<ul>
<li>语法 </li>
<li>类型 </li>
<li>语句 </li>
<li>关键字 </li>
<li>保留字 </li>
<li>运算符 </li>
<li>对象 (封装 继承 多态) 基于对象的语言.使用对象.</li>
</ul>
<h3 id="JavaScript的引入方式"><a href="#JavaScript的引入方式" class="headerlink" title="JavaScript的引入方式"></a>JavaScript的引入方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;#1 直接编写#&#125;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        alert(&#39;hello yuan&#39;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&#123;#2 导入文件#&#125;</span><br><span class="line">    &lt;script src&#x3D;&quot;hello.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="二-JavaScript的基础"><a href="#二-JavaScript的基础" class="headerlink" title="二 JavaScript的基础"></a>二 JavaScript的基础</h2><h3 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;5</span><br><span class="line">y&#x3D;6</span><br><span class="line">z&#x3D;x+y</span><br></pre></td></tr></table></figure>
<p>在代数中，我们使用字母（比如 x）来保存值（比如 5）。</p>
<p>通过上面的表达式 z=x+y，我们能够计算出 z 的值为 11。</p>
<p>在 JavaScript 中，这些字母被称为变量。</p>
<p>0 变量是弱类型的(很随便)；</p>
<p>1 声明变量时不用声明变量类型. 全都使用var关键字;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a;</span><br></pre></td></tr></table></figure>
<p>2 一行可以声明多个变量.并且可以是不同类型.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name&#x3D;&quot;yuan&quot;, age&#x3D;20, job&#x3D;&quot;lecturer&quot;;</span><br></pre></td></tr></table></figure>
<p>3 (了解) <strong>声明变量时 可以不用var. 如果不用var 那么它是全局变量.</strong></p>
<p>4 变量命名,首字符只能是字母,下划线,$美元符 三选一，且区分大小写，x与X是两个变量</p>
<p>5 变量还应遵守以下某条著名的命名规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Camel 标记法</span><br><span class="line">首字母是小写的，接下来的字母都以大写字符开头。例如：</span><br><span class="line">var myTestValue &#x3D; 0, mySecondValue &#x3D; &quot;hi&quot;;</span><br><span class="line">Pascal 标记法</span><br><span class="line">首字母是大写的，接下来的字母都以大写字符开头。例如：</span><br><span class="line">Var MyTestValue &#x3D; 0, MySecondValue &#x3D; &quot;hi&quot;;</span><br><span class="line">匈牙利类型标记法</span><br><span class="line">在以 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。例如，i 表示整数，s 表示字符串，如下所示“</span><br><span class="line">Var iMyTestValue &#x3D; 0, sMySecondValue &#x3D; &quot;hi&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    function func1()&#123;</span><br><span class="line">        </span><br><span class="line">        var a &#x3D; 123;</span><br><span class="line">        b&#x3D;456</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func1();</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;    alert(a);</span><br><span class="line">&#x2F;&#x2F;    alert(b);</span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br></pre></td></tr></table></figure>
<h3 id="2-2-基础规范"><a href="#2-2-基础规范" class="headerlink" title="2.2 基础规范"></a>2.2 基础规范</h3><p>1 每行结束可以不加分号. 没有分号会以换行符作为每行的结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;1;b&#x3D;2;</span><br><span class="line">a&#x3D;1 b&#x3D;2;------错误</span><br><span class="line"></span><br><span class="line">a&#x3D;1</span><br><span class="line">b&#x3D;2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;推荐</span><br><span class="line">a&#x3D;1;</span><br><span class="line">b&#x3D;2;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> a&#x3D;1;</span><br><span class="line"> b&#x3D;2;</span><br><span class="line">    &#x2F;&#x2F;推荐加tab</span><br><span class="line">    a&#x3D;1;</span><br><span class="line">    b&#x3D;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 注释 支持多行注释和单行注释. /<em> </em>/  //</p>
<p>3 <strong>使用{}来封装代码块</strong></p>
<h3 id="2-3-常量和标识符"><a href="#2-3-常量和标识符" class="headerlink" title="2.3 常量和标识符"></a>2.3 常量和标识符</h3><p><strong>常量</strong> ：直接在程序中出现的数据值</p>
<p><strong>标识符</strong>：</p>
<ol>
<li>由不以数字开头的字母、数字、下划线(_)、美元符号($)组成</li>
<li>常用于表示函数、变量等的名称</li>
<li>例如：_abc,$abc,abc,abc123是标识符，而1abc不是</li>
<li>JavaScript语言中代表特定含义的词称为保留字，不允许程序再定义为标识符</li>
</ol>
<p>​         <img src="image/877318-20161020152532717-389530735.png" alt="img"></p>
<p>​           <img src="image/877318-20161020153916560-1468649784.png" alt="img"></p>
<h3 id="2-4-数据类型"><a href="#2-4-数据类型" class="headerlink" title="2.4 数据类型"></a>2.4 数据类型</h3><p>​            <img src="image/877318-20161023225846513-154917493.png" alt="img">     <a href="image">image</a> <img src="image/877318-20161023224930873-196677017.png" alt="img">    </p>
<h4 id="数字类型-Number"><a href="#数字类型-Number" class="headerlink" title="数字类型(Number)"></a>数字类型(Number)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介</span><br><span class="line">最基本的数据类型</span><br><span class="line">不区分整型数值和浮点型数值</span><br><span class="line">所有数字都采用64位浮点格式存储，相当于Java和C语言中的double格式</span><br><span class="line">能表示的最大值是±1.7976931348623157 x 10308 </span><br><span class="line">能表示的最小值是±5 x 10 -324</span><br></pre></td></tr></table></figure>
<p>   整数：<br>           在JavaScript中10进制的整数由数字的序列组成<br>           精确表达的范围是-9007199254740992 (-253) 到 9007199254740992 (253)<br>           超出范围的整数，精确度将受影响<br>  浮点数：<br>           使用小数点记录数据<br>           例如：3.4，5.6<br>           使用指数记录数据<br>           例如：4.3e23 = 4.3 x 1023</p>
<p>  16进制和8进制数的表达<br>           16进制数据前面加上0x，八进制前面加0<br>           16进制数是由0-9,A-F等16个字符组成<br>           8进制数由0-7等8个数字组成<br>           16进制和8进制与2进制的换算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 2进制: 1111 0011 1101 0100   &lt;-----&gt; 16进制:0xF3D4 &lt;-----&gt; 10进制:62420</span><br><span class="line"># 2进制: 1 111 001 111 010 100 &lt;-----&gt; 8进制:0171724</span><br></pre></td></tr></table></figure>
<h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介</span><br><span class="line">是由Unicode字符、数字、标点符号组成的序列</span><br><span class="line">字符串常量首尾由单引号或双引号括起</span><br><span class="line">JavaScript中没有字符类型</span><br><span class="line">常用特殊字符在字符串中的表达</span><br><span class="line">字符串中部分特殊字符必须加上右划线\</span><br><span class="line">常用的转义字符 \n:换行  \&#39;:单引号   \&quot;:双引号  \\:右划线</span><br></pre></td></tr></table></figure>
<p>String数据类型的使用</p>
<ul>
<li>特殊字符的使用方法和效果</li>
<li>Unicode的插入方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        var str&#x3D;&quot;\u4f60\u597d\n欢迎来到\&quot;JavaScript世界\&quot;&quot;;</span><br><span class="line">        alert(str);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="布尔型-Boolean"><a href="#布尔型-Boolean" class="headerlink" title="布尔型(Boolean)"></a>布尔型(Boolean)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介</span><br><span class="line">Boolean类型仅有两个值：true和false，也代表1和0，实际运算中true&#x3D;1,false&#x3D;0</span><br><span class="line">布尔值也可以看作on&#x2F;off、yes&#x2F;no、1&#x2F;0对应true&#x2F;false</span><br><span class="line">Boolean值主要用于JavaScript的控制语句，例如</span><br><span class="line">    if (x&#x3D;&#x3D;1)&#123;</span><br><span class="line">    y&#x3D;y+1;</span><br><span class="line">    &#125;else    &#123;</span><br><span class="line">    y&#x3D;y-1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Null-amp-Undefined"><a href="#Null-amp-Undefined" class="headerlink" title="Null &amp; Undefined"></a>Null &amp; Undefined</h4><p><strong>Undefined 类型</strong></p>
<p>Undefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。</p>
<p>当函数无明确返回值时，返回的也是值 “undefined”;</p>
<p><strong>Null 类型</strong></p>
<p>另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。</p>
<p>尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。</p>
<p>var person=new Person()</p>
<p>var person=null</p>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JavaScript属于松散类型的程序语言</span><br><span class="line">变量在声明的时候并不需要指定数据类型</span><br><span class="line">变量只有在赋值的时候才会确定数据类型</span><br><span class="line">表达式中包含不同类型数据则在计算过程中会强制进行类别转换</span><br></pre></td></tr></table></figure>
<p>数字 + 字符串：数字转换为字符串</p>
<p>数字 + 布尔值：true转换为1，false转换为0</p>
<p>字符串 + 布尔值：布尔值转换为字符串true或false</p>
<p><strong>强制类型转换函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数parseInt：   强制转换成整数   例如parseInt(&quot;6.12&quot;)&#x3D;6  ; parseInt(“12a&quot;)&#x3D;12 ; parseInt(“a12&quot;)&#x3D;NaN  ;parseInt(“1a2&quot;)&#x3D;1</span><br><span class="line"></span><br><span class="line">函数parseFloat： 强制转换成浮点数  parseFloat(&quot;6.12&quot;)&#x3D;6.12</span><br><span class="line"></span><br><span class="line">函数eval：       将字符串强制转换为表达式并返回结果 eval(&quot;1+1&quot;)&#x3D;2 ; eval(&quot;1&lt;2&quot;)&#x3D;true</span><br></pre></td></tr></table></figure>
<h4 id="类型查询函数-typeof"><a href="#类型查询函数-typeof" class="headerlink" title="类型查询函数(typeof)"></a><strong>类型查询函数(</strong>typeof<strong>)</strong></h4><p>ECMAScript 提供了 typeof 运算符来判断一个值是否在某种类型的范围内。可以用这种运算符判断一个值是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数typeof ：查询数值当前类型 (string &#x2F; number &#x2F; boolean &#x2F; object )</span><br><span class="line"></span><br><span class="line">例如typeof(&quot;test&quot;+3)      &quot;string&quot;</span><br><span class="line">例如typeof(null)          &quot;object &quot;</span><br><span class="line">例如typeof(true+1)        &quot;number&quot;</span><br><span class="line">例如typeof(true-false)    &quot;number&quot;</span><br></pre></td></tr></table></figure>
<h2 id="ECMAScript-运算符"><a href="#ECMAScript-运算符" class="headerlink" title="ECMAScript 运算符"></a><strong>ECMAScript 运算符</strong></h2><h3 id="ECMAScript-算数运算符"><a href="#ECMAScript-算数运算符" class="headerlink" title="ECMAScript 算数运算符"></a>ECMAScript <strong>算数运算符</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加(＋)、 减(－)、 乘(*) 、除(&#x2F;) 、余数(% )  加、减、乘、除、余数和数学中的运算方法一样  例如：9&#x2F;2&#x3D;4.5，4*5&#x3D;20，9%2&#x3D;1</span><br><span class="line"></span><br><span class="line">-除了可以表示减号还可以表示负号  例如：x&#x3D;-y</span><br><span class="line"></span><br><span class="line">+除了可以表示加法运算还可以用于字符串的连接  例如：&quot;abc&quot;+&quot;def&quot;&#x3D;&quot;abcdef&quot;</span><br></pre></td></tr></table></figure>
<p> <strong>递增(＋＋) 、递减(－－)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假如x&#x3D;2，那么x++表达式执行后的值为3，x--表达式执行后的值为1</span><br><span class="line">i++相当于i&#x3D;i+1，i--相当于i&#x3D;i-1</span><br><span class="line">递增和递减运算符可以放在变量前也可以放在变量后：--i</span><br><span class="line">    </span><br><span class="line">var i&#x3D;1;</span><br><span class="line">console.log(i++);  #先执行后加法</span><br><span class="line">console.log(++i);  #先加法后执行</span><br><span class="line">console.log(i--);</span><br><span class="line">console.log(--i);</span><br></pre></td></tr></table></figure>
<p><strong>一元加减法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    var a&#x3D;1;</span><br><span class="line">    var b&#x3D;1;</span><br><span class="line">    a&#x3D;-a;  &#x2F;&#x2F;a&#x3D;-1</span><br><span class="line"></span><br><span class="line">    var c&#x3D;&quot;10&quot;;</span><br><span class="line">    alert(typeof (c));</span><br><span class="line">    c&#x3D;+c;    &#x2F;&#x2F;类型转换</span><br><span class="line">    alert(typeof (c));</span><br><span class="line">&#x2F;&#x2F;    -------------------</span><br><span class="line">    var d&#x3D;&quot;yuan&quot;;</span><br><span class="line">    d&#x3D;+d;</span><br><span class="line">    alert(d);&#x2F;&#x2F;NaN:属于Number类型的一个特殊值,当遇到将字符串转成数字无效时,就会得到一个NaN数据</span><br><span class="line">    alert(typeof(d));&#x2F;&#x2F;Number</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;NaN特点:</span><br><span class="line">    </span><br><span class="line">    var n&#x3D;NaN;</span><br><span class="line">    </span><br><span class="line">    alert(n&gt;3);</span><br><span class="line">    alert(n&lt;3);</span><br><span class="line">    alert(n&#x3D;&#x3D;3);</span><br><span class="line">    alert(n&#x3D;&#x3D;NaN);</span><br><span class="line">    </span><br><span class="line">    alert(n!&#x3D;NaN);&#x2F;&#x2F;NaN参与的所有的运算都是false,除了!&#x3D;</span><br></pre></td></tr></table></figure>
<h3 id="ECMAScript-逻辑运算符"><a href="#ECMAScript-逻辑运算符" class="headerlink" title="ECMAScript 逻辑运算符"></a>ECMAScript <strong>逻辑运算符</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">等于 ( &#x3D;&#x3D; )  、不等于( !&#x3D; ) 、 大于( &gt; ) 、 小于( &lt; ) 大于等于(&gt;&#x3D;) 、小于等于(&lt;&#x3D;)</span><br><span class="line">与 (&amp;&amp;) 、或(||) 、非(!)</span><br><span class="line">1 &amp;&amp; 1 &#x3D; 1  1 || 1 &#x3D; 1</span><br><span class="line">1 &amp;&amp; 0 &#x3D; 0  1 || 0 &#x3D; 1</span><br><span class="line">0 &amp;&amp; 0 &#x3D; 0  0 || 0 &#x3D; 0</span><br><span class="line"></span><br><span class="line">!0&#x3D;1</span><br><span class="line">!1&#x3D;0</span><br></pre></td></tr></table></figure>
<h4 id="逻辑-AND-运算符-amp-amp"><a href="#逻辑-AND-运算符-amp-amp" class="headerlink" title="逻辑 AND 运算符(&amp;&amp;)"></a><strong>逻辑 AND 运算符(&amp;&amp;)</strong></h4><p>逻辑 AND 运算的运算数可以是任何类型的，不止是 Boolean 值。</p>
<p>如果某个运算数不是原始的 Boolean 型值，逻辑 AND 运算并不一定返回 Boolean 值：</p>
<ul>
<li>如果某个运算数是 null，返回 null。 </li>
<li>如果某个运算数是 NaN，返回 NaN。 </li>
<li>如果某个运算数是 undefined，返回undefined。 </li>
</ul>
<h4 id="逻辑-OR-运算符"><a href="#逻辑-OR-运算符" class="headerlink" title="逻辑 OR 运算符(||)"></a><strong>逻辑 OR 运算符(||)</strong></h4><p>与逻辑 AND 运算符相似，如果某个运算数不是 Boolean 值，逻辑 OR 运算并不一定返回 Boolean 值</p>
<h3 id="ECMAScript-赋值运算符"><a href="#ECMAScript-赋值运算符" class="headerlink" title="ECMAScript 赋值运算符"></a>ECMAScript 赋值运算符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">赋值 &#x3D; </span><br><span class="line">JavaScript中&#x3D;代表赋值，两个等号&#x3D;&#x3D;表示判断是否相等</span><br><span class="line">例如，x&#x3D;1表示给x赋值为1</span><br><span class="line">if (x&#x3D;&#x3D;1)&#123;...&#125;程序表示当x与1相等时</span><br><span class="line">if(x&#x3D;&#x3D;“on”)&#123;…&#125;程序表示当x与“on”相等时</span><br><span class="line"> 配合其他运算符形成的简化表达式</span><br><span class="line">例如i+&#x3D;1相当于i&#x3D;i+1，x&amp;&#x3D;y相当于x&#x3D;x&amp;y</span><br></pre></td></tr></table></figure>
<p>实例：              </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 &#x3D;&#x3D; “2”     #进行类型转换后比较</span><br><span class="line">2 &#x3D;&#x3D;&#x3D; “2”    #不进行类型转换直接进行比较     </span><br><span class="line">4 !&#x3D; “4”            </span><br><span class="line">4 !&#x3D;&#x3D; “4”        </span><br><span class="line"></span><br><span class="line">var a &#x3D; 2; var b &#x3D; 4;</span><br><span class="line">var c &#x3D; a&lt;b | --b&gt;--a;</span><br><span class="line">var c &#x3D; a&lt;b || --b&gt;--a; </span><br><span class="line"> var c &#x3D; a&lt;b &amp;&amp;--b&gt;--a;</span><br><span class="line">var c &#x3D; a&lt;b &amp; --b&gt;--a;</span><br></pre></td></tr></table></figure>
<h3 id="ECMAScript等性运算符"><a href="#ECMAScript等性运算符" class="headerlink" title="ECMAScript等性运算符"></a>ECMAScript<strong>等性运算符</strong></h3><p>执行类型转换的规则如下：</p>
<ul>
<li>如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 </li>
<li>如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 </li>
<li>如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 </li>
<li>如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。 </li>
</ul>
<p>在比较时，该运算符还遵守下列规则：</p>
<ul>
<li>值 null 和 undefined 相等。 </li>
<li>在检查相等性时，不能把 null 和 undefined 转换成其他值。 </li>
<li>如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 </li>
<li>如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 </li>
</ul>
<p>​        <img src="image/877318-20161023233321013-877495606.png" alt="img"></p>
<h3 id="ECMAScript-关系运算符-重要"><a href="#ECMAScript-关系运算符-重要" class="headerlink" title="ECMAScript 关系运算符**(重要)**"></a><strong>ECMAScript 关系运算符**</strong>(重要)**</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bResult &#x3D; &quot;Blue&quot; &lt; &quot;alpha&quot;;</span><br><span class="line">alert(bResult); &#x2F;&#x2F;输出 true</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，字符串 “Blue” 小于 “alpha”，因为字母 B 的字符代码是 66，字母 a 的字符代码是 97。</p>
<p><strong>比较数字和字符串</strong></p>
<p>另一种棘手的状况发生在比较两个字符串形式的数字时，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bResult &#x3D; &quot;25&quot; &lt; &quot;3&quot;;</span><br><span class="line">alert(bResult); &#x2F;&#x2F;输出 &quot;true&quot;</span><br></pre></td></tr></table></figure>
<p>上面这段代码比较的是字符串 “25” 和 “3”。两个运算数都是字符串，所以比较的是它们的字符代码（”2” 的字符代码是 50，”3” 的字符代码是 51）。</p>
<p>不过，如果把某个运算数该为数字，那么结果就有趣了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bResult &#x3D; &quot;25&quot; &lt; 3;</span><br><span class="line">alert(bResult); &#x2F;&#x2F;输出 &quot;false&quot;</span><br></pre></td></tr></table></figure>
<p>这里，字符串 “25” 将被转换成数字 25，然后与数字 3 进行比较，结果不出所料。</p>
<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比较运算符两侧如果一个是数字类型,一个是其他类型,会将其类型转换成数字类型.</span><br><span class="line">比较运算符两侧如果都是字符串类型,比较的是最高位的asc码,如果最高位相等,继续取第二位比较.</span><br></pre></td></tr></table></figure>
<h3 id="Boolean运算符-重要"><a href="#Boolean运算符-重要" class="headerlink" title="Boolean运算符(重要)"></a>Boolean运算符(重要)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var temp&#x3D;new Object();&#x2F;&#x2F; false;[];0; null; undefined;object(new Object();)</span><br><span class="line"></span><br><span class="line">    if(temp)&#123;</span><br><span class="line">        console.log(&quot;yuan&quot;)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        console.log(&quot;alex&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="全等号和非全等号"><a href="#全等号和非全等号" class="headerlink" title="全等号和非全等号"></a><strong>全等号和非全等号</strong></h3><p>等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。</p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="if-控制语句"><a href="#if-控制语句" class="headerlink" title="if 控制语句"></a>if 控制语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if-else基本格式</span><br><span class="line">if (表达式)&#123;</span><br><span class="line">语句１;</span><br><span class="line">......</span><br><span class="line">&#125;else&#123;</span><br><span class="line">语句２;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line">功能说明</span><br><span class="line">如果表达式的值为true则执行语句1,</span><br><span class="line">否则执行语句2</span><br></pre></td></tr></table></figure>
<p>​                 <img src="image/877318-20161020163908654-382264302.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x&#x3D; (new Date()).getDay();</span><br><span class="line">&#x2F;&#x2F;获取今天的星期值，0为星期天</span><br><span class="line">var y;</span><br><span class="line"></span><br><span class="line">if ( (x&#x3D;&#x3D;6) || (x&#x3D;&#x3D;0) ) &#123;</span><br><span class="line">y&#x3D;&quot;周末&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">y&#x3D;&quot;工作日&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(y);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line"></span><br><span class="line">y&#x3D;&quot;工作日&quot;;</span><br><span class="line">if ( (x&#x3D;&#x3D;6) || (x&#x3D;&#x3D;0) ) &#123;</span><br><span class="line">y&#x3D;&quot;周末&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 可以单独使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if语句嵌套格式</span><br><span class="line">if (表达式1) &#123;</span><br><span class="line">    语句1;</span><br><span class="line">&#125;else if (表达式2)&#123;</span><br><span class="line">    语句2;</span><br><span class="line">&#125;else if (表达式3)&#123;</span><br><span class="line">    语句3;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    语句4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                    <img src="image/877318-20161020164919248-1127492807.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (x&#x3D;&#x3D;1)&#123;</span><br><span class="line">    y&#x3D;&quot;星期一&quot;;</span><br><span class="line">&#125;else if (x&#x3D;&#x3D;2)&#123;</span><br><span class="line">    y&#x3D;&quot;星期二&quot;;</span><br><span class="line">...</span><br><span class="line">&#125;else if (x&#x3D;&#x3D;6)&#123;</span><br><span class="line">    y&#x3D;&quot;星期六&quot;;</span><br><span class="line">&#125;else if (x&#x3D;&#x3D;0)&#123;</span><br><span class="line">    y&#x3D;&quot;星期日&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    y&#x3D;&quot;未定义&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="switch-选择控制语句"><a href="#switch-选择控制语句" class="headerlink" title="switch  选择控制语句"></a>switch  选择控制语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch基本格式</span><br><span class="line">switch (表达式) &#123;</span><br><span class="line">    case 值1:语句1;break;</span><br><span class="line">    case 值2:语句2;break;</span><br><span class="line">    case 值3:语句3;break;</span><br><span class="line">    default:语句4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="image/877318-20161020165151420-915008211.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch(x)&#123;</span><br><span class="line">case 1:y&#x3D;&quot;星期一&quot;;    break;</span><br><span class="line">case 2:y&#x3D;&quot;星期二&quot;;    break;</span><br><span class="line">case 3:y&#x3D;&quot;星期三&quot;;    break;</span><br><span class="line">case 4:y&#x3D;&quot;星期四&quot;;    break;</span><br><span class="line">case 5:y&#x3D;&quot;星期五&quot;;    break;</span><br><span class="line">case 6:y&#x3D;&quot;星期六&quot;;    break;</span><br><span class="line">case 7:y&#x3D;&quot;星期日&quot;;    break;</span><br><span class="line">default: y&#x3D;&quot;未定义&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>switch</strong>比<strong>else if</strong>结构更加简洁清晰，使程序可读性更强,效率更高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先要看一个问题，if 语句适用范围比较广，只要是 boolean 表达式都可以用 if 判断；而 switch 只能对基本类型进行数值比较。两者的可比性就仅限在两个基本类型比较的范围内。</span><br><span class="line">说到基本类型的数值比较，那当然要有两个数。然后重点来了——</span><br><span class="line">if 语句每一句都是独立的，看下面的语句：</span><br><span class="line">if (a &#x3D;&#x3D; 1) ...</span><br><span class="line">else if (a &#x3D;&#x3D; 2) ...</span><br><span class="line">这样 a 要被读入寄存器两次，1 和 2 分别被读入寄存器一次。于是你是否发现其实 a 读两次是有点多余的，在你全部比较完之前只需要一次读入寄存器就行了，其余都是额外开销。但是 if 语句必须每次都把里面的两个数从内存拿出来读到寄存器，它不知道你其实比较的是同一个 a。</span><br><span class="line">于是 switch case 就出来了，把上面的改成 switch case 版本：</span><br><span class="line">switch (a) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">                break;</span><br><span class="line">        case 1:</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">总结:</span><br><span class="line"></span><br><span class="line">1.switch用来根据一个整型值进行多路分支，并且编译器可以对多路分支进行优化</span><br><span class="line">2.switch-case只将表达式计算一次,然后将表达式的值与每个case的值比较,进而选</span><br><span class="line">  择执行哪一个case的语句块</span><br><span class="line">3.if..else 的判断条件范围较广，每条语句基本上独立的，每次判断时都要条件加载</span><br><span class="line">  一次。</span><br><span class="line">所以在多路分支时用switch比if..else if .. else结构要效率高。</span><br></pre></td></tr></table></figure>
<h3 id="for-循环控制语句"><a href="#for-循环控制语句" class="headerlink" title="for  循环控制语句"></a>for  循环控制语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for循环基本格式</span><br><span class="line">for (初始化;条件;增量)&#123;</span><br><span class="line">    语句1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">功能说明</span><br><span class="line">实现条件循环，当条件成立时，执行语句1，否则跳出循环体</span><br></pre></td></tr></table></figure>
<p>​                    <img src="image/877318-20161020165544795-930677647.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i&#x3D;1;i&lt;&#x3D;7;i++)&#123;</span><br><span class="line">    document.write(&quot;&lt;H&quot;+i+&quot;&gt;hello&lt;&#x2F;H &quot;+i+&quot;&gt; &quot;);</span><br><span class="line">    document.write(&quot;&lt;br&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line">    var arr&#x3D;[1,&quot;hello&quot;,true]&#x2F;&#x2F;var dic&#x3D;&#123;&quot;1&quot;:&quot;111&quot;&#125;</span><br><span class="line">    for (var i in arr)&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">        console.log(arr[i])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    doms&#x3D;document.getElementsByTagName(&quot;p&quot;);</span><br><span class="line"></span><br><span class="line">    for (var i in doms)&#123;</span><br><span class="line">       console.log(i); &#x2F;&#x2F; 0 1 2 length item namedItem</span><br><span class="line">       &#x2F;&#x2F;console.log(doms[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;循环的是你获取的th一个DOM元素集，for in用来循环对象的所有属性，dom元素集包含了你上面输出的属性。</span><br><span class="line">&#x2F;&#x2F;如果你只要循环dom对象的话，可以用for循环:</span><br><span class="line"></span><br><span class="line">    for (var i&#x3D;0;i&lt;doms.length;i++)&#123;</span><br><span class="line">        console.log(i) ; &#x2F;&#x2F; 0 1 2</span><br><span class="line">        &#x2F;&#x2F;console.log(doms[i])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>结论：for i in 不推荐使用.</strong></p>
<h3 id="while-循环控制语句"><a href="#while-循环控制语句" class="headerlink" title="while  循环控制语句"></a>while  循环控制语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while循环基本格式</span><br><span class="line">while (条件)&#123;</span><br><span class="line">语句1；</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">功能说明</span><br><span class="line">运行功能和for类似，当条件成立循环执行语句花括号&#123;&#125;内的语句，否则跳出循环</span><br></pre></td></tr></table></figure>
<p>​               <img src="image/877318-20161020165834920-189719722.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i&#x3D;1;</span><br><span class="line">while (i&lt;&#x3D;7) &#123;</span><br><span class="line">    document.write(&quot;&lt;H&quot;+i+&quot;&gt;hello&lt;&#x2F;H &quot;+i+&quot;&gt; &quot;);</span><br><span class="line">    document.write(&quot;&lt;br&gt;&quot;);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;循环输出H1到H7的字体大小</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;JavaScript&quot;&gt;</span><br><span class="line">&#x2F;* sayhello是定义的函数名，前面必须加上function和空格*&#x2F;</span><br><span class="line">function sayHello()&#123;</span><br><span class="line">    var hellostr;</span><br><span class="line">    var myname&#x3D;prompt(&quot;请问您贵姓？&quot;,&quot;苑&quot;); </span><br><span class="line">    hellostr&#x3D;&quot;您好，&quot;+myname+&#39;先生，欢迎进入&quot;探索之旅&quot;！&#39;;</span><br><span class="line">    alert(hellostr); </span><br><span class="line">    document.write(hellostr);</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;&#x2F;这里是对前面定义的函数进行调用</span><br><span class="line">sayHello();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>练习：分别用for循环和while循环计算出1-100的和？</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F;这段代码从上往下运行，其中任何一个语句抛出异常该代码块就结束运行</span><br><span class="line">&#125;</span><br><span class="line">catch (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果try代码块中抛出了异常，catch代码块中的代码就会被执行。</span><br><span class="line">    &#x2F;&#x2F;e是一个局部变量，用来指向Error对象或者其他抛出的对象</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">     &#x2F;&#x2F;无论try中代码是否有异常抛出（甚至是try代码块中有return语句），finally代码块中始终会被执行。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：主动抛出异常 throw Error(‘xxxx’)　　</p>
<h2 id="ECMA对象"><a href="#ECMA对象" class="headerlink" title="ECMA对象"></a><strong>ECMA对象</strong></h2><p>从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。</p>
<p>var o = new Object();</p>
<h3 id="对象的概念与分类："><a href="#对象的概念与分类：" class="headerlink" title="对象的概念与分类："></a>对象的概念与分类：</h3><ul>
<li>由ECMAScript定义的本地对象.独立于宿主环境的 ECMAScript 实现提供的对象.(native object)</li>
<li>ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现.这意味着开发者不必明确实例化内置对象，它已被实例化了。ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。（built-in object）</li>
<li>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有 BOM 和 DOM 对象都是宿主对象。</li>
</ul>
<p><strong>object对象</strong>：ECMAScript 中的所有对象都由这个对象继承而来；Object 对象中的所有属性和方法都会出现在其他对象中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ToString() :  返回对象的原始字符串表示。</span><br><span class="line">ValueOf()  : 返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。</span><br></pre></td></tr></table></figure>
<h4 id="11种内置对象"><a href="#11种内置对象" class="headerlink" title="11种内置对象"></a><strong>11种内置对象</strong></h4><p><strong>包括：</strong></p>
<p><strong>Array ,String , Date, Math, Boolean, Number</strong>  <strong>Function, Global, Error, RegExp , Object</strong></p>
<p><strong>简介：</strong></p>
<p>在JavaScript中除了null和undefined以外其他的数据类型都被定义成了对象，也可以用创建对象的方法定义变量，String、Math、Array、Date、RegExp都是JavaScript中重要的内置对象，在JavaScript程序大多数功能都是通过对象实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;javascript&quot;&gt;</span><br><span class="line">var aa&#x3D;Number.MAX_VALUE; </span><br><span class="line">&#x2F;&#x2F;利用数字对象获取可表示最大数</span><br><span class="line">var bb&#x3D;new String(&quot;hello JavaScript&quot;); </span><br><span class="line">&#x2F;&#x2F;创建字符串对象</span><br><span class="line">var cc&#x3D;new Date();</span><br><span class="line">&#x2F;&#x2F;创建日期对象</span><br><span class="line">var dd&#x3D;new Array(&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;); </span><br><span class="line">&#x2F;&#x2F;数组对象</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>​                  <img src="image/877318-20161020172116545-1736844688.png" alt="img">   </p>
<h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a><strong>String对象</strong></h3><p>自动创建字符串对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str1&#x3D;&quot;hello world&quot;;</span><br><span class="line">alert(str1.length);</span><br><span class="line">alert(str1.substr(1,5));</span><br></pre></td></tr></table></figure>
<p>调用字符串的对象属性或方法时自动创建对象，用完就丢弃</p>
<p>手工创建字符串对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str1&#x3D; new String(&quot;hello word&quot;);</span><br><span class="line">alert(str1.length);</span><br><span class="line">alert(str1.substr(1,3));</span><br></pre></td></tr></table></figure>
<p>采用new创建字符串对象str1，全局有效</p>
<h4 id="String对象的属性"><a href="#String对象的属性" class="headerlink" title="String对象的属性"></a><strong>String对象的属性</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取字符串长度</span><br><span class="line">length</span><br></pre></td></tr></table></figure>
<p>var str1=”String对象”;</p>
<p>var str2=””;</p>
<p>alert(“str1长度 “+str1.length);</p>
<p>alert(“str2长度 “+str2.length);</p>
<p>​                       <img src="image/877318-20161020172806967-1903422661.png" alt="img">　</p>
<p><img src="image/877318-20161020175449873-1889565656.png" alt="img"><strong><img src="image/877318-20161020180038045-1855840599.png" alt="img"><img src="image/877318-20161020181134123-1739380581.png" alt="img"></strong></p>
<p><strong>String对象的方法(1) —— 格式编排方法</strong></p>
<p>格式编排方法返回值列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">书写格式:</span><br><span class="line"></span><br><span class="line">String对象提供了一组针对HTML格式的方法，如x.anchor()返回锚定义字符串&lt;a&gt;x&lt;&#x2F;a&gt;，</span><br><span class="line">x.bold()返回粗体表示字符串&lt;b&gt;x&lt;&#x2F;b&gt;，x.sup()返回上标格式字符串&lt;sup&gt;x&lt;&#x2F;sup&gt;。</span><br><span class="line">-----------------------------------------</span><br><span class="line"></span><br><span class="line">var x&#x3D;&quot;yuan&quot;;</span><br><span class="line">var y&#x3D;&quot;x.italics():&quot;+x.italics();</span><br><span class="line">document.write(y.fontsize(10));&#x2F;&#x2F;&lt;font size&#x3D;&quot;10&quot;&gt;x.italics():&lt;i&gt;yuan&lt;&#x2F;i&gt;&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>
<p><strong>String对象的方法(2)——  大小写转换</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str1&#x3D;&quot;AbcdEfgh&quot;; </span><br><span class="line"></span><br><span class="line">var str2&#x3D;str1.toLowerCase();</span><br><span class="line">var str3&#x3D;str1.toUpperCase();</span><br><span class="line">alert(str2);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;abcdefgh&quot;</span><br><span class="line">alert(str3);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;ABCDEFGH&quot;</span><br></pre></td></tr></table></figure>
<p><strong>String对象的方法(3) —— 获取指定字符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">书写格式</span><br><span class="line"></span><br><span class="line">x.charAt(index)</span><br><span class="line"></span><br><span class="line">x.charCodeAt(index)</span><br><span class="line"></span><br><span class="line">使用注解</span><br><span class="line"></span><br><span class="line">x代表字符串对象</span><br><span class="line">index代表字符位置</span><br><span class="line">index从0开始编号</span><br><span class="line">charAt返回index位置的字符</span><br><span class="line">charCodeAt返回index位置的Unicode编码</span><br><span class="line">----------------------</span><br><span class="line">var str1&#x3D;&quot;welcome to the world of JS! 苑昊&quot;;</span><br><span class="line"></span><br><span class="line">var str2&#x3D;str1.charAt(28);</span><br><span class="line">var str3&#x3D;str1.charCodeAt(28);</span><br><span class="line">alert(str2);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;苑&quot;</span><br><span class="line">alert(str3);</span><br><span class="line">&#x2F;&#x2F;结果为33489</span><br></pre></td></tr></table></figure>
<p><strong>String对象的方法(4)——  查询字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;书写格式</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x.indexOf(findstr,index)</span><br><span class="line">&#x2F;&#x2F;x.lastIndexOf(findstr)</span><br><span class="line">&#x2F;&#x2F;-------------------------------------</span><br><span class="line">var str1&#x3D;&quot;welcome to the world of JS!&quot;;</span><br><span class="line"></span><br><span class="line">var str2&#x3D;str1.indexOf(&quot;l&quot;);</span><br><span class="line">var str3&#x3D;str1.lastIndexOf(&quot;l&quot;);</span><br><span class="line">alert(str2);</span><br><span class="line">&#x2F;&#x2F;结果为2</span><br><span class="line">alert(str3);</span><br><span class="line">&#x2F;&#x2F;结果为18</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------*********************************************************-------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;书写格式</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x.match(regexp)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x.search(regexp)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;使用注解</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x代表字符串对象</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;regexp代表正则表达式或字符串</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;match返回匹配字符串的数组，如果没有匹配则返回null</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;search返回匹配字符串的首字符位置索引</span><br><span class="line">&#x2F;&#x2F;-------------------------------------</span><br><span class="line">var str1&#x3D;&quot;welcome to the world of JS!&quot;;</span><br><span class="line"></span><br><span class="line">var str2&#x3D;str1.match(&quot;world&quot;);</span><br><span class="line">var str3&#x3D;str1.search(&quot;world&quot;);</span><br><span class="line">alert(str2[0]);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;world&quot;</span><br><span class="line">alert(str3);</span><br><span class="line">&#x2F;&#x2F;结果为15</span><br></pre></td></tr></table></figure>
<p><strong>String对象的方法(5) ——子字符串处理</strong></p>
<p><strong>截取子字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;截取子字符串</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;书写格式</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x.substr(start, length)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x.substring(start, end)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;使用注解</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x代表字符串对象</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;start表示开始位置</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;length表示截取长度</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;end是结束位置加1</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;第一个字符位置为0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var str1&#x3D;&quot;abcdefgh&quot;;</span><br><span class="line">var str2&#x3D;str1.substr(2,4);</span><br><span class="line">var str3&#x3D;str1.substring(2,4);</span><br><span class="line">alert(str2);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;cdef&quot;</span><br><span class="line">alert(str3);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;cd&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------*********************************************************-------</span><br><span class="line">&#x2F;&#x2F;x.slice(start, end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var str1&#x3D;&quot;abcdefgh&quot;;</span><br><span class="line">var str2&#x3D;str1.slice(2,4);</span><br><span class="line">var str3&#x3D;str1.slice(4);</span><br><span class="line">var str4&#x3D;str1.slice(2,-1);</span><br><span class="line">var str5&#x3D;str1.slice(-3,-1);</span><br><span class="line">alert(str2);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;cd&quot;</span><br><span class="line">alert(str3);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;efgh&quot;</span><br><span class="line">alert(str4);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;cdefg&quot;</span><br><span class="line">alert(str5);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;fg&quot;</span><br></pre></td></tr></table></figure>
<p><strong>替换子字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;x.replace(findstr,tostr)</span><br><span class="line"></span><br><span class="line">var str1&#x3D;&quot;abcdefgh&quot;;</span><br><span class="line">var str2&#x3D;str1.replace(&quot;cd&quot;,&quot;aaa&quot;);</span><br><span class="line">alert(str2);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;abaaaefgh&quot;</span><br></pre></td></tr></table></figure>
<p><strong>分割字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str1&#x3D;&quot;一,二,三,四,五,六,日&quot;; </span><br><span class="line"></span><br><span class="line">var strArray&#x3D;str1.split(&quot;,&quot;);</span><br><span class="line"></span><br><span class="line">alert(strArray[1]);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;二&quot;</span><br></pre></td></tr></table></figure>
<p><strong>连接字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;y&#x3D;x.concat(addstr)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;使用注解</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x代表字符串对象</span><br><span class="line">&#x2F;&#x2F;addstr为添加字符串</span><br><span class="line">&#x2F;&#x2F;返回x+addstr字符串</span><br><span class="line">    </span><br><span class="line">var str1&#x3D;&quot;abcd&quot;; </span><br><span class="line">var str2&#x3D;str1.concat(&quot;efgh&quot;);</span><br><span class="line"></span><br><span class="line">alert(str2);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;abcdefgh&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><h4 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array 对象用于在单个的变量中存储多个值。</span><br><span class="line">语法:</span><br><span class="line"></span><br><span class="line">创建方式1:</span><br><span class="line">var a&#x3D;[1,2,3];</span><br><span class="line"></span><br><span class="line">创建方式2:</span><br><span class="line">new Array();     &#x2F;&#x2F;  创建数组时允许指定元素个数也可以不指定元素个数。</span><br><span class="line">new Array(size);&#x2F;&#x2F;if 1个参数且为数字,即代表size,not content</span><br><span class="line">    初始化数组对象:</span><br><span class="line">    var cnweek&#x3D;new Array(7);</span><br><span class="line">        cnweek[0]&#x3D;&quot;星期日&quot;;</span><br><span class="line">        cnweek[1]&#x3D;&quot;星期一&quot;;</span><br><span class="line">        ...</span><br><span class="line">        cnweek[6]&#x3D;&quot;星期六&quot;;</span><br><span class="line"></span><br><span class="line">new Array(element0, element1, ..., elementn)&#x2F;&#x2F;也可以直接在建立对象时初始化数组元素，元素类型允许不同</span><br><span class="line"></span><br><span class="line">var test&#x3D;new Array(100,&quot;a&quot;,true);</span><br></pre></td></tr></table></figure>
<h4 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cnweek&#x3D;new Array(7);</span><br><span class="line">for (var i&#x3D;0;i&lt;&#x3D;6;i++)&#123;</span><br><span class="line">    cnweek[i]&#x3D;new Array(2);</span><br><span class="line">&#125;</span><br><span class="line">cnweek[0][0]&#x3D;&quot;星期日&quot;;</span><br><span class="line">cnweek[0][1]&#x3D;&quot;Sunday&quot;;</span><br><span class="line">cnweek[1][0]&#x3D;&quot;星期一&quot;;</span><br><span class="line">cnweek[1][1]&#x3D;&quot;Monday&quot;;</span><br><span class="line">...</span><br><span class="line">cnweek[6][0]&#x3D;&quot;星期六&quot;;</span><br><span class="line">cnweek[6][1]&#x3D;&quot;Saturday&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="Array对象的属性"><a href="#Array对象的属性" class="headerlink" title="Array对象的属性"></a>Array对象的属性</h4><p>获取数组元素的个数：length</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cnweek&#x3D;new Array(7);</span><br><span class="line">cnweek[0]&#x3D;&quot;星期日&quot;;</span><br><span class="line">cnweek[1]&#x3D;&quot;星期一&quot;;</span><br><span class="line">cnweek[2]&#x3D;&quot;星期二&quot;;</span><br><span class="line">cnweek[3]&#x3D;&quot;星期三&quot;;</span><br><span class="line">cnweek[4]&#x3D;&quot;星期四&quot;;</span><br><span class="line">cnweek[5]&#x3D;&quot;星期五&quot;;</span><br><span class="line">cnweek[6]&#x3D;&quot;星期六&quot;;</span><br><span class="line">for (var i&#x3D;0;i&lt;cnweek.length;i++)&#123;</span><br><span class="line">  document.write(cnweek[i]+&quot; | &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Array对象的方法"><a href="#Array对象的方法" class="headerlink" title="Array对象的方法"></a>Array对象的方法</h4><p><img src="image/877318-20161020184913529-1770859465.png" alt="img"><img src="image/877318-20161020184335935-64813950.png" alt="img"></p>
<p><strong>连接数组-join方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;书写格式</span><br><span class="line">&#x2F;&#x2F;x.join(bystr)</span><br><span class="line">&#x2F;&#x2F;使用注解</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x代表数组对象</span><br><span class="line">&#x2F;&#x2F;bystr作为连接数组中元素的字符串</span><br><span class="line">&#x2F;&#x2F;返回连接后的字符串</span><br><span class="line">&#x2F;&#x2F;与字符串的split功能刚好相反</span><br><span class="line">    </span><br><span class="line">var arr1&#x3D;[1, 2, 3, 4, 5, 6, 7];</span><br><span class="line"></span><br><span class="line">var str1&#x3D;arr1.join(&quot;-&quot;);</span><br><span class="line"></span><br><span class="line">alert(str1);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;1-2-3-4-5-6-7&quot;</span><br></pre></td></tr></table></figure>
<p><strong>连接数组-concat方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;连接数组-concat方法</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x.concat(value,...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var a &#x3D; [1,2,3];</span><br><span class="line">var a &#x3D; new Array(1,2,3);</span><br><span class="line">var b&#x3D;a.concat(4,5) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alert(a.toString());</span><br><span class="line">&#x2F;&#x2F;返回结果为1,2,3</span><br><span class="line">alert(b.toString());</span><br><span class="line">&#x2F;&#x2F;返回结果为1,2,3,4,5</span><br></pre></td></tr></table></figure>
<p><strong>数组排序-reverse sort</strong></p>
<p><strong>默认将数字转换为字符串后比较。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;x.reverse()</span><br><span class="line">&#x2F;&#x2F;x.sort()</span><br><span class="line"></span><br><span class="line">var arr1&#x3D;[32, 12, 111, 444];</span><br><span class="line">&#x2F;&#x2F;var arr1&#x3D;[&quot;a&quot;,&quot;d&quot;,&quot;f&quot;,&quot;c&quot;];</span><br><span class="line"></span><br><span class="line">arr1.reverse(); &#x2F;&#x2F;颠倒数组元素</span><br><span class="line">alert(arr1.toString());</span><br><span class="line">&#x2F;&#x2F;结果为444,111,12,32</span><br><span class="line"></span><br><span class="line">arr1.sort();    &#x2F;&#x2F;排序数组元素</span><br><span class="line">alert(arr1.toString());</span><br><span class="line">&#x2F;&#x2F;结果为111,12,32,444</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;------------------------------</span><br><span class="line">arr&#x3D;[1,5,2,100];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;arr.sort();</span><br><span class="line">&#x2F;&#x2F;alert(arr);</span><br><span class="line">&#x2F;&#x2F;如果就想按着数字比较呢?</span><br><span class="line"></span><br><span class="line">function intSort(a,b)&#123;</span><br><span class="line">    if (a&gt;b)&#123;</span><br><span class="line">        return 1;&#x2F;&#x2F;-1</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a&lt;b)&#123;</span><br><span class="line">        return -1;&#x2F;&#x2F;1</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.sort(intSort);</span><br><span class="line"></span><br><span class="line">alert(arr);</span><br><span class="line"></span><br><span class="line">function IntSort(a,b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组切片-slice</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;x.slice(start, end)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;使用注解</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x代表数组对象</span><br><span class="line">&#x2F;&#x2F;start表示开始位置索引</span><br><span class="line">&#x2F;&#x2F;end是结束位置下一数组元素索引编号</span><br><span class="line">&#x2F;&#x2F;第一个数组元素索引为0</span><br><span class="line">&#x2F;&#x2F;start、end可为负数，-1代表最后一个数组元素</span><br><span class="line">&#x2F;&#x2F;end省略则相当于从start位置截取以后所有数组元素</span><br><span class="line"></span><br><span class="line">var arr1&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;];</span><br><span class="line">var arr2&#x3D;arr1.slice(2,4);</span><br><span class="line">var arr3&#x3D;arr1.slice(4);</span><br><span class="line">var arr4&#x3D;arr1.slice(2,-1);</span><br><span class="line"></span><br><span class="line">alert(arr2.toString());</span><br><span class="line">&#x2F;&#x2F;结果为&quot;c,d&quot; </span><br><span class="line">alert(arr3.toString());</span><br><span class="line">&#x2F;&#x2F;结果为&quot;e,f,g,h&quot;</span><br><span class="line">alert(arr4.toString());</span><br><span class="line">&#x2F;&#x2F;结果为&quot;c,d,e,f,g&quot;</span><br></pre></td></tr></table></figure>
<p><strong>删除子数组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;x. splice(start, deleteCount, value, ...)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;使用注解</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x代表数组对象</span><br><span class="line">&#x2F;&#x2F;splice的主要用途是对数组指定位置进行删除和插入</span><br><span class="line">&#x2F;&#x2F;start表示开始位置索引</span><br><span class="line">&#x2F;&#x2F;deleteCount删除数组元素的个数</span><br><span class="line">&#x2F;&#x2F;value表示在删除位置插入的数组元素</span><br><span class="line">&#x2F;&#x2F;value参数可以省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var a &#x3D; [1,2,3,4,5,6,7,8];</span><br><span class="line">a.splice(1,2);</span><br><span class="line">&#x2F;&#x2F;a变为 [1,4,5,6,7,8]</span><br><span class="line">alert(a.toString());</span><br><span class="line">a.splice(1,1);</span><br><span class="line"> &#x2F;&#x2F;a变为[1,5,6,7,8]</span><br><span class="line">alert(a.toString());</span><br><span class="line">a.splice(1,0,2,3);</span><br><span class="line"> &#x2F;&#x2F;a变为[1,2,3,5,6,7,8]</span><br><span class="line">alert(a.toString());</span><br></pre></td></tr></table></figure>
<p><strong>数组的进出栈操作(1)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;push pop这两个方法模拟的是一个栈操作</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;x.push(value, ...)  压栈</span><br><span class="line">&#x2F;&#x2F;x.pop()             弹栈      </span><br><span class="line">&#x2F;&#x2F;使用注解</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x代表数组对象</span><br><span class="line">&#x2F;&#x2F;value可以为字符串、数字、数组等任何值</span><br><span class="line">&#x2F;&#x2F;push是将value值添加到数组x的结尾</span><br><span class="line">&#x2F;&#x2F;pop是将数组x的最后一个元素删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr1&#x3D;[1,2,3];</span><br><span class="line">arr1.push(4,5);</span><br><span class="line">alert(arr1);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;1,2,3,4,5&quot;</span><br><span class="line">arr1.push([6,7]);</span><br><span class="line">alert(arr1)</span><br><span class="line">&#x2F;&#x2F;结果为&quot;1,2,3,4,5,6,7&quot;</span><br><span class="line">arr1.pop();</span><br><span class="line">alert(arr1);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;1,2,3,4,5&quot;</span><br></pre></td></tr></table></figure>
<p><strong>数组的进出栈操作(2)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; unshift shift </span><br><span class="line">&#x2F;&#x2F;x.unshift(value,...)</span><br><span class="line">&#x2F;&#x2F;x.shift()</span><br><span class="line">&#x2F;&#x2F;使用注解</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;x代表数组对象</span><br><span class="line">&#x2F;&#x2F;value可以为字符串、数字、数组等任何值</span><br><span class="line">&#x2F;&#x2F;unshift是将value值插入到数组x的开始</span><br><span class="line">&#x2F;&#x2F;shift是将数组x的第一个元素删除</span><br><span class="line"></span><br><span class="line">var arr1&#x3D;[1,2,3];</span><br><span class="line">arr1.unshift(4,5);</span><br><span class="line">alert(arr1);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;4,5,1,2,3&quot;</span><br><span class="line">arr1. unshift([6,7]);</span><br><span class="line">alert(arr1);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;6,7,4,5,1,2,3&quot;</span><br><span class="line">arr1.shift();</span><br><span class="line">alert(arr1);</span><br><span class="line">&#x2F;&#x2F;结果为&quot;4,5,1,2,3&quot;</span><br></pre></td></tr></table></figure>
<p><strong>总结js的数组特性：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  js中数组的特性</span><br><span class="line">         &#x2F;&#x2F;java中数组的特性,  规定是什么类型的数组,就只能装什么类型.只有一种类型.</span><br><span class="line">         &#x2F;&#x2F;js中的数组特性1: js中的数组可以装任意类型,没有任何限制.</span><br><span class="line">         &#x2F;&#x2F;js中的数组特性2: js中的数组,长度是随着下标变化的.用到多长就有多长.</span><br><span class="line">         var arr5 &#x3D; [&#39;abc&#39;,123,1.14,true,null,undefined,new String(&#39;1213&#39;),new Function(&#39;a&#39;,&#39;b&#39;,&#39;alert(a+b)&#39;)];</span><br><span class="line">        &#x2F;*  alert(arr5.length);&#x2F;&#x2F;8</span><br><span class="line">         arr5[10] &#x3D; &quot;hahaha&quot;;</span><br><span class="line">         alert(arr5.length); &#x2F;&#x2F;11</span><br><span class="line">         alert(arr5[9]);&#x2F;&#x2F; undefined *&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><h4 id="创建Date对象"><a href="#创建Date对象" class="headerlink" title="创建Date对象"></a>创建Date对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;方法1：不指定参数</span><br><span class="line">var nowd1&#x3D;new Date();</span><br><span class="line">alert(nowd1.toLocaleString( ));</span><br><span class="line">&#x2F;&#x2F;方法2：参数为日期字符串</span><br><span class="line">var nowd2&#x3D;new Date(&quot;2004&#x2F;3&#x2F;20 11:12&quot;);</span><br><span class="line">alert(nowd2.toLocaleString( ));</span><br><span class="line">var nowd3&#x3D;new Date(&quot;04&#x2F;03&#x2F;20 11:12&quot;);</span><br><span class="line">alert(nowd3.toLocaleString( ));</span><br><span class="line">&#x2F;&#x2F;方法3：参数为毫秒数</span><br><span class="line">var nowd3&#x3D;new Date(5000);</span><br><span class="line">alert(nowd3.toLocaleString( ));</span><br><span class="line">alert(nowd3.toUTCString());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法4：参数为年月日小时分钟秒毫秒</span><br><span class="line">var nowd4&#x3D;new Date(2004,2,20,11,12,0,300);</span><br><span class="line">alert(nowd4.toLocaleString( ));</span><br><span class="line">&#x2F;&#x2F;毫秒并不直接显示</span><br></pre></td></tr></table></figure>
<h4 id="Date对象的方法—获取日期和时间"><a href="#Date对象的方法—获取日期和时间" class="headerlink" title="Date对象的方法—获取日期和时间"></a>Date对象的方法—获取日期和时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取日期和时间</span><br><span class="line">getDate()                 获取日</span><br><span class="line">getDay ()                 获取星期</span><br><span class="line">getMonth ()               获取月（0-11）</span><br><span class="line">getFullYear ()            获取完整年份</span><br><span class="line">getYear ()                获取年</span><br><span class="line">getHours ()               获取小时</span><br><span class="line">getMinutes ()             获取分钟</span><br><span class="line">getSeconds ()             获取秒</span><br><span class="line">getMilliseconds ()        获取毫秒</span><br><span class="line">getTime ()                返回累计毫秒数(从1970&#x2F;1&#x2F;1午夜)</span><br></pre></td></tr></table></figure>
<p><strong>练习实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getCurrentDate()&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 创建Date对象</span><br><span class="line">        var date &#x3D; new Date(); &#x2F;&#x2F;没有填入任何参数那么就是当前时间</span><br><span class="line">        &#x2F;&#x2F;2. 获得当前年份</span><br><span class="line">        var year &#x3D; date.getFullYear();</span><br><span class="line">        &#x2F;&#x2F;3. 获得当前月份 js中月份是从0到11.</span><br><span class="line">        var month &#x3D; date.getMonth()+1;</span><br><span class="line">        &#x2F;&#x2F;4. 获得当前日</span><br><span class="line">        var day &#x3D; date.getDate();</span><br><span class="line">        &#x2F;&#x2F;5. 获得当前小时</span><br><span class="line">        var hour &#x3D; date.getHours();</span><br><span class="line">        &#x2F;&#x2F;6. 获得当前分钟</span><br><span class="line">        var min &#x3D; date.getMinutes();</span><br><span class="line">        &#x2F;&#x2F;7. 获得当前秒</span><br><span class="line">        var sec &#x3D; date.getSeconds();</span><br><span class="line">        &#x2F;&#x2F;8. 获得当前星期</span><br><span class="line">        var week &#x3D; date.getDay(); &#x2F;&#x2F;没有getWeek</span><br><span class="line">        &#x2F;&#x2F; 2014年06月18日 15:40:30 星期三</span><br><span class="line">        return year+&quot;年&quot;+changeNum(month)+&quot;月&quot;+day+&quot;日 &quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec+&quot; &quot;+parseWeek(week);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">alert(getCurrentDate());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解决 自动补齐成两位数字的方法</span><br><span class="line">    function changeNum(num)&#123;</span><br><span class="line">    if(num &lt; 10)&#123;</span><br><span class="line">        return &quot;0&quot;+num;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将数字 0~6 转换成 星期日到星期六</span><br><span class="line">    function parseWeek(week)&#123;</span><br><span class="line">    var arr &#x3D; [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;];</span><br><span class="line">    &#x2F;&#x2F;             0      1      2      3 .............</span><br><span class="line">    return arr[week];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Date对象的方法—设置日期和时间"><a href="#Date对象的方法—设置日期和时间" class="headerlink" title="Date对象的方法—设置日期和时间"></a>Date对象的方法—设置日期和时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置日期和时间</span><br><span class="line">&#x2F;&#x2F;setDate(day_of_month)       设置日</span><br><span class="line">&#x2F;&#x2F;setMonth (month)                 设置月</span><br><span class="line">&#x2F;&#x2F;setFullYear (year)               设置年</span><br><span class="line">&#x2F;&#x2F;setHours (hour)         设置小时</span><br><span class="line">&#x2F;&#x2F;setMinutes (minute)     设置分钟</span><br><span class="line">&#x2F;&#x2F;setSeconds (second)     设置秒</span><br><span class="line">&#x2F;&#x2F;setMillliseconds (ms)       设置毫秒(0-999)</span><br><span class="line">&#x2F;&#x2F;setTime (allms)     设置累计毫秒(从1970&#x2F;1&#x2F;1午夜)</span><br><span class="line">    </span><br><span class="line">var x&#x3D;new Date();</span><br><span class="line">x.setFullYear (1997);    &#x2F;&#x2F;设置年1997</span><br><span class="line">x.setMonth(7);        &#x2F;&#x2F;设置月7</span><br><span class="line">x.setDate(1);        &#x2F;&#x2F;设置日1</span><br><span class="line">x.setHours(5);        &#x2F;&#x2F;设置小时5</span><br><span class="line">x.setMinutes(12);    &#x2F;&#x2F;设置分钟12</span><br><span class="line">x.setSeconds(54);    &#x2F;&#x2F;设置秒54</span><br><span class="line">x.setMilliseconds(230);        &#x2F;&#x2F;设置毫秒230</span><br><span class="line">document.write(x.toLocaleString( )+&quot;&lt;br&gt;&quot;);</span><br><span class="line">&#x2F;&#x2F;返回1997年8月1日5点12分54秒</span><br><span class="line"></span><br><span class="line">x.setTime(870409430000); &#x2F;&#x2F;设置累计毫秒数</span><br><span class="line">document.write(x.toLocaleString( )+&quot;&lt;br&gt;&quot;);</span><br><span class="line">&#x2F;&#x2F;返回1997年8月1日12点23分50秒</span><br></pre></td></tr></table></figure>
<h4 id="Date对象的方法—日期和时间的转换"><a href="#Date对象的方法—日期和时间的转换" class="headerlink" title="Date对象的方法—日期和时间的转换"></a>Date对象的方法—日期和时间的转换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">日期和时间的转换:</span><br><span class="line"></span><br><span class="line">getTimezoneOffset():8个时区×15度×4分&#x2F;度&#x3D;480;</span><br><span class="line">返回本地时间与GMT的时间差，以分钟为单位</span><br><span class="line">toUTCString()</span><br><span class="line">返回国际标准时间字符串</span><br><span class="line">toLocalString()</span><br><span class="line">返回本地格式时间字符串</span><br><span class="line">Date.parse(x)</span><br><span class="line">返回累计毫秒数(从1970&#x2F;1&#x2F;1午夜到本地时间)</span><br><span class="line">Date.UTC(x)</span><br><span class="line">返回累计毫秒数(从1970&#x2F;1&#x2F;1午夜到国际时间)</span><br></pre></td></tr></table></figure>
<h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;RegExp对象</span><br><span class="line">    &#x2F;&#x2F; 在表单验证时使用该对象验证用户填入的字符串是否符合规则.</span><br><span class="line">    &#x2F;&#x2F;创建正则对象方式1  参数1 正则表达式  参数2 验证模式  g global &#x2F; i 忽略大小写. &#x2F;&#x2F;参数2一般填写g就可以，也有“gi”.</span><br><span class="line">    &#x2F;&#x2F; 用户名 首字母必须是英文, 除了第一位其他只能是英文数字和_ . 长度最短不能少于6位 最长不能超过12位</span><br><span class="line">    &#x2F;&#x2F;----------------------------创建方式1</span><br><span class="line">    &#x2F;* var reg1 &#x3D; new RegExp(&quot;^[a-zA-Z][a-zA-Z0-9_]&#123;5,11&#125;$&quot;,&quot;g&quot;);</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;验证字符串</span><br><span class="line">    var str &#x3D; &quot;bc123&quot;;</span><br><span class="line">    alert(reg1.test(str));&#x2F;&#x2F; true</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;----------------------------创建方式2  &#x2F;填写正则表达式&#x2F;匹配模式;</span><br><span class="line">    var reg2 &#x3D; &#x2F;^[a-zA-Z][a-zA-Z0-9_]&#123;5,11&#125;$&#x2F;g;</span><br><span class="line">    </span><br><span class="line">    alert(reg2.test(str));&#x2F;&#x2F; true</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;-------------------------------正则对象的方法-------------------</span><br><span class="line">        &#x2F;&#x2F;test方法  &#x3D;&#x3D;&gt;  测试一个字符串是否复合 正则规则. 返回值是true 和false.</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;-------------------------String 中与正则结合的4个方法------------------.</span><br><span class="line">    &#x2F;&#x2F; macth search split replace</span><br><span class="line">    var str &#x3D; &quot;hello world&quot;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;alert(str.match(&#x2F;o&#x2F;g)); &#x2F;&#x2F;查找字符串中 复合正则的 内容.</span><br><span class="line">    &#x2F;&#x2F;alert(str.search(&#x2F;h&#x2F;g));&#x2F;&#x2F; 0  查找字符串中符合正则表达式的内容位置</span><br><span class="line">    &#x2F;&#x2F;alert(str.split(&#x2F;o&#x2F;g)); &#x2F;&#x2F; 按照正则表达式对字符串进行切割. 返回数组;</span><br><span class="line">    alert(str.replace(&#x2F;o&#x2F;g, &quot;s&quot;)); &#x2F;&#x2F; hells wsrld  对字符串按照正则进行替换.</span><br></pre></td></tr></table></figure>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;Math对象</span><br><span class="line">    &#x2F;&#x2F;该对象中的属性方法 和数学有关.</span><br><span class="line">    &#x2F;&#x2F;Math是内置对象 , 与Global的不同之处是, 在调用时 需要打出 &quot;Math.&quot;前缀.</span><br><span class="line">    &#x2F;&#x2F;属性学习:</span><br><span class="line">    &#x2F;&#x2F;alert(Math.PI);</span><br><span class="line">    &#x2F;&#x2F;方法学习:</span><br><span class="line">        &#x2F;&#x2F;alert(Math.random()); &#x2F;&#x2F; 获得随机数 0~1 不包括1.</span><br><span class="line">        &#x2F;&#x2F;alert(Math.round(1.5)); &#x2F;&#x2F; 四舍五入</span><br><span class="line">        &#x2F;&#x2F;练习：获取1-100的随机整数，包括1和100</span><br><span class="line">             &#x2F;&#x2F;var num&#x3D;Math.random();</span><br><span class="line">            &#x2F;&#x2F;num&#x3D;num*10;</span><br><span class="line">            &#x2F;&#x2F;num&#x3D;Math.round(num);</span><br><span class="line">            &#x2F;&#x2F; alert(num)</span><br><span class="line">        &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;max  min&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        &#x2F;* alert(Math.max(1,2));&#x2F;&#x2F; 2</span><br><span class="line">        alert(Math.min(1,2));&#x2F;&#x2F; 1 *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;-------------pow--------------------------------</span><br><span class="line">        alert(Math.pow(2,4));&#x2F;&#x2F; pow 计算参数1 的参数2 次方.</span><br><span class="line">        </span><br><span class="line">abs(x)    返回数的绝对值。</span><br><span class="line">exp(x)    返回 e 的指数。</span><br><span class="line">floor(x)对数进行下舍入。</span><br><span class="line">log(x)    返回数的自然对数（底为e）。</span><br><span class="line">max(x,y)    返回 x 和 y 中的最高值。</span><br><span class="line">min(x,y)    返回 x 和 y 中的最低值。</span><br><span class="line">pow(x,y)    返回 x 的 y 次幂。</span><br><span class="line">random()    返回 0 ~ 1 之间的随机数。</span><br><span class="line">round(x)    把数四舍五入为最接近的整数。</span><br><span class="line">sin(x)    返回数的正弦。</span><br><span class="line">sqrt(x)    返回数的平方根。</span><br><span class="line">tan(x)    返回角的正切。</span><br></pre></td></tr></table></figure>
<h3 id="Function-对象-重点"><a href="#Function-对象-重点" class="headerlink" title="Function 对象(重点)"></a>Function 对象(重点)</h3><h4 id="函数的定义："><a href="#函数的定义：" class="headerlink" title="函数的定义："></a><strong>函数的定义：</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 函数名 (参数)&#123;函数体;</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能说明：</strong></p>
<ul>
<li>可以使用变量、常量或表达式作为函数调用的参数</li>
<li>函数由关键字function定义</li>
<li>函数名的定义规则与标识符一致，大小写是敏感的</li>
<li>返回值必须使用return</li>
</ul>
<p>Function 类可以表示开发者定义的任何函数。</p>
<p>用 Function 类直接创建函数的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 函数名 (参数)&#123;</span><br><span class="line">    函数体;</span><br><span class="line">   return 返回值;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;another way:</span><br><span class="line">var 函数名 &#x3D; new Function(&quot;参数1&quot;,&quot;参数n&quot;,&quot;function_body&quot;);</span><br></pre></td></tr></table></figure>
<p>虽然由于字符串的关系，第二种形式写起来有些困难，但有助于理解函数只不过是一种引用类型，它们的行为与用 Function 类明确创建的函数行为是相同的。</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(1);</span><br><span class="line">function func1()&#123;</span><br><span class="line">    alert(&#39;hello yuan!&#39;);</span><br><span class="line">    return 8</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    ret&#x3D;func1();</span><br><span class="line">    alert(ret)</span><br><span class="line">－－－－－－－－－－－－－－－－</span><br><span class="line"> </span><br><span class="line">var func1&#x3D;new Function(&quot;name&quot;,&quot;alert(\&quot;hello\&quot;+name);&quot;)</span><br><span class="line">func1(&quot;yuan&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>注意：js的函数加载执行与python不同，它是整体加载完才会执行，所以执行函数放在函数声明上面或下面都可以：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;f(); ---&gt;OK</span><br><span class="line"></span><br><span class="line">    function f()&#123;</span><br><span class="line">        console.log(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f() &#x2F;&#x2F;-----&gt;OK</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Function 对象的 length 属性</strong></p>
<p>如前所述，函数属于引用类型，所以它们也有属性和方法。</p>
<p>比如，ECMAScript 定义的<strong>属性 length 声明了函数期望的参数个数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;alert(func1.length)&#96;</span><br></pre></td></tr></table></figure>
<p><strong>Function 对象的方法</strong></p>
<p>Function 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;alert(void(fun1(1,2)))&#96;</span><br></pre></td></tr></table></figure>
<p>运算符void()作用：拦截方法的返回值　</p>
<h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a><strong>函数的调用</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func1(a,b)&#123;</span><br><span class="line"></span><br><span class="line">    alert(a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    func1(1,2);  &#x2F;&#x2F;3</span><br><span class="line">    func1(1,2,3);&#x2F;&#x2F;3</span><br><span class="line">    func1(1);    &#x2F;&#x2F;NaN</span><br><span class="line">    func1();     &#x2F;&#x2F;NaN</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;只要函数名写对即可,参数怎么填都不报错.</span><br><span class="line"></span><br><span class="line">-------------------面试题-----------</span><br><span class="line"> function a(a,b)&#123;</span><br><span class="line">    alert(a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   var a&#x3D;1;</span><br><span class="line">   var b&#x3D;2;</span><br><span class="line">   a(a,b)</span><br></pre></td></tr></table></figure>
<h4 id="函数的内置对象arguments"><a href="#函数的内置对象arguments" class="headerlink" title="函数的内置对象arguments"></a>函数的内置对象arguments</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(a+b);&#x2F;&#x2F;3</span><br><span class="line">        console.log(arguments.length);&#x2F;&#x2F;2</span><br><span class="line">        console.log(arguments);&#x2F;&#x2F;[1,2]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    add(1,2)</span><br><span class="line"></span><br><span class="line">    ------------------arguments的用处1 ------------------</span><br><span class="line">    function nxAdd()&#123;</span><br><span class="line">        var result&#x3D;0;</span><br><span class="line">        for (var num in arguments)&#123;</span><br><span class="line">            result+&#x3D;arguments[num]</span><br><span class="line">        &#125;</span><br><span class="line">        alert(result)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nxAdd(1,2,3,4,5)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;     ------------------arguments的用处2 ------------------</span><br><span class="line"></span><br><span class="line">    function f(a,b,c)&#123;</span><br><span class="line">        if (arguments.length!&#x3D;3)&#123;</span><br><span class="line">            throw new Error(&quot;function f called with &quot;+arguments.length+&quot; arguments,but it just need 3 arguments&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            alert(&quot;success!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f(1,2,3,4,5)</span><br></pre></td></tr></table></figure>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 匿名函数</span><br><span class="line">    var func &#x3D; function(arg)&#123;</span><br><span class="line">        return &quot;tony&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匿名函数的应用</span><br><span class="line">    (function()&#123;</span><br><span class="line">        alert(&quot;tony&quot;);</span><br><span class="line">    &#125; )()</span><br><span class="line"></span><br><span class="line">    (function(arg)&#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;)(&#39;123&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="函数的作用域链和闭包"><a href="#函数的作用域链和闭包" class="headerlink" title="函数的作用域链和闭包"></a>函数的作用域链和闭包</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>js的作用域和py相似，if while等控制语句并没有自己作用域；而函数是有自己的作用域的；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(1&#x3D;&#x3D;1)&#123;</span><br><span class="line"></span><br><span class="line">        var s&#x3D;12;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(s);&#x2F;&#x2F;12</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ----------------------</span><br><span class="line">    function f()&#123;</span><br><span class="line">        var temp&#x3D;666;</span><br><span class="line">    &#125;</span><br><span class="line">    f();</span><br><span class="line">    console.log(temp);&#x2F;&#x2F;Uncaught ReferenceError: temp is not defined</span><br></pre></td></tr></table></figure>
<p>嵌套函数的作用域：</p>
<p>例1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var city &#x3D; &#39;beijing&#39;;</span><br><span class="line"></span><br><span class="line">    function func()&#123;</span><br><span class="line">        var city &#x3D; &#39;shanghai&#39;;</span><br><span class="line">        function inner()&#123;</span><br><span class="line">            var city &#x3D; &#39;shenzhen&#39;;</span><br><span class="line">            console.log(city);</span><br><span class="line">        &#125;</span><br><span class="line">        inner();</span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br></pre></td></tr></table></figure>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2:"></a>例2:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var city &#x3D; &#39;beijing&#39;;</span><br><span class="line">function Bar()&#123;</span><br><span class="line">    console.log(city);</span><br><span class="line">&#125;</span><br><span class="line">function func()&#123;</span><br><span class="line"></span><br><span class="line">    var city &#x3D; &#39;shanghai&#39;;</span><br><span class="line">    return Bar;</span><br><span class="line">&#125;</span><br><span class="line">var ret &#x3D; func();</span><br><span class="line">ret();    &#x2F;&#x2F;beijing</span><br></pre></td></tr></table></figure>
<h4 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var city &#x3D; &#39;beijing&#39;;</span><br><span class="line"></span><br><span class="line">function func()&#123;</span><br><span class="line">    var city &#x3D; &quot;shanghai&quot;;</span><br><span class="line">    function inner()&#123;</span><br><span class="line">        &#x2F;&#x2F; var city &#x3D; &quot;langfang&quot;;</span><br><span class="line">        console.log(city);</span><br><span class="line">    &#125;</span><br><span class="line">    return inner;</span><br><span class="line">&#125;</span><br><span class="line">var ret &#x3D; func();</span><br><span class="line">ret();</span><br></pre></td></tr></table></figure>
<p><strong>思考题1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var city &#x3D; &#39;beijing&#39;;</span><br><span class="line"></span><br><span class="line">function func()&#123;</span><br><span class="line">    var city &#x3D; &quot;shanghai&quot;;</span><br><span class="line"></span><br><span class="line">    function inner()&#123;</span><br><span class="line">        &#x2F;&#x2F; var city &#x3D; &quot;langfang&quot;;</span><br><span class="line">        console.log(city);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ret &#x3D; func();</span><br><span class="line">ret();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var city &#x3D; &#39;beijing&#39;;</span><br><span class="line"></span><br><span class="line">function Bar()&#123;</span><br><span class="line">    console.log(city);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func()&#123;</span><br><span class="line"></span><br><span class="line">    var city &#x3D; &#39;shanghai&#39;;</span><br><span class="line">    return Bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ret &#x3D; func();</span><br><span class="line">ret();    &#x2F;&#x2F;beijing</span><br></pre></td></tr></table></figure>
<h4 id="作用域链-Scope-Chain-："><a href="#作用域链-Scope-Chain-：" class="headerlink" title="作用域链(Scope Chain)："></a>作用域链(Scope Chain)：</h4><p>​      在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x&#x3D;1;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var y &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">    function bar() &#123;</span><br><span class="line">        var z &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#bar的作用域链： barScopeChain&#x3D;[bar.AO, foo.AO, global.VO];</span><br><span class="line"></span><br><span class="line">#foo的作用域链： fooScopeChain&#x3D;[foo.Ao, global.VO];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">什么是AO,VO?</span><br><span class="line">       在函数创建时，每个函数都会创建一个活动对象Active Object(AO)，全局对象为Global Object(VO)，创建函数的过程也就是为这个对象添加属性的过程，作用域链就是由这些绑定了属性的活动对象构成的。</span><br><span class="line">        例如：找x变量；bar函数在搜寻变量x的过程中，先从自身AO对象上找，如果bar.AO存在这个属性，那么会直接使用这个属性的值，如果不存在，则会转到父级函数的AO对象，也就是foo.AO</span><br><span class="line">        如果找到x属性则使用，找不到继续 在global.VO对象查找，找到x的属性，返回属性值。如果在global.VO中没有找到，则会抛出异常ReferenceError</span><br><span class="line"></span><br><span class="line">执行上下文。</span><br><span class="line">       函数在执行时会创建一个称为“执行上下文（execution context）”的内部对象，执行上下文定义了函数</span><br><span class="line">       执行时的环境。每个执行上下文都有自己的作用域链，用于标识符解析，当执行上下文被创建时，而它的作用</span><br><span class="line">       域链初始化为当前运行函数的[[Scope]]所包含的对象。</span><br><span class="line">函数执行</span><br><span class="line">       在函数执行过程中，每遇到一个变量，都会检索从哪里获取和存储数据，该过程从作用域链头部，也就是从活</span><br><span class="line">       动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没有则继续搜索作用域</span><br><span class="line">       链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义，函数执行过程中，每个标识符都</span><br><span class="line">       要经历这样的搜索过程。</span><br></pre></td></tr></table></figure>
<p><strong>创建作用域链的过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  函数进入全局，创建VO对象，绑定x属性&lt;入栈&gt;</span><br><span class="line">    global.VO&#x3D;&#123;x&#x3D;underfind; foo:reference of function&#125;(这里只是预解析，为AO对象绑定声明的属性，函数执行时才会执行赋值语句，所以值是underfind)</span><br><span class="line"> 遇到foo函数，创建foo.AO，绑定y属性&lt;入栈&gt;</span><br><span class="line"> foo.AO&#x3D;&#123;y&#x3D;underfind, bar:reference of function&#125;</span><br><span class="line"> 遇到bar函数，创建bar.AO，绑定z属性&lt;入栈&gt;</span><br><span class="line">  bar.AO&#x3D;&#123;z:underfind&#125;</span><br><span class="line">作用域链和执行上下文都会保存在堆栈中，所以：</span><br><span class="line">bar函数的scope chain为：[0]bar.AO--&gt;[1]foo.AO--&gt;[2]global.VO</span><br><span class="line"></span><br><span class="line">      foo函数的scope chain为：[0]foo.AO--&gt;[1]global.Vo</span><br><span class="line">&#x2F;&#x2F;建议：少定义全局变量</span><br><span class="line">&#x2F;&#x2F;理由：因为作用域链是栈的结构，全局变量在栈底，每次访问全局变量都会遍历一次栈，&#x2F;&#x2F;这样会影响效率</span><br></pre></td></tr></table></figure>
<p>函数的scope等于自身的AO对象加上父级的scope，也可以理解为一个函数的作用域等于自身活动对象加上父级作用域.</p>
<p>函数执行前后的作用域链：</p>
<p>  <img src="image/877318-20161113161313920-1451924338.png" alt="img">    <img src="image/877318-20161113160610936-722944716.png" alt="img">  </p>
<p><strong>注意：作用域链的非自己部分在函数对象被建立（函数声明、函数表达式）的时候建立，而不需要等到执行</strong></p>
<p><strong>思考题2:</strong>                                                                                                              </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> for (var i&#x3D;1; i&lt;&#x3D;9; i++) &#123;</span><br><span class="line">     setTimeout( function timer()&#123;</span><br><span class="line">     console.log( i );</span><br><span class="line">     &#125;,1000 );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</span><br><span class="line"></span><br><span class="line">for (var i&#x3D;1; i&lt;&#x3D;9; i++) &#123;</span><br><span class="line">    (function()&#123;</span><br><span class="line">      var j &#x3D; i;</span><br><span class="line">      setTimeout( function timer()&#123;</span><br><span class="line">           console.log( j );</span><br><span class="line">      &#125;, 1000 );</span><br><span class="line">     &#125;)();</span><br></pre></td></tr></table></figure>
<h1 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a><strong>BOM对象</strong></h1><p>BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。</p>
<p>使 JavaScript 有能力与浏览器“对话”。 </p>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a><strong>window对象</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window对象</span><br><span class="line">    所有浏览器都支持 window 对象。</span><br><span class="line">    概念上讲.一个html文档对应一个window对象.</span><br><span class="line">    功能上讲: 控制浏览器窗口的.</span><br><span class="line">    使用上讲: window对象不需要创建对象,直接使用即可.</span><br></pre></td></tr></table></figure>
<h3 id="Window-对象方法"><a href="#Window-对象方法" class="headerlink" title="Window 对象方法"></a>Window 对象方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert()            显示带有一段消息和一个确认按钮的警告框。</span><br><span class="line">confirm()          显示带有一段消息以及确认按钮和取消按钮的对话框。</span><br><span class="line">prompt()           显示可提示用户输入的对话框。</span><br><span class="line"></span><br><span class="line">open()             打开一个新的浏览器窗口或查找一个已命名的窗口。</span><br><span class="line">close()            关闭浏览器窗口。</span><br><span class="line">setInterval()      按照指定的周期（以毫秒计）来调用函数或计算表达式。</span><br><span class="line">clearInterval()    取消由 setInterval() 设置的 timeout。</span><br><span class="line">setTimeout()       在指定的毫秒数后调用函数或计算表达式。</span><br><span class="line">clearTimeout()     取消由 setTimeout() 方法设置的 timeout。</span><br><span class="line">scrollTo()         把内容滚动到指定的坐标。</span><br></pre></td></tr></table></figure>
<p><strong>交互方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法讲解:    </span><br><span class="line">        &#x2F;&#x2F;----------alert confirm prompt----------------------------</span><br><span class="line">    &#x2F;&#x2F;alert(&#39;aaa&#39;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;* var result &#x3D; confirm(&quot;您确定要删除吗?&quot;);</span><br><span class="line">    alert(result); *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;prompt 参数1 : 提示信息.   参数2:输入框的默认值. 返回值是用户输入的内容.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; var result &#x3D; prompt(&quot;请输入一个数字!&quot;,&quot;haha&quot;);</span><br><span class="line">    &#x2F;&#x2F; alert(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    方法讲解:    </span><br><span class="line">        &#x2F;&#x2F;open方法 打开和一个新的窗口 并 进入指定网址.参数1 : 网址.</span><br><span class="line">        &#x2F;&#x2F;调用方式1</span><br><span class="line">            &#x2F;&#x2F;open(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);</span><br><span class="line">        &#x2F;&#x2F;参数1 什么都不填 就是打开一个新窗口.  参数2.填入新窗口的名字(一般可以不填). 参数3: 新打开窗口的参数.</span><br><span class="line">            open(&#39;&#39;,&#39;&#39;,&#39;width&#x3D;200,resizable&#x3D;no,height&#x3D;100&#39;); &#x2F;&#x2F; 新打开一个宽为200 高为100的窗口</span><br><span class="line">        &#x2F;&#x2F;close方法  将当前文档窗口关闭.</span><br><span class="line">            &#x2F;&#x2F;close();</span><br></pre></td></tr></table></figure>
<p><strong>练习：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num &#x3D; Math.round(Math.random()*100);</span><br><span class="line">function acceptInput()&#123;</span><br><span class="line">&#x2F;&#x2F;2.让用户输入(prompt)    并接受 用户输入结果</span><br><span class="line">var userNum &#x3D; prompt(&quot;请输入一个0~100之间的数字!&quot;,&quot;0&quot;);</span><br><span class="line">&#x2F;&#x2F;3.将用户输入的值与 随机数进行比较</span><br><span class="line">        if(isNaN(+userNum))&#123;</span><br><span class="line">            &#x2F;&#x2F;用户输入的无效(重复2,3步骤)</span><br><span class="line">            alert(&quot;请输入有效数字!&quot;);</span><br><span class="line">            acceptInput();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(userNum &gt; num)&#123;</span><br><span class="line">        &#x2F;&#x2F;大了&#x3D;&#x3D;&gt; 提示用户大了,让用户重新输入(重复2,3步骤)</span><br><span class="line">            alert(&quot;您输入的大了!&quot;);</span><br><span class="line">            acceptInput();</span><br><span class="line">        &#125;else if(userNum &lt; num)&#123;</span><br><span class="line">        &#x2F;&#x2F;小了&#x3D;&#x3D;&gt; 提示用户小了,让用户重新输入(重复2,3步骤)</span><br><span class="line">            alert(&quot;您输入的小了!&quot;);</span><br><span class="line">            acceptInput();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;答对了&#x3D;&#x3D;&gt;提示用户答对了 , 询问用户是否继续游戏(confirm).</span><br><span class="line">            var result &#x3D; confirm(&quot;恭喜您!答对了,是否继续游戏?&quot;);</span><br><span class="line">            if(result)&#123;</span><br><span class="line">                &#x2F;&#x2F;是 &#x3D;&#x3D;&gt; 重复123步骤.</span><br><span class="line">                num &#x3D; Math.round(Math.random()*100);</span><br><span class="line">                acceptInput();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;否&#x3D;&#x3D;&gt; 关闭窗口(close方法).</span><br><span class="line">                close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><strong>setInterval clearInterval</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;ID1&quot; type&#x3D;&quot;text&quot; onclick&#x3D;&quot;begin()&quot;&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;end()&quot;&gt;停止&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function showTime()&#123;</span><br><span class="line">           var nowd2&#x3D;new Date().toLocaleString();</span><br><span class="line">           var temp&#x3D;document.getElementById(&quot;ID1&quot;);</span><br><span class="line">           temp.value&#x3D;nowd2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var clock;</span><br><span class="line"></span><br><span class="line">    function begin()&#123;</span><br><span class="line"></span><br><span class="line">        if (clock&#x3D;&#x3D;undefined)&#123;</span><br><span class="line"></span><br><span class="line">             showTime();</span><br><span class="line">             clock&#x3D;setInterval(showTime,1000);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function end()&#123;</span><br><span class="line"></span><br><span class="line">        clearInterval(clock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>setTimeout clearTimeout</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ID &#x3D; setTimeout(abc,2000); &#x2F;&#x2F; 只调用一次对应函数.</span><br><span class="line">            clearTimeout(ID);</span><br><span class="line">    function abc()&#123;</span><br><span class="line">        alert(&#39;aaa&#39;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a><strong>History 对象</strong></h2><h4 id="History-对象属性"><a href="#History-对象属性" class="headerlink" title="History 对象属性"></a>History 对象属性</h4><p>History 对象包含用户（在浏览器窗口中）访问过的 URL。</p>
<p>History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;length  返回浏览器历史列表中的 URL 数量。&#96;</span><br></pre></td></tr></table></figure>
<h4 id="History-对象方法"><a href="#History-对象方法" class="headerlink" title="History 对象方法"></a>History 对象方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back()    加载 history 列表中的前一个 URL。</span><br><span class="line">forward()    加载 history 列表中的下一个 URL。</span><br><span class="line">go()    加载 history 列表中的某个具体页面。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;rrr.html&quot;&gt;click&lt;&#x2F;a&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot; history.forward()&quot;&gt;&gt;&gt;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;history.back()&quot;&gt;back&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;history.go()&quot;&gt;back&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a><strong>Location 对象</strong></h2><p>Location 对象包含有关当前 URL 的信息。</p>
<p>Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。</p>
<h4 id="Location-对象方法"><a href="#Location-对象方法" class="headerlink" title="Location 对象方法"></a>Location 对象方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location.assign(URL)</span><br><span class="line">location.reload()</span><br><span class="line">location.replace(newURL)&#x2F;&#x2F;注意与assign的区别</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/yuanchenqi/articles/5980312.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="DOM对象-DHTML"><a href="#DOM对象-DHTML" class="headerlink" title="DOM对象(DHTML)"></a><strong>DOM对象(DHTML)</strong></h1><h2 id="7-1-什么是-DOM？"><a href="#7-1-什么是-DOM？" class="headerlink" title="7.1 什么是 DOM？"></a><strong>7.1 什么是 DOM？</strong></h2><p>DOM 是 W3C（万维网联盟）的标准。DOM 定义了访问 HTML 和 XML 文档的标准：</p>
<p>“W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”</p>
<p>W3C DOM 标准被分为 3 个不同的部分：</p>
<ul>
<li>核心 DOM - 针对任何结构化文档的标准模型</li>
<li>XML DOM - 针对 XML 文档的标准模型</li>
<li>HTML DOM - 针对 HTML 文档的标准模型</li>
</ul>
<ul>
<li>什么是 XML DOM？  －－－－&gt;XML DOM 定义了所有 XML 元素的对象和属性，以及访问它们的方法。</li>
<li>什么是 HTML DOM？－－－－&gt;HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。</li>
</ul>
<h2 id="7-2-DOM-节点"><a href="#7-2-DOM-节点" class="headerlink" title="7.2 DOM 节点"></a><strong>7.2 DOM 节点</strong></h2><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点(NODE)：</p>
<ul>
<li>整个文档是一个文档节点(document对象)</li>
<li>每个 HTML 元素是元素节点(element 对象)</li>
<li>HTML 元素内的文本是文本节点(text对象)</li>
<li>每个 HTML 属性是属性节点(attribute对象)</li>
<li>注释是注释节点(comment对象)</li>
</ul>
<p>画dom树是为了展示文档中各个对象之间的关系，用于对象的导航。</p>
<p><img src="image/877318-20161109144227733-1189353791.png" alt="img"></p>
<p>节点(自身)属性:</p>
<ul>
<li>attributes - 节点（元素）的属性节点</li>
<li>nodeType – 节点类型</li>
<li>nodeValue – 节点值</li>
<li>nodeName – 节点名称</li>
<li>innerHTML - 节点（元素）的文本值</li>
</ul>
<p>导航属性:</p>
<ul>
<li>parentNode - 节点（元素）的父节点 (推荐)</li>
<li>firstChild – 节点下第一个子元素</li>
<li>lastChild – 节点下最后一个子元素</li>
<li>childNodes - 节点（元素）的子节点 </li>
</ul>
<p><strong>注意：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;p&gt;hello yuan&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var div&#x3D;document.getElementById(&quot;div2&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(div.nextSibling.nodeName);  &#x2F;&#x2F;思考:为什么不是P?</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>推荐导航属性：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parentElement              &#x2F;&#x2F; 父节点标签元素</span><br><span class="line"></span><br><span class="line">children                        &#x2F;&#x2F; 所有子标签</span><br><span class="line">  </span><br><span class="line">firstElementChild          &#x2F;&#x2F; 第一个子标签元素</span><br><span class="line"></span><br><span class="line">lastElementChild           &#x2F;&#x2F; 最后一个子标签元素</span><br><span class="line"></span><br><span class="line">nextElementtSibling       &#x2F;&#x2F; 下一个兄弟标签元素</span><br><span class="line"></span><br><span class="line">previousElementSibling  &#x2F;&#x2F; 上一个兄弟标签元素</span><br></pre></td></tr></table></figure>
<p>节点树中的节点彼此拥有层级关系。</p>
<p>父(parent),子(child)和同胞(sibling)等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）。</p>
<ul>
<li>在节点树中，顶端节点被称为根（root）</li>
<li>每个节点都有父节点、除了根（它没有父节点）</li>
<li>一个节点可拥有任意数量的子</li>
<li>同胞是拥有相同父节点的节点</li>
</ul>
<p>下面的图片展示了节点树的一部分，以及节点之间的关系：</p>
<p>​         <img src="image/877318-20161109150149420-1767730470.png" alt="img"></p>
<p>访问 HTML 元素（节点）,访问 HTML 元素等同于访问节点,我们能够以不同的方式来访问 HTML 元素：</p>
<p>页面查找：</p>
<ul>
<li>通过使用 getElementById() 方法 </li>
<li>通过使用 getElementsByTagName() 方法 </li>
<li>通过使用 getElementsByClassName() 方法 </li>
<li>通过使用 getElementsByName() 方法 </li>
</ul>
<p>局部查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class&#x3D;&quot;div2&quot;&gt;i am div2&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div name&#x3D;&quot;yuan&quot;&gt;i am div2&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;div3&quot;&gt;i am div2&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;p&gt;hello p&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   var div1&#x3D;document.getElementById(&quot;div1&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;支持;</span><br><span class="line">&#x2F;&#x2F;   var ele&#x3D; div1.getElementsByTagName(&quot;p&quot;);</span><br><span class="line">&#x2F;&#x2F;   alert(ele.length);</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;支持</span><br><span class="line">&#x2F;&#x2F;   var ele2&#x3D;div1.getElementsByClassName(&quot;div2&quot;);</span><br><span class="line">&#x2F;&#x2F;   alert(ele2.length);</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;不支持</span><br><span class="line">&#x2F;&#x2F;   var ele3&#x3D;div1.getElementById(&quot;div3&quot;);</span><br><span class="line">&#x2F;&#x2F;   alert(ele3.length);</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;不支持</span><br><span class="line">&#x2F;&#x2F;   var ele4&#x3D;div1.getElementsByName(&quot;yuan&quot;);</span><br><span class="line">&#x2F;&#x2F;   alert(ele4.length)</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-HTML-DOM-Event-事件"><a href="#7-3-HTML-DOM-Event-事件" class="headerlink" title="7.3 HTML DOM Event(事件)"></a>7.3 HTML DOM Event(事件)</h2><p>HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onclick        当用户点击某个对象时调用的事件句柄。</span><br><span class="line">ondblclick     当用户双击某个对象时调用的事件句柄。</span><br><span class="line"></span><br><span class="line">onfocus        元素获得焦点。               &#x2F;&#x2F;练习：输入框</span><br><span class="line">onblur         元素失去焦点。               应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.</span><br><span class="line">onchange       域的内容被改变。             应用场景：通常用于表单元素,当元素内容被改变时触发.（三级联动）</span><br><span class="line"></span><br><span class="line">onkeydown      某个键盘按键被按下。          应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.</span><br><span class="line">onkeypress     某个键盘按键被按下并松开。</span><br><span class="line">onkeyup        某个键盘按键被松开。</span><br><span class="line">onload         一张页面或一幅图像完成加载。</span><br><span class="line">onmousedown    鼠标按钮被按下。</span><br><span class="line">onmousemove    鼠标被移动。</span><br><span class="line">onmouseout     鼠标从某元素移开。</span><br><span class="line">onmouseover    鼠标移到某元素之上。</span><br><span class="line">onmouseleave   鼠标从元素离开</span><br><span class="line"></span><br><span class="line">onselect      文本被选中。</span><br><span class="line">onsubmit      确认按钮被点击。</span><br></pre></td></tr></table></figure>
<p>两种为元素附加事件属性的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div onclick&#x3D;&quot;alert(123)&quot;&gt;点我呀&lt;&#x2F;div&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;abc&quot;&gt;试一试!&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var ele&#x3D;document.getElementById(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ele.onclick&#x3D;function()&#123;</span><br><span class="line">        alert(&quot;hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;abc&quot; onclick&#x3D;&quot;func1(this)&quot;&gt;事件绑定方式1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;id123&quot;&gt;事件绑定方式2&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function func1(self)&#123;</span><br><span class="line">        console.log(self.id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;jquery下是$(self), 这种方式this参数必须填写;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;------------------------------------------</span><br><span class="line">    var ele&#x3D;document.getElementById(&quot;id123&quot;).onclick&#x3D;function()&#123;</span><br><span class="line">         console.log(this.id);</span><br><span class="line">        &#x2F;&#x2F;jquery下是$(this), 这种方式不需要this参数;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>onload：</strong></p>
<p>onload 属性开发中 只给 body元素加.<br>这个属性的触发 标志着 页面内容被加载完成.<br>应用场景: 当有些事情我们希望页面加载完立刻执行,那么可以使用该事件属性.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;          window.onload&#x3D;function()&#123;</span><br><span class="line">&#x2F;&#x2F;               var ele&#x3D;document.getElementById(&quot;ppp&quot;);</span><br><span class="line">&#x2F;&#x2F;               ele.onclick&#x3D;function()&#123;</span><br><span class="line">&#x2F;&#x2F;                alert(123)</span><br><span class="line">&#x2F;&#x2F;            &#125;;</span><br><span class="line">&#x2F;&#x2F;          &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          function fun1() &#123;</span><br><span class="line">              var ele&#x3D;document.getElementById(&quot;ppp&quot;);</span><br><span class="line">               ele.onclick&#x3D;function()&#123;</span><br><span class="line">                alert(123)</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;fun1()&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;p id&#x3D;&quot;ppp&quot;&gt;hello p&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>onsubmit:</strong></p>
<p>是当表单在提交时触发. 该属性也只能给form元素使用.应用场景: 在表单提交前验证用户输入是否正确.如果验证失败.在该方法中我们应该阻止表单的提交.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form id&#x3D;&quot;form&quot;&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;text&quot;&#x2F;&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;点我!&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">            &#x2F;&#x2F;阻止表单提交方式1().</span><br><span class="line">            &#x2F;&#x2F;onsubmit 命名的事件函数,可以接受返回值. 其中返回false表示拦截表单提交.其他为放行.</span><br><span class="line"></span><br><span class="line">            var ele&#x3D;document.getElementById(&quot;form&quot;);</span><br><span class="line">            ele.onsubmit&#x3D;function(event) &#123;</span><br><span class="line">&#x2F;&#x2F;                alert(&quot;验证失败 表单不会提交!&quot;);</span><br><span class="line">&#x2F;&#x2F;                return false;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F; 阻止表单提交方式2 event.preventDefault(); &#x3D;&#x3D;&gt;通知浏览器不要执行与事件关联的默认动作。</span><br><span class="line">             alert(&quot;验证失败 表单不会提交!&quot;);</span><br><span class="line">             event.preventDefault();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Event 对象</strong></p>
<p>Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p>
<p>事件通常与函数结合使用，函数不会在事件发生前被执行！event对象在事件发生时系统已经创建好了,并且会在事件函数被调用时传给事件函数.我们获得仅仅需要接收一下即可.</p>
<p>比如onkeydown,我们想知道哪个键被按下了，需要问下event对象的属性，这里就时KeyCode；</p>
<p>思考：onclick＝function(event){};这个方法是谁调用的？</p>
<p><strong>事件传播：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;abc_1&quot; style&#x3D;&quot;border:1px solid red;width:300px;height:300px;&quot;&gt;</span><br><span class="line">        &lt;div id&#x3D;&quot;abc_2&quot; style&#x3D;&quot;border:1px solid red;width:200px;height:200px;&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&quot;abc_1&quot;).onclick&#x3D;function()&#123;</span><br><span class="line">        alert(&#39;111&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&quot;abc_2&quot;).onclick&#x3D;function(event)&#123;</span><br><span class="line">        alert(&#39;222&#39;);</span><br><span class="line">        event.stopPropagation(); &#x2F;&#x2F;阻止事件向外层div传播.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="7-4-增删改查演示"><a href="#7-4-增删改查演示" class="headerlink" title="7.4 增删改查演示"></a>7.4 增删改查演示</h2><h3 id="7-4-1-node的CURD："><a href="#7-4-1-node的CURD：" class="headerlink" title="7.4.1 node的CURD："></a><strong>7.4.1 node的CURD：</strong></h3><p><strong>增:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;createElement(name)创建元素</span><br><span class="line">appendChild();将元素添加&#96;</span><br></pre></td></tr></table></figure>
<p><strong>删</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;获得要删除的元素&#96;&#96;获得它的父元素</span><br><span class="line">使用removeChild()方法删除&#96;</span><br></pre></td></tr></table></figure>
<p><strong>改</strong>:</p>
<p>第一种方式:</p>
<p>​      使用上面增和删结合完成修改</p>
<p>第二种方式:</p>
<p>使用setAttribute();方法修改属性          </p>
<p>使用innerHTML属性修改元素的内容</p>
<p><strong>查</strong>:  使用之前介绍的方法.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;在第一个div中动态增加一个a标签. 该a标签点击之后跳转到百度首页.</span><br><span class="line">    function addNode()&#123;</span><br><span class="line">        &#x2F;&#x2F;1.获得 第一个div</span><br><span class="line">        var div &#x3D; document.getElementById(&quot;div_1&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建a标签  createElement&#x3D;&#x3D;&gt;创建一个a标签   &lt;a&gt;&lt;&#x2F;a&gt;</span><br><span class="line">        var eleA &#x3D;  document.createElement(&quot;a&quot;);</span><br><span class="line">        &#x2F;&#x2F;3.为a标签添加属性 &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">        eleA.setAttribute(&quot;href&quot;, &quot;http:&#x2F;&#x2F;www.baidu.com&quot;);</span><br><span class="line">        &#x2F;&#x2F;4.为a标签添加内容 &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;</span><br><span class="line">        eleA.innerHTML &#x3D; &quot;百度&quot;;    </span><br><span class="line">        &#x2F;&#x2F;5.将a标签添加到div中</span><br><span class="line">        div.appendChild(eleA);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;点击后 删除div区域2</span><br><span class="line">    function deleteNode()&#123;</span><br><span class="line">        &#x2F;&#x2F;1 获得要删除的div区域</span><br><span class="line">            var div &#x3D; document.getElementById(&quot;div_2&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.获得父亲</span><br><span class="line">            var parent &#x3D; div.parentNode;</span><br><span class="line">        &#x2F;&#x2F;3 由父亲操刀 </span><br><span class="line">            parent.removeChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;点击后 替换div区域3 为一个美女</span><br><span class="line">    function updateNode()&#123;</span><br><span class="line">        &#x2F;&#x2F;1 获得要替换的div区域3</span><br><span class="line">        var div &#x3D; document.getElementById(&quot;div_3&quot;);</span><br><span class="line">        &#x2F;&#x2F;2创建img标签对象 &lt;img &#x2F;&gt;</span><br><span class="line">        var img &#x3D; document.createElement(&quot;img&quot;);</span><br><span class="line">        &#x2F;&#x2F;3添加属性 &lt;img src&#x3D;&quot;001.jpg&quot; &#x2F;&gt;</span><br><span class="line">        img.setAttribute(&quot;src&quot;, &quot;001.JPG&quot;);</span><br><span class="line">        &#x2F;&#x2F;4.获得父节点</span><br><span class="line">        var parent &#x3D; div.parentNode;</span><br><span class="line">        &#x2F;&#x2F;5.替换</span><br><span class="line">        parent.replaceChild(img, div);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;点击后 将div区域4 克隆一份 添加到页面底部</span><br><span class="line">    </span><br><span class="line">    function copyNode()&#123;</span><br><span class="line">        &#x2F;&#x2F;1.获取要克隆的div</span><br><span class="line">        var div &#x3D; document.getElementById(&quot;div_4&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.克隆 参数为true 那么克隆时克隆所有子元素. false 只克隆自己</span><br><span class="line">        var div_copy &#x3D; div.cloneNode(true);</span><br><span class="line">        &#x2F;&#x2F;3.获得父亲</span><br><span class="line">        var parent &#x3D; div.parentNode;</span><br><span class="line">        &#x2F;&#x2F;4.添加</span><br><span class="line">        parent.appendChild(div_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-2-修改-HTML-DOM"><a href="#7-4-2-修改-HTML-DOM" class="headerlink" title="7.4.2  修改 HTML DOM"></a>7.4.2  修改 HTML DOM</h3><ul>
<li>改变 HTML 内容 </li>
</ul>
<p>​        改变元素内容的最简答的方法是使用 innerHTML ，innerText。</p>
<ul>
<li>改变 CSS 样式 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&lt;p id&#x3D;&#96;&#96;&quot;p2&quot;&#96;&#96;&gt;Hello world!&lt;&#x2F;p&gt;&#96;&#96;document.getElementById(&#96;&#96;&quot;p2&quot;&#96;&#96;).style.color&#x3D;&#96;&#96;&quot;blue&quot;&#96;&#96;;&lt;br&gt;                             .style.fontSize&#x3D;48px&#96;</span><br></pre></td></tr></table></figure>
<ul>
<li>改变 HTML 属性 </li>
</ul>
<p>​        elementNode.setAttribute(name,value)</p>
<p>​        elementNode.getAttribute(name)&lt;———————&gt;elementNode.value(DHTML)</p>
<ul>
<li>创建新的 HTML 元素 </li>
</ul>
<p>​        createElement(name)</p>
<ul>
<li>删除已有的 HTML 元素 </li>
</ul>
<p>​        elementNode.removeChild(node)</p>
<ul>
<li>关于class的操作 </li>
</ul>
<p>​        elementNode.className</p>
<p>​        elementNode.classList.add</p>
<p>​        elementNode.classList.remove</p>
<p><a href="https://www.cnblogs.com/yuanchenqi/articles/5980312.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="8-实例练习"><a href="#8-实例练习" class="headerlink" title="8 实例练习"></a>8 实例练习</h1><h3 id="1-搜索框"><a href="#1-搜索框" class="headerlink" title="1 搜索框"></a>1 搜索框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;ID1&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;请输入用户名&quot; onblur&#x3D;&quot;Blurs()&quot; onfocus&#x3D;&quot;Focus()&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">function Focus()&#123;</span><br><span class="line"></span><br><span class="line">    var input&#x3D;document.getElementById(&quot;ID1&quot;);</span><br><span class="line">    if (input.value&#x3D;&#x3D;&quot;请输入用户名&quot;)&#123;</span><br><span class="line">        input.value&#x3D;&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Blurs()&#123;</span><br><span class="line"></span><br><span class="line">    var ele&#x3D;document.getElementById(&quot;ID1&quot;);</span><br><span class="line">    var val&#x3D;ele.value;</span><br><span class="line">    if(!val.trim())&#123;</span><br><span class="line"></span><br><span class="line">        ele.value&#x3D;&quot;请输入用户名&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-模态对话框"><a href="#2-模态对话框" class="headerlink" title="2 模态对话框"></a>2 模态对话框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .back&#123;</span><br><span class="line">            background-color: rebeccapurple;</span><br><span class="line">            height: 2000px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .shade&#123;</span><br><span class="line">            position: fixed;</span><br><span class="line">            top: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            left:0;</span><br><span class="line">            right: 0;</span><br><span class="line">            background-color: coral;</span><br><span class="line">            opacity: 0.4;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .hide&#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .models&#123;</span><br><span class="line">            position: fixed;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            margin-left: -100px;</span><br><span class="line">            margin-top: -100px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            width: 200px;</span><br><span class="line">            background-color: gold;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;back&quot;&gt;</span><br><span class="line">    &lt;input id&#x3D;&quot;ID1&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;click&quot; onclick&#x3D;&quot;action(&#39;show&#39;)&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;shade hide&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;models hide&quot;&gt;</span><br><span class="line">    &lt;input id&#x3D;&quot;ID2&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;cancel&quot; onclick&#x3D;&quot;action(&#39;hide&#39;)&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    function action(act)&#123;</span><br><span class="line">        var ele&#x3D;document.getElementsByClassName(&quot;shade&quot;)[0];</span><br><span class="line">        var ele2&#x3D;document.getElementsByClassName(&quot;models&quot;)[0];</span><br><span class="line">        if(act&#x3D;&#x3D;&quot;show&quot;)&#123;</span><br><span class="line">              ele.classList.remove(&quot;hide&quot;);</span><br><span class="line">              ele2.classList.remove(&quot;hide&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">              ele.classList.add(&quot;hide&quot;);</span><br><span class="line">              ele2.classList.add(&quot;hide&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-全选反选取消"><a href="#3-全选反选取消" class="headerlink" title="3 全选反选取消"></a>3 全选反选取消</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;button onclick&#x3D;&quot;select(&#39;all&#39;);&quot;&gt;全选&lt;&#x2F;button&gt;</span><br><span class="line">     &lt;button onclick&#x3D;&quot;select(&#39;cancel&#39;);&quot;&gt;取消&lt;&#x2F;button&gt;</span><br><span class="line">     &lt;button onclick&#x3D;&quot;select(&#39;reverse&#39;);&quot;&gt;反选&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">     &lt;table border&#x3D;&quot;1&quot; id&#x3D;&quot;Table&quot;&gt;</span><br><span class="line">         &lt;tr&gt;</span><br><span class="line">             &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">             &lt;td&gt;111&lt;&#x2F;td&gt;</span><br><span class="line">         &lt;&#x2F;tr&gt;</span><br><span class="line">         &lt;tr&gt;</span><br><span class="line">             &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">             &lt;td&gt;222&lt;&#x2F;td&gt;</span><br><span class="line">         &lt;&#x2F;tr&gt;</span><br><span class="line">         &lt;tr&gt;</span><br><span class="line">             &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">             &lt;td&gt;333&lt;&#x2F;td&gt;</span><br><span class="line">         &lt;&#x2F;tr&gt;</span><br><span class="line">         &lt;tr&gt;</span><br><span class="line">             &lt;td&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">             &lt;td&gt;444&lt;&#x2F;td&gt;</span><br><span class="line">         &lt;&#x2F;tr&gt;</span><br><span class="line">     &lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function select(choice)&#123;</span><br><span class="line">        var ele&#x3D;document.getElementById(&quot;Table&quot;);</span><br><span class="line"></span><br><span class="line">        var inputs&#x3D;ele.getElementsByTagName(&quot;input&quot;);</span><br><span class="line">        for (var i&#x3D;0;i&lt;inputs.length;i&#x3D;i+1)&#123;</span><br><span class="line"></span><br><span class="line">                   var ele2&#x3D;inputs[i];</span><br><span class="line">            if (choice&#x3D;&#x3D;&quot;all&quot;)&#123;</span><br><span class="line">                ele2.checked&#x3D;true;</span><br><span class="line"></span><br><span class="line">            &#125;else if(choice&#x3D;&#x3D;&quot;cancel&quot;)&#123;</span><br><span class="line">                ele2.checked&#x3D;false;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line"></span><br><span class="line">                if (ele2.checked)&#123;</span><br><span class="line">                    ele2.checked&#x3D;false;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    ele2.checked&#x3D;true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-两级联动"><a href="#4-两级联动" class="headerlink" title="4 两级联动"></a>4 两级联动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;province&quot;&gt;</span><br><span class="line">    &lt;option&gt;请选择省:&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;city&quot;&gt;</span><br><span class="line">    &lt;option&gt;请选择市:&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    data&#x3D;&#123;&quot;河北省&quot;:[&quot;廊坊&quot;,&quot;邯郸&quot;],&quot;北京&quot;:[&quot;朝阳区&quot;,&quot;海淀区&quot;]&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      var p&#x3D;document.getElementById(&quot;province&quot;);</span><br><span class="line">      var c&#x3D;document.getElementById(&quot;city&quot;);</span><br><span class="line">    </span><br><span class="line">    for(var i in data)&#123;</span><br><span class="line">        var option_pro&#x3D;document.createElement(&quot;option&quot;);</span><br><span class="line"></span><br><span class="line">        option_pro.innerHTML&#x3D;i;</span><br><span class="line"></span><br><span class="line">        p.appendChild(option_pro);</span><br><span class="line">    &#125;</span><br><span class="line">     p.onchange&#x3D;function()&#123;</span><br><span class="line"></span><br><span class="line">            pro&#x3D;(this.options[this.selectedIndex]).innerHTML;</span><br><span class="line">            citys&#x3D;data[pro];</span><br><span class="line"></span><br><span class="line">         c.options.length&#x3D;0;</span><br><span class="line"></span><br><span class="line">         for (var i in citys)&#123;</span><br><span class="line">             var option_city&#x3D;document.createElement(&quot;option&quot;);</span><br><span class="line">             option_city.innerHTML&#x3D;citys[i];</span><br><span class="line">             c.appendChild(option_city);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-select左右移"><a href="#5-select左右移" class="headerlink" title="5 select左右移"></a>5 select左右移</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;box1&quot;&gt;</span><br><span class="line">    &lt;select multiple&#x3D;&quot;multiple&quot; size&#x3D;&quot;10&quot; id&#x3D;&quot;left&quot;&gt;</span><br><span class="line">        &lt;option&gt;book&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;book2&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;book3&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;book4&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;book5&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;book6&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;choice&quot;&gt;</span><br><span class="line">    &lt;input class&#x3D;&quot;add&quot;     type&#x3D;&quot;button&quot; value&#x3D;&quot;---&gt;&quot; onclick&#x3D;&quot;add()&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input class&#x3D;&quot;remove&quot;  type&#x3D;&quot;button&quot; value&#x3D;&quot;&lt;---&quot; onclick&#x3D;&quot;remove();&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input class&#x3D;&quot;add-all&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot; onclick&#x3D;&quot;ADDall()&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input class&#x3D;&quot;remove-all&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;&lt;&#x3D;&#x3D;&#x3D;&quot; onclick&#x3D;&quot;remall()&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;select multiple&#x3D;&quot;multiple&quot; size&#x3D;&quot;10&quot; id&#x3D;&quot;right&quot;&gt;</span><br><span class="line">        &lt;option&gt;book9&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">     function add()&#123;</span><br><span class="line">         var right&#x3D;document.getElementById(&quot;right&quot;);</span><br><span class="line">         var options&#x3D;document.getElementById(&quot;left&quot;).getElementsByTagName(&quot;option&quot;);</span><br><span class="line"></span><br><span class="line">         for (var i&#x3D;0; i&lt;options.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">             var option&#x3D;options[i];</span><br><span class="line"></span><br><span class="line">             if(option.selected&#x3D;&#x3D;true)&#123;</span><br><span class="line">                   right.appendChild(option);</span><br><span class="line">                 i--;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    function ADDall()&#123;</span><br><span class="line">         var right&#x3D;document.getElementById(&quot;right&quot;);</span><br><span class="line">         var options&#x3D;document.getElementById(&quot;left&quot;).getElementsByTagName(&quot;option&quot;);</span><br><span class="line">         for (var i&#x3D;0; i&lt;options.length;i++)&#123;</span><br><span class="line">             var option&#x3D;options[i];</span><br><span class="line">             right.appendChild(option);</span><br><span class="line">             i--;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-SE笔记2</title>
    <url>/2020/12/29/JAVA-SE%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>JAVA SE笔记第二部分:</p>
<p>反射、注解、范型、集合、IO、日期和时间<br><a id="more"></a></p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射是指程序运行期间可以拿到一个对象的所有信息。</p>
<p>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p>
<p>除了<code>int</code>等基本类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>）。</p>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。</p>
<p>它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个Class实例包含了该class的所有完整信息：</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package &#x3D; &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super &#x3D; &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface &#x3D; CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field &#x3D; value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method &#x3D; indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>
<h3 id="获取Class实例"><a href="#获取Class实例" class="headerlink" title="获取Class实例"></a>获取Class实例</h3><p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>
<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>
<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
<p><code>Class</code>类提供了以下几个方法来获取字段：</p>
<ul>
<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getFields()：获取所有public的field（包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类） </li>
</ul>
<p>一个<code>Field</code>对象包含了一个字段的所有信息：</p>
<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">Field f = String.class.getDeclaredField("value");</span><br><span class="line">f.getName(); <span class="comment">// "value"</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// "Xiao Ming"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f.setAccessible(true);</span><br></pre></td></tr></table></figure>
<p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p>
<blockquote>
<p><code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
</blockquote>
<p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的，其中第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。</p>
<pre><code>Field f = c.getDeclaredField(&quot;name&quot;);
f.setAccessible(true);
f.set(p, &quot;Xiao Hong&quot;);
</code></pre><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p><code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p>
<ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class stdClass = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">System.out.println(stdClass.getMethod(<span class="string">"getScore"</span>, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"><span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">System.out.println(stdClass.getMethod(<span class="string">"getName"</span>));</span><br><span class="line"><span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">System.out.println(stdClass.getDeclaredMethod(<span class="string">"getGrade"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>
<p><strong>调用方法</strong></p>
<p>一个<code>Method</code>对象包含一个方法的所有信息：</p>
<ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>{String.class, int.class}</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">// String对象:</span></span><br><span class="line">String s = <span class="string">"Hello world"</span>;</span><br><span class="line"><span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">Method m = String.class.getMethod("substring", int.class);</span><br><span class="line"><span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。</span></span><br><span class="line"><span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">Method m = Integer.class.getMethod("parseInt", String.class);</span><br><span class="line"><span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">"12345"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>调用非public方法</strong></p>
<p>为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用.</p>
<blockquote>
<p><code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
<p>使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。</p>
</blockquote>
<h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = Person<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;    </span><br><span class="line"><span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">Constructor cons1 = Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">// 调用构造方法:</span></span><br><span class="line">Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>通过Class实例获取Constructor的方法如下：</p>
<ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><p><strong>获取父类的Class</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class i = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class n = i.getSuperclass();</span><br></pre></td></tr></table></figure>
<p><strong>获取interface</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">Class s = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class[] is = s.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型</p>
</blockquote>
<p><strong>继承关系</strong></p>
<p>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Number</span>.<span class="title">class</span>)</span>; <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><code>class</code>和<code>interface</code>的区别：</p>
<ul>
<li>可以实例化<code>class</code>（非<code>abstract</code>）；</li>
<li>不能实例化<code>interface</code>。</li>
</ul>
<p>所有<code>interface</code>类型的变量总是通过向上转型并指向某个实例的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CharSequence cs = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>
<p>动态代理（Dynamic Proxy）机制：在运行期动态创建某个<code>interface</code>的实例。</p>
<p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p>
<ol>
<li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li>
<li>通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：<ol>
<li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去；</li>
<li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li>
</ol>
</li>
<li>将返回的<code>Object</code>强制转型为接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"morning"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Good morning, "</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), // 传入<span class="title">ClassLoader</span></span></span><br><span class="line">            new Class[] &#123; Hello.class &#125;, // 传入要实现的接口</span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">"Bob"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is a component:</span></span><br><span class="line"><span class="meta">@Resource</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(@Param String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Java的注解可以分为三类：</strong></p>
<ol>
<li>第一类是由<strong>编译器使用的注解</strong>，例如：</li>
</ol>
<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>
</ul>
<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
<ol>
<li><p>第二类是由<strong>工具处理<code>.class</code>文件使用的注解</strong>，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>
</li>
<li><p>第三类是在<strong>程序运行期能够读取的注解</strong>，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
</li>
</ol>
<p><strong>定义一个注解时，还可以定义配置参数。配置参数可以包括：</strong></p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<p><strong>定义注解</strong></p>
<p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<p><strong>@Target</strong></p>
<p>使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为数组<code>{ ElementType.METHOD, ElementType.FIELD }</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">    ElementType.METHOD,</span><br><span class="line">    ElementType.FIELD</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>
<ul>
<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>
<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>
<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>
</ul>
<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@Repeatable</strong></p>
<p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。这个注解应用不是特别广泛。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repeatable(Reports.class)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Report(type&#x3D;1, level&#x3D;&quot;debug&quot;)</span><br><span class="line">@Report(type&#x3D;2, level&#x3D;&quot;warning&quot;)</span><br><span class="line">public class Hello &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@Inherited</strong></p>
<p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Inherited</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用的时候，如果一个类用到了<code>@Report</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Report(type&#x3D;1)</span><br><span class="line">public class Person &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则它的子类默认也定义了该注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student extends Person &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何定义Annotation</strong></p>
<p>我们总结一下定义<code>Annotation</code>的步骤：</p>
<p>第一步，用<code>@interface</code>定义注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public @interface Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，添加参数、默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<p>第三步，用元注解配置注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<h2 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h2><p><code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>
<p>注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>
<p><strong>反射API</strong></p>
<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p><strong>使用注解</strong></p>
<p>在某个JavaBean中，我们可以使用该注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    @Range(min&#x3D;1, max&#x3D;20)</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    @Range(max&#x3D;10)</span><br><span class="line">    public String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid field: "</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>
<h1 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h1><p>类型<code>ArrayList&lt;T&gt;</code>可以向上转型为<code>List&lt;T&gt;</code>。</p>
<p>要<em>特别注意</em>：不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>。</p>
<h2 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h2><p>编写泛型类时，要特别注意，泛型类型<code>&lt;T&gt;</code>不能用于静态方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; <span class="function">Pair&lt;K&gt; <span class="title">create</span><span class="params">(K first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h3><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Pair&lt;T, K&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private K last;</span><br><span class="line">    public Pair(T first, K last) &#123;</span><br><span class="line">        this.first &#x3D; first;</span><br><span class="line">        this.last &#x3D; last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123; ... &#125;</span><br><span class="line">    public K getLast() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h2><p>擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p>
<p>Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>
<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>
</ul>
<p>因为Java泛型的实现方式——擦拭法，Java泛型的局限：</p>
<ul>
<li>局限一：<code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pair&lt;int&gt; p &#x3D; new Pair&lt;&gt;(1, 2); &#x2F;&#x2F; compile error!</span><br></pre></td></tr></table></figure>
<ul>
<li>局限二：无法取得带泛型的<code>Class</code>。如<code>Pair&lt;T&gt;</code>通过<code>getClass()</code>得到的永远是<code>Pair&lt;Object&gt;</code></li>
<li>局限三：无法判断带泛型的类型</li>
<li>局限四：不能实例化<code>T</code>类型.（不能使用<code>new T()</code>）</li>
</ul>
<h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类的类型是<code>Pair&lt;Integer&gt;</code>，子类的类型是<code>IntPair</code>，可以这么继承：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IntPair extends Pair&lt;Integer&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IntPair ip &#x3D; new IntPair(1, 2);</span><br></pre></td></tr></table></figure>
<p>前面讲了，我们无法获取<code>Pair&lt;T&gt;</code>的<code>T</code>类型，即给定一个变量<code>Pair&lt;Integer&gt; p</code>，无法从<code>p</code>中获取到<code>Integer</code>类型。</p>
<p>但是，在父类是泛型类型的情况下，编译器就必须把类型<code>T</code>（对<code>IntPair</code>来说，也就是<code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code>IntPair</code>只能存取<code>Integer</code>这种类型。</p>
<p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。</p>
<h2 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h2><p><code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">    Number first = p.getFirst();</span><br><span class="line">    Number last = p.getLast();</span><br><span class="line">    <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code>T</code>的上界限定在<code>Number</code>了。</p>
<p><code>List&lt;? extends Integer&gt;</code>的限制：</p>
<ul>
<li>允许调用<code>get()</code>方法获取<code>Integer</code>的引用；</li>
<li>不允许调用<code>set(? extends Integer)</code>方法并传入任何<code>Integer</code>的引用（<code>null</code>除外）。</li>
</ul>
<p><strong>使用extends限定T类型</strong></p>
<p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们只能定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Number&gt; p1 = <span class="keyword">null</span>;</span><br><span class="line">Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Pair&lt;Double&gt; p3 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h2><p><code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</p>
<p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>
<ul>
<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>
<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li>
</ul>
<h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p><strong>PECS原则</strong>：Producer Extends Consumer Super。</p>
<p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p>
<h2 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h2><p>Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code>?</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void sample(Pair&lt;?&gt; p) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p>
<ul>
<li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li>
<li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li>
<li>既不能读，也不能写，那只能做一些<code>null</code>判断：</li>
</ul>
<p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类</p>
<h2 id="范型和反射"><a href="#范型和反射" class="headerlink" title="范型和反射"></a>范型和反射</h2><p>可以声明带泛型的数组，但不能用<code>new</code>操作符创建带泛型的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt;[] ps = <span class="keyword">null</span>; <span class="comment">// ok</span></span><br><span class="line">Pair&lt;String&gt;[] ps = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">2</span>]; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>
<p>必须通过强制转型实现带泛型的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> Pair[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。</p>
</blockquote>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除<code>Map</code>外所有其他集合类的根接口。Java的<code>java.util</code>包主要提供了以下三种类型的集合：</p>
<ul>
<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>
<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>
</ul>
<p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 只能放入String类型</span><br></pre></td></tr></table></figure>
<p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>
<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>
<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p>
<ul>
<li><p>在末尾添加一个元素：<code>boolean add(E e)</code></p>
</li>
<li><p>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></p>
</li>
<li><p>删除指定索引的元素：<code>int remove(int index)</code></p>
</li>
<li><p>删除某个元素：<code>int remove(Object e)</code></p>
</li>
<li><p>获取指定索引的元素：<code>E get(int index)</code></p>
</li>
<li><p>获取链表大小（包含元素的个数）：<code>int size()</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建1</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"apple"</span>); <span class="comment">// size=1</span></span><br><span class="line">list.add(<span class="keyword">null</span>); <span class="comment">// size=2</span></span><br><span class="line"><span class="comment">// 创建2</span></span><br><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="comment">// 始终坚持使用迭代器Iterator来访问List。Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。</span></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>);</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">  String s = it.next();</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与上述方法等价</span></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List和Array转换</span></span><br><span class="line"><span class="comment">// List to Array</span></span><br><span class="line"><span class="comment">// 方法1（会丢失类型信息，所以实际应用很少。）</span></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">Integer[] array = list.toArray(<span class="keyword">new</span> Integer[list.size()]);</span><br><span class="line"><span class="comment">// 方法3</span></span><br><span class="line">Integer[] array = list.toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array to List</span></span><br><span class="line">Integer[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array); <span class="comment">//返回的是一个只读List</span></span><br></pre></td></tr></table></figure>
<h2 id="编写equals方法"><a href="#编写equals方法" class="headerlink" title="编写equals方法"></a>编写equals方法</h2><p><strong><code>equals()</code>方法要求我们必须满足以下条件：</strong></p>
<ul>
<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>
<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>
<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>
<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>
<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>
</ul>
<p><strong><code>equals()</code>方法的正确编写方法：</strong></p>
<ol>
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li>
<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">"Xiao Ming"</span>, <span class="number">99</span>);</span><br><span class="line">        Map&lt;String, Student&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"Xiao Ming"</span>, s); <span class="comment">// 将"Xiao Ming"和Student实例映射并关联</span></span><br><span class="line">        Student target = map.get(<span class="string">"Xiao Ming"</span>); <span class="comment">// 通过key查找并返回映射的Student实例</span></span><br><span class="line">        System.out.println(target == s); <span class="comment">// true，同一个实例</span></span><br><span class="line">        System.out.println(target.score); <span class="comment">// 99</span></span><br><span class="line">        Student another = map.get(<span class="string">"Bob"</span>); <span class="comment">// 通过另一个key查找</span></span><br><span class="line">        System.out.println(another); <span class="comment">// 未找到返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// keySet</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// entitySet</span></span><br></pre></td></tr></table></figure>
<p><strong>equals和hashCode</strong></p>
<p>对应两个实例<code>a</code>和<code>b</code>：</p>
<ul>
<li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li>
<li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果firstName或lastName为null，上述代码工作起来就会抛NullPointerException。为了解决这个问题，我们在计算hashCode()的时候，经常借助Objects.hash()来计算</span></span><br><span class="line">    <span class="keyword">return</span> Objects.hash(firstName, lastName, age);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</strong></p>
<p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p>
<p><strong>map扩容</strong></p>
<p>map扩容要重新确定hashCode计算索引位置，频繁扩容对<code>HashMap</code>的性能影响很大。如果我们确定要使用一个容量为<code>10000</code>个<code>key-value</code>的<code>HashMap</code>，更好的方式是创建<code>HashMap</code>时就指定容量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;(10000);</span><br></pre></td></tr></table></figure>
<p>虽然指定容量是<code>10000</code>，但<code>HashMap</code>内部的数组长度总是2n，因此，实际数组长度被初始化为比<code>10000</code>大的<code>16384</code>（214）。</p>
<h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p><code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(DayOfWeek<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">map.put(DayOfWeek.MONDAY, <span class="string">"星期一"</span>);</span><br><span class="line">map.put(DayOfWeek.TUESDAY, <span class="string">"星期二"</span>);</span><br><span class="line">map.put(DayOfWeek.WEDNESDAY, <span class="string">"星期三"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Map│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashMap│ │SortedMap│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeMap │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure>
<p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"Bob"</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">"Bob"</span>))); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;Person: "</span> + name + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code>a</code>和<code>b</code>，如果<code>a&lt;b</code>，则返回负数，通常是<code>-1</code>，如果<code>a==b</code>，则返回<code>0</code>，如果<code>a&gt;b</code>，则返回正数，通常是<code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。</p>
<h2 id="使用Properties"><a href="#使用Properties" class="headerlink" title="使用Properties"></a>使用Properties</h2><p><code>Properties</code>表示一组配置，用于读取配置文件。</p>
<blockquote>
<p>由于历史遗留原因，<code>Properties</code>内部本质上是一个<code>Hashtabel</code></p>
</blockquote>
<h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>用<code>Properties</code>读取配置文件，一共有三步：</p>
<ol>
<li>创建<code>Properties</code>实例；</li>
<li>调用<code>load()</code>读取文件；</li>
<li>调用<code>getProperty()</code>获取配置。</li>
</ol>
<p>典型的配置文件（Java默认配置文件以<code>.properties</code>为扩展名，每行以<code>key=value</code>表示，以<code>#</code>课开头的是注释。）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># setting.properties</span><br><span class="line"></span><br><span class="line">last_open_file=/data/hello.txt</span><br><span class="line">auto_save_interval=<span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String f = <span class="string">"setting.properties"</span>;</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 默认使用ascii编码</span></span><br><span class="line">props.load(<span class="keyword">new</span> java.io.FileInputStream(f)); <span class="comment">//InputStream读入字节流</span></span><br><span class="line"><span class="comment">// 修改编码方式</span></span><br><span class="line">props.load(<span class="keyword">new</span> FileReader(<span class="string">"settings.properties"</span>, StandardCharsets.UTF_8)); <span class="comment">// FileReader读入的是字符流</span></span><br><span class="line"></span><br><span class="line">String filepath = props.getProperty(<span class="string">"last_open_file"</span>);</span><br><span class="line">String interval = props.getProperty(<span class="string">"auto_save_interval"</span>, <span class="string">"120"</span>); <span class="comment">//默认值</span></span><br></pre></td></tr></table></figure>
<p><strong>写入配置文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.setProperty(<span class="string">"url"</span>, <span class="string">"http://www.liaoxuefeng.com"</span>);</span><br><span class="line">props.setProperty(<span class="string">"language"</span>, <span class="string">"Java"</span>);</span><br><span class="line">props.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\conf\\setting.properties"</span>), <span class="string">"这是写入的properties注释"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>成员方法</strong></p>
<p><code>Set</code>用于存储不重复的元素集合，主要提供以下几个方法：</p>
<ul>
<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>
<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>
<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>
</ul>
<p>最常用的<code>Set</code>实现类是<code>HashSet</code>，实际上，<code>HashSet</code>仅仅是对<code>HashMap</code>的一个简单封装。</p>
<p><strong>接口</strong></p>
<p><code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：</p>
<ul>
<li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li>
<li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Set│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashSet│ │SortedSet│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeSet │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure>
<h2 id="使用Queue"><a href="#使用Queue" class="headerlink" title="使用Queue"></a>使用Queue</h2><p><code>Queue&lt;String&gt; q = new LinkedList&lt;&gt;();</code></p>
<p><code>Queue</code>定义了以下几个方法：</p>
<ul>
<li><code>int size()</code>：获取队列长度；</li>
<li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li>
<li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li>
<li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">throw Exception</th>
<th style="text-align:left">返回false或null</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">添加元素到队尾</td>
<td style="text-align:left">add(E e)</td>
<td style="text-align:left">boolean offer(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队首元素并删除</td>
<td style="text-align:left">E remove()</td>
<td style="text-align:left">E poll()</td>
</tr>
<tr>
<td style="text-align:left">取队首元素但不删除</td>
<td style="text-align:left">E element()</td>
<td style="text-align:left">E peek()</td>
</tr>
</tbody>
</table>
</div>
<h2 id="使用PriorityQueue"><a href="#使用PriorityQueue" class="headerlink" title="使用PriorityQueue"></a>使用PriorityQueue</h2><p><code>Queue&lt;String&gt; q = new PriorityQueue&lt;&gt;();</code></p>
<p><code>PriorityQueue</code>允许我们提供一个<code>Comparator</code>对象来判断两个元素的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> UserComparator());</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">"Bob"</span>, <span class="string">"A1"</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">"Alice"</span>, <span class="string">"A2"</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">"Boss"</span>, <span class="string">"V1"</span>));</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Boss/V1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Bob/A1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Alice/A2</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == u2.number.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class="line">            <span class="keyword">return</span> u1.number.compareTo(u2.number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == <span class="string">'V'</span>) &#123;</span><br><span class="line">            <span class="comment">// u1的号码是V开头,优先级高:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"/"</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Deque"><a href="#使用Deque" class="headerlink" title="使用Deque"></a>使用Deque</h2><p><code>Queue</code>和<code>Deque</code>出队和入队的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Queue</th>
<th style="text-align:left">Deque</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">添加元素到队尾</td>
<td style="text-align:left">add(E e) / offer(E e)</td>
<td style="text-align:left">addLast(E e) / offerLast(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队首元素并删除</td>
<td style="text-align:left">E remove() / E poll()</td>
<td style="text-align:left">E removeFirst() / E pollFirst()</td>
</tr>
<tr>
<td style="text-align:left">取队首元素但不删除</td>
<td style="text-align:left">E element() / E peek()</td>
<td style="text-align:left">E getFirst() / E peekFirst()</td>
</tr>
<tr>
<td style="text-align:left">添加元素到队首</td>
<td style="text-align:left">无</td>
<td style="text-align:left">addFirst(E e) / offerFirst(E e)</td>
</tr>
<tr>
<td style="text-align:left">取队尾元素并删除</td>
<td style="text-align:left">无</td>
<td style="text-align:left">E removeLast() / E pollLast()</td>
</tr>
<tr>
<td style="text-align:left">取队尾元素但不删除</td>
<td style="text-align:left">无</td>
<td style="text-align:left">E getLast() / E peekLast()</td>
</tr>
</tbody>
</table>
</div>
<p><code>Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</code></p>
<h2 id="使用Stack"><a href="#使用Stack" class="headerlink" title="使用Stack"></a>使用Stack</h2><p><code>Stack</code>只有入栈和出栈的操作：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li>
<li>取栈顶元素但不弹出：<code>peek(E)</code>。</li>
</ul>
<p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>/<code>addFirst(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop(E)</code>/<code>removeFirst()</code>；</li>
<li>取栈顶元素但不弹出：<code>peek(E)</code>/<code>peekFirst()</code>。</li>
</ul>
<h2 id="使用Iterator"><a href="#使用Iterator" class="headerlink" title="使用Iterator"></a>使用Iterator</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">     String s = it.next();</span><br><span class="line">     System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p>
<ul>
<li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li>
<li>用<code>Iterator</code>对象迭代集合内部数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseList&lt;String&gt; rlist = <span class="keyword">new</span> ReverseList&lt;&gt;();</span><br><span class="line">        rlist.add(<span class="string">"Apple"</span>);</span><br><span class="line">        rlist.add(<span class="string">"Orange"</span>);</span><br><span class="line">        rlist.add(<span class="string">"Pear"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : rlist) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseIterator(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        ReverseIterator(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ReverseList.<span class="keyword">this</span>.list.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p><code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>
<p><strong>创建空集合</strong></p>
<ul>
<li>创建空List：<code>List&lt;T&gt; emptyList()</code></li>
<li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li>
<li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两种方法等价</span></span><br><span class="line">List&lt;String&gt; list1 = List.of();</span><br><span class="line">List&lt;String&gt; list2 = Collections.emptyList();</span><br></pre></td></tr></table></figure>
<p><strong>创建单元素集合</strong></p>
<ul>
<li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li>
<li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li>
<li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of(); <span class="comment">// empty list</span></span><br><span class="line">List&lt;String&gt; list2 = List.of(<span class="string">"apple"</span>); <span class="comment">// 1 element</span></span><br><span class="line">List&lt;String&gt; list3 = List.of(<span class="string">"apple"</span>, <span class="string">"pear"</span>); <span class="comment">// 2 elements</span></span><br><span class="line">List&lt;String&gt; list4 = List.of(<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"orange"</span>); <span class="comment">// 3 elements</span></span><br><span class="line">List&lt;String&gt; list2 = Collections.singletonList(<span class="string">"apple"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list);</span><br></pre></td></tr></table></figure>
<p><strong>洗牌</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.shuffle(list);</span><br></pre></td></tr></table></figure>
<p><strong>不可变集合</strong></p>
<p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p>
<ul>
<li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>
<li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>
<li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">mutable.add(<span class="string">"apple"</span>);</span><br><span class="line">mutable.add(<span class="string">"pear"</span>);</span><br><span class="line"><span class="comment">// 变为不可变集合,返回的对象不影响之前的对象，之前的mutable仍然是可变的</span></span><br><span class="line">List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">immutable.add(<span class="string">"orange"</span>); <span class="comment">// UnsupportedOperationException!</span></span><br></pre></td></tr></table></figure>
<p><strong>线程安全集合</strong></p>
<p><code>Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p>
<ul>
<li>变为线程安全的List：<code>List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>
<li>变为线程安全的Set：<code>Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>
<li>变为线程安全的Map：<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>
</ul>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><strong>InputStream / OutputStream</strong></p>
<p>IO流以<code>byte</code>（字节）为最小单位，因此也称为<em>字节流</em>。</p>
<p><strong>Reader/Writer</strong></p>
<p><code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。<code>Reader</code>和<code>Writer</code>本质上是一个能自动编解码的<code>InputStream</code>和<code>OutputStream</code>。</p>
<p><strong>同步和异步</strong></p>
<p><strong>同步IO</strong>是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p>
<p><strong>异步IO</strong>是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p>
<p>Java标准库的包<code>java.io</code>提供了同步IO，而<code>java.nio</code>则是异步IO。上面我们讨论的<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>和<code>Writer</code>都是同步IO的抽象类，对应的具体实现类，以文件为例，有<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>和<code>FileWriter</code>。</p>
<h2 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line">File f = <span class="keyword">new</span> file(<span class="string">"/usr/local/bin/1.txt"</span>);</span><br><span class="line">System.out.println(f); <span class="comment">// "/usr/local/bin/1.txt"</span></span><br><span class="line"></span><br><span class="line">File.separator; <span class="comment">//当前平台的分隔符</span></span><br><span class="line"></span><br><span class="line">f.getPath(); <span class="comment">//返回构造方法传入的路径</span></span><br><span class="line">f.getAbsolutePath(); <span class="comment">//返回绝对路径</span></span><br><span class="line">f.getCanonicalPath(); <span class="comment">//返回规范路径（规范路径就是把.和..转换成标准的绝对路径后的路径）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件和目录</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">"C:\\Windows"</span>);</span><br><span class="line">f1.isFile(); <span class="comment">// 对象是否是一个已存在的文件</span></span><br><span class="line">f1.isDirectory(); <span class="comment">// 对象是否是一个已存在的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：</span></span><br><span class="line"><span class="comment">//boolean canRead()：是否可读；</span></span><br><span class="line"><span class="comment">//boolean canWrite()：是否可写；</span></span><br><span class="line"><span class="comment">//boolean canExecute()：是否可执行；</span></span><br><span class="line"><span class="comment">//long length()：文件字节大小。</span></span><br></pre></td></tr></table></figure>
<p><strong>创建删除文件</strong></p>
<p>当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"/path/to/file"</span>);</span><br><span class="line"><span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">    <span class="comment">// 文件创建成功:</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">if</span> (file.delete()) &#123;</span><br><span class="line">        <span class="comment">// 删除文件成功:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序需要读写一些临时文件，File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = File.createTempFile(<span class="string">"tmp-"</span>, <span class="string">".txt"</span>); <span class="comment">// 提供临时文件的前缀和后缀</span></span><br><span class="line">        f.deleteOnExit(); <span class="comment">// JVM退出时自动删除</span></span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>遍历文件和目录</strong></p>
<p>当File对象表示一个目录时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"/usr/local/bin"</span>);</span><br><span class="line">File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">printFiles(fs1);</span><br><span class="line">File[] fs2 = f.listFiles(<span class="keyword">new</span> FilenameFilter() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">".exe"</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Path对象</strong></p>
<p><code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path p1 = Paths.get(<span class="string">"."</span>, <span class="string">"project"</span>, <span class="string">"study"</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        Path p2 = p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        Path p3 = p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        File f = p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">".."</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">"  "</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p><code>InputStream</code>并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是<code>int read()</code>，签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法会读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）。如果已读到末尾，返回<code>-1</code>表示不能继续读取了。</p>
<p><strong>FileInputStream</strong></p>
<p><code>read()</code>读取输入流的下一个字节.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p>
</blockquote>
<p><strong>利用缓冲区一次读取多个字节</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" bytes."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ByteArrayInputStream模拟InputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] ba = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(ba)) &#123;</span><br><span class="line">            String s = readAsString(is);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsString</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p><code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract void write(int b) throws IOException;</span><br></pre></td></tr></table></figure>
<p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）。</p>
<blockquote>
<p><code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"out/readme.txt"</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            output.write(<span class="string">"Hello "</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            output.write(<span class="string">"world!"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data, <span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以同时写两个文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取input.txt，写入output.txt:</span></span><br><span class="line"><span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>);</span><br><span class="line">     OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"output.txt"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    input.transferTo(output); <span class="comment">// transferTo的作用是将input文件拷贝到output文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Filter模式"><a href="#Filter模式" class="headerlink" title="Filter模式"></a>Filter模式</h2><p>Java的IO标准库提供的<code>InputStream</code>根据来源可以包括：</p>
<ul>
<li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li>
<li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li>
<li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li>
<li>…</li>
</ul>
<p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code>InputStream</code>分为两大类：</p>
<p>一类是直接提供数据的基础<code>InputStream</code>，例如：</p>
<ul>
<li>FileInputStream</li>
<li>ByteArrayInputStream</li>
<li>ServletInputStream</li>
<li>…</li>
</ul>
<p>一类是提供额外附加功能的<code>InputStream</code>，例如：</p>
<ul>
<li>BufferedInputStream</li>
<li>DigestInputStream</li>
<li>CipherInputStream</li>
<li>…</li>
</ul>
<p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream file &#x3D; new FileInputStream(&quot;test.gz&quot;);</span><br></pre></td></tr></table></figure>
<p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream buffered &#x3D; new BufferedInputStream(file);</span><br></pre></td></tr></table></figure>
<p>最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream gzip &#x3D; new GZIPInputStream(buffered);</span><br></pre></td></tr></table></figure>
<p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────┐</span><br><span class="line">│GZIPInputStream          │</span><br><span class="line">│┌───────────────────────┐│</span><br><span class="line">││BufferedFileInputStream││</span><br><span class="line">││┌─────────────────────┐││</span><br><span class="line">│││   FileInputStream   │││</span><br><span class="line">││└─────────────────────┘││</span><br><span class="line">│└───────────────────────┘│</span><br><span class="line">└─────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                 ┌─────────────┐</span><br><span class="line">                 │ InputStream │</span><br><span class="line">                 └─────────────┘</span><br><span class="line">                       ▲ ▲</span><br><span class="line">┌────────────────────┐ │ │ ┌─────────────────┐</span><br><span class="line">│  FileInputStream   │─┤ └─│FilterInputStream│</span><br><span class="line">└────────────────────┘ │   └─────────────────┘</span><br><span class="line">┌────────────────────┐ │     ▲ ┌───────────────────┐</span><br><span class="line">│ByteArrayInputStream│─┤     ├─│BufferedInputStream│</span><br><span class="line">└────────────────────┘ │     │ └───────────────────┘</span><br><span class="line">┌────────────────────┐ │     │ ┌───────────────────┐</span><br><span class="line">│ ServletInputStream │─┘     ├─│  DataInputStream  │</span><br><span class="line">└────────────────────┘       │ └───────────────────┘</span><br><span class="line">                             │ ┌───────────────────┐</span><br><span class="line">                             └─│CheckedInputStream │</span><br><span class="line">                               └───────────────────┘</span><br></pre></td></tr></table></figure>
<p>类似的，<code>OutputStream</code>也是以这种模式来提供各种功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                  ┌─────────────┐</span><br><span class="line">                  │OutputStream │</span><br><span class="line">                  └─────────────┘</span><br><span class="line">                        ▲ ▲</span><br><span class="line">┌─────────────────────┐ │ │ ┌──────────────────┐</span><br><span class="line">│  FileOutputStream   │─┤ └─│FilterOutputStream│</span><br><span class="line">└─────────────────────┘ │   └──────────────────┘</span><br><span class="line">┌─────────────────────┐ │     ▲ ┌────────────────────┐</span><br><span class="line">│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│</span><br><span class="line">└─────────────────────┘ │     │ └────────────────────┘</span><br><span class="line">┌─────────────────────┐ │     │ ┌────────────────────┐</span><br><span class="line">│ ServletOutputStream │─┘     ├─│  DataOutputStream  │</span><br><span class="line">└─────────────────────┘       │ └────────────────────┘</span><br><span class="line">                              │ ┌────────────────────┐</span><br><span class="line">                              └─│CheckedOutputStream │</span><br><span class="line">                                └────────────────────┘</span><br></pre></td></tr></table></figure>
<h2 id="操作Zip"><a href="#操作Zip" class="headerlink" title="操作Zip"></a>操作Zip</h2><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p>
<div id="flowchart-0" class="flow-chart"></div>

<blockquote>
<p><code>JarInputStream</code>是从<code>ZipInputStream</code>派生，它增加的主要功能是直接读取jar文件里面的<code>MANIFEST.MF</code>文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p>
</blockquote>
<h3 id="读取Zip文件"><a href="#读取Zip文件" class="headerlink" title="读取Zip文件"></a>读取Zip文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipInputStream zip = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(...))) &#123;</span><br><span class="line">    ZipEntry entry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = zip.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String name = entry.getName();</span><br><span class="line">        <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = zip.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写入Zip文件"><a href="#写入Zip文件" class="headerlink" title="写入Zip文件"></a>写入Zip文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipOutputStream zip = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(...))) &#123;</span><br><span class="line">    File[] files = ...</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        zip.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()));</span><br><span class="line">        zip.write(getFileDataAsBytes(file));</span><br><span class="line">        zip.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取classpath资源"><a href="#读取classpath资源" class="headerlink" title="读取classpath资源"></a>读取classpath资源</h2><p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把<code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p>
<blockquote>
<p>在classpath中的资源文件，路径总是以<code>／</code>开头</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream input = getClass().getResourceAsStream(<span class="string">"/default.properties"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(inputStreamFromClassPath(<span class="string">"/default.properties"</span>));</span><br><span class="line">props.load(inputStreamFromFile(<span class="string">"./conf.properties"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">"Hello"</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p><code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(...)) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = input.readInt();</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">    Double d = (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readObject()</code>可能抛出的异常有：</p>
<ul>
<li><code>ClassNotFoundException</code>：没有找到对应的Class；</li>
<li><code>InvalidClassException</code>：Class不匹配。</li>
</ul>
<p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2709425275741743919L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p>
</blockquote>
<h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><blockquote>
<p>除了特殊的<code>CharArrayReader</code>和<code>StringReader</code>，普通的<code>Reader</code>实际上是基于<code>InputStream</code>构造的，因为<code>Reader</code>需要从<code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为<code>char</code>就可以实现字符流。如果我们查看<code>FileReader</code>的源码，它在内部实际上持有一个<code>FileInputStream</code>。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">InputStream</th>
<th style="text-align:left">Reader</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字节流，以<code>byte</code>为单位</td>
<td style="text-align:left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td style="text-align:left">读取字节（-1，0~255）：<code>int read()</code></td>
<td style="text-align:left">读取字符（-1，0~65535）：<code>int read()</code></td>
</tr>
<tr>
<td style="text-align:left">读到字节数组：<code>int read(byte[] b)</code></td>
<td style="text-align:left">读到字符数组：<code>int read(char[] c)</code></td>
</tr>
</tbody>
</table>
</div>
<p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int read() throws IOException;</span><br></pre></td></tr></table></figure>
<p>这个方法读取字符流的下一个字符，并返回字符表示的<code>int</code>，范围是<code>0</code>~<code>65535</code>。如果已读到末尾，返回<code>-1</code>。</p>
<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个FileReader对象:</span></span><br><span class="line">    Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>); <span class="comment">// 字符编码是???</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = reader.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)n); <span class="comment">// 打印char</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"1.txt"</span>,StandardCharsets.UTF_8))&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取到缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" chars."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>charArrayReader</strong></p>
<p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> CharArrayReader(<span class="string">"Hello"</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>StringReader</strong></p>
<p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> StringReader(<span class="string">"Hello"</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>InputStreamReader</strong></p>
<p><code>Reader</code>本质上是一个基于<code>InputStream</code>的<code>byte</code>到<code>char</code>的转换器，那么，如果我们已经有一个<code>InputStream</code>，想把它转换为<code>Reader</code>，是完全可行的。<code>InputStreamReader</code>就是这样一个转换器，它可以把任何<code>InputStream</code>转换为<code>Reader</code>。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<p>构造<code>InputStreamReader</code>时，我们需要传入<code>InputStream</code>，还需要指定编码，就可以得到一个<code>Reader</code>对象。上述代码可以通过<code>try (resource)</code>更简洁地改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>), <span class="string">"UTF-8"</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实际上就是<code>FileReader</code>的一种实现方式。</p>
<p>使用<code>try (resource)</code>结构时，当我们关闭<code>Reader</code>时，它会在内部自动调用<code>InputStream</code>的<code>close()</code>方法，所以，只需要关闭最外层的<code>Reader</code>对象即可。</p>
<h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">OutputStream</th>
<th style="text-align:left">Writer</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字节流，以<code>byte</code>为单位</td>
<td style="text-align:left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td style="text-align:left">写入字节（0~255）：<code>void write(int b)</code></td>
<td style="text-align:left">写入字符（0~65535）：<code>void write(int c)</code></td>
</tr>
<tr>
<td style="text-align:left">写入字节数组：<code>void write(byte[] b)</code></td>
<td style="text-align:left">写入字符数组：<code>void write(char[] c)</code></td>
</tr>
<tr>
<td style="text-align:left">无对应方法</td>
<td style="text-align:left">写入String：<code>void write(String s)</code></td>
</tr>
</tbody>
</table>
</div>
<p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p>
<ul>
<li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li>
<li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li>
<li>写入String表示的所有字符：<code>void write(String s)</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">'H'</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CharArrayWriter</strong></p>
<p><code>CharArrayWriter</code>可以在内存中创建一个<code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code>char</code>，最后得到写入的<code>char[]</code>数组，这和<code>ByteArrayOutputStream</code>非常类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter()) &#123;</span><br><span class="line">    writer.write(<span class="number">65</span>);</span><br><span class="line">    writer.write(<span class="number">66</span>);</span><br><span class="line">    writer.write(<span class="number">67</span>);</span><br><span class="line">    <span class="keyword">char</span>[] data = writer.toCharArray(); <span class="comment">// &#123; 'A', 'B', 'C' &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>StringWriter</strong></p>
<p><code>StringWriter</code>也是一个基于内存的<code>Writer</code>，它和<code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个<code>StringBuffer</code>，并对外提供了<code>Writer</code>接口。</p>
<p><strong>OutputStreamWriter</strong></p>
<p>除了<code>CharArrayWriter</code>和<code>StringWriter</code>外，普通的Writer实际上是基于<code>OutputStream</code>构造的，它接收<code>char</code>，然后在内部自动转换成一个或多个<code>byte</code>，并写入<code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的<code>OutputStream</code>转换为<code>Writer</code>的转换器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (Writer writer &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;readme.txt&quot;), &quot;UTF-8&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实际上就是<code>FileWriter</code>的一种实现方式。这和上一节的<code>InputStreamReader</code>是一样的。</p>
<h2 id="PrintStream和PrintWriter"><a href="#PrintStream和PrintWriter" class="headerlink" title="PrintStream和PrintWriter"></a>PrintStream和PrintWriter</h2><p><code>PrintStream</code>在<code>OutputStream</code>接口上提供了一组写入各种数据的方法：<code>print(int)</code>,<code>print(boolean)</code>以及一组<code>println()</code>（自动加换行符）</p>
<p><code>System.out</code>是系统默认提供的<code>PrintStream</code></p>
<p><code>PrintStream</code>最终输出的总是byte数据，而<code>PrintWriter</code>则是扩展了<code>Writer</code>接口，它的<code>print()</code>/<code>println()</code>方法最终输出的是<code>char</code>数据。两者的使用方法几乎是一模一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</span><br><span class="line">        StringWriter buffer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter pw = <span class="keyword">new</span> PrintWriter(buffer)) &#123;</span><br><span class="line">            pw.println(<span class="string">"Hello"</span>);</span><br><span class="line">            pw.println(<span class="number">12345</span>);</span><br><span class="line">            pw.println(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Files"><a href="#使用Files" class="headerlink" title="使用Files"></a>使用Files</h2><p><strong>将一个文件的全部内容读取为一个</strong><code>byte[]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = Files.readAllBytes(Paths.get(<span class="string">"/path/to/file.txt"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>把一个文件的全部内容读取为</strong><code>String</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认使用UTF-8编码读取:</span></span><br><span class="line">String content1 = Files.readString(Paths.get(<span class="string">"/path/to/file.txt"</span>));</span><br><span class="line"><span class="comment">// 可指定编码:</span></span><br><span class="line">String content2 = Files.readString(Paths.get(<span class="string">"/path/to/file.txt"</span>), StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行读取并返回每行内容:</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">"/path/to/file.txt"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>写入文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入二进制文件:</span></span><br><span class="line"><span class="keyword">byte</span>[] data = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">"/path/to/file.txt"</span>), data);</span><br><span class="line"><span class="comment">// 写入文本并指定编码:</span></span><br><span class="line">Files.writeString(Paths.get(<span class="string">"/path/to/file.txt"</span>), <span class="string">"文本内容..."</span>, StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行写入文本:</span></span><br><span class="line">List&lt;String&gt; lines = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">"/path/to/file.txt"</span>), lines);</span><br></pre></td></tr></table></figure>
<p><code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p>
<blockquote>
<p><code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p>
</blockquote>
<h1 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h1><blockquote>
<p>夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。</p>
<p> 计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</p>
</blockquote>
<p>在计算机中，通常使用<code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，<code>zh_CN</code>表示中文+中国，<code>en_US</code>表示英文+美国。语言使用小写，国家使用大写。</p>
<p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p>
<ul>
<li>zh_CN：2016-11-30</li>
<li>en_US：11/30/2016</li>
</ul>
<h2 id="Date和Calendar"><a href="#Date和Calendar" class="headerlink" title="Date和Calendar"></a>Date和Calendar</h2><p><code>Epoch Time</code>又称为时间戳，在不同的编程语言中，会有几种存储方式：</p>
<ul>
<li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li>
<li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li>
<li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</li>
</ul>
<p>Java程序中，时间戳通常是用<code>long</code>表示的毫秒数，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long t &#x3D; 1574208900123L;</span><br></pre></td></tr></table></figure>
<p>转换成北京时间就是<code>2019-11-20T8:15:00.123</code>。要获取当前时间戳，可以使用<code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</p>
<h2 id="标准库API"><a href="#标准库API" class="headerlink" title="标准库API"></a>标准库API</h2><p>Java标准库有两套处理日期和时间的API：</p>
<ul>
<li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li>
<li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li>
</ul>
<h2 id="旧API"><a href="#旧API" class="headerlink" title="旧API"></a>旧API</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p><code>java.util.Date</code>是用于表示一个日期和时间的对象，它实际上存储了一个long类型的以毫秒表示的时间戳。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date.getYear() + <span class="number">1900</span>); <span class="comment">// 必须加上1900</span></span><br><span class="line">        System.out.println(date.getMonth() + <span class="number">1</span>); <span class="comment">// 0~11，必须加上1</span></span><br><span class="line">        System.out.println(date.getDate()); <span class="comment">// 1~31，不能加1</span></span><br><span class="line">        <span class="comment">// 转换为String:</span></span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">        <span class="comment">// 转换为GMT时区:</span></span><br><span class="line">        System.out.println(date.toGMTString());</span><br><span class="line">        <span class="comment">// 转换为本地时区:</span></span><br><span class="line">        System.out.println(date.toLocaleString());</span><br><span class="line">        </span><br><span class="line">                <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Date</code>对象有几个严重的问题：它不能转换时区，除了<code>toGMTString()</code>可以按<code>GMT+0:00</code>输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</p>
</blockquote>
<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar相比Date多了日期计算功能。年份不需要转换，月份要加一，星期1～7分别表示周日、周一、…、周六</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">int</span> y = c.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> + c.get(Calendar.MONTH);</span><br><span class="line">        <span class="keyword">int</span> d = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="keyword">int</span> w = c.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="keyword">int</span> hh = c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">int</span> mm = c.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> ss = c.get(Calendar.SECOND);</span><br><span class="line">        <span class="keyword">int</span> ms = c.get(Calendar.MILLISECOND);</span><br><span class="line">        System.out.println(y + <span class="string">"-"</span> + m + <span class="string">"-"</span> + d + <span class="string">" "</span> + w + <span class="string">" "</span> + hh + <span class="string">":"</span> + mm + <span class="string">":"</span> + ss + <span class="string">"."</span> + ms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时区选择</span></span><br><span class="line">TimeZone tzDefault = TimeZone.getDefault(); <span class="comment">// 当前时区</span></span><br><span class="line">TimeZone tzGMT9 = TimeZone.getTimeZone(<span class="string">"GMT+09:00"</span>); <span class="comment">// GMT+9:00时区</span></span><br><span class="line">TimeZone tzNY = TimeZone.getTimeZone(<span class="string">"America/New_York"</span>); <span class="comment">// 纽约时区</span></span><br><span class="line">System.out.println(tzDefault.getID()); <span class="comment">// Asia/Shanghai</span></span><br><span class="line">System.out.println(tzGMT9.getID()); <span class="comment">// GMT+09:00</span></span><br><span class="line">System.out.println(tzNY.getID()); <span class="comment">// America/New_York</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特定时区</span></span><br><span class="line"><span class="comment">// 当前时间:</span></span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 清除所有:</span></span><br><span class="line">c.clear();</span><br><span class="line"><span class="comment">// 设置为北京时区:</span></span><br><span class="line">c.setTimeZone(TimeZone.getTimeZone(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line"><span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 加5天并减去2小时:</span></span><br><span class="line">c.add(Calendar.DAY_OF_MONTH, <span class="number">5</span>);</span><br><span class="line">c.add(Calendar.HOUR_OF_DAY, -<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 显示时间:</span></span><br><span class="line"><span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">sdf.setTimeZone(TimeZone.getTimeZone(<span class="string">"America/New_York"</span>));</span><br><span class="line">System.out.println(sdf.format(c.getTime()));</span><br><span class="line"><span class="comment">// 2019-11-19 19:15:00</span></span><br></pre></td></tr></table></figure>
<p>利用<code>Calendar</code>进行时区转换的步骤是：</p>
<ol>
<li>清除所有字段；</li>
<li>设定指定时区；</li>
<li>设定日期和时间；</li>
<li>创建<code>SimpleDateFormat</code>并设定目标时区；</li>
<li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li>
</ol>
<blockquote>
<p>本质上时区转换只能通过<code>SimpleDateFormat</code>在显示的时候完成。</p>
</blockquote>
<h2 id="新API"><a href="#新API" class="headerlink" title="新API"></a>新API</h2><p>从Java 8开始，<code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p>
<ul>
<li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li>
<li>带时区的日期和时间：<code>ZonedDateTime</code>；</li>
<li>时刻：<code>Instant</code>；</li>
<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li>
<li>时间间隔：<code>Duration</code>。</li>
</ul>
<p>以及一套新的用于取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code>。</p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate d = LocalDate.now(); <span class="comment">// 当前日期</span></span><br><span class="line">LocalTime t = LocalTime.now(); <span class="comment">// 当前时间</span></span><br><span class="line">LocalDateTime dt = LocalDateTime.now(); <span class="comment">// 当前日期和时间</span></span><br><span class="line">System.out.println(d); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">System.out.println(t); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">System.out.println(dt); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免获取延迟</span></span><br><span class="line">LocalDateTime dt = LocalDateTime.now(); <span class="comment">// 当前日期和时间</span></span><br><span class="line">LocalDate d = dt.toLocalDate(); <span class="comment">// 转换到当前日期</span></span><br><span class="line">LocalTime t = dt.toLocalTime(); <span class="comment">// 转换到当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定日期和时间:</span></span><br><span class="line">LocalDate d2 = LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>); <span class="comment">// 2019-11-30, 注意11=11月</span></span><br><span class="line">LocalTime t2 = LocalTime.of(<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>); <span class="comment">// 15:16:17</span></span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line">LocalDateTime dt3 = LocalDateTime.of(d2, t2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加减时间</span></span><br><span class="line">LocalDateTime dt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(dt);</span><br><span class="line"><span class="comment">// 加5天减3小时:</span></span><br><span class="line">LocalDateTime dt2 = dt.plusDays(<span class="number">5</span>).minusHours(<span class="number">3</span>);</span><br><span class="line">System.out.println(dt2); <span class="comment">// 2019-10-31T17:30:59</span></span><br><span class="line"><span class="comment">// 减1月:</span></span><br><span class="line">LocalDateTime dt3 = dt2.minusMonths(<span class="number">1</span>);</span><br><span class="line">System.out.println(dt3); <span class="comment">// 2019-09-30T17:30:59</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整日期</span></span><br><span class="line"><span class="comment">// 调整年：withYear()</span></span><br><span class="line"><span class="comment">// 调整月：withMonth()</span></span><br><span class="line"><span class="comment">// 调整日：withDayOfMonth()</span></span><br><span class="line"><span class="comment">// 调整时：withHour()</span></span><br><span class="line"><span class="comment">// 调整分：withMinute()</span></span><br><span class="line"><span class="comment">// 调整秒：withSecond()</span></span><br><span class="line">LocalDateTime dt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(dt);</span><br><span class="line"><span class="comment">// 日期变为31日:</span></span><br><span class="line">LocalDateTime dt2 = dt.withDayOfMonth(<span class="number">31</span>);</span><br><span class="line">System.out.println(dt2); <span class="comment">// 2019-10-31T20:30:59</span></span><br><span class="line"><span class="comment">// 月份变为9:</span></span><br><span class="line">LocalDateTime dt3 = dt2.withMonth(<span class="number">9</span>);</span><br><span class="line">System.out.println(dt3); <span class="comment">// 2019-09-30T20:30:59</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// With</span></span><br><span class="line"><span class="comment">// 本月第一天0:00时刻:</span></span><br><span class="line">LocalDateTime firstDay = LocalDate.now().withDayOfMonth(<span class="number">1</span>).atStartOfDay();</span><br><span class="line">System.out.println(firstDay);</span><br><span class="line"><span class="comment">// 本月最后1天:</span></span><br><span class="line">LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">System.out.println(lastDay);</span><br><span class="line"><span class="comment">// 下月第1天:</span></span><br><span class="line">LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class="line">System.out.println(nextMonthFirstDay);</span><br><span class="line"><span class="comment">// 本月第1个周一:</span></span><br><span class="line">LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</span><br><span class="line">System.out.println(firstWeekday);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断日期先后</span></span><br><span class="line"><span class="comment">// isBefore和isAfter</span></span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">LocalDateTime target = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(now.isBefore(target));</span><br><span class="line">System.out.println(LocalDate.now().isBefore(LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>)));</span><br><span class="line">System.out.println(LocalTime.now().isAfter(LocalTime.parse(<span class="string">"08:15:00"</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间间隔</span></span><br><span class="line"><span class="comment">// Duration表示两个时刻之间的时间间隔。另一个类似的Period表示两个日期之间的天数</span></span><br><span class="line">LocalDateTime start = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">LocalDateTime end = LocalDateTime.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">30</span>);</span><br><span class="line">Duration d = Duration.between(start, end);</span><br><span class="line">System.out.println(d); <span class="comment">// PT1235H10M30S  ：表示1235小时10分钟30秒。</span></span><br><span class="line"></span><br><span class="line">Period p = LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>).until(LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">System.out.println(p); <span class="comment">// P1M21D ： 表示1个月21天。</span></span><br><span class="line"></span><br><span class="line">Duration d1 = Duration.ofHours(<span class="number">10</span>); <span class="comment">// 10 hours</span></span><br><span class="line">Duration d2 = Duration.parse(<span class="string">"P1DT2H3M"</span>); <span class="comment">// 1 day, 2 hours, 3 minutes</span></span><br></pre></td></tr></table></figure>
<p>ISO 8601规定的日期和时间分隔符是<code>T</code>。标准格式如下：</p>
<ul>
<li>日期：yyyy-MM-dd</li>
<li>时间：HH:mm:ss</li>
<li>带毫秒的时间：HH:mm:ss.SSS</li>
<li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li>
<li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li>
</ul>
<h3 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义格式化:</span></span><br><span class="line">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>);</span><br><span class="line"><span class="comment">//DateTimeFormatter formatter = DateTimeFormatter.ofPattern("E, yyyy-MMMM-dd HH:mm", Locale.US);</span></span><br><span class="line">System.out.println(dtf.format(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用自定义格式解析:</span></span><br><span class="line">LocalDateTime dt2 = LocalDateTime.parse(<span class="string">"2019/11/30 15:16:17"</span>, dtf);</span><br><span class="line">System.out.println(dt2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ISO8601显示</span></span><br><span class="line"><span class="keyword">var</span> ldt = LocalDateTime.now();</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));</span><br></pre></td></tr></table></figure>
<h3 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h3><p>可以简单地把<code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">ZonedDateTime zbj = ZonedDateTime.now(); <span class="comment">// 默认时区</span></span><br><span class="line">ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(<span class="string">"America/New_York"</span>)); <span class="comment">// 用指定时区获取当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="comment">// LocalDateTime to ZonedDateTime</span></span><br><span class="line">LocalDateTime ldt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line">ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());</span><br><span class="line">ZonedDateTime zny = ldt.atZone(ZoneId.of(<span class="string">"America/New_York"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时区转换</span></span><br><span class="line"><span class="comment">// 以中国时区获取当前时间:</span></span><br><span class="line">ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line"><span class="comment">// 转换为纽约时间:</span></span><br><span class="line">ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(<span class="string">"America/New_York"</span>));</span><br><span class="line">System.out.println(zbj);</span><br><span class="line">System.out.println(zny);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换本地时间</span></span><br><span class="line">ZonedDateTime zdt = ...</span><br><span class="line">LocalDateTime ldt = zdt.toLocalDateTime();</span><br></pre></td></tr></table></figure>
<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>当前时间戳在<code>java.time</code>中以<code>Instant</code>类型表示，我们用<code>Instant.now()</code>获取当前时间戳，效果和<code>System.currentTimeMillis()</code>类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以指定时间戳创建Instant</span></span><br><span class="line">Instant ins = Instant.ofEpochSecond(<span class="number">1568568760</span>);</span><br><span class="line">ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(zdt); <span class="comment">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="旧API转新API"><a href="#旧API转新API" class="headerlink" title="旧API转新API"></a>旧API转新API</h3><p>如果要把旧式的<code>Date</code>或<code>Calendar</code>转换为新API对象，可以通过<code>toInstant()</code>方法转换为<code>Instant</code>对象，再继续转换为<code>ZonedDateTime</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Date -&gt; Instant:</span><br><span class="line">Instant ins1 &#x3D; new Date().toInstant();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Calendar -&gt; Instant -&gt; ZonedDateTime:</span><br><span class="line">Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">Instant ins2 &#x3D; calendar.toInstant();</span><br><span class="line">ZonedDateTime zdt &#x3D; ins2.atZone(calendar.getTimeZone().toZoneId());</span><br></pre></td></tr></table></figure>
<p>从上面的代码还可以看到，旧的<code>TimeZone</code>提供了一个<code>toZoneId()</code>，可以把自己变成新的<code>ZoneId</code>。</p>
<h3 id="新API转旧API"><a href="#新API转旧API" class="headerlink" title="新API转旧API"></a>新API转旧API</h3><p>如果要把新的<code>ZonedDateTime</code>转换为旧的API对象，只能借助<code>long</code>型时间戳做一个“中转”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ZonedDateTime -&gt; long:</span><br><span class="line">ZonedDateTime zdt &#x3D; ZonedDateTime.now();</span><br><span class="line">long ts &#x3D; zdt.toEpochSecond() * 1000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; long -&gt; Date:</span><br><span class="line">Date date &#x3D; new Date(ts);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; long -&gt; Calendar:</span><br><span class="line">Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">calendar.clear();</span><br><span class="line">calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));</span><br><span class="line">calendar.setTimeInMillis(zdt.toEpochSecond() * 1000);</span><br></pre></td></tr></table></figure>
<p>从上面的代码还可以看到，新的<code>ZoneId</code>转换为旧的<code>TimeZone</code>，需要借助<code>ZoneId.getId()</code>返回的<code>String</code>完成。</p>
<h3 id="在数据库中存储日期和时间"><a href="#在数据库中存储日期和时间" class="headerlink" title="在数据库中存储日期和时间"></a>在数据库中存储日期和时间</h3><p>除了旧式的<code>java.util.Date</code>，我们还可以找到另一个<code>java.sql.Date</code>，它继承自<code>java.util.Date</code>，但会自动忽略所有时间相关信息。这个奇葩的设计原因要追溯到数据库的日期与时间类型。</p>
<p>在数据库中，也存在几种日期和时间类型：</p>
<ul>
<li><code>DATETIME</code>：表示日期和时间；</li>
<li><code>DATE</code>：仅表示日期；</li>
<li><code>TIME</code>：仅表示时间；</li>
<li><code>TIMESTAMP</code>：和<code>DATETIME</code>类似，但是数据库会在创建或者更新记录的时候同时修改<code>TIMESTAMP</code>。</li>
</ul>
<p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。下表是数据库类型与Java新旧API的映射关系：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据库</th>
<th style="text-align:left">对应Java类（旧）</th>
<th style="text-align:left">对应Java类（新）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">java.util.Date</td>
<td style="text-align:left">LocalDateTime</td>
</tr>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">java.sql.Date</td>
<td style="text-align:left">LocalDate</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">java.sql.Time</td>
<td style="text-align:left">LocalTime</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">java.sql.Timestamp</td>
<td style="text-align:left">LocalDateTime</td>
</tr>
</tbody>
</table>
</div>
<p>实际上，在数据库中，我们需要存储的最常用的是时刻（<code>Instant</code>），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数<code>long</code>表示，在数据库中存储为<code>BIGINT</code>类型。</p>
<p>通过存储一个<code>long</code>型时间戳，我们可以编写一个<code>timestampToString()</code>的方法，非常简单地为不同用户以不同的偏好来显示不同的本地时间：</p>
<p><code>import java.time.*; import java.time.format.*; import java.util.Locale;</code> Run</p>
<p>对上述方法进行调用，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>年<span class="number">11</span>月<span class="number">20</span>日 上午<span class="number">8</span>:<span class="number">15</span></span><br><span class="line">Nov <span class="number">19</span>, <span class="number">2019</span>, <span class="number">7</span>:<span class="number">15</span> PM</span><br></pre></td></tr></table></figure>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">is=>operation: InputStream
fis=>operation: FilterInputStream
iis=>operation: InflaterInputStream
zis=>operation: ZipInputStream
jis=>operation: JarInputStream

is->fis->iis->zis->jis</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令</title>
    <url>/2020/06/29/linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>参考链接：<a href="https://www.cnblogs.com/linhaifeng/articles/6045600.html" target="_blank" rel="noopener">https://www.cnblogs.com/linhaifeng/articles/6045600.html</a><br><a id="more"></a></p>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p><strong>1.常用命令</strong><br>df -hl 查看磁盘空间<br>ls 列出当前文件夹中文件（-l 详细信息 -a 显示隐藏文件 -all 同 -a）<br>ll = ls -l —color = auto<br>alias 别名<br>cd 切换到目录（- 返回  ..上一级）<br>pwd  当前目录<br>whoami 查看当前登录用户<br>who 查看所有登录用户<br>date 显示当前时间和日期<br>cal 月历<br>clear 清屏（ctrl+l）<br>useradd (用户名) 添加用户<br>passwd (用户名) 更改用户密码<br>su - (用户名) 切换用户<br>man 命令 使用说明（q退出）<br>echo 回显命令<br>histort查看历史命令<br>grep 搜索过滤(-v 反向过滤)<br>lsof -i :8080 查看8080端口的进程</p>
<p>nestat -an|grep 8080 查看端口状态<br>init 0 关闭linux系统</p>
<p>命令 —help    帮助信息<br>命令跳到行首 ctrl+a   跳到行尾 ctrl+e</p>
<p><strong>2.目录</strong><br>/ 根目录<br>. 当前目录<br>.. 上一层目录<br>bin 可执行文件目录(binary)<br>sbin 系统的可执行文件<br>home 用户的文件<br>dev 设备文件目录<br>etc 配置文件目录<br>/mnt /opt /media 随便用</p>
<p><strong>3.目录及文件操作</strong><br>cp 复制（-i 询问是否覆盖 -r 递归拷贝 -）<br>mv 移动<br>mkdir 建文件夹（-p 递归建立文件夹）<br>touch 建文件 （touch /test/{a..z}.txt）<br>rm 删除（-f 不提示是否删除 -r 删除文件夹）<br>cat 查看文件内容<br>head 查看文件第一行(-n 前n行)<br>tail 查看文件最后一行（-n 最后n行 -f 动态查看文件内容变化）<br>more 按照百分比显示文件内容<br>less 可以用上下键翻</p>
<p>tail -1 /etc/passwd  用户信息<br>tail -1 /etc/shadow  密码<br>tail -1 /etc/group<br>tail -1 /etc/gshadow<br>tail -1 /var/spool/mail/username<br>tail -1 /home/username</p>
<p>useradd (-u 指定用户uid -g 指定用户所属的群组 -d指定用户的家目录 -c指定用户的备注信息 -s指定用户的shell)<br>userdel 删除用户<br>usermod 修改用户信息（-u -g -d -c -s同上 -G 将用户加入指定的群组 -L将用户加锁 -U将用户解锁）</p>
<p><strong>4.对文件的权限管理</strong><br>文件详细信息<br>10位<br>1:文件类型<br>-:普通文件  d:目录   l:软链接   b:设备   p:管道文件<br>2-4:属主权限 —-》u<br>分三类：读r，写w，执行x,没有权限-<br>5-7:属组权限 —-》g<br>8-10:其他用户 —-》o</p>
<p>修改权限：<br>chmod u=rw- a.txt<br>chmod u-rw a.txt</p>
<p>root 用户不受权限限制</p>
<p>执行文件：<br>sh 文件路径<br>bash 文件路径<br>. 文件路径<br>./ 文件路径<br>——————vim原理 读取到内存中，进行修改。</p>
<p><strong>5.对目录的权限管理</strong><br>ll -d 目录  获取目录权限<br>增加文件，删除文件</p>
<p><strong>6.属主属组及基于数字的权限管理</strong><br>chown 属主.属组 参数<br>只改属主： chown 属主 参数<br>只改属组： chown .属组 参数</p>
<p>chown -R (递归修改权限：目录和文件)</p>
<p>数字权限管理<br>-rw-rw-r— 为 664</p>
<p><strong>7.文件合并与文件归档</strong><br>> 左侧命令输出结果覆盖右侧文件 cat /etc/passwd &gt; a.txt<br>>&gt; 左侧命令输出结果追加到右侧文件</p>
<p>wc -l 统计文件行数<br>| 管道符将前面的结果作为后面的指令的参数</p>
<p>归档<br>tar<br>c：创建一个新的tar文件。<br>t：列出tar文件中目录的内容。<br>x：从tar文件中抽取文件。<br>f：指定归档文件或磁带（也可能是软盘）设备（一般都要选）。<br>v：显示所打包的文件的详细信息，v是verbose的第1个字母。<br>z：使用gzip压缩算法来压缩打包后的文件。<br>j：使用bzip2压缩算法来压缩打包后的文件。</p>
<p>打包：tar cvf arch.tar arch<br>解包：tar xvf arch.tar -C 路径</p>
<p>压缩 gzip bzip2<br>解压 gunzip bunzip2<br>打包后压缩 tar czvf test1.tar.gz 1.txt 2.txt 3.txt</p>
<p>8.vim编辑器<br>命令行模式  esc<br>编辑模式  a i o<br>扩展模式  :     (:wq退出)</p>
<p>dd 删除（剪切）<br>ndd 删除光标所在的向下n行<br>yy 复制光标所在的那一行<br>nyy 复制光标所在的向下n行<br>p 将已复制的数据在光标的下一行粘贴<br>np 复制n次<br>P 将已复制的数据在光标的上一行粘贴<br>u 撤销上一步操作<br>ctrl+r 前进一步<br>0 移动到行首(home)<br>$ 移动到行尾(end)<br>gg 移动到文章开头<br>G 移动到文章最后一行<br>nG 移动到文章第n行<br>H 移动到屏幕最上方<br>M 移动到屏幕中央<br>L 移动到屏幕最下方<br>:w 将文件写入磁盘<br>:q 退出<br>:wq 写入并退出<br>:set nu 显示行号</p>
<p><strong>9.系统启动流程</strong><br>linux系统引导顺序： BIOS—&gt;MBR(主引导记录,512B,从何处装载程序)—&gt;Boot loader(引导)—&gt;Kernel—&gt;init progress</p>
<p>操作系统的启动级别 7个（/etc/inittab）<br>查看内核信息 uname -r<br>查看内核详细信息 uname -a</p>
<p><strong>10.grub加密</strong><br><strong>11.bios加密<br>12.top命令</strong><br>僵尸进程:父进程结束，子进程没有结束（仍然存在）<br>终端:bash程序<br>buffer：缓冲区（内存空间）<br>cache:高速缓存（内存空间，存放cpu经常使用的数据）<br>pid 进程号<br>PR<br>NI（nice） 好心值 值越高优先级越低<br>VIRT 虚拟内存<br>RES 物理内存<br>SHR 共享内存</p>
<p><strong>13.free命令</strong><br>free 查看内存信息<br>free -m 以兆为单位<br>free -h 以G为单位</p>
<p><strong>14.进程管理</strong><br>ps aux 查看所有进程<br>kill 进程号(-9 强制杀死进程)<br>kill %工作号<br>firefox &amp; 打开firefox并在后台运行<br>jobs 查看后台进程<br>fg % 后台掉前台<br>bg % 在后台运行<br>pgrep == ps grep</p>
<p><strong>15.磁盘分区</strong><br>步骤： （1）fdisk /dev/sdb新建分区 （2）partprobe更新分区表（3）mkfs.ext4格式化（4）mount 挂载</p>
<p>ls /dev/sd<br>块存储(磁盘) 文件存储(文件夹) 对象存储(百度网盘)</p>
<p>查看硬盘详细信息 fdisk -l /dev/sdb<br>硬盘分区 fdisk /dev/sdb</p>
<p>写分区列表  w<br>更新分区列表  partprobe</p>
<p>格式化为ext4 : mkfs.ext4 /dev/sdb1<br>扩展分区为逻辑分区不能格式化</p>
<p><strong>16.文件系统与挂载</strong><br>挂载：由设备映射到目录<br>mount /dev/sdb1 /sdb1/ 将sdb1挂载到/sdb1/\<br>df 查看挂载信息</p>
<p>文件系统<br>xfs 海量数据存贮<br>btrfs 存储效率高</p>
<p>一个设备可以有多个挂载点</p>
<p>卸载：umount 设备（删除最后一个挂载点）<br>      umount 挂载点</p>
<p>touch /opt/a.txt 若/opt不存在则寻找/</p>
<p>查看挂载信息： df mount<br>统计某一目录下文件大小 du -sh /etc/</p>
<p>文件包括元数据（存放在inode块中）和数据信息<br>操作系统中的block：<br>super block<br>inode block中存放的信息：inode号。权限，属主，属组，创建时间，文件名，指针<br>directory block中存放的信息：文件+inode号<br>block：存放数据的块</p>
<p>df -i 查看inode的占用情况<br>写文件： dd if=输入文件目录 of=输出文件目录 bs=10G count=1（bs：一个块的大小一般为512）</p>
<p><strong>17.软链接和硬链接</strong></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html</a></p>
<p>软链接(快捷方式)： ln -s &lt;源文件路径&gt; &lt;目标文件路径&gt;<br>硬链接： ln &lt;源文件路径&gt; &lt;目标文件路径&gt;<br>软链接的目标和源文件的inode号不同，可以跨分区<br>硬链接的目标和源文件的inode号相同，不可以跨分区</p>
<p><strong>18.linux网络地址管理</strong><br>ip地址<br>格式： 4段.分十进制（4段8位二进制数）<br>网络地址： ip地址和子网掩码按位与<br>查看网卡信息： ifconfig<br>永久修改网卡ip地址： vim /etc/sysconfig/network-scripts/ifcfg-eth0<br>BOOTPROTO=dhcp 从局域网的dhcp服务器获取<br>BOOTPROTO=static<br>IPADDR=192168.11.200<br>NETMASK=255.255.255.0<br>GATEWAY=192.168.11.1<br>DNS1=2.2.106.0.20<br>DNS2=8.8.8.8</p>
<p><strong>19.软件包管理</strong><br>编译安装：将程序编码为二进制文件存放到计算机中</p>
<p>软件包最后一位为奇数为测试版，偶数为稳定版</p>
<p>rpm 红帽软件包管理<br>rpm包本身就是编译好的二进制文件</p>
<p>yum软件包管理</p>
<p><strong>20.补充</strong><br>ssh服务<br>在服务端开启ssh服务，然后客户端输入ssh <ip地址><br>主机密钥错误：vim ~/.ssh/known</p>
<h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h3><p><strong>操作系统的内核</strong>：操作系统的内核是一个管理和控制程序，负责管理计算机的所有物理资源，其中包括。文件系统、内存管理、设备管理和进程管理。</p>
<p><strong>UNIX操作系统</strong>的特点：多用户和多任务<br>a)    多用户表示在同一时刻可以有多个用户同时使用UNIX操作系统而且他们互不干扰；<br>b)    多任务表示任何一个用户在同一时间可以在UNIX操作系统上运行多个程序。</p>
<p><strong>Linux</strong>的定义：Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。</p>
<p><strong>登录和退出Linux</strong>（操作演示图解见linux系统管理P17-P22）<br>1)    掌握关闭Linux系统的命令：init 0<br>2)    掌握什么是Linux终端：Linux终端也称为虚拟控制台。Linux终端采用字符命令行方式工作，用户通过键盘输入命令，通过Linux终端对系统进行控制。<br>3)    掌握切换虚拟终端的方法：Ctrl+Alt+F[1～6]，如想切换到第二号虚拟终端，则同时按Ctrl+Alt+F2<br>4)    掌握普通用户登录后系统的提示符：$<br>5)    掌握root用户登录后系统的提示符：#<br>6)    掌握退出命令：exit</p>
<h3 id="二-linux命令"><a href="#二-linux命令" class="headerlink" title="二.linux命令"></a>二.linux命令</h3><ol>
<li><strong>whoami</strong>命令（详见linux系统管理P24）<br>1)    了解whoami命令的功能:列出目前登陆Linux系统所使用的用户名（账号）。</li>
<li><strong>who</strong>命令（详见linux系统管理P25）<br>1)    掌握who命令的功能：列出目前哪些用户在系统上工作。<br>2)    掌握who命令的输出结果：显示当前登录的所有用户，以及当前的日期和时间。</li>
<li><strong>date、cal、和clear</strong>命令及带有参数的命令<br>（详见linux系统管理P28-P29）<br>1)    掌握date命令的功能：显示系统当前的日期和时间。<br>2)    掌握date命令设置时间时间的格式：date 月日时分年。<br>例如：将时间设定成2013年12月24日上午10点18的命令：<br>扩展（date 12241018201<br>hwclock –s 同步硬件 –w 同步系统）<br>3)    掌握cal命令的功能：显示某月的日历。<br>4)    灵活应用cal命令列出某一年某月的日历：例如显示2008年8月份日历的命令为：cal 8 2008<br>5)    掌握clear命令的功能：清除屏幕<br>6)    掌握清屏快捷键：ctrl+l</li>
<li>su和passwd命令（详见linux系统管理P29-P31）<br>1)    掌握su命令的功能：从当前的用户切换到另一个指定的其他用户。<br>2)    灵活应用su命令切换用户：<br>例如：切到root用户的命令：su – root<br>3)    掌握passwd命令功能：修改用户（既可以是普通用户，也可以是root用户）的密码，查看用户的密码状态等。Useradd<br>4)    掌握使用passwd命令修改用户密码：<br>例如：修改dog用户密码的命令：passwd dog</li>
<li>利用man命令来获取帮助信息（详见linux系统管理P34）<br>1)    掌握man命令的功能：获取某个Linux命令的使用说明。<br>2)    掌握使用man命令查看某命令的使用说明：<br>例如：查看su命令的使用说明的命令为:man su</li>
<li>使用“命令名 —help”获取帮助<br>1)    例如:查看ls命令帮助的命令为：(不使用man方法)<br>ls –-help</li>
</ol>
<h3 id="三-目录文件的浏览"><a href="#三-目录文件的浏览" class="headerlink" title="三.目录文件的浏览"></a>三.目录文件的浏览</h3><p>1.Linux系统中的一些<strong>重要的目录</strong>（详见linux系统管理P41）<br>a)    <strong>bin目录</strong>：用来存放常用的可执行文件<br>b)    <strong>sbin目录</strong>：用来存放系统的可执行文件<br>c)    <strong>家目录</strong>：用来存放用户自己的文件或目录，其中，超级用户root的家目录是/root，而普通用户的家目录被存放在/home目录下，并使用用户名作为最后一级目录（家目录）的名称，如cat用户的家目录为/home/cat<br>d)    <strong>dev目录</strong>：设备文件目录<br>e)    <strong>etc目录</strong>：配置文件目录<br>f)    <strong>挂载点(目录)</strong>：通常可移除式硬件会被挂载在/media或/mnt目录之下</p>
<ol>
<li>使用<strong>pwd</strong>和<strong>cd</strong>命令来确定和切换目录（详见linux系统管理P43-P46）<br>1)    掌握pwd命令的功能：确定现在所在的工作目录<br>2)    掌握cd命令的功能：切换当前目录<br>3)    掌握“cd –”命令：切换到用户之前的工作目录</li>
<li>使用ls命令列出目录中的内容(详见linux系统管理P47-P50)<br>1)    掌握ls -a命令：列出目录下的所有文件，包括以“.”开头的隐含文件<br>2)    掌握ls –l命令：列出某个目录中每一个文件的详细资料</li>
<li>使用cp命令复制文件和目录（详见linux系统管理P50）<br>1)    掌握cp命令的功能：将文件（可以是多个）复制成一个指定的目的文件或复制到一个指定的目标目录中。<br>2)    掌握cp命令的常用选项：  Cp 源文件 目标文件<br>a)    –r（recursive，递归的）：递归地复制目录。当复制一个目录时，复制该目录中所有的内容，其中包括子目录的全部内容。<br>b)    <strong>-f（force，强制）：在目标文件已经存在的时候不询问直接强制复制</strong></li>
<li>使用mv命令移动及修改文件和目录名（详见linux系统管理P54）<br>1)    掌握mv命令的功能：既可以在不同的目录之间移动文件和目录，也可以重新命名文件和目录。<br>2)    掌握mv命令的用法举例：<br>a)    移动文件和目录的例子：<br>将当前目录中的lists文件移动到其子目录babydog中的命令：<br>mv lists babydog<br>b)    重命名文件和目录的例子：<br>将bigdog目录名改为babydog的命令：<br>mv bigdog babydog</li>
<li>使用mkdir命令创建目录（详见linux系统管理P55）<br>1)    掌握mkdir命令的功能：创建一个新目录<br>2)    掌握mkdir命令的用法举例：<br>创建目录daddog的命令：mkdir dadgog</li>
<li>使用touch命令创建文件(详见linux系统管理P56)<br>1)    掌握touch命令的功能：可以创建一个空文件，也可以同时创建多个文件。<br>2)    掌握touch命令的用法举例：<br>在当前目录中创建一个名为babydog1的文件的命令：<br>touch babydog1 </li>
<li>使用rm命令删除文件（详见linux系统管理P57）<br>1)    掌握rm命令的功能：永久地在文件系统中删除文件或目录。<br>2)    掌握rm命令的常用选项：<br>a)    –r(recursive，递归的）：递归地删除目录。当删除一个目录时，删除该目录中所有的内容，其中包括子目录中的全部内容。<br>b)    –f（force，强制）：系统并不询问而是强制删除，即直接删除原有的文件。<br>3)    掌握rm命令的用法举例：<br>删除当前目录中的babydog1文件的命令：rm babydog1</li>
<li>使用rmdir或rm –r命令删除目录（详见linux系统管理P59）<br>1)    掌握<strong>rmdir命令的功能：删除空目录。</strong><br>2)    掌握rmdir命令的用法举例：<br>删除空目录 mumdog/girldog/babydog的命令：<br>rmdir mumdog/girldog/babydog<br>3)    掌握rm –r命令的功能：删除包含文件和子目录的目录。<br>4)    掌握rm –r命令的用法举例：<br>删除非空目录mumdog的命令：<br>rm –r mumdog</li>
<li>使用cat命令浏览正文文件的内容（详见linux系统管理P73）<br>5)    掌握cat命令的功能：将一个或多个文件的内容显示在屏幕上，该命令会不停的以只读的方式显示整个文件的内容。<br>6)    掌握cat命令的用法举例：<br>a)    浏览game.txt文件中的全部内容的命令：<br>cat game.txt</li>
<li>使用head命令浏览文件中的内容（详见linux系统管理P75）<br>1)    掌握head命令的功能：默认将显示一个文件的前10行。<br>2)    掌握head命令的常用选项：<br>-n 改变显示的行数<br>3)    掌握head命令的用法举例：<br>a)    查看/etc/passwd文件中前10行的详细信息的命令：<br>head /etc/passwd<br>b)    查看/etc/passwd文件中前5行的详细信息的命令：<br>head –n 5 /etc/passwd</li>
<li>使用tail命令浏览文件中的内容（详见linux系统管理P76）<br>1)    掌握tail命令的功能：默认显示文件最后10行的内容。<br>2)    掌握tail命令的常用选项：<br>-n 显示从文件末尾算起的n行<br>3)    掌握tail命令的用法举例：<br>a)    查看/etc/passwd文件中最后10行的详细信息的命令：<br>tail /etc/passwd<br>b)    查看/etc/passwd文件中最后5行的详细信息的命令：<br>tail –n 5 /etc/passwd</li>
<li>使用more命令浏览文件（详见linux系统管理P78）<br>1)    掌握more命令的功能：使用more命令之后，每次在屏幕上显示一屏（一页）的文件内容，并且在屏幕的尾部将会出现“—More—（n%）”的信息，其中，n%是已经显示文件内容的百分比。<br>2)    灵活应用more命令<br>a)    分页浏览learning.txt文件内容的命令：(翻页：空格，查找：/字符串)<br>more learning.txt</li>
</ol>
<h3 id="四-用户群组和权限"><a href="#四-用户群组和权限" class="headerlink" title="四.用户群组和权限"></a>四.用户群组和权限</h3><ol>
<li><p>用户及<strong>passwd</strong>文件<br>1)    掌握/etc/passwd文件的功能：存储所有用户的相关信息，该文件也被称为用户信息数据库（Database）。<br>2)    /etc/passwd文件每个字段的具体含义：<br>a)    第1个字段（列）记录的是这个用户的名字（在创建用户时root用户起的）。<br>b)    第2个字段（列）如果是x，表示该用户登录Linux系统时必须使用密码；如果为空，则该用户在登录时无须提供密码。<br>c)    第3个字段（列）记录的是这个用户的uid。<br>d)    第4个字段（列）记录的是这个用户所属群组的gid。<br>e)    第5个字段（列）记录的是有关这个用户的注释信息（如全名或通信地址）。<br>f)    第6个字段（列）记录的是这个用户的家目录的路径。<br>g)    第7个字段（列）记录的是这个用户登录后，第一个要执行的进程。</p>
</li>
<li><p><strong>shadow文件</strong>（详见linux系统管理P133）<br>1)    /etc/shadow文件的功能：存储所有用户的密码，每一个用户占用一行记录，该文件实际上就是存放用户密码的数据库（Database）。<br>2)    /etc/shadow文件每个字段的具体含义：<br>a)    第1个字段（列）是用户名。<br>b)    第2个字段（列）是密码，这个密码是经过MD5加密算法加密过的密码。</p>
</li>
<li><p><strong>群组及group文件</strong>（详见linux系统管理P135）<br>1)    /etc/group文件的功能：存放了Linux系统中所有群组的信息，它实际上就是一个存放群组信息的数据库（Database）。<br>2)    /etc/group文件每个字段的具体含义：<br>a)    第1个字段是这个群组的名字。<br>b)    第2个字段中的x表示这个群组在登录Linux系统时必须使用密码。<br>c)    第3个字段记录的是这个群组的gid。<br>d)    第4个字段记录的是这个群组里还有哪些群组成员。</p>
</li>
<li><p>怎样在Linux系统中添加一个新的用户账户（详见linux系统管理P449）<br>1)    掌握<strong>useradd</strong>命令的功能：新增一个用户。<br>2)    了解useradd命令的常用选项：</p>
<p>-m: 创建家目录</p>
<p>a)    –u：指定用户的UID<br>b)    –g：指定用户所属的群组<br>c)    –d：指定用户的家目录<br>d)    –c：指定用户的备注信息<br>e)    –s：指定用户所用的shell<br>3)    灵活应用useradd命令的举例：<br>a)    例如：在系统中新增一个fox（狐狸）用户的命令：useradd fox<br>b)    例如：在系统中新增一个用户user01，属组为police以及uid为600的命令：<br>useradd –u 600 –g police user01</p>
</li>
<li><p>使用<strong>usermod</strong>命令修改用户账户（详见linux系统管理P458）<br>1)    掌握usermod命令的功能：修改用户的账户信息。<br>2)    了解usermod命令的常用选项：<br>a)    –u：修改用户的UID<br>b)    –g：修改用户的GID<br>c)    –G：将一个用户加入到指定的群组中<br>d)    –d：修改用户的家目录<br>e)    –c：修改用户的备注信息<br>f)    –s：修改用户所用的shell<br>3)    灵活应用usermod命令的举例：<br>a)    修改babydog4用户的家目录为/home/babies的命令：<br>usermod –d /home/babies babydog4<br>b)    将babydog4这个用户添加到babydog6这个群组中的命令：<br>usermod –G babydog6 babydog4<br>c)    将babydog4这个用户的的gid变更为dog群组的命令：<br>usermod –g dog babydog4</p>
</li>
<li><p>使用usermod命令<strong>锁住用户及将用户解锁</strong>（详见linux系统管理P461）<br>1)    了解usermod –L命户令的功能：将用户的账号锁住<br>2)    了解usermod –L命户令的用法举例：<br>例如：将babydog6用户的账号锁住的命令：usermod –L babydog6<br>3)    了解usermod –U命户令的功能：将用户的账号解锁<br>4)    了解usermod –U命户令的用法举例：<br>例如：将babydog6用户的账号解锁的命令：usermod –U babydog6</p>
</li>
<li><p>使用userdel命令删除用户账号（详见linux系统管理P462）<br>1)    掌握userdel命令的功能：删除用户。<br>2)    了解userdel命令的常用选项：<br>a)    <strong>–r：在删除用户的同时删除这个用户的家目录及其邮箱。</strong><br>3)    灵活应用userdel命令删除用户的举例：<br>a)    例如：删除babydog5用户不删除其家目录的命令：</p>
</li>
<li><p>群组的管理<br>1)    掌握groupadd命令的功能：创建一个新的群组账号。<br>2)    了解groupadd命令的常用选项：<br>c)    –g：指定群组的GID<br>3)    灵活应用groupadd命令的举例：<br>例如：在系统中新增加一个名为boydogs的群组的命令：<br>groupadd boydogs<br>4)    掌握groupmod命令的功能：修改一个群组账号的信息。<br>5)    了解groupmod命令的常用选项：<br>a)    –g：修改群组的GID<br>b)    –n：修改群组的名称<br>6)    灵活应用groupmod命令的举例：<br>a)    例如：修改police群组的gid为521的命令：<br>groupmod –g 521 police<br>b)    例如：将群组boydogs改名为daddogs的命令：<br>groupmod –n daddogs boydogs<br>7)    掌握groupdel命令的功能：删除一个群组账号。<br>8)    灵活应用groupdel命令的举例：<br>例如：删除daddogs群组的命令：groupdel daddogs</p>
</li>
</ol>
<h3 id="五-用户群组权限"><a href="#五-用户群组权限" class="headerlink" title="五.用户群组权限"></a>五.用户群组权限</h3><ol>
<li>怎样查看文件的权限（详见linux系统管理P138）<br>1)    掌握使用ls –l命令查看文件上所设定的权限。<br>2)    掌握ls –l命令的显示结果中的第一列分成4组，其中;<br>a)    第1个字符为第1组，代表这是一个文件（-）或是一个目录（d），也可以是其他资源。<br>b)    第2、3、4个字符为第2组，定义了文件或目录的所有者（owner）所具有限的权，使用u代表所有者（owner）对文件的所有权限。<br>c)    第5、6、7个字符为第3组，定义了文件或目录的所有者所在的群组中其他（用户）所具有的权限，使用g代表这一组（group）权限。<br>d)    第8、9、10个字符为第4组，定义了既不是owner也不和owner在同一群组的其他用户对文件或目录所具有的权限。使用o代表这一组（other）权限。<br>3)    掌握ls –l命令的显示结果中的第三列、第四列为文件的属主和属组。</li>
<li>root用户及文件的安全控制（详见linux系统管理P136）<br>1)    掌握root用户的定义：root用户也称为超级用户，它可以完全不受限制地访问任何用户的账户和所有文件及目录。<br>2)    了解Linux系统中用户分类：<br>Linux系统是将系统中的所有用户分成了3类：<br>a)    第1类：所有者<br>b)    第2类：同组用户（修正：所属组，因为你创建一个用户的过程会以为这个用户名为名字创建一个同名的组）<br>c)    第3类：非同组的其他用户<br>3)    掌握文件操作权限包括读（read）、写（write）和执行（execute）<br>4)    掌握Linux操作系统在显示权限时，使用如下4个字符来表示文件操作权限：<br>a)    r：表示read权限，也就是可以阅读文件或者ls命令列出目录内容的权限。<br>b)    w：表示write权限，也就是可以编辑文件或者在一个目录中创建和删除文件的权限。<br>c)    x：表示execute权限，也就是可以执行程序或者使用cd命令切换到这个目录以及使用带有-l选项的ls命令列出这个目录中详细内容的权限等。<br>d)    -：表示没有相应的权限（与所在位置的r、w或x相对应）。</li>
<li>掌握使用<strong>chown修改文件的属主</strong><br>chown 属主:属组 文件<br>chown :属组 文件<br>chown 属主 文件<br>a)    例如，修改文件file1的属主为root的命令为：chown root file1</li>
<li>掌握使用<strong>chgrp修改文件的属组</strong><br>chgrp 属组 文件<br>a)    例如，修改文件file1的属组为wg的命令为：chgrp wg file1</li>
<li>使用符号法设定文件或目录上的权限（详见linux系统管理P132）<br>1)    掌握chmod命令的功能：设定或更改文件或目录上的权限。<br>2)    <strong>掌握-R选项：不但设置（或更改）该目录权限，而且还要递归地设置（或）更改该目录中所有文件或子目录的权限。</strong><br>3)    掌握是符号表示法的定义：<br>符号表示法是使用几个特定的符号来设定权限的状态。<br>4)    掌握权限状态可以分为3个部分：<br>a)    第1个部分，表示要设定或更改谁的权限状态。其中的具体表示如下：<br>u:表示所有者（owner）的权限。<br>g：表示群组（group）的权限。<br>o：表示既不是owner也不与owner在同一个group的其他用户（other）的权限。<br>a：表示以上3组，也就是所有用户（all）的权限。<br>b)    第2部分，是运算符（operator），也有人称为操作符，其中的具体表示如下：<br>+：表示加入权限<br>-：表示去掉权限<br>=：表示设定权限<br>c)    第3部分，表示权限（permission），其中的具体表示如下：<br>r：表示read（读）权限。<br>w：表示write（写）权限。<br>X：表示execut（执行）权限。<br>5)    灵活应用符号表示法设定或更改文件或目录上的权限：<br>a)    例如：在dog_wolf文件上添加所有者和同组用户的可执行权限的命令：<br>chmod ug+x dog_wolf<br>b)    例如：在babydog目录上为其他用户添加写权限的命令：<br>chmod o+w babydog</li>
<li>使用数字表示法设定文件或目录上的权限（详见linux系统管理P143）<br>1)    掌握数字表示法的定义：<br>数字表示法是指使用一组三位数的数字来表示文件或目录上的权限状态。其中：<br>第1个数字代表所有者（owner）的权限（u）。<br>第2个数字代表群组（group）的权限（g）。<br>第3个数字代表其他用户（other）的权限（o）。<br>2)    数字代表的资源权限状态：<br>4：表示具有读（read）权限。<br>2：表示具有写（write）权限。<br>1：表示具有执行（execute）权限。<br>0：表示没有相应的权限。<br>3)    灵活应用数字法表示法设定或更改文件或目录上的权限：<br>a)    例如：使用数字表示法对owner开放/home/dog/babydog目录和其中所有文件的一切权限，但是对同组用户开放读和执行权限，而对其他用户只开放读权限的命令：<br>chmod -R 754 /home/dog/babydog </li>
</ol>
<h3 id="六-正文处理命令及tar命令"><a href="#六-正文处理命令及tar命令" class="headerlink" title="六.正文处理命令及tar命令"></a>六.正文处理命令及tar命令</h3><ol>
<li>使用cat命令进行文件的纵向合并<br>1)    掌握<strong>使用cat命令实现文件的纵向合并</strong>：<br>a)    例如：使用cat命令将baby.age、baby.kg和baby.sex这三个文件纵向<strong>合并</strong>为baby文件的方法：<br>cat baby.age baby.kg baby.sex &gt;baby<br>b)    例如：使用cat命令将baby.age文件的内容<strong>添加到</strong>baby2文件中的方法：<br>cat baby.age &gt;&gt;baby2</li>
<li>归档文件和归档技术（详见linux系统管理P209）<br>1)    掌握归档的定义：归档（archiving）就是将许多文件（或目录）打包成一个文件。<br>2)    了解归档的目的：归档的目的就是方便备份、还原及文件的传输操作。<br>3)    掌握tar命令的功能：将多个文件（也可能包括目录，因为目录本身也是文件）放在一起存放到一个磁带或磁盘归档文件中。并且将来可以根据需要只还原归档文件中的某些指定的文件。<br>4)    掌握tar命令的常用选项：<br>c：创建一个新的tar文件。<br>t：列出tar文件中目录的内容。<br>x：从tar文件中抽取文件。<br>f：指定归档文件或磁带（也可能是软盘）设备（一般都要选）。<br>v：显示所打包的文件的详细信息，v是verbose的第1个字母。<br>z：使用gzip压缩算法来压缩打包后的文件。<br>j：使用bzip2压缩算法来压缩打包后的文件。</li>
<li><p>使用tar命令创建、查看及抽取归档文件（详见linux系统管理P210）<br>1)    掌握使用tar命令创建归档文件的用法举例：<br>例如：使用tar命令将arch目录打包成一个名为arch.tar的归档文件的方法(要求显示所有打包的文件和目录)：<br>tar cvf arch.tar arch<br>掌握使用tar命令查看归档文件的用法举例：<br>例如：使用tar命令显示arch.tar这个归档文件（包）中的所有文件的方法：<br>tar tf arch.tar<br>2)    掌握使用tar命令抽取归档文件的用法举例：<br>例如：使用tar命令恢复arch.tar中的全部内容的方法：<br><strong>tar xvf arch.tar -C 路径</strong></p>
</li>
<li><p>文件的压缩和解压缩（详见linux系统管理P212）<br>1)    掌握压缩的定义：压缩就是将一个大的文件通过一些压缩算法变成一个小文件。<br>2)    了解压缩的目的：主要是缩小文件的大小，这样会节省存储文件的磁盘或磁带的空间，另外在网络上传输这些小文件也会减少网络的浏览（也就是节省网络的带宽）。<br>3)    掌握解压缩的定义：解压缩就是将一个通过一些压缩算法的文件恢复到压缩之前的样子。<br>4)    掌握gzip命令和gunzip命令的用法举例：<br>a)    例如：将文件file1压缩成.gz格式的压缩包应该使用的命令为：gzip file1 –c &gt; /路径/name.gz<br>b)    例如：将压缩文件file1.gz解压缩的命令为：<br>gunzip file1.gz &gt;<br>5)    掌握bzip2命令和bunzip2命令的用法举例：<br>a)    例如：将文件file1压缩成.bz2格式的压缩包应该使用的命令为：bzip2 file1 &gt;<br>b)    例如：将压缩文件file1.bz2解压缩的命令为：<br>bunzip2 file1.bz2 &gt;</p>
</li>
<li>在使用tar命令的同时进行压缩和解压缩（详见linux系统管理P214）<br>1)    掌握在使用tar命令的同时进行压缩和解压缩的用法举例<br>a)    例如：使用tar命令将arch目录打包而且同时使用gzip的技术压缩打包后文件的方法（打包后的文件名为arch.tar.gz）：<br><strong>tar cvfz arch.tar.gz arch</strong><br>b)    例如：使用tar命令将arch目录打包而且同时使用bzip2的技术压缩打包后文件的方法（打包后的文件名为arch.tar.bz2）：tar cvfj arch.tar.bz2 arch</li>
</ol>
<h3 id="七-vi编辑器"><a href="#七-vi编辑器" class="headerlink" title="七.vi编辑器"></a>七.vi编辑器</h3><ol>
<li>vi编辑器的操作模式（详见linux系统管理P255）<br>1)    掌握vi编辑器的3中基本模式：<br>a)    命令行模式：vi的默认模式。在这一模式中，所有的输入被解释成vi命令，可以执行修改、复制、移动、粘贴和删除正文等命令，也可以进行移动光标、搜索字符串和退出vi的操作等。<br>b)    编辑模式：在编辑模式中，可以往一个文件中输入正文。在这一模式下，输入的每一个字符都被vi编辑器解释为输入的正文。使用ESC键返回命令行模式。<br>c)    扩展模式：在一些UNIX系统上也叫最后一行模式。在这一模式下，可以使用一些高级编辑命令，如搜寻和替代字符串、存盘或退出vi编辑器等。要进入最后一行模式，需要在命令行模式中输入冒号（：），冒号这一操作将把光标移到屏幕的最后一行。</li>
<li>在vi编辑器中光标的移动（详见linux系统管理P256）<br>1)    掌握在vi编辑器中用来移动光标位置的键与光标移动之间的关系，如下表：</li>
</ol>
<p><img src="image/1036857-20161109123528842-995787310.png" alt="img"></p>
<ol>
<li><p>进入插入模式（详见linux系统管理P258）<br>1)    掌握从命令行模式进入插入模式的命令：<br>a：进入插入模式并在光标之后进行添加。<br>i：进入插入模式并在光标之前进行插入。<br>o：进入插入模式并在当前（光标所在）行之下开启新的一行。</p>
</li>
<li><p>在命令行模式下删除与复制的操作（详见linux系统管理P259）<br>1)    掌握常用的删除与复制的常用按键</p>
</li>
</ol>
<p><img src="image/1036857-20161109123710170-1185294317.png" alt="img"></p>
<p>6.粘贴命令</p>
<p>1) 掌握粘贴命令：</p>
<p><img src="image/1036857-20161109123818467-1517669241.png" alt="img"></p>
<p>\7. 复原和重做命令</p>
<p>1) 掌握常用的复原和重做命令：</p>
<p><img src="image/1036857-20161109123941967-1490120946.png" alt="img"></p>
<p>8.扩展模式与文件的存储和退出</p>
<p>1)掌握扩展模式下常用的命令： </p>
<p><img src="image/1036857-20161109124015452-733251563.png" alt="img"></p>
<p>9.快速移动光标在文件中的位置 </p>
<p> 1）掌握快速移动光标在文件中的位置的命令</p>
<p><img src="image/1036857-20161109124031827-559358850.png" alt="img"></p>
<p> 10.快速移动光标在屏幕中的位置</p>
<p>1）掌握快速在屏幕中移动光标的位置的命令</p>
<p><img src="image/1036857-20161109124041514-1031334101.png" alt="img"></p>
<h3 id="八-linux系统初始化和服务"><a href="#八-linux系统初始化和服务" class="headerlink" title="八.linux系统初始化和服务"></a>八.linux系统初始化和服务</h3><ol>
<li><p><strong>Linux系统引导的顺序</strong>（详见linux系统管理P312）</p>
<p>最初始阶段<br>当我们打开计算机电源，计算机会自动<strong>从主板的BIOS(Basic Input/Output System)读取其中所存储的程序</strong>。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。<br>下一步，计算机将从你所选择的存储设备中读取起始的512 bytes(比如光盘一开是的512 bytes，如果我们从光盘启动的话)。这512 bytes叫做<strong>主引导记录MBR</strong> (master boot record)。MBR会告诉电脑从该设备的某一个分区(partition)来装载引导加载程序(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。常用的boot loader有GRUB和LILO。<br>随后，<strong>boot loader会帮助我们加载kernel</strong>。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。<br>（Linus Torvalds与其说是Linux之父，不如说是Linux kernel之父。他依然负责Linux kernel的开发和维护。至于Ubuntu, Red Hat, 它们都是基于相同的kernel之上，囊括了不同的应用和界面构成的一个更加完整的操作系统版本。)<br>实际上，我们可以在多个分区安装boot loader，每个boot loader对应不同的操作系统，在读取MBR的时候选择我们想要启动的boot loader。这就是多操作系统的原理。<br>小结：BIOS -&gt; MBR -&gt; boot loader -&gt; kernel<br>kernel<br>如果我们加载的是Linux kernel，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过驱动程序(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个init进程。它是Linux系统中的1号进程(Linux系统没有0号进程)。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。<br>小结: kernel -&gt; init process<br>init process<br>(根据boot loader的选项，Linux此时可以进入单用户模式(single user mode)。在此模式下，初始脚本还没有开始执行，我们可以检测并修复计算机可能存在的错误)<br>随后，init会运行一系列的初始脚本(startup scripts)，这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：<br>设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……<br>当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录！！！init会给出登录(login)对话框，或者是图形化的登录界面。</p>
<p>输入用户名(比如说vamei)和密码，DONE！<br>在此后的过程中，你将以用户(user)vamei的身份操作电脑。此外，根据你创建用户时的设定，Linux还会将你归到某个组(group)中，比如可以是stupid组，或者是vamei组。<br>所以你将是用户vamei， 同时是vamei组的组员。(注意，组vamei和用户vamei只是重名而已，就好想你可以叫Dell, 同时还是Dell公司的老板一样。你完全也可以是用户vamei，同时为stupid组的组员)<br>总结<br>BIOS -&gt; MBR -&gt; boot loader -&gt; kernel -&gt; init process -&gt; login<br>用户，组</p>
<p>1)    掌握Linux系统引导的顺序：（详见附1）</p>
<p><img src="image/1036857-20161109091943202-2140545101.png" alt="img"></p>
</li>
</ol>
<p>其中，<strong>BIOS的工作是检查计算机的硬件设备</strong>，如CPU、内存和风扇速度等；<br>MBR会在启动盘的第1个块中，大小为512B。其中前446中的程序代码是用来选择boot partition（分区），也就是由哪个分区来装入开机用的代码；<br>在<strong>内核部分主要是安装计算机设备的驱动程序</strong>以便操作系统可以控制计算机上的设备。并且以只读的方式挂载/(根)文件系统，也就是此时的操作系统只能读到根文件系统（目录）所在的分区；<br>init程序的进程id为1，即Linux操作系统第1个执行的程序。</p>
<ol>
<li>BOIS的初始化和引导加载程序（详见linux系统管理P313）<br>1)    掌握BIOS的定义：BIOS（Basic Input/Output System）（基本输入/输出系统的缩写），它是硬件与软件之间的接口，而且是非常基本的接口。</li>
<li>GRUB程序和grub.conf文件（详见linux系统管理P317）<br>1)    掌握GRUB的定义：GRUB是Grand Unified Bootloader（多重操作系统启动管理器）的缩写。<br>2)    掌握grub的配置文件为：grub.conf<br>设置grub Md5加密命令 grub-MD5-crypt<br>Password = 明文或 password —md5 密文（编辑grub配置文件的密码）<br>Title red hat 标题<br>Password = 明文或 password —md5 密文（加载内核系统引导必须的密码）</li>
<li>内核的初始化和init的初始化（详见linux系统管理P322）<br>1)    掌握init的配置文件为：/etc/inittab<br>2)    了解init程序要做的工作：<br>a)    决定预设（默认）要使用哪个run levels（运行级别）。<br>b)    执行一些系统初始化的脚本（程序）来初始化操作系统。<br>c)    根据run level的设置来执行所对应目录中的程序，以决定要启动哪些服务。<br>d)    设定某些组合键。<br>e)    定义UPS不间断电源系统，即当电源出现问题时或电源恢复时要执行哪些程序。<br>f)    产生6个virtual consoles，也就是tty1～tty6。</li>
<li><p>run levels（运行级别）（详见linux系统管理P326）<br>1)    掌握所有的运行级别及每一个运行级别对应的功能：</p>
</li>
<li><p>关闭系统及重启系统（详见linux系统管理P342）<br>1)    掌握常用的可以关闭系统的命令：<br>shutdown -h now<br>halt<br>poweroff<br>init 0<br>2)    掌握常用的可以重启系统的命令：<br>shutdown -r now<br>reboot<br>init 6<br>Ctrl+Alt+Delete键</p>
</li>
<li>掌握单用户模式修改用户的密码</li>
<li>掌握救援模式</li>
</ol>
<h3 id="九-系统监控"><a href="#九-系统监控" class="headerlink" title="九.系统监控"></a>九.系统监控</h3><ol>
<li>系统监视和进程控制工具—top和free<br>1)    掌握top命令的功能：top命令是Linux下常用的性能分析工具,能够实时显示系统中各个进程的资源占用状况,类似于Windows的任务管理器。<br>2)    了解使用top命令列出系统状态时，系统默认每5秒刷新一下屏幕上的显示结果。</li>
</ol>
<p>\1. 第一行是任务队列信息</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>12:38:33</th>
<th>当前时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>up 50days</td>
<td>系统运行时间，格式为时:分</td>
</tr>
<tr>
<td>1 user</td>
<td>当前登录用户数</td>
</tr>
<tr>
<td>load average: 0.06, 0.60, 0.48</td>
<td>系统负载。 三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。</td>
</tr>
</tbody>
</table>
</div>
<p>\2. 第二、三行为进程和CPU的信息</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tasks: 29 total</th>
<th>进程总数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>28 sleeping</td>
<td>睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程数</td>
</tr>
<tr>
<td>Cpu(s): 0.3% us</td>
<td>用户空间占用CPU百分比</td>
</tr>
<tr>
<td>1.0% sy</td>
<td>内核空间占用CPU百分比</td>
</tr>
<tr>
<td>0.0% ni</td>
<td>用户进程空间内改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td>98.7% id</td>
<td>空闲CPU百分比</td>
</tr>
<tr>
<td>0.0% wa</td>
<td>等待输入输出的CPU时间百分比</td>
</tr>
<tr>
<td>0.0% hi</td>
<td>硬件中断占用CPU时间的百分比</td>
</tr>
<tr>
<td>0.0% si</td>
<td>软件中断占用CPU时间的百分比</td>
</tr>
</tbody>
</table>
</div>
<p>\3. 第四五行为内存信息。</p>
<p><img src="image/1036857-20170525235729091-1652844480.png" alt="img"></p>
<p>\4.  进程信息</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程id</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程id</td>
</tr>
<tr>
<td>RUSER</td>
<td>Real user name</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户id</td>
</tr>
<tr>
<td>USER</td>
<td>进程所有者的用户名</td>
</tr>
<tr>
<td>GROUP</td>
<td>进程所有者的组名</td>
</tr>
<tr>
<td>TTY</td>
<td>启动进程的终端名。不是从终端启动的进程则显示为 ?</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>NI</td>
<td>nice值。负值表示高优先级，正值表示低优先级</td>
</tr>
<tr>
<td>P</td>
<td>最后使用的CPU，仅在多CPU环境下有意义</td>
</tr>
<tr>
<td>%CPU</td>
<td>上次更新到现在的CPU时间占用百分比</td>
</tr>
<tr>
<td>TIME</td>
<td>进程使用的CPU时间总计，单位秒</td>
</tr>
<tr>
<td>TIME+</td>
<td>进程使用的CPU时间总计，单位1/100秒</td>
</tr>
<tr>
<td>%MEM</td>
<td>进程使用的物理内存百分比</td>
</tr>
<tr>
<td>VIRT</td>
<td>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td>
</tr>
<tr>
<td>SWAP</td>
<td>进程使用的虚拟内存中，被换出的大小，单位kb。</td>
</tr>
<tr>
<td>RES</td>
<td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td>
</tr>
<tr>
<td>CODE</td>
<td>可执行代码占用的物理内存大小，单位kb</td>
</tr>
<tr>
<td>DATA</td>
<td>可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</td>
</tr>
<tr>
<td>SHR</td>
<td>共享内存大小，单位kb</td>
</tr>
<tr>
<td>nFLT</td>
<td>页面错误次数</td>
</tr>
<tr>
<td>nDRT</td>
<td>最后一次写入到现在，被修改过的页面数。</td>
</tr>
<tr>
<td>S</td>
<td>进程状态。             D=不可中断的睡眠状态             R=运行             S=睡眠             T=跟踪/停止             Z=僵尸进程</td>
</tr>
<tr>
<td>COMMAND</td>
<td>命令名/命令行</td>
</tr>
<tr>
<td>WCHAN</td>
<td>若该进程在睡眠，则显示睡眠中的系统函数名</td>
</tr>
<tr>
<td>Flags</td>
<td>任务标志，参考 sched.h</td>
</tr>
</tbody>
</table>
</div>
<p>cpu利用率与load average</p>
<p>cpu利用率：上一天班的时间是8个小时，而码农敲代码的时间为2个小时，2/8=0.25  ,25%就是码农在一天的时间内的利用率（正常情况，cpu利用率&lt;70%）</p>
<p>cpu负载：公司在一分钟内为某个码农安排了3个任务，而1分钟内该码农能做6个任务，那么该码农一分钟内的负载为0.5</p>
<p>　　        如果公司在5分钟内为某个码农安排了100个任务，而5分钟内该码农只能做50个任务，那么该码农5分钟内的负载为2.0，即超负荷运转</p>
<p>　　　　  cpu负载&lt;=1:能正常应付</p>
<p>​             cpu负载&gt;1:超负荷运转</p>
<p>​             </p>
<p>　　　　 如果有4核，相当于将100个任务交给4个码农去干，如果每个码农的负载都是100%，那么整体的cpu负载达到4.0则是很正常的现象</p>
<p>　　　　　　</p>
<p>​             多核cpu， <strong>load average 应该 &lt;= cpu核数 * 0.7</strong></p>
<p>为何要有1分钟，5分钟，15分钟三种cpu负载？</p>
<p>　　其实之所以要给出3个值，就是希望我们能结合起来看。或者说希望展示一个动态的图表式的数据，比如最近一分钟显示负载120%。而最近5分钟和15分钟显示负载为50%。可能你不用太过担心。但是如果你发现系统的负载一直维持在120%以上，就必须要提高硬件配置了。</p>
<p>cpu利用率和cpu负载过高，都是不好的现象，但是也有可能出现，低利用率，高负载的情况：</p>
<p>　　为一个码农分配了100个项目，毫无疑问，该码农的负载是很高的，但是码农在具体去做一个项目时，可能会碰到需要购买机器，或者查询资料等耗费时间的问题，真正动手写代码的时间可能很短，而这段时间才是码农真正为公司干活的时间，如果每个项目都有类似这种问题，那么100个项目加到一起，码农真正工作的时间也不会太多，这就造成了低利用率。</p>
<p>　　在两种情况下会导致一个进程在逻辑上不能运行，</p>
<p>　　1. 进程挂起是自身原因，遇到I/O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作</p>
<p>　　2. 与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。</p>
<p>　　因而一个进程有三种状态</p>
<p><img src="image/1036857-20170506221818429-279774518.png" alt="img"></p>
<p>3)    掌握free命令的功能：显示内存的使用状态。(下图centos6中查看效果，用二维数组代表FO即free output)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                   1          2          3          4          5          6</span><br><span class="line">1              total       used       free     shared    buffers     cached</span><br><span class="line">2 Mem:      24677460   23276064    1401396          0     870540   12084008</span><br><span class="line">3 -&#x2F;+ buffers&#x2F;cache:   10321516   14355944</span><br><span class="line">4 Swap:     25151484     224188   24927296</span><br></pre></td></tr></table></figure>
<p>从操作系统的角度：</p>
<p>　　物理内存FO[2][1]=24677460KB</p>
<p>　　物理内存被使用的内存FO[2][2]=23276064KB</p>
<p>　　可以用内存F[2][3]=1401396KB</p>
<p>　　等式：FO[2][1] = FO[2][2] + FO[2][3]</p>
<p>　　共享内存F[2][4]=0,表示几个进程共享的内存（数据共享）</p>
<p>　　F[2][5]=870540表示已经分配但是还未使用的buffers大小</p>
<p>　　F[2][6]=12084008表示已经分配但是还未使用的buffers大小</p>
<p>　　buffer和cache的解释：</p>
<ul>
<li><ul>
<li><em>A buffer is something that has yet to be “written” to disk.</em> </li>
<li><em>A cache is something that has been “read” from the disk and stored for later use.</em></li>
</ul>
</li>
</ul>
<p>　　也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。</p>
<p>　　Linux和其他成熟的操作系统（例如windows），为了提高IO read的性能，总是要多cache一些数据，这也就是为什么FO[2][6]（cached memory）比较大，而FO[2][3]比较小的原因。我们可以做一个简单的测试</p>
<ol>
<li><p>释放掉被系统cache占用的数据；</p>
<p>echo 3&gt;/proc/sys/vm/drop_caches </p>
</li>
<li><p>读一个大文件，并记录时间；</p>
</li>
<li><p>关闭该文件；</p>
</li>
<li><p>重读这个大文件，并记录时间；</p>
</li>
</ol>
<p>　　第二次读应该比第一次快很多。</p>
<p>　　free输出的第二行是从一个应用程序的角度看系统内存的使用情况。</p>
<ul>
<li>对于FO[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；</li>
<li>对于FO[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存；</li>
</ul>
<p>　　因为被系统cache和buffer占用的内存可以被快速回收，所以通常FO[3][3]比FO[2][3]会大很多。</p>
<p>　　这里还用两个等式：</p>
<ul>
<li>FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]</li>
<li>FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]</li>
</ul>
<p>　　free命令的所有输出值都是从/proc/meminfo中读出的。</p>
<p>4)  掌握free命令的功能：显示内存的使用状态。(下面均为centos7中查看效果)</p>
<p><a href="http://www.linuxatemyram.com/提到使用`free`命令查看`Linux`系统使用内存时，`used`一项会把当前`cache`的大小也会加进去，这样会造成`free`这一栏显示的内存特别少：" target="_blank" rel="noopener">http://www.linuxatemyram.com/提到使用`free`命令查看`Linux`系统使用内存时，`used`一项会把当前`cache`的大小也会加进去，这样会造成`free`这一栏显示的内存特别少：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">               total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           1504        1491          13           0         855      869</span><br><span class="line">Swap:          2047           6        2041</span><br></pre></td></tr></table></figure>
<p>可是实际上，<code>cache</code>根据应用程序的需要是可以回收利用的，因此<code>free</code>这一栏并不能真实地表现有多少“可以使用”的内存。实际系统可用内存应该以<code>available</code>数据为准。</p>
<p><code>linuxatemyram</code>所提到的<code>free</code>命令也许是比较老的版本，我尝试了<code>RHEL 7.2</code>，<code>Ubuntu 16.04</code>和<code>Arch Linux</code>这<code>3</code>个<code>Linux</code>发行版，均没有出现<code>used</code>包含<code>cache</code>的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:          64325       47437        3150        1860       13737       14373</span><br></pre></td></tr></table></figure>
<p>另外，从<code>man free</code>命令中也可以得到，目前计算<code>used</code>的值是要减掉<code>free</code>和<code>buff/cache</code>的：</p>
<blockquote>
<p>used Used memory (calculated as total – free – buffers – cache)</p>
</blockquote>
<p>可以使用<code>-w</code>命令行选项得到<code>buff</code>和<code>cache</code>各自使用的数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ free -wm</span><br><span class="line">              total        used        free      shared     buffers       cache   available</span><br><span class="line">Mem:          64325       48287        2476        1859        1430       12131       13524</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>free</code>表示的是当前完全没有被程序使用的内存；而<code>cache</code>在有需要时，是可以被释放出来以供其它进程使用的（当然，并不是所有<code>cache</code>都可以释放，比如当前被用作<code>ramfs</code>的内存）。而<code>available</code>才真正表明系统目前可以提供给应用程序使用的内存。<code>/proc/meminfo</code>从<code>3.14</code>内核版本开始提供<code>MemAvailable</code>的值；在<code>2.6.27</code>~<code>3.14</code>版本之间，是<code>free</code>程序自己计算<code>available</code>的值；早于<code>2.6.27</code>版本，<code>available</code>的值则同<code>free</code>一样。</p>
<p>\2. <strong>系统中进程的监控—ps</strong>（详见linux系统管理P363）<br>1)    掌握进程的定义：进程是程序的一次动态执行。<br>2)    掌握守护进程的定义：守护进程是在后台运行并提供系统服务的一些进程。<br>3)    掌握父进程、子进程的定义：当一个进程创建另一个进程时，第1个进程被称为新进程的父进程，而新进程被称为子进程。<br>4)    掌握ps命令的功能：用来显示当前进程的状态。<br><strong>ps –aux 显示所有的与用户相关的完整信息</strong><br>系统中进程的监控pstree、kill</p>
<p><strong>centos7默认没有pstree，需要yum -y install psmisc</strong><br>1)    掌握pstree命令的功能：以树状图显示程序。<br>2)    掌握pstree命令的用法举例：<br>例如：列出PID为4729的进程的进程状态树的命令：pstree 4729<br>3)    掌握kill命令的功能：把一个信号发送给一个或多个进程。默认发送终止信号。<br>4)    灵活应用kill命令终止进程<br>例如：终止PID为3852的进程的命令：kill 3852<br>5)    灵活应用kill -9命令杀死进程<br>例如：杀死PID为3906的进程的命令：kill -9 3906</p>
<ol>
<li>掌握pgrep命令的功能：通过名称或其他属性查找进程<br>例如：查找名为firefox的进程的命令为：pgrep firefox</li>
<li>掌握pkill命令的功能：通过名称或其他属性发信号给进程<br>例如：杀死名为firefox的进程的命令为：pkill firefox</li>
</ol>
<h3 id="十-硬盘分区、格式化、文件系统管理"><a href="#十-硬盘分区、格式化、文件系统管理" class="headerlink" title="十.硬盘分区、格式化、文件系统管理"></a>十.硬盘分区、格式化、文件系统管理</h3><ol>
<li>硬件设备与文件名的对应关系（详见linux系统管理P297）<br>1)    掌握在Linux系统中，每个设备都被当初一个文件来对待。<br>2)    掌握各种设备在Linux中的文件名</li>
</ol>
<p><img src="image/1036857-20161109124853764-690268125.png" alt="img"></p>
<ol>
<li>硬盘的结构及硬盘分区（详见linux系统管理P301）<br> 1)    了解为什么要进行硬盘分区：<br> a)    更容易管理和控制系统，因为相关的文件和目录都放在一个分区中。<br> b)    系统效率更高。<br> c)    可以限制用户使用硬盘的份额（磁盘空间的大小）。<br> d)    更容易备份和恢复。<br> 2)    掌握硬盘的逻辑结构：<br>一个硬盘逻辑上可以被划分成块、磁道、磁柱和分区。<br> 3)    掌握块的定义：块是盘片上寻址（访问）的最小单位，一个块可以存储一定字节的数据。<br> 4)    掌握磁道的定义：磁道是由一系列头尾相连的块组成的圆圈。<br> 5)    掌握磁柱的定义：磁柱是由一叠磁道，由在相同半径上每个盘面的磁道所组成。<br> 6)    掌握分区的定义：分区是由一组相邻的磁柱所组成。</li>
<li>Linux系统中硬盘的分区（详见linux系统管理P303）<br>1)    掌握硬盘分区的分类：硬盘的分区可以分为主分区、扩展分区和逻辑分区。<br>2)    掌握<strong>主分区的数量：在一个硬盘上最多可以划分出4个主分区。</strong><br>3)    了解Linux操作系统的内核支持每个硬盘上的分区数量还是有一定限制的，Linux内核在每个硬盘上可以最多支持：<br>a)    在SCSI硬盘上划分15个分区（Partitions）。<br>b)    在IDE硬盘上划分63个分区（Partitions）。</li>
<li>使用fdisk和partprobe命令来管理硬盘分区（详见linux系统管理P394）<br>1)    掌握fdisk命令的功能：创建磁盘分区。<br>2)    掌握fdisk命令列表中常用的命令：<br>a)    d：删除一个（已经存在的）分区，其中d是delete的第1个字母。<br>b)    l：列出（已经存在的）分区的类型，其中l是list的第1个字母。<br>c)    m：列出fdisk中使用的所有命令，其中m是menu的第1个字母。<br>d)    n：添加一个新的分区，其中n是new的第1个字母。<br>e)    p：列出分区表的内容，其中p是print的第1个字母。<br>f)    q：退出fdisk，但是不存储所做的变化，其中q是quit的第1个字母。<br>g)    t：改变分区系统的id，其中t是title的第1个字母。<br>h)    w：退出fdisk并存储所做的变化，其中w是write的第1个字母。<br>3)    掌握partprobe命令的功能：重新初始化内存中内核的分区表。</li>
<li>创建文件系统（数据的管理）（详见linux系统管理P399）<br>1)    掌握格式化的定义：所谓的格式化就是将分区中的硬盘空间划分成大小相等的一些数据块（Blocks），以及设定这个分区中有多少个i节点可以使用等。<br>2)    掌握文件系统的定义：文件系统是操作系统用于明确磁盘或分区上的文件的方法和数据结构；即在磁盘上组织文件的方法。<br>3)    了解常用的文件系统类型<br>ext2：Linux系统中标准的文件系统<br>ext3：一种日志式文件系统<br>ext4：一种针对ext3系统的扩展日志式文件系统<br>lvm：逻辑盘卷管理<br>iso9660：目前唯一通用的光盘文件系统<br>4)    掌握mkfs命令的功能：格式化磁盘。<br>5)    灵活应用常用的<strong>格式化命令</strong>：<br>mkfs.文件系统类型<br>例如，将分区/dev/sdb1格式化为ext4文件系统的命令为：<br><strong>mkfs.ext4 /dev/sdb1</strong></li>
<li>为一个分区设定label（分区名）（详见linux系统管理P405）<br>1)    掌握e2label命令的功能：设定或查看一个设备的label名称。<br>2)    灵活应用e2label命令设定label：<br>a)    例如：查看/dev/sdb1分区的label的命令为：<br>e2label /dev/sdb1<br>b)    例如：将/dev/sdb1分区的label设定为wg的命令：<br>e2label /dev/sdb1 wg</li>
</ol>
<ol>
<li>文件系统的挂载与卸载（详见linux系统管理P406）<br>1)    掌握挂载的定义：挂载指将一个设备（通常是存储设备）挂接到一个已存在的目录上。<br>2)    掌握mount命令的功能：实现文件系统的挂载。<br>3)    灵活应用mount命令实现文件系统的挂载：<br>例如：将/dev/sdb1分区挂载到/wg目录上的命令：<br>mount /dev/sdb1 /wg<br>4)    掌握umount命令的功能：实现文件系统的卸载。<br>5)    灵活应用umount命令实现文件系统的卸载：<br>例如：卸载/wg上的文件系统的命令：<br>umount /wg<ol>
<li>虚拟内存的概念以及设置与管理（详见linux系统管理P414）<br>1)    掌握虚拟内存的定义：所谓虚拟内存就是一块硬盘空间被当做内存使用，也被称为交换分区（swap）。<br>2)    了解Linux交换分区的类型为：0x82<br>3)    掌握mkswap命令的功能：设置交换分区。<br>4)    掌握使用mkswap命令设置交换分区的用法举例：<br>例如：将分区/dev/sdb2设置为交换分区的命令：mkswap /dev/sdb2<br>5)    掌握swapon命令的功能：启动交换分区。<br>6)    掌握swapon –a命令的功能：启动全部的交换分区。<br>7)    掌握swapon –s命令的功能：列出当前正在使用的所有系统交换分区的状态。<br>8)    掌握使用swapon命令的用法举例：<br>例如：启用交换分区/dev/sdb2的命令：swapon /dev/sdb2</li>
<li>i节点（详见linux系统管理P170）<br>1)    掌握i节点的定义：i节点实际上是一个数据结构，它存放了有关一个普通文件、目录或其他文件系统对象的基本信息。</li>
<li>符号（软）链接（详见linux系统管理P174）<br>1)    <strong>掌握符号链接的定义：符号链接是指向另一个文件的一个文件。</strong><br>2)    掌握ln命令创建软连接的用法举例：<br>a)    为wolf/dog.wolf.baby文件建立一个dog<em> wolf.boy符号链接并放在bodydog目录中的命令：<br>ln –s wolf/dog.wolf.baby bodydog/dog</em> wolf.boy</li>
<li>硬链接（详见linux系统管理P179）<br>1)    掌握硬链接的定义：<strong>一个硬链接（hard link）是一个文件名与一个i节点之间的对应关系</strong>，也可以认为一个硬链接是在所对应的文件上添加了一个额外的路径名。<br>2)    掌握ln命令创建硬连接的用法举例：<br>a)    为wolf/wolf.dog文件在backup目录中建立一个名为wolf.dog2的硬链接命令：<br>ln wolf/wolf.dog backup/wolf.dog2</li>
<li>Linux系统中的文件类型（详见linux系统管理P183）<br>1)    掌握Linux系统中常见的文件类型：<br>-：普通文件（regular file），也有人称为正规文件。<br>d:目录（directory）。<br>l：符号（软）链接。<br>b:块特殊文件（b是block的第1个字符），一般指块设备，如硬盘。<br>c:字符特殊文件（c是character的第1个字符），一般指字符设备，如键盘。</li>
<li>怎样检查磁盘空间（详见linux系统管理P185）<br>1)    掌握df命令的功能：<strong>显示文件系统中磁盘使用和空闲区的数量。</strong><br>-a 显示所有磁盘<br>-h 单位转换<br>2)    掌握du命令的功能： 显示目录和文件的大小a h同上</li>
</ol>
</li>
</ol>
<h3 id="十一-linux网络"><a href="#十一-linux网络" class="headerlink" title="十一.linux网络"></a>十一.linux网络</h3><ol>
<li>使用ifconfig命令来维护网络（详见linux系统管理P422）<br>1)    掌握ifconfig命令的功能：显示所有正在启动的网卡的详细信息或设定系统中网卡的IP地址。<br>2)    灵活应用ifconfig命令设定网卡的IP地址：<br>例如：修改eth0网卡的IP地址为172.18.48.56和子网掩码255.255.255.128的命令：<br>ifconfig eth0 172.18.48.56 netmask 255.255.255.128</li>
<li>使用ifup和ifdown命令启动和停止网卡（详见linux系统管理P424）<br>1)    掌握ifup命令的功能：启动系统上指定的网卡。<br>2)    掌握ifdown命令的功能：停止系统上指定的网卡。<br>3)    掌握使用ifup命令启用指定网卡的举例：<br>例如：启动eth0网卡的命令：ifup eth0<br>4)    掌握使用ifdown命令停用指定网卡的举例：<br>只能作用于配置文件<br>例如：停用eth0网卡的命令：ifdown eth0</li>
<li>网络配置文件 （详见linux系统管理P425）<br>1)    了解网卡的配置文件存放在/etc/sysconfig/network-scripts目录中，且每个网卡对应的配置文件的文件名以ifcfg-开始，如eth0这个网卡对应的网络配置文件就是ifcfg-eth0。<br>补：虚拟机新添加网卡没有配置文件需手动添加配置或图形添加网卡<br>λ    掌握网络配置的定义：所谓的网络配置（设定）就是要修改网卡所对应的网络配置文件，可以通过使用文字编辑器（vi）直接编辑网络配置文件来重新配置网络。</li>
</ol>
<h3 id="十二-软件包管理"><a href="#十二-软件包管理" class="headerlink" title="十二.软件包管理"></a>十二.软件包管理</h3><ol>
<li>使用RPM安装及移除软件（详见linux系统管理P374）<br>1)    掌握RPM的定义：RPM就是Red Hat Package Manger（红帽软件包管理工具）的缩写。<br>2)    了解rpm的文件名分为5部分，其中：<br>第1部分是name，表示这个rpm软件包的名称；<br>第2部分是version，表示这个rpm软件包的版本编号；<br>第3部分是release，表示这个rpm软件包的版本发布次数（修正号码）；<br>第4部分是architectures，表示这个rpm软件包适用于哪些平台；<br>最后一部分是rpm，表示这个rpm软件包的文件扩展名。<br>3)    掌握rpm软件安装与移除工作中经常使用的选项：<br>a)    –i：安装（Install）软件。<br>b)    –U：升级（Upgrade）旧版本的软件。<br>c)    –e：移除/删除（Erase）软件。<br>d)    –v：显示详细的处理信息。<br>e)    –h：显示安装进度。卸载不能用</li>
<li>查看RPM软件包中的信息（详见linux系统管理P379）<br>1)    掌握常用的查询已安装的软件包信息的命令：<br>a)    rpm –qa：显示目前操作系统上安装的全部软件包，其中q是query（查询）的第1个字母，a是all（全部）的第1个字母。<br>Rpm –qa | grep dhcp<br>b)    rpm –qf 文件名：显示这个文件是由哪个软件包安装的，f是file（文件）的第1个字母。<br>例如：列出安装/bin/tar文件的软件包的命令为：rpm –qf /bin/tar<br>c)    rpm –qi 软件包名：显示这个软件包的信息，i是information（信息）的第1个字母。<br>例如：列出tar-1.14-10.RHEL4这个软件包的详细信息的命令：rpm –qi tar-1.14-10.RHEL4<br>d)    rpm –ql 软件包名：列出这个软件包中所包含的全部文件，其中l是list的第1个字母。<br>例如：列出tar-1.14-10.RHEL4这个软件包中所包含的全部文件的命令：rpm –ql tar<br>p数据包</li>
<li>RPM包的属性依赖性问题（详见linux系统管理P388）<br>1)    掌握RPM软件包的属性依赖性问题的定义：所谓的RPM软件包的属性依赖性问题，即这个软件包的安装依赖于其他软件包的安装。</li>
</ol>
<ol>
<li>yum的功能：yum是Yellow dog Updater, Modified的缩写，目的就是为了解决RPM的依赖关系的问题，方便使用者进行软件的安装、升级等等工作。</li>
<li>掌握光盘挂载和镜像挂载<br>a)    光盘挂载<br>mount /dev/sr0 挂载点<br>或者<br>mount /dev/cdrom 挂载点<br>b)    镜像文件的挂载<br>mount -o loop -t iso9660 镜像文件 挂载点<br>其中，-o loop：用来把一个文件当成硬盘分区挂接上系统</li>
<li>掌握yum的配置<br>yum的配置一般有两种方式，一种是直接配置/etc目录下的yum.conf文件，另外一种是在/etc/yum.repos.d目录下增加.repo文件。</li>
<li>掌握本地yum配置<br>[root@localhost ~]# mount /dev/cdrom /mnt #挂载光盘到/mnt目录<br>[root@localhost ~]# cd /etc/yum.repos.d/<br>[root@localhost yum.repos.d]# ls<br>rhel-source.repo<br>[root@localhost yum.repos.d]# cp rhel-source.repo rhel.repo #拷贝一份配置文件<br>[root@localhost yum.repos.d]# vi rhel.repo #编辑配置文件如下[rhel-local] #模块名称，须修改不能与其他.repo文件中的重名name=Red Hat Enterprise Linux 6 local repo #名称随便起baseurl=file:///mnt #指定rpm仓库的位置<br>enabled=1 #1开启该配置，0为关闭<br>gpgcheck=1 #1为校对软件<br>[root@localhost ~]# yum install vsftpd httpd #安装vsftpd及httpd服务</li>
<li>掌握远程yum配置方法</li>
<li>利用vsftpd搭建yum源服务器：<br>Vsftpd默认的配置文件是允许匿名访问，这里直接启动就可以了：<br>[root@localhost ~]# umount /dev/cdrom #卸载光盘<br>[root@localhost ~]# mount /dev/cdrom /var/ftp/pub/ #挂载光盘到vsftpd的公众目录<br>[root@localhost ~]# service vsftpd restart #重启vsftpd服务<br>必须关闭防火墙和selinux<br>Service iptables stop<br>Getenforce :查看selinux状态<br>临时关闭：不用重启：setenforce 0<br>0 permissive允许 1 enforcing 执行</li>
</ol>
<p>配置客户机：<br>[root@localhost ~]# cd /etc/yum.repos.d/<br>[root@localhost yum.repos.d]# ls #rhel.repo是按照本地yum配置生成的<br>rhel.repo rhel-source.repo<br>[root@localhost yum.repos.d]# cat rhel.repo #修改为以下内容<br>[rhel-ftp]<br>name=Red Hat Enterprise Linux 6<br>baseurl=ftp://192.168.8.42/pub #指定yum源地址<br>enabled=1<br>gpgcheck=1<br>测试：<br>[root@localhost ~]# yum install bind #安装DNS服务</p>
<ol>
<li>掌握使用yum安装软件<br>yum –y install 软件名</li>
<li>掌握使用yum删除软件<br>yum –y remove 软件名</li>
<li>掌握使用yum安装组件<br>yum –y groupinstall 组件名</li>
<li>掌握使用yum删除组件<br>yum –y groupremove 组件名</li>
<li>掌握清除yum缓存<br>yum clean all</li>
<li>使用yum查找软件包<br>yum search</li>
</ol>
<h3 id="十三-samba服务"><a href="#十三-samba服务" class="headerlink" title="十三.samba服务"></a>十三.samba服务</h3><ol>
<li>掌握samba的功能： samba是一个网络服务器，用于Linux和Windows之间共享文件。</li>
<li>掌握samba服务的启动、停止、重启<br>service smb start|stop|restart</li>
<li>掌握samba的主配置文件为：/etc/samba/smb.conf</li>
<li>掌握配置samba服务</li>
</ol>
<p>注意：</p>
<p>1 客户端要对目录是否有权限，必须samba软件放权+系统放权</p>
<p>2 每个用户的访问方式是：\服务端ip\用户名，默认访问自己的家目录（该用户对该目录有w权限，且samba对用户的家目录开启了writeable=yes的权限）</p>
<p>3 对于共享的目录，是所有人打开目录进行操作的，而不是一个打印机，所以printable一定要设置no</p>
<p>4 writeable=yes代表对所有用户放行了写权限，write list=user1,user2无效，因为放行的所有用户中已然包含user1和user2</p>
<p>5 writeable=no，write list=user1,user2代表所有人都没有写权限，唯独user1和user2有</p>
<p><img src="image/1036857-20161109125128077-1610180483.png" alt="img"></p>
<p>comment = ……   设置共享注译<br>path =    设置共享目录的物理路径<br>valid users = @组名,用户名   设置允许哪些合法组或用户访问<br>public = yes|no  设置共享资源是否能给游客帐号访问<br>browseable = yes|no  设置该共享为隐藏共享<br>writable = yes|no 设置是否允许客户端写入数据<br>hosts allow =  设置允许访问该共享的合法网段或IP<br>samba安全认证掌握两种：share （匿名访问）user：用户名密码<br>添加smb用户和设置密码：smbpasswd –a 用户<br>Useradd u</p>
<ol>
<li>掌握windows客户端的访问方式</li>
</ol>
<p><img src="image/1036857-20161109125221061-1760008764.png" alt="img"></p>
<p>6.掌握Linux客户端的访问方式</p>
<p><img src="image/1036857-20161109125337374-1770454035.png" alt="img"></p>
<p><img src="image/1036857-20161109125345139-186084377.png" alt="img"></p>
<h3 id="十四-NFS服务"><a href="#十四-NFS服务" class="headerlink" title="十四.NFS服务"></a>十四.NFS服务</h3><h3 id="十五-计划任务crond服务"><a href="#十五-计划任务crond服务" class="headerlink" title="十五.计划任务crond服务"></a>十五.计划任务crond服务</h3><p><strong>什么是计划任务：</strong><br>后台运行，到了预定的时间就会自动执行的任务，前提是：事先手动将计划任务设定好。这就用到了crond服务</p>
<p><strong>crond服务相关的软件包</strong><br>[root@MiWiFi-R3-srv ~]# rpm -qa |grep cron<br>cronie-anacron-1.4.11-14.el7.x86_64<br>crontabs-1.11-6.20121102git.el7.noarch<br>cronie-1.4.11-14.el7.x86_64</p>
<p>这些包在最小化安装系统时就已经安装了，并且会开机自启动crond服务，并为我们提供好编写计划任务的crontab命令。</p>
<p><strong>计划任务分为两类：系统级和用户级</strong></p>
<p>首先需要知道的是，无论是系统级还是用户级的cron计划都是文本文件，系统的计划文件存放在/etc/crontab路径下。用户的计划文件放在/var/spool/cron/用户名,不管是哪一种，都可以满足我们定制计划任务的需求。</p>
<p>root用户可以直接对文件进行修改来编写计划任务也可以使用 crontab -e命令，而普通用户只能使用后者。除此之外，系统crontab文件中任务的定义也有所不同，在前五个部分之后插入了一个“用户”部分。</p>
<p>[root@MiWiFi-R3-srv ~]# cat /etc/crontab #查看全局计划任务<br>SHELL=/bin/bash<br>PATH=/sbin:/bin:/usr/sbin:/usr/bin<br>MAILTO=root</p>
<p># For details see man 4 crontabs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># | .------------- hour (0 - 23)</span><br><span class="line"># | | .---------- day of month (1 - 31)</span><br><span class="line"># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># | | | | .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># | | | | |</span><br><span class="line"># * * * * * user-name command to be executed</span><br><span class="line"></span><br><span class="line">* * * * * root run-parts &#x2F;test #run-parts命令，可以执行一个目录下所有的可执行文件，目录下文件必须有执行权限</span><br><span class="line"></span><br><span class="line">You have new mail in &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@MiWiFi-R3-srv ~]# crontab -u tom -l #通过命令查看用户tom的计划任务</span><br><span class="line">*&#x2F;1 * * * * echo 123213123213</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@MiWiFi-R3-srv ~]# cat &#x2F;var&#x2F;spool&#x2F;cron&#x2F;tom #从文件中查看用户tom的计划任务</span><br><span class="line">*&#x2F;1 * * * * echo 123213123213</span><br></pre></td></tr></table></figure>
<p><strong>crontab命令编写计划任务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语　　法：crontab [-u &lt;用户名称&gt;][配置文件] 或 crontab [-u &lt;用户名称&gt;][-elr]</span><br></pre></td></tr></table></figure>
<p>crontab任务配置基本格式：<br>*  <em>　 </em>　 <em>　 </em>　　command<br>分钟(0-59)　小时(0-23)　日期(1-31)　月份(1-12)　星期(0-6,0代表星期天)　 命令</p>
<p>第1列表示分钟1～59 每分钟用<em>或者 </em>/1表示<br>第2列表示小时1～23（0表示0点）<br>第3列表示日期1～31<br>第4列表示月份1～12<br>第5列标识号星期0～6（0表示星期天）<br>第6列要运行的命令</p>
<p>参　　数：<br>-e 　编辑该用户的计时器设置。<br>-l 　列出该用户的计时器设置。<br>-r 　删除该用户的计时器设置。<br>-u&lt;用户名称&gt; 　指定要设定计时器的用户名称。</p>
<p>注意：</p>
<p>1 查看计划任务的执行：tail -f /var/log/cron</p>
<p>2 写计划任务时，命令必须加上绝对路径，否则会出现这种情况：从日志中看，确实触发了计划任务的执行，但是命令却没有执行成功，比如<em> </em> <em> </em> * reboot就会出现这种情况，需要将reboot写成/usr/sbin/reboot</p>
<p>crontab例子：</p>
<p>30 21 <em> </em> * /usr/local/etc/rc.d/apache restart #每晚的21:30 重启apache</p>
<p>45 4 1,10,22 <em> </em> /usr/local/etc/rc.d/apache restart #每月1、10、22日的4 : 45重启apache</p>
<p>10 1 <em> </em> 6,0 /usr/local/etc/rc.d/apache restart #每周六、周日的1 : 10重启apache</p>
<p>0,30 18-23 <em> </em> * /usr/local/etc/rc.d/apache restart #每天18 : 00至23 : 00之间每隔30分钟重启apache</p>
<p>0 23 <em> </em> 6 /usr/local/etc/rc.d/apache restart #每星期六的11 : 00 pm重启apache</p>
<p>* 23-7/1 <em> </em> * /usr/local/etc/rc.d/apache restart #晚上11点到早上7点之间，每隔一个小时的每分钟重启 apache</p>
<p>0 <em>/1 </em> <em> </em> /usr/local/etc/rc.d/apache restart #每一小时重启apache</p>
<p>0 11 4 * mon-wed /usr/local/etc/rc.d/apache restart #每月的4号与每周一到周三的11点重启apache</p>
<p>0 4 1 jan * /usr/local/etc/rc.d/apache restart #一月一号的4点重启apache</p>
<p><em>/30 </em> <em> </em> * /usr/sbin/ntpdate 210.72.145.44 #每半小时同步一下时间</p>
<p>0 <em>/2 </em> <em> </em> www /usr/bin/somecommand &gt;&gt; /dev/null 2&gt;&amp;1 #以用户www的身份每两小时就运行某个程序：</p>
<p>0 1 <em> </em> * /home/testuser/test.sh #每天1点调用/home/testuser/test.sh</p>
<p><em>/10 </em> <em> </em> * /home/testuser/test.sh #每10钟调用一次/home/testuser/test.sh</p>
<p>30 21 <em> </em> * /usr/local/etc/rc.d/lighttpd restart #每天的21:30重启lighttpd</p>
<p>45 4 1,10,22 <em> </em> /usr/local/etc/rc.d/lighttpd restart #每月1、10、22日的4 : 45重启lighttpd</p>
<p><em>10 1 \</em> <em> 6,0 /usr/local/etc/rc.d/lighttpd restart #每周六、周日的1 : 10重启lighttpd</em></p>
<p>0,30 18-23 <em> </em> * /usr/local/etc/rc.d/lighttpd restart #上面的例子表示在每天18 : 00至23 : 00之间每隔30分钟重启apache。</p>
<p>0 23 <em> </em> 6 /usr/local/etc/rc.d/lighttpd restart #上面的例子表示每星期六的11 : 00 pm重启lighttpd</p>
<p>* <em>/2 </em> <em> </em> /usr/local/etc/rc.d/lighttpd restart #每两小时的每分钟重启lighttpd</p>
<p>0 23-7/1 <em> </em> * /usr/local/etc/rc.d/lighttpd restart #晚上11点到早上7点之间，每隔一小时重启lighttpd</p>
<p>0 11 4 * mon-wed /usr/local/etc/rc.d/lighttpd restart #每月的4号与每周一到周三的11点重启lighttpd</p>
<p>0 4 1 jan * /usr/local/etc/rc.d/lighttpd restart #一月一号的4点重启lighttpd</p>
<p><em>/30 </em> <em> </em> * /usr/sbin/ntpdate 210.72.145.44 #每半小时同步一下时间</p>
<p><strong>对于一些常见的时间格式可以用如@yearly的方式代替</strong></p>
<p>@reboot 代表的意思Run once, at startup.<br>@yearly 代表的意思Run once a year, “0 0 1 1 <em>“.<br>@annually 与@yearly相同意思<br>@monthly 代表的意思Run once a month, “0 0 1 </em> <em>“.<br>@weekly 代表的意思Run once a week, “0 0 </em> <em> 0”.<br>@daily 代表的意思Run once a day, “0 0 </em> <em> </em>“.<br>@midnight 与@daily的意思相同<br>@hourly 代表的意思Run once an hour, “0 <em> </em> <em> </em>“.<br><strong>除此之外，系统还有一些自带的计划任务</strong></p>
<p>cron默认配置了调度任务，分别为：hourly、daily、weekly、mouthly，默认配置文件为/etc/anacrontab</p>
<p>将需要执行的脚本放到相应的目录下即可，目录分别为：</p>
<p>/etc/cron.hourly</p>
<p>/etc/cron.daily</p>
<p>/etc/cron.weekly</p>
<p>/ect/cron.mouthly</p>
<p><strong>查看cron服务是否起作用：</strong></p>
<p>如果我们要查看定时任务是否准时调用了可以/var/log/cron中的运行信息</p>
<p>cat /var/log/cron</p>
<p>也可以用tail -f /var/spool/mail/用户名，来查看普通用户的计划任务执行情况</p>
<p>此处需要记住两点：</p>
<p><strong>第一：cron 守护进程每分钟都检查 /etc/crontab 文件、etc/cron.d/ 目录、以及 /var/spool/cron 目录中的改变。如果发现了改变，它们就会被载入内存。这样，当某个 crontab 文件改变后就不必重新启动守护进程了。</strong></p>
<p><strong>第二：crontab的用户手册中推荐每一个命令使用绝对路径，例如调用rm命令时写作：/bin/rm，这是为了防止由于每一个用户的PATH环境变量不同而导致命令无法找到的错误。</strong></p>
<p><strong>网上查询到的资料crontab不执行的问题：</strong></p>
<p>转自：<a href="http://blog.csdn.net/jbgtwang/article/details/7995801" target="_blank" rel="noopener">http://blog.csdn.net/jbgtwang/article/details/7995801</a></p>
<p>第一，脚本的原因：大多数情况下，我们要相信科学，相信计算机，不是有鬼，就是我们的脚本的问题，这种问题导致crontab不能执行的概率占到 70%以上。因为程序执行到某一步导致crontab终止执行，我就碰到一次在迁移代码的时候将数据库连错了。导致无法访问而死在那里了。</p>
<p>第二，执行环境问题，当我们碰到第一情况下，一般都可以通过手动执行程序将问题扼杀在摇篮里，一般情况下高手是不应该犯第一种错误的。问题是当我们 手动执行成功而crontab不能执行的时候，笔者碰到一次就是执行环境的问题，例如相关路径的设置问题。解决方案：在代码最前面执行 source /home/user/.bash_profile</p>
<p>第三，系统时间不正确。这种问题最好理解，也是比较常见和隐蔽的问题，解决方案：date -s <strong><em>**</em></strong></p>
<p>第四，就是我们的脚本是否有可执行权限。必须保证执行脚本的用户有执行改文件的权限。</p>
<p>第五，crontab 守护进程死掉了。这种情况是极少发生的，但也不排除，当我们实在是找不到其他原因的时候可以用。解决方案：重启该进程。</p>
<p>第六，crontab不执行的问题困扰了好长时间，脚本写的都正确，但是就是不执行，最终解决方法如下：<br>crontab -u root /var/spool/cron/root<br>这样root用户的crontab就生效了<br>service crond restart<br>重启下服务就好了</p>
<p>第七，crond没有启动</p>
<p>第八，脚本编码问题，脚本在window下编写，传到linux下后报“锘?!/bin/bash”，用vi编辑器新建新shell脚本，输入内容后保存。</p>
<p>第九</p>
<p><strong><em> \</em> * * * tar czf /tmp/<code>date &#39;+%Y&#39;</code> /etc 该计划任务中命令的执行流程是crond-&gt;tar命令，而crond在执行tar命令时，无法识别通配符%的意思（shell能识别），所以该命令无法正常执行</strong></p>
<p><strong>改正结果：* * * * * tar czf /tmp/<code>date &#39;+\%Y&#39;</code> /etc</strong></p>
<p><strong>通常都会把要执行的操作放到文件中，然后/bin/bash a.sh去执行，* * *</strong> <em> **</em> /bin/bash a.sh  ，这样的执行流程就变成了crond-&gt;bash shell-&gt;a.sh,这样a.sh内即便是写%号，也能被识别出来**</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/2020/06/29/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="零零"><a href="#零零" class="headerlink" title="零零"></a>零零</h2><a id="more"></a>
<h3 id="小东西"><a href="#小东西" class="headerlink" title="小东西"></a>小东西</h3><h4 id="星号的作用"><a href="#星号的作用" class="headerlink" title="星号的作用"></a>星号的作用</h4><p>传递实参和定义形参（所谓实参就是调用函数时传入的参数，形参则是定义函数是定义的参数）的时候，你还可以使用两个特殊的语法：<em>、*</em> 。</p>
<p><strong>调用函数时</strong>使用<em> ，*</em></p>
<p>test(<em>args)中 </em> 的作用：其实就是把序列 args 中的每个元素，当作位置参数传进去。比如上面这个代码，如果 args 等于 (1,2,3) ，那么这个代码就等价于 test(1, 2, 3) 。</p>
<p>test(**kwargs)中 的作用：则是把字典 kwargs 变成关键字参数传递。比如上面这个代码，如果 kwargs 等于 {‘a’:1,’b’:2,’c’:3} ，那这个代码就等价于 test(a=1,b=2,c=3) 。</p>
<p><strong>定义函数参数时</strong>使用<em> 、*</em></p>
<p>def test(<em>args):<br>    …定义函数参数时 </em> 的含义又要有所不同，在这里 *args 表示把传进来的位置参数都装在元组 args 里面。比如说上面这个函数，调用 test(1, 2, 3) 的话， args 的值就是 (1, 2, 3) 。:</p>
<p>def test(**kwargs):<br>    …类似的，  就是针对关键字参数和字典的了。 调用 test(a=1,b=2,c=3) 的话， kwargs 的值就是 {‘a’:1,’b’:2,’c’:3} 了。</p>
<p>普通的参数定义和传递方式和 <em> 们都可以和平共处，不过显然 </em> 必须放在所有位置参数的最后，而 ** 则必须放在所有关键字参数的最后，否则就要产生歧义了。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#exec：三个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数一：包含一系列python代码的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数二：全局作用域（字典形式），如果不指定，默认为globals()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数三：局部作用域（字典形式），如果不指定，默认为locals()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以把exec命令的执行当成是一个函数的执行，会将执行期间产生的名字存放于局部名称空间中</span></span><br><span class="line">g=&#123;</span><br><span class="line">    <span class="string">'x'</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">'y'</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">l=&#123;&#125;</span><br><span class="line"></span><br><span class="line">exec(<span class="string">'''</span></span><br><span class="line"><span class="string">global x,z</span></span><br><span class="line"><span class="string">x=100</span></span><br><span class="line"><span class="string">z=200</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">m=300</span></span><br><span class="line"><span class="string">'''</span>,g,l)</span><br><span class="line"></span><br><span class="line">print(g) <span class="comment">#&#123;'x': 100, 'y': 2,'z':200,......&#125;</span></span><br><span class="line">print(l) <span class="comment">#&#123;'m': 300&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串编码方式"><a href="#字符串编码方式" class="headerlink" title="字符串编码方式"></a>字符串编码方式</h4><ul>
<li>ASCII：8位二进制数，第一位为0，有128个符号</li>
<li>Unicode：有许多种不同的二进制格式，可以用来表示 Unicode</li>
<li>UTF-8：是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<ul>
<li>对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</li>
<li>对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</li>
</ul>
</li>
</ul>
<h4 id="字符串前的urb字母"><a href="#字符串前的urb字母" class="headerlink" title="字符串前的urb字母"></a>字符串前的urb字母</h4><p>u/U:表示unicode字符串<br>不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。<br>一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。<br>建议所有编码方式采用utf8</p>
<p>r/R:非转义的原始字符串<br>与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。<br>以r开头的字符，常用于正则表达式，对应着re模块。</p>
<p>b:bytes<br>python3.x里默认的str是(py2.x里的)unicode, bytes是(py2.x)的str, b”“前缀代表的就是bytes </p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l.pop(<span class="number">2</span>)  按照索引删除</span><br><span class="line">l.remove(<span class="number">2</span>)  按照值删除</span><br></pre></td></tr></table></figure>
<h4 id="深拷贝，浅拷贝"><a href="#深拷贝，浅拷贝" class="headerlink" title="深拷贝，浅拷贝"></a>深拷贝，浅拷贝</h4><p><a href="https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html</a></p>
<ul>
<li><strong>直接赋值：</strong>其实就是对象的引用（别名）。</li>
<li><strong>浅拷贝(copy)：</strong>拷贝父对象，不会拷贝对象的内部的子对象。</li>
<li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li>
</ul>
<h5 id="字典浅拷贝实例"><a href="#字典浅拷贝实例" class="headerlink" title="字典浅拷贝实例"></a>字典浅拷贝实例</h5><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><blockquote>
<blockquote>
<blockquote>
<p>a = {1: [1,2,3]}<br>b = a.copy()<br>a, b<br>({1: [1, 2, 3]}, {1: [1, 2, 3]})<br>a[1].append(4)<br>a, b<br>({1: [1, 2, 3, 4]}, {1: [1, 2, 3, 4]})</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>深度拷贝需要引入 copy 模块：</strong></p>
<h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><blockquote>
<blockquote>
<blockquote>
<p>import copy<br>c = copy.deepcopy(a)<br>a, c<br>({1: [1, 2, 3, 4]}, {1: [1, 2, 3, 4]})<br>a[1].append(5)<br>a, c<br>({1: [1, 2, 3, 4, 5]}, {1: [1, 2, 3, 4]})</p>
</blockquote>
</blockquote>
</blockquote>
<h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p>1、<strong>b = a:</strong> 赋值引用，a 和 b 都指向同一个对象。</p>
<p><img src="image/1489720931-7116-4AQC6.png" alt="img"></p>
<p><strong>2、b = a.copy():</strong> 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。</p>
<p><img src="image/1489720930-6827-Vtk4m.png" alt="img"></p>
<p><strong>b = copy.deepcopy(a):</strong> 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。</p>
<p><img src="image/1489720930-5882-BO4qO.png" alt="img"></p>
<h5 id="更多实例"><a href="#更多实例" class="headerlink" title="更多实例"></a>更多实例</h5><p>以下实例是使用 copy 模块的 copy.copy（ 浅拷贝 ）和（copy.deepcopy ）:</p>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*-coding:utf-8 -*-   </span></span><br><span class="line"><span class="keyword">import</span> copy </span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]] <span class="comment">#原始对象   </span></span><br><span class="line">b = a                       <span class="comment">#赋值，传对象的引用 </span></span><br><span class="line">c = copy.copy(a)            <span class="comment">#对象拷贝，浅拷贝 </span></span><br><span class="line">d = copy.deepcopy(a)        <span class="comment">#对象拷贝，深拷贝   </span></span><br><span class="line">a.append(<span class="number">5</span>)                 <span class="comment">#修改对象a </span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)            <span class="comment">#修改对象a中的['a', 'b']数组对象   </span></span><br><span class="line">print( <span class="string">'a = '</span>, a ) </span><br><span class="line">print( <span class="string">'b = '</span>, b ) </span><br><span class="line">print( <span class="string">'c = '</span>, c ) </span><br><span class="line">print( <span class="string">'d = '</span>, d )</span><br></pre></td></tr></table></figure>
<p>以上实例执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#39;a &#x3D; &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5])</span><br><span class="line">(&#39;b &#x3D; &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5])</span><br><span class="line">(&#39;c &#x3D; &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]])</span><br><span class="line">(&#39;d &#x3D; &#39;, [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]])</span><br></pre></td></tr></table></figure>
<h4 id="字典循环"><a href="#字典循环" class="headerlink" title="字典循环"></a>字典循环</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h4 id="print颜色"><a href="#print颜色" class="headerlink" title="print颜色"></a>print颜色</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'\033[32;1mcontent\033[0m'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="类设置属性"><a href="#类设置属性" class="headerlink" title="类设置属性"></a>类设置属性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setattr(obj,key,value)</span><br><span class="line">obj.__dict__[key] = value</span><br></pre></td></tr></table></figure>
<h2 id="零、文件"><a href="#零、文件" class="headerlink" title="零、文件"></a>零、文件</h2><p><a href="https://blog.51cto.com/pmghong/1349978" target="_blank" rel="noopener">文件读写</a></p>
<p>一读一写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(file1,<span class="string">'r'</span>) <span class="keyword">as</span> x, open(file2, <span class="string">'w'</span>) <span class="keyword">as</span> y:</span><br><span class="line">    y.write(x.read())</span><br></pre></td></tr></table></figure>
<p>有文件句柄，写完文件之后一定要close()</p>
<p>如果直接config.write(open(‘1.txt’,’w’))不用close</p>
<p>文件操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">os.remove(path)   <span class="comment">#删除文件</span></span><br><span class="line">os.removedirs(path)   <span class="comment">#删除空文件夹</span></span><br><span class="line">shutil.rmtree(path)    <span class="comment">#递归删除文件夹</span></span><br></pre></td></tr></table></figure>
<p>shutil</p>
<p><a href="https://blog.csdn.net/qq_38640439/article/details/81410116" target="_blank" rel="noopener">python 中使用 shutil 实现文件或目录的复制、删除、移动</a></p>
<h2 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h2><p>global x 全局<br>nonlocal x上一级的x</p>
<h3 id="1、匿名函数"><a href="#1、匿名函数" class="headerlink" title="1、匿名函数"></a>1、匿名函数</h3><p> lambda函数用完即在内存中删除。<br>  lambda x: x+1<br>   lambda &lt;参数&gt;：&lt;返回值&gt;<br>   lambda只能有一个返回值</p>
<p><strong>应用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func &#x3D; lambda x: x+1</span><br><span class="line">func(10)</span><br></pre></td></tr></table></figure>
<h3 id="2-函数尾调用"><a href="#2-函数尾调用" class="headerlink" title="2.函数尾调用"></a>2.函数尾调用</h3><p>在函数执行的最后一步调用另一个函数。<br><strong>尾递归调用优化：</strong><br>在函数调用的最后一步进行递归调用</p>
<h3 id="3-高阶函数"><a href="#3-高阶函数" class="headerlink" title="3.高阶函数"></a>3.高阶函数</h3><p>高阶函数：函数的传入参数/返回值是一个函数名<br>（1）map函数<br>依次处理列表中的每一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test(func, args):</span><br><span class="line">	ret  &#x3D; []</span><br><span class="line">	for i in args:</span><br><span class="line">		ret.append(func(args))</span><br><span class="line">	return ret</span><br><span class="line">test(lambda x:x+1, args)</span><br></pre></td></tr></table></figure>
<p>map的第一个参数为函数对象（匿名函数或函数名均可），第二个参数为可迭代对象，返回结果为一个list，迭代器，只能迭代一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res &#x3D; map(lambda x:x+1, num_l)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<p>（2）filter函数<br>获取符合条件的数据，返回值为True的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res &#x3D; filter(lambda x:x.endswith(&#39;sb&#39;), num_l)</span><br></pre></td></tr></table></figure>
<p>（3）reduce函数<br>将整体的数据进行压缩(处理一个序列，对序列进行合并操作)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">reduce(lambda x,y:x*y,num_list)</span><br><span class="line">reduce(lambda x,y:x*y,num_list, start_num)</span><br></pre></td></tr></table></figure>
<h3 id="4-内置函数"><a href="#4-内置函数" class="headerlink" title="4.内置函数"></a>4.内置函数</h3><p><img src="./image/1.png" alt=""></p>
<p>eval()提取字符串中的数据结构<br>可hash的即为不可变数据类型<br>zip()拉链 将两个序列组成元组序列。如果两个序列长度不等，则根据最小长度的序列进行返回。<br>max()可以指定方法<br>list = [{‘name’:’xx’,’age’:30},{‘name’:’yy’,’age’:34}]<br>max(list,key= lambda dict: dict[‘age’])<br>pow(x,y) → x,y<br>pow(x,y,z)  → x**y%z<br>s1 = slice(1,5,2) l = [1,2,3,4,5]  l[s1]<br>sorted(list,key = lambda x:dic[x])</p>
<p>模块就是一个.py文件<br>导入字符串类型的模块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">module_name = <span class="string">'test'</span></span><br><span class="line">m = __import__(module_name)</span><br><span class="line">m.sayhi()</span><br></pre></td></tr></table></figure>
<h2 id="二、文件处理"><a href="#二、文件处理" class="headerlink" title="二、文件处理"></a>二、文件处理</h2><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(file_name,encoding = <span class="string">'utf-8'</span>,<span class="string">'w'</span>) <span class="comment">#根据操作系统的文件编码方式决定 win：gbk mac:utf-8 </span></span><br><span class="line">f.read() <span class="comment">#读取所有的文件内容</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h3 id="2-打开方式"><a href="#2-打开方式" class="headerlink" title="2.打开方式"></a>2.打开方式</h3><p>w写，r读，a追加(默认以文本方式打开，即wt，rt，at)</p>
<p><strong>读</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.read() <span class="comment">#读取所有的文件内容</span></span><br><span class="line">f.readable()  <span class="comment">#判断是否可读</span></span><br><span class="line">f.readline()  <span class="comment">#读取一行</span></span><br><span class="line">f.readlines()	<span class="comment">#读取所有行，放在一个列表中</span></span><br></pre></td></tr></table></figure>
<p><strong>写</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#'w'模式，无论文件是否存在，新建空文件，进行写操作</span></span><br><span class="line"><span class="comment">#写的参数必须是字符串类型</span></span><br><span class="line">f.write(<span class="string">'text\n'</span>)</span><br><span class="line">f.writelines([<span class="string">'text\n'</span>,<span class="string">'text2\n'</span>])</span><br></pre></td></tr></table></figure>
<p>+标识可以同时读写 ，使用：w+,r+,a+均可，均为读写<br>文件没有修改的说法，都是将数据进行覆盖。</p>
<p><strong>使用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(file_name,<span class="string">'w'</span>,newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment">#newline=''读取文件真正的换行符号</span></span><br><span class="line">    <span class="comment">#使用with打开文件不需要进行close()操作</span></span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure>
<p>linux中读取文件，vim将文件读取到内存中进行操作，cat不读取到内存中<br><strong>b模式</strong><br>以字节的模型对文件进行操作，不能指定编码方式<br>可用：wb,rb,ab,w+b,r+b,a+b<br>win平台的回车\r\n</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.write(bytes(<span class="string">'xx'</span>,encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">f.write(<span class="string">'xx'</span>.encoding(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<p><strong>其他操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.flush() <span class="comment">#刷新，将内存中的东西写入到文件中</span></span><br><span class="line">f.read(<span class="number">4</span>) <span class="comment">#读取4个字符</span></span><br><span class="line">f.tell() <span class="comment">#光标当前所在的位置（除了read()方法，其余方法以byte为单位）</span></span><br><span class="line">f.seek(<span class="number">1</span>) <span class="comment">#控制光标的移动</span></span><br><span class="line">f.truncate(<span class="number">10</span>) <span class="comment">#截取，留下源文件的前10个bytes</span></span><br></pre></td></tr></table></figure>
<p><strong>seek的高级操作</strong></p>
<p>基于相对位置的seek</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.seek(<span class="number">10</span>,<span class="number">0</span>) <span class="comment">#0：（默认模式）相对于文件开头</span></span><br><span class="line">f.seek(<span class="number">10</span>,<span class="number">1</span>) <span class="comment">#1：相对于上一次的光标位置</span></span><br><span class="line">f.seek(<span class="number">-10</span>,<span class="number">2</span>) <span class="comment">#2：从文件末尾开始seek，第一个参数应该为负数（日志文件中使用）</span></span><br></pre></td></tr></table></figure>
<p>日志文件的读取（读取文件最后一行）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    offs = <span class="number">-10</span> <span class="comment">#偏移量的估算</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f.seek(offs,<span class="number">2</span>)</span><br><span class="line">        data = f.readlines()</span><br><span class="line">        <span class="keyword">if</span> len(data)&gt;<span class="number">1</span>:</span><br><span class="line">            print(<span class="string">'文件的最后一行是&#123;&#125;'</span>.format(data[<span class="number">-1</span>].decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        offs*=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>循环文件的推荐方式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一行一行的获取</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<h2 id="三-迭代器协议"><a href="#三-迭代器协议" class="headerlink" title="三.迭代器协议"></a>三.迭代器协议</h2><p><a href="http://www.cnblogs.com/linhaifeng/articles/7580428.html" target="_blank" rel="noopener">林海峰博客</a></p>
<h3 id="1-迭代器协议"><a href="#1-迭代器协议" class="headerlink" title="1.迭代器协议"></a>1.迭代器协议</h3><p>迭代器协议：对象必须提供一个next方法，执行该方法要么返回迭代器中的下一项，要么就引起一个Stopiteration异常，以终止迭代（只能往后，不能往前）</p>
<p>可迭代对象：实现了迭代器协议的对象（实现方法：对象内部定义一个__iter__()方法）</p>
<p>迭代器运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">next(t)</span><br><span class="line">t.__next__()</span><br></pre></td></tr></table></figure>
<h3 id="2-for循环机制"><a href="#2-for循环机制" class="headerlink" title="2.for循环机制"></a>2.for循环机制</h3><p>for循环的工作原理<br>1：执行in后对象的dic.__iter__()方法，得到一个迭代器对象iter_dic<br>2: 执行next(iter_dic),将得到的值赋值给k,然后执行循环体代码<br>3: 重复过程2，直到捕捉到异常StopIteration,结束循环</p>
<h3 id="3-生成器和列表解析"><a href="#3-生成器和列表解析" class="headerlink" title="3.生成器和列表解析"></a>3.生成器和列表解析</h3><p><strong><font color=red>生成器只能遍历一次</font></strong></p>
<p>只要函数内部包含有yield关键字，那么函数名()的到的结果就是生成器，并且不会执行函数内部代码</p>
<p>生成器自动实现了可迭代协议，不用调用__iter__()方法</p>
<p>三元表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'xx'</span> <span class="keyword">if</span> name ==<span class="string">'xuexuan'</span> <span class="keyword">else</span> <span class="string">'yy'</span></span><br></pre></td></tr></table></figure>
<p>列表解析(会生成列表，会占用内存)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i &gt;<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>生成器表达式(节省内存)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>sum参数中的加入生成器不需要小括号</p>
<p>yield的作用：</p>
<p>1) 相当于return控制函数的返回值，x = yield num</p>
<p>2）接受send传过来的值 x = yield  test().send(value)</p>
<p>3）函数中有yield，则调用func()不会执行函数中的内容，使用next()</p>
<h2 id="四、装饰器"><a href="#四、装饰器" class="headerlink" title="四、装饰器"></a>四、装饰器</h2><p>本质就是函数，功能是为其他函数添加附加功能</p>
<p>装饰器 = 高阶函数 + 函数嵌套 + 闭包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(func1)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func1(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>@func2相当于 func1 = func2(func1)</p>
<p>带参数的装饰器，外面添加一层</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(para)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(func1)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        	func1(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">   	<span class="keyword">return</span> func2</span><br></pre></td></tr></table></figure>
<h3 id="1-原则"><a href="#1-原则" class="headerlink" title="1.原则"></a>1.原则</h3><p>（1）不修改被修饰函数的运行方式<br>（2）不修改被修饰函数的源代码</p>
<h3 id="解压序列"><a href="#解压序列" class="headerlink" title="*解压序列"></a>*解压序列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">10</span>,<span class="number">15</span>,<span class="number">45</span>,<span class="number">8</span>,<span class="number">78</span>,<span class="number">687</span>,<span class="number">9</span>,<span class="number">87987</span>,<span class="number">987</span>,<span class="number">78</span>,<span class="number">7</span>]</span><br><span class="line">a,*_,c = l  <span class="comment"># *_去掉中间的元素</span></span><br><span class="line">a,*b,c = l  <span class="comment"># 将中间的元素储存在b中</span></span><br><span class="line">a,b = b,a <span class="comment"># 交换两个变量</span></span><br></pre></td></tr></table></figure>
<h2 id="五、模块"><a href="#五、模块" class="headerlink" title="五、模块"></a>五、模块</h2><p><a href="http://www.cnblogs.com/yuanchenqi/articles/5732581.html" target="_blank" rel="noopener">http://www.cnblogs.com/yuanchenqi/articles/5732581.html</a></p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>(1) from a import b  会执行a中所有的语句<br>(2) sys path获取 import的路径<br>(3) input()接受str，eval()取出<br>(4) os.rename(xx.bak)备份<br>(5) tag（执行标记）的用法<br>(6) from a import <em> 不推荐<br>(7) 程序入口一般bin.py<br>(8) main.py:逻辑相关函数<br>(9)from a import </em> 不会导入下划线开头的属性</p>
<p>临时修改环境变量，<code>sys.path.append()</code></p>
<h3 id="1-内置模块"><a href="#1-内置模块" class="headerlink" title="1.内置模块"></a>1.内置模块</h3><p>time,sys等模块是C语言实现的，嵌入到python解释器中，调用时一定会有限调用。</p>
<h4 id="1-1-time模块"><a href="#1-1-time模块" class="headerlink" title="1.1 time模块"></a>1.1 time模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#时间戳</span></span><br><span class="line">time.time() <span class="comment">#1970年1月1日0点至今的秒数，用于计时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结构化时间</span></span><br><span class="line">time.localtime() <span class="comment">#返回结构化时间（当地时间）</span></span><br><span class="line">time.localtime().tm_year <span class="comment">#返回年份（tm_mon:月,tm_wday:星期，tm_hour:小时等）</span></span><br><span class="line">time.gmtime() <span class="comment">#返回结构化时间（0时区的时间）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结构化时间转化为时间戳</span></span><br><span class="line">time.mktime(time.localtime())</span><br><span class="line"><span class="comment">#结构化时间转化为字符串时间</span></span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d %X"</span>,time.localtime())  <span class="comment">#%X为时间</span></span><br><span class="line"><span class="comment">#字符串时间转成结构化时间</span></span><br><span class="line">time.strptime(<span class="string">'2016:12:24:17:50:36'</span>,<span class="string">'%Y:%m:%d:%X'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接给定直观的时间</span></span><br><span class="line">time.asctime()  <span class="comment">#结构化时间转化为字符串时间</span></span><br><span class="line">time.ctime()  <span class="comment">#时间戳转换为字符串时间</span></span><br><span class="line"></span><br><span class="line">time.sleep()</span><br></pre></td></tr></table></figure>
<p><img src="./image/2.png" alt=""></p>
<p><img src="./image/3.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">datetime.datetime.now() <span class="comment"># year-month-day h:m:s</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-random模块"><a href="#1-2-random模块" class="headerlink" title="1.2 random模块"></a>1.2 random模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random</span><br><span class="line">print(random.random())<span class="comment">#(0,1)----float</span></span><br><span class="line">print(random.randint(<span class="number">1</span>,<span class="number">3</span>))  <span class="comment">#[1,3]</span></span><br><span class="line">print(random.randrange(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">#[1,3) -- int</span></span><br><span class="line">print(random.choice([<span class="number">1</span>,<span class="string">'23'</span>,[<span class="number">4</span>,<span class="number">5</span>]]))<span class="comment">#23</span></span><br><span class="line">print(random.sample([<span class="number">1</span>,<span class="string">'23'</span>,[<span class="number">4</span>,<span class="number">5</span>]],<span class="number">2</span>))<span class="comment">#[[4, 5], '23']</span></span><br><span class="line">print(random.uniform(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">#1.927109612082716</span></span><br><span class="line">print(random.shuffle([<span class="number">123</span>,<span class="number">4</span>,<span class="number">5234</span>,<span class="number">5</span>])) <span class="comment">#洗牌</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-os模块"><a href="#1-3-os模块" class="headerlink" title="1.3 os模块"></a>1.3 os模块</h4><p>os模块只能删除空文件夹，不能删除非空文件夹</p>
<p>删除文件用os.remove()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span><br><span class="line">os.getpid()	获得进程的进程id</span><br><span class="line">os.getppid() 获得父进程的进程id</span><br><span class="line">os.chdir(<span class="string">"dirname"</span>)  改变当前脚本工作目录；相当于shell下cd</span><br><span class="line">os.curdir  返回当前目录: (<span class="string">'.'</span>)</span><br><span class="line">os.pardir  获取当前目录的父目录字符串名：(<span class="string">'..'</span>)</span><br><span class="line">os.makedirs(<span class="string">'dirname1/dirname2'</span>)    可生成多层递归目录</span><br><span class="line">os.removedirs(<span class="string">'dirname1'</span>)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(<span class="string">'dirname'</span>)    生成单级目录；相当于shell中mkdir dirname</span><br><span class="line">os.rmdir(<span class="string">'dirname'</span>)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(<span class="string">'dirname'</span>)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(<span class="string">"oldname"</span>,<span class="string">"newname"</span>)  重命名文件/目录</span><br><span class="line">os.stat(<span class="string">'path/filename'</span>)  <span class="comment">#获取文件/目录信息 st_atime上一次查看时间 st_mtime上一次修改时间，st_ctime创建时间</span></span><br><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为<span class="string">"\\"</span>,Linux下为<span class="string">"/"</span></span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为<span class="string">"\r\n"</span>,Linux下为<span class="string">"\n"</span></span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;'nt'; Linux-&gt;'posix'</span><br><span class="line">os.system(<span class="string">"bash command"</span>)  运行shell命令，直接显示  (推荐使用：subprocess模块)</span><br><span class="line">os.environ  获取系统环境变量</span><br><span class="line">os.path.abspath(path)  返回path规范化的绝对路径</span><br><span class="line">os.path.split(path)  将path分割成目录和文件名二元组返回</span><br><span class="line">os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</span><br><span class="line">os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line">os.path.exists(path)  如果path存在，返回<span class="literal">True</span>；如果path不存在，返回<span class="literal">False</span></span><br><span class="line">os.path.isabs(path)  如果path是绝对路径，返回<span class="literal">True</span></span><br><span class="line">os.path.isfile(path)  如果path是一个存在的文件，返回<span class="literal">True</span>。否则返回<span class="literal">False</span></span><br><span class="line">os.path.isdir(path)  如果path是一个存在的目录，则返回<span class="literal">True</span>。否则返回<span class="literal">False</span></span><br><span class="line">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span><br><span class="line">os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span><br></pre></td></tr></table></figure>
<h4 id="1-4-sys模块"><a href="#1-4-sys模块" class="headerlink" title="1.4 sys模块"></a>1.4 sys模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.argv           命令行参数List，第一个元素是程序本身路径（文件名）</span><br><span class="line">sys.exit(n)        退出程序，正常退出时exit(<span class="number">0</span>)</span><br><span class="line">sys.version        获取Python解释程序的版本信息</span><br><span class="line">sys.maxint         最大的Int值</span><br><span class="line">sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">sys.platform       返回操作系统平台名称</span><br><span class="line">sys.stdout.write(<span class="string">'#'</span>)  向屏幕显示相应的内容</span><br></pre></td></tr></table></figure>
<p>进度条</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sys.stdout.write(&#39;#&#39;)  #写入缓存</span><br><span class="line">sys.stdout.flush()  #将缓存中的文件显示在屏幕</span><br></pre></td></tr></table></figure>
<h4 id="1-5-Json-amp-Pickel"><a href="#1-5-Json-amp-Pickel" class="headerlink" title="1.5 Json&amp;Pickel"></a>1.5 Json&amp;Pickel</h4><ul>
<li><p>json可以进行任何语言间的数据交换，将变量改变为字符串。最多储存到函数级别</p>
</li>
<li><p>只要是js字符串就可以被loads，不一定需要dump</p>
</li>
<li><p>Pickle写入文件需要wb模式，</p>
<p><strong>python中对象依托于类存在，pickle load时必须有相应的类才能load</strong></p>
</li>
</ul>
<p><strong>序列化</strong></p>
<p>我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p>
<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<p><strong>json</strong></p>
<p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>
<p><img src="./image/4.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#----------------------------序列化</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line">dic=&#123;<span class="string">'name'</span>:<span class="string">'alvin'</span>,<span class="string">'age'</span>:<span class="number">23</span>,<span class="string">'sex'</span>:<span class="string">'male'</span>&#125;</span><br><span class="line">print(type(dic))<span class="comment">#&lt;class 'dict'&gt;</span></span><br><span class="line"> </span><br><span class="line">j=json.dumps(dic)</span><br><span class="line">print(type(j))<span class="comment">#&lt;class 'str'&gt;</span></span><br><span class="line">  </span><br><span class="line">f=open(<span class="string">'序列化对象'</span>,<span class="string">'w'</span>)</span><br><span class="line">f.write(j)  <span class="comment">#-------------------等价于json.dump(dic,f)</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment">#-----------------------------反序列化&lt;br&gt;</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">f=open(<span class="string">'序列化对象'</span>)</span><br><span class="line">data=json.loads(f.read())<span class="comment">#  等价于data=json.load(f)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Pickle与json的用法完全相同</li>
</ul>
<p>Pickle是python特有的，支持的数据类型更多。</p>
<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>
<h4 id="1-5-shelve"><a href="#1-5-shelve" class="headerlink" title="1.5 shelve"></a>1.5 shelve</h4><p>open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import shelve</span><br><span class="line">f &#x3D; shelve.open(r&#39;shelve.txt&#39;)</span><br><span class="line"></span><br><span class="line"># f[&#39;stu1_info&#39;]&#x3D;&#123;&#39;name&#39;:&#39;alex&#39;,&#39;age&#39;:&#39;18&#39;&#125;</span><br><span class="line"># f[&#39;stu2_info&#39;]&#x3D;&#123;&#39;name&#39;:&#39;alvin&#39;,&#39;age&#39;:&#39;20&#39;&#125;</span><br><span class="line"># f[&#39;school_info&#39;]&#x3D;&#123;&#39;website&#39;:&#39;oldboyedu.com&#39;,&#39;city&#39;:&#39;beijing&#39;&#125;</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># f.close()</span><br><span class="line"></span><br><span class="line">print&#96;&#96;(f.get(&#96;&#96;&#39;stu_info&#39;&#96;&#96;)[&#96;&#96;&#39;age&#39;&#96;&#96;])</span><br></pre></td></tr></table></figure>
<h4 id="1-6-XML模块"><a href="#1-6-XML模块" class="headerlink" title="1.6 XML模块"></a>1.6 XML模块</h4><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;country name&#x3D;&quot;Liechtenstein&quot;&gt;</span><br><span class="line">        &lt;rank updated&#x3D;&quot;yes&quot;&gt;2&lt;&#x2F;rank&gt;</span><br><span class="line">        &lt;year&gt;2008&lt;&#x2F;year&gt;</span><br><span class="line">        &lt;gdppc&gt;141100&lt;&#x2F;gdppc&gt;</span><br><span class="line">        &lt;neighbor name&#x3D;&quot;Austria&quot; direction&#x3D;&quot;E&quot;&#x2F;&gt;</span><br><span class="line">        &lt;neighbor name&#x3D;&quot;Switzerland&quot; direction&#x3D;&quot;W&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;country&gt;</span><br><span class="line">    &lt;country name&#x3D;&quot;Singapore&quot;&gt;</span><br><span class="line">        &lt;rank updated&#x3D;&quot;yes&quot;&gt;5&lt;&#x2F;rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;&#x2F;year&gt;</span><br><span class="line">        &lt;gdppc&gt;59900&lt;&#x2F;gdppc&gt;</span><br><span class="line">        &lt;neighbor name&#x3D;&quot;Malaysia&quot; direction&#x3D;&quot;N&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;country&gt;</span><br><span class="line">    &lt;country name&#x3D;&quot;Panama&quot;&gt;</span><br><span class="line">        &lt;rank updated&#x3D;&quot;yes&quot;&gt;69&lt;&#x2F;rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;&#x2F;year&gt;</span><br><span class="line">        &lt;gdppc&gt;13600&lt;&#x2F;gdppc&gt;</span><br><span class="line">        &lt;neighbor name&#x3D;&quot;Costa Rica&quot; direction&#x3D;&quot;W&quot;&#x2F;&gt;</span><br><span class="line">        &lt;neighbor name&#x3D;&quot;Colombia&quot; direction&#x3D;&quot;E&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;country&gt;</span><br><span class="line">&lt;&#x2F;data&gt;</span><br></pre></td></tr></table></figure>
<p>操作xml</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(<span class="string">"xmltest.xml"</span>) <span class="comment">#解析</span></span><br><span class="line">root = tree.getroot()</span><br><span class="line">print(root.tag)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#遍历xml文档</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root:</span><br><span class="line">    print(child.tag, child.attrib)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> child:</span><br><span class="line">        print(i.tag,i.text)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#只遍历year 节点</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> root.iter(<span class="string">'year'</span>):</span><br><span class="line">    print(node.tag,node.text)</span><br><span class="line"><span class="comment">#---------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(<span class="string">"xmltest.xml"</span>)</span><br><span class="line">root = tree.getroot()</span><br><span class="line"> </span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> root.iter(<span class="string">'year'</span>):</span><br><span class="line">    new_year = int(node.text) + <span class="number">1</span></span><br><span class="line">    node.text = str(new_year) <span class="comment">#修改文本</span></span><br><span class="line">    node.set(<span class="string">"updated"</span>,<span class="string">"yes"</span>) <span class="comment">#设置属性</span></span><br><span class="line">tree.write(<span class="string">"xmltest.xml"</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#删除node</span></span><br><span class="line"><span class="keyword">for</span> country <span class="keyword">in</span> root.findall(<span class="string">'country'</span>):</span><br><span class="line">   rank = int(country.find(<span class="string">'rank'</span>).text)</span><br><span class="line">   <span class="keyword">if</span> rank &gt; <span class="number">50</span>:</span><br><span class="line">     root.remove(country)</span><br><span class="line"> </span><br><span class="line">tree.write(<span class="string">'output.xml'</span>)</span><br></pre></td></tr></table></figure>
<p>创建xml文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">new_xml = ET.Element(<span class="string">"namelist"</span>)</span><br><span class="line">name = ET.SubElement(new_xml,<span class="string">"name"</span>,attrib=&#123;<span class="string">"enrolled"</span>:<span class="string">"yes"</span>&#125;)</span><br><span class="line">age = ET.SubElement(name,<span class="string">"age"</span>,attrib=&#123;<span class="string">"checked"</span>:<span class="string">"no"</span>&#125;)</span><br><span class="line">sex = ET.SubElement(name,<span class="string">"sex"</span>)</span><br><span class="line">sex.text = <span class="string">'33'</span></span><br><span class="line">name2 = ET.SubElement(new_xml,<span class="string">"name"</span>,attrib=&#123;<span class="string">"enrolled"</span>:<span class="string">"no"</span>&#125;)</span><br><span class="line">age = ET.SubElement(name2,<span class="string">"age"</span>)</span><br><span class="line">age.text = <span class="string">'19'</span></span><br><span class="line"> </span><br><span class="line">et = ET.ElementTree(new_xml) <span class="comment">#生成文档对象</span></span><br><span class="line">et.write(<span class="string">"test.xml"</span>, encoding=<span class="string">"utf-8"</span>,xml_declaration=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">ET.dump(new_xml) <span class="comment">#打印生成的格式</span></span><br></pre></td></tr></table></figure>
<h4 id="1-7-re模块"><a href="#1-7-re模块" class="headerlink" title="1.7 re模块"></a>1.7 re模块</h4><p>正则表达式</p>
<p>字符匹配（普通字符，元字符）：</p>
<p>1 普通字符：大多数字符和字母都会和自身匹配<br>              >&gt;&gt; re.findall(‘alvin’,’yuanaleSxalexwupeiqi’)<br>                      [‘alvin’] </p>
<p>2 元字符：. ^ $ * + ? { } [ ] | ( ) \</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. 通配符（一个字符）</span><br><span class="line">^ 以xxx开头</span><br><span class="line">$ 以xxx结尾</span><br><span class="line">*+?&#123;&#125;</span><br><span class="line">* 按照紧挨的字符重复 0~∞次(注意是0次开始)</span><br><span class="line">+ 按照紧挨的字符重复 1~∞次(注意是1次开始)</span><br><span class="line">? 按照紧挨的字符重复 0或1次</span><br><span class="line">&#123;&#125; 按照紧挨的字符重复 &#123;0,&#125;:*   &#123;1,&#125;:+</span><br><span class="line"></span><br><span class="line">*+?都是贪婪匹配，后面加?为变为惰性匹配</span><br><span class="line"></span><br><span class="line">元字符之转义符\</span><br><span class="line">反斜杠后边跟元字符去除特殊功能,比如\.</span><br><span class="line">反斜杠后边跟普通字符实现特殊功能,比如\d</span><br><span class="line"></span><br><span class="line">\d  匹配任何十进制数；它相当于类 [0-9]。</span><br><span class="line">\D 匹配任何非数字字符；它相当于类 [^0-9]。</span><br><span class="line">\s  匹配任何空白字符；它相当于类 [ \t\n\r\f\v]。</span><br><span class="line">\S 匹配任何非空白字符；它相当于类 [^ \t\n\r\f\v]。</span><br><span class="line">\w 匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。</span><br><span class="line">\W 匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]</span><br><span class="line">\b  匹配一个特殊字符边界，比如空格 ，&amp;，＃等</span><br><span class="line"></span><br><span class="line">在“”中使用转义字符时，需要进行r&quot;&quot;.</span><br><span class="line"></span><br><span class="line">python str --&gt; python解释器---&gt;re层&quot;&quot;进行匹配</span><br><span class="line">#-----------------------------eg1:</span><br><span class="line">import re</span><br><span class="line">ret&#x3D;re.findall(&#39;c\l&#39;,&#39;abc\le&#39;)</span><br><span class="line">print(ret)#[]</span><br><span class="line">ret&#x3D;re.findall(&#39;c\\l&#39;,&#39;abc\le&#39;)</span><br><span class="line">print(ret)#[]</span><br><span class="line">ret&#x3D;re.findall(&#39;c\\\\l&#39;,&#39;abc\le&#39;)</span><br><span class="line">print(ret)#[&#39;c\\l&#39;]</span><br><span class="line">ret&#x3D;re.findall(r&#39;c\\l&#39;,&#39;abc\le&#39;)</span><br><span class="line">print(ret)#[&#39;c\\l&#39;]</span><br><span class="line"> </span><br><span class="line">#-----------------------------eg2:</span><br><span class="line">#之所以选择\b是因为\b在ASCII表中是有意义的</span><br><span class="line">m &#x3D; re.findall(&#39;\bblow&#39;, &#39;blow&#39;)</span><br><span class="line">print(m)</span><br><span class="line">m &#x3D; re.findall(r&#39;\bblow&#39;, &#39;blow&#39;)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>
<p><strong>[] 字符集</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------字符集[]</span></span><br><span class="line">ret=re.findall(<span class="string">'a[bc]d'</span>,<span class="string">'acd'</span>)</span><br><span class="line">print(ret)<span class="comment">#['acd']</span></span><br><span class="line"> </span><br><span class="line">ret=re.findall(<span class="string">'[a-z]'</span>,<span class="string">'acd'</span>)</span><br><span class="line">print(ret)<span class="comment">#['a', 'c', 'd']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># []没有特殊符号</span></span><br><span class="line">ret=re.findall(<span class="string">'[.*+]'</span>,<span class="string">'a.cd+'</span>)</span><br><span class="line">print(ret)<span class="comment">#['.', '+']</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#在字符集里有功能的符号: - ^ \</span></span><br><span class="line"><span class="comment"># - 范围</span></span><br><span class="line">ret=re.findall(<span class="string">'[1-9]'</span>,<span class="string">'45dha3'</span>)</span><br><span class="line">print(ret)<span class="comment">#['4', '5', '3']</span></span><br><span class="line"><span class="comment"># ^ 非</span></span><br><span class="line">ret=re.findall(<span class="string">'[^ab]'</span>,<span class="string">'45bdha3'</span>)</span><br><span class="line">print(ret)<span class="comment">#['4', '5', 'd', 'h', '3']</span></span><br><span class="line">  </span><br><span class="line">ret=re.findall(<span class="string">'[\d]'</span>,<span class="string">'45bdha3'</span>)</span><br><span class="line">print(ret)<span class="comment">#['4', '5', '3']</span></span><br></pre></td></tr></table></figure>
<p>|  或</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret=re.search(<span class="string">'(ab)|\d'</span>,<span class="string">'rabhdg8sd'</span>)</span><br><span class="line">print(ret.group())<span class="comment">#ab</span></span><br></pre></td></tr></table></figure>
<p>（）分组</p>
<p>当匹配中有分组时，findall优先返回分组中的匹配机制，</p>
<p>如果要返回所有的匹配结果，使用(?:xxxxx)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = re.findall(<span class="string">r'(ad)+'</span>, <span class="string">'add'</span>)</span><br><span class="line">print(m)</span><br><span class="line"> </span><br><span class="line">m = re.findall(<span class="string">'(?:abc)+'</span>,<span class="string">'abcabcabc'</span>) <span class="comment">#abcabcabc</span></span><br><span class="line">    </span><br><span class="line">ret=re.search(<span class="string">'(?P&lt;id&gt;\d&#123;2&#125;)/(?P&lt;name&gt;\w&#123;3&#125;)'</span>,<span class="string">'23/com'</span>)</span><br><span class="line">print(ret.group())<span class="comment">#23/com</span></span><br><span class="line">print(ret.group(<span class="string">'id'</span>))<span class="comment">#23</span></span><br></pre></td></tr></table></figure>
<p>re下的常用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">re.findall(<span class="string">'a'</span>,<span class="string">'alvin yuan'</span>)    <span class="comment">#返回所有满足匹配条件的结果,放在列表里</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">re.search(<span class="string">'a'</span>,<span class="string">'alvin yuan'</span>).group()  <span class="comment">#函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">re.match(<span class="string">'a'</span>,<span class="string">'abc'</span>).group()     <span class="comment">#同search,不过尽在字符串开始处进行匹配，返回的是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">ret=re.split(<span class="string">'[ab]'</span>,<span class="string">'abcd'</span>)     <span class="comment">#先按'a'分割得到''和'bcd',在对''和'bcd'分别按'b'分割</span></span><br><span class="line">print(ret)<span class="comment">#['', '', 'cd']</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#5 替换</span></span><br><span class="line">ret=re.sub(<span class="string">'\d'</span>,<span class="string">'abc'</span>,<span class="string">'alvin5yuan6'</span>,<span class="number">1</span>)  <span class="comment">#匹配的次数</span></span><br><span class="line">print(ret)<span class="comment">#alvinabcyuan6</span></span><br><span class="line">ret=re.subn(<span class="string">'\d'</span>,<span class="string">'abc'</span>,<span class="string">'alvin5yuan6'</span>)  <span class="comment">#返回元组，一为结果，二为匹配的次数</span></span><br><span class="line">print(ret)<span class="comment">#('alvinabcyuanabc', 2)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#6 模板</span></span><br><span class="line">obj=re.compile(<span class="string">'\d&#123;3&#125;'</span>)</span><br><span class="line">ret=obj.search(<span class="string">'abc123eeee'</span>)</span><br><span class="line">print(ret.group())<span class="comment">#123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ret=re.finditer(<span class="string">'\d'</span>,<span class="string">'ds3sy4784a'</span>)</span><br><span class="line">print(ret)        <span class="comment">#&lt;callable_iterator object at 0x10195f940&gt;</span></span><br><span class="line"> </span><br><span class="line">print(next(ret).group())</span><br><span class="line">print(next(ret).group())</span><br></pre></td></tr></table></figure>
<h4 id="1-8-logging模块"><a href="#1-8-logging模块" class="headerlink" title="1.8 logging模块"></a>1.8 logging模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line"><span class="comment"># 级别从低到高</span></span><br><span class="line">logging.debug(<span class="string">'debug message'</span>)  </span><br><span class="line">logging.info(<span class="string">'info message'</span>)  </span><br><span class="line">logging.warning(<span class="string">'warning message'</span>)  </span><br><span class="line">logging.error(<span class="string">'error message'</span>)  </span><br><span class="line">logging.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下<a href="http://lib.csdn.net/base/11" target="_blank" rel="noopener">Python</a>的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET），默认的日志格式为日志级别：Logger名称：用户输出消息。</p>
<p>二  <strong>灵活配置日志级别，日志格式，输出位置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import logging  </span><br><span class="line">logging.basicConfig(level&#x3D;logging.DEBUG,  </span><br><span class="line">                    format&#x3D;&#39;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#39;,  </span><br><span class="line">                    datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S&#39;,  </span><br><span class="line">                    filename&#x3D;&#39;&#x2F;tmp&#x2F;test.log&#39;,  </span><br><span class="line">                    filemode&#x3D;&#39;w&#39;)  </span><br><span class="line">  </span><br><span class="line">logging.debug(&#39;debug message&#39;)  </span><br><span class="line">logging.info(&#39;info message&#39;)  </span><br><span class="line">logging.warning(&#39;warning message&#39;)  </span><br><span class="line">logging.error(&#39;error message&#39;)  </span><br><span class="line">logging.critical(&#39;critical message&#39;)</span><br></pre></td></tr></table></figure>
<p>  在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有<br>filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。<br>filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。<br>format：指定handler使用的日志显示格式。<br>datefmt：指定日期时间格式。<br>level：设置rootlogger（后边会讲解具体概念）的日志级别<br>stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</p>
<p>format参数中可能用到的格式化串：<br>%(name)s Logger的名字<br>%(levelno)s 数字形式的日志级别<br>%(levelname)s 文本形式的日志级别<br>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有<br>%(filename)s 调用日志输出函数的模块的文件名<br>%(module)s 调用日志输出函数的模块名<br>%(funcName)s 调用日志输出函数的函数名<br>%(lineno)d 调用日志输出函数的语句所在的代码行<br>%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示<br>%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数<br>%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒<br>%(thread)d 线程ID。可能没有<br>%(threadName)s 线程名。可能没有<br>%(process)d 进程ID。可能没有<br>%(message)s用户输出的消息  </p>
<p><strong>三  logger对象</strong></p>
<p>​    上述几个例子中我们了解到了logging.debug()、logging.info()、logging.warning()、logging.error()、logging.critical()（分别用以记录不同级别的日志信息），logging.basicConfig()（用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到root logger（根Logger）中）这几个logging模块级别的函数，另外还有一个模块级别的函数是logging.getLogger([name])（返回一个logger对象，如果没有指定名字将返回root logger）</p>
<p>​     先看一个最简单的过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line"><span class="comment"># 创建一个handler，用于写入日志文件</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">'test.log'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再创建一个handler，用于输出到控制台</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line"></span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">logger.addHandler(fh) <span class="comment">#logger对象可以添加多个fh和ch对象</span></span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">'logger debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'logger info message'</span>)</span><br><span class="line">logger.warning(<span class="string">'logger warning message'</span>)</span><br><span class="line">logger.error(<span class="string">'logger error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'logger critical message'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>四、两个logger对象</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################################################</span></span><br><span class="line">logger1 = logging.getLogger(<span class="string">'mylogger'</span>)</span><br><span class="line">logger1.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logger2 = logging.getLogger(<span class="string">'mylogger'</span>) <span class="comment">#与logger名称相同，为同一个对象</span></span><br><span class="line">logger2.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">logger1.addHandler(fh)</span><br><span class="line">logger1.addHandler(ch)</span><br><span class="line"></span><br><span class="line">logger2.addHandler(fh)</span><br><span class="line">logger2.addHandler(ch)</span><br><span class="line"></span><br><span class="line">logger1.debug(<span class="string">'logger1 debug message'</span>)</span><br><span class="line">logger1.info(<span class="string">'logger1 info message'</span>)</span><br><span class="line">logger1.warning(<span class="string">'logger1 warning message'</span>)</span><br><span class="line">logger1.error(<span class="string">'logger1 error message'</span>)</span><br><span class="line">logger1.critical(<span class="string">'logger1 critical message'</span>)</span><br><span class="line">  </span><br><span class="line">logger2.debug(<span class="string">'logger2 debug message'</span>)</span><br><span class="line">logger2.info(<span class="string">'logger2 info message'</span>)</span><br><span class="line">logger2.warning(<span class="string">'logger2 warning message'</span>)</span><br><span class="line">logger2.error(<span class="string">'logger2 error message'</span>)</span><br><span class="line">logger2.critical(<span class="string">'logger2 critical message'</span>)</span><br></pre></td></tr></table></figure>
<p>(1)我们明明通过logger1.setLevel(logging.DEBUG)将logger1的日志级别设置为了DEBUG，为何显示的时候没有显示出DEBUG级别的日志信息，而是从INFO级别的日志开始显示呢？</p>
<p>​       原来logger1和logger2对应的是同一个Logger实例，只要logging.getLogger（name）中名称参数name相同则返回的Logger实例就是同一个，且仅有一个，也即name与Logger实例一一对应。在logger2实例中通过logger2.setLevel(logging.INFO)设置mylogger的日志级别为logging.INFO，所以最后logger1的输出遵从了后来设置的日志级别。</p>
<p>(2)为什么logger1、logger2对应的每个输出分别显示两次?<br>这是因为我们通过logger = logging.getLogger()显示的创建了root Logger，而logger1 = logging.getLogger(‘mylogger’)创建了root Logger的孩子(root.)mylogger,logger2同样。而孩子,孙子，重孙……既会将消息分发给他的handler进行处理也会传递给所有的祖先Logger处理。</p>
<h4 id="1-9-configparser模块"><a href="#1-9-configparser模块" class="headerlink" title="1.9 configparser模块"></a>1.9 configparser模块</h4><p><strong>好多软件的常见文档格式如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ServerAliveInterval &#x3D; 45</span><br><span class="line">Compression &#x3D; yes</span><br><span class="line">CompressionLevel &#x3D; 9</span><br><span class="line">ForwardX11 &#x3D; yes</span><br><span class="line">  </span><br><span class="line">[bitbucket.org]</span><br><span class="line">User &#x3D; hg</span><br><span class="line">  </span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port &#x3D; 50022</span><br><span class="line">ForwardX11 &#x3D; no</span><br></pre></td></tr></table></figure>
<p>如果想用python生成一个这样的文档怎么做呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import configparser</span><br><span class="line">  </span><br><span class="line">config &#x3D; configparser.ConfigParser()</span><br><span class="line">config[&quot;DEFAULT&quot;] &#x3D; &#123;&#39;ServerAliveInterval&#39;: &#39;45&#39;,</span><br><span class="line">                      &#39;Compression&#39;: &#39;yes&#39;,</span><br><span class="line">                     &#39;CompressionLevel&#39;: &#39;9&#39;&#125;</span><br><span class="line">  </span><br><span class="line">config[&#39;bitbucket.org&#39;] &#x3D; &#123;&#125;</span><br><span class="line">config[&#39;bitbucket.org&#39;][&#39;User&#39;] &#x3D; &#39;hg&#39;</span><br><span class="line">config[&#39;topsecret.server.com&#39;] &#x3D; &#123;&#125;</span><br><span class="line">topsecret &#x3D; config[&#39;topsecret.server.com&#39;]</span><br><span class="line">topsecret[&#39;Host Port&#39;] &#x3D; &#39;50022&#39;     # mutates the parser</span><br><span class="line">topsecret[&#39;ForwardX11&#39;] &#x3D; &#39;no&#39;  # same here</span><br><span class="line">config[&#39;DEFAULT&#39;][&#39;ForwardX11&#39;] &#x3D; &#39;yes&#39;&lt;br&gt;</span><br><span class="line">with open(&#39;example.ini&#39;, &#39;w&#39;) as configfile:</span><br><span class="line">   config.write(configfile)</span><br></pre></td></tr></table></figure>
<p><strong>config section名称不区分大小写</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------------查</span></span><br><span class="line">print(config.sections())   <span class="comment">#[]</span></span><br><span class="line">config.read(<span class="string">'example.ini'</span>)</span><br><span class="line">print(config.sections())   <span class="comment">#['bitbucket.org', 'topsecret.server.com']</span></span><br><span class="line">print(<span class="string">'bytebong.com'</span> <span class="keyword">in</span> config)<span class="comment"># False</span></span><br><span class="line">print(config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>]) <span class="comment"># hg</span></span><br><span class="line">print(config[<span class="string">'DEFAULT'</span>][<span class="string">'Compression'</span>]) <span class="comment">#yes</span></span><br><span class="line">print(config[<span class="string">'topsecret.server.com'</span>][<span class="string">'ForwardX11'</span>])  <span class="comment">#no</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> config[<span class="string">'bitbucket.org'</span>]:</span><br><span class="line">    print(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># user</span></span><br><span class="line"><span class="comment"># serveraliveinterval</span></span><br><span class="line"><span class="comment"># compression</span></span><br><span class="line"><span class="comment"># compressionlevel</span></span><br><span class="line"><span class="comment"># forwardx11</span></span><br><span class="line"></span><br><span class="line">print(config.options(<span class="string">'bitbucket.org'</span>))<span class="comment">#['user', 'serveraliveinterval', 'compression', 'compressionlevel', 'forwardx11']</span></span><br><span class="line">print(config.items(<span class="string">'bitbucket.org'</span>))  <span class="comment">#[('serveraliveinterval', '45'), ('compression', 'yes'), ('compressionlevel', '9'), ('forwardx11', 'yes'), ('user', 'hg')]</span></span><br><span class="line"></span><br><span class="line">print(config.get(<span class="string">'bitbucket.org'</span>,<span class="string">'compression'</span>))<span class="comment">#yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------------删,改,增(config.write(open('i.cfg', "w")))</span></span><br><span class="line"></span><br><span class="line">config.add_section(<span class="string">'yuan'</span>)</span><br><span class="line"></span><br><span class="line">config.remove_section(<span class="string">'topsecret.server.com'</span>)</span><br><span class="line">config.remove_option(<span class="string">'bitbucket.org'</span>,<span class="string">'user'</span>)</span><br><span class="line"></span><br><span class="line">config.set(<span class="string">'bitbucket.org'</span>,<span class="string">'k1'</span>,<span class="string">'11111'</span>)</span><br><span class="line"></span><br><span class="line">config.write(open(<span class="string">'i.cfg'</span>, <span class="string">"w"</span>))</span><br></pre></td></tr></table></figure>
<h4 id="1-10-hashlib模块"><a href="#1-10-hashlib模块" class="headerlink" title="1.10 hashlib模块"></a>1.10 hashlib模块</h4><p>摘要算法：md5，sha256等。只能将明文变为密文，不是可逆操作。</p>
<p>密码操作将所有的明文都变成密文在进行比较</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line">m=hashlib.md5()<span class="comment"># m=hashlib.sha256()</span></span><br><span class="line"> </span><br><span class="line">m.update(<span class="string">'hello'</span>.encode(<span class="string">'utf8'</span>))</span><br><span class="line">print(m.hexdigest())  <span class="comment">#5d41402abc4b2a76b9719d911017c592</span></span><br><span class="line"> </span><br><span class="line">m.update(<span class="string">'alvin'</span>.encode(<span class="string">'utf8'</span>))</span><br><span class="line"> </span><br><span class="line">print(m.hexdigest())  <span class="comment">#92a7e713c30abbb0319fa07da2a5c4af</span></span><br><span class="line"> </span><br><span class="line">m2=hashlib.md5()</span><br><span class="line">m2.update(<span class="string">'helloalvin'</span>.encode(<span class="string">'utf8'</span>))</span><br><span class="line">print(m2.hexdigest()) <span class="comment">#92a7e713c30abbb0319fa07da2a5c4af</span></span><br></pre></td></tr></table></figure>
<p>hash</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"><span class="comment"># ######## 256 ########</span></span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha256(<span class="string">'898oaFs09f'</span>.encode(<span class="string">'utf8'</span>))</span><br><span class="line">hash.update(<span class="string">'alvin'</span>.encode(<span class="string">'utf8'</span>))</span><br><span class="line"><span class="keyword">print</span> (hash.hexdigest())<span class="comment">#e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7</span></span><br></pre></td></tr></table></figure>
<p>不同对象的区分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_md5</span><span class="params">()</span>:</span></span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    m.update(str(time.time()).encode(utf<span class="number">-8</span>))</span><br><span class="line">    <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">school</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.id = create_md5() <span class="comment"># 通过id区分</span></span><br><span class="line">        <span class="comment">#通过pickle保存到文件</span></span><br></pre></td></tr></table></figure>
<h4 id="1-11-subprocess模块"><a href="#1-11-subprocess模块" class="headerlink" title="1.11 subprocess模块"></a>1.11 subprocess模块</h4><p>我们需要调用系统的命令的时候，最先考虑的os模块。用os.system()和os.popen()来进行操作。但是这两个命令过于简单，不能完成一些复杂的操作，如给运行的命令提供输入或者读取命令的输出，判断该命令的运行状态，管理多个命令的并行等等。这时subprocess中的Popen命令就能有效的完成我们需要的操作。</p>
<p>​      subprocess模块允许一个进程创建一个新的子进程，通过管道连接到子进程的stdin/stdout/stderr，获取子进程的返回值等操作。 </p>
<p>这个模块一个类：Popen。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;#Popen它的构造函数如下：&#96; &#96;subprocess.Popen(args, bufsize&#96;&#96;&#x3D;&#96;&#96;0&#96;&#96;, executable&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;, stdin&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;, stdout&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;,stderr&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;, preexec_fn&#96;&#96;&#x3D;&#96;&#96;None&#96;&#96;, close_fds&#96;&#96;&#x3D;&#96;&#96;False&#96;&#96;, shell&#96;&#96;&#x3D;&#96;&#96;False&#96;&#96;,&lt;br&gt;     &#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">subprocess.Popen(<span class="string">'dir'</span>,shell=<span class="literal">True</span>)  <span class="comment">#shell：命令解释器</span></span><br><span class="line"></span><br><span class="line">res = subprocess.Popen(<span class="string">'dir'</span>,shell=<span class="literal">True</span>)</span><br><span class="line">res.stdout.read().decode()   stdout--&gt;输出给管道</span><br><span class="line">管道中对象只能取一次</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stderr&#x3D;subprocess.PIPE, stdout&#x3D;subprocess.PIPE, stdin&#x3D;subprocess.PIPE)</span><br><span class="line">err &#x3D; res.stderr.read()</span><br><span class="line">if err:</span><br><span class="line">msg &#x3D; err</span><br><span class="line">else:</span><br><span class="line">msg &#x3D; res.stdout.read()</span><br><span class="line">print(msg.decode(&#39;utf-8&#39;))</span><br><span class="line">if msg:</span><br><span class="line">self.send_bytes(msg)</span><br><span class="line">else:</span><br><span class="line">self.send_msg(&#39;No return msg.&#39;)</span><br></pre></td></tr></table></figure>
<p><strong>简单命令：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"> </span><br><span class="line">a=subprocess.Popen(<span class="string">'ls'</span>)<span class="comment">#  创建一个新的进程,与主进程不同步</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>,a)<span class="comment">#a是Popen的一个实例对象</span></span><br><span class="line"> </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;subprocess.Popen object at 0x10185f860&gt;</span></span><br><span class="line"><span class="string">__init__.py</span></span><br><span class="line"><span class="string">__pycache__</span></span><br><span class="line"><span class="string">log.py</span></span><br><span class="line"><span class="string">main.py</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># subprocess.Popen('ls -l',shell=True)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># subprocess.Popen(['ls','-l'])</span></span><br></pre></td></tr></table></figure>
<p><strong>subprocess.PIPE</strong></p>
<p>在创建Popen对象时，subprocess.PIPE可以初始化stdin, stdout或stderr参数。表示与子进程通信的标准流。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"> </span><br><span class="line"><span class="comment"># subprocess.Popen('ls')</span></span><br><span class="line">p=subprocess.Popen(<span class="string">'ls'</span>,stdout=subprocess.PIPE)<span class="comment">#结果跑哪去啦?</span></span><br><span class="line"></span><br><span class="line">print(p.stdout.read())<span class="comment">#这这呢:b'__pycache__\nhello.py\nok.py\nweb\n'</span></span><br></pre></td></tr></table></figure>
<p>这是因为subprocess创建了子进程，结果本在子进程中，if 想要执行结果转到主进程中，就得需要一个管道，即 ： stdout=subprocess.PIPE</p>
<p><strong>subprocess.STDOUT</strong></p>
<p>创建Popen对象时，用于初始化stderr参数，表示将错误通过标准输出流输出。</p>
<p><strong>Popen的方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Popen.poll() </span><br><span class="line">用于检查子进程是否已经结束。设置并返回returncode属性。</span><br><span class="line"></span><br><span class="line">Popen.wait() </span><br><span class="line">等待子进程结束。设置并返回returncode属性。</span><br><span class="line"></span><br><span class="line">Popen.communicate(input&#x3D;None)</span><br><span class="line">与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。 Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如 果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。</span><br><span class="line"></span><br><span class="line">Popen.send_signal(signal) </span><br><span class="line">向子进程发送信号。</span><br><span class="line"></span><br><span class="line">Popen.terminate()</span><br><span class="line">停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。</span><br><span class="line"></span><br><span class="line">Popen.kill()</span><br><span class="line">杀死子进程。</span><br><span class="line"></span><br><span class="line">Popen.stdin </span><br><span class="line">如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。</span><br><span class="line"></span><br><span class="line">Popen.stdout </span><br><span class="line">如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。</span><br><span class="line"></span><br><span class="line">Popen.stderr </span><br><span class="line">如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。</span><br><span class="line"></span><br><span class="line">Popen.pid </span><br><span class="line">获取子进程的进程ID。</span><br><span class="line"></span><br><span class="line">Popen.returncode </span><br><span class="line">获取进程的返回值。如果进程还没有结束，返回None。</span><br></pre></td></tr></table></figure>
<p><strong>supprocess模块的工具函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">supprocess模块提供了一些函数，方便我们用于创建进程来实现一些简单的功能。</span><br><span class="line"> </span><br><span class="line">subprocess.call(*popenargs, **kwargs)</span><br><span class="line">运行命令。该函数将一直等待到子进程运行结束，并返回进程的returncode。如果子进程不需要进行交 互,就可以使用该函数来创建。</span><br><span class="line"> </span><br><span class="line">subprocess.check_call(*popenargs, **kwargs)</span><br><span class="line">与subprocess.call(*popenargs, **kwargs)功能一样，只是如果子进程返回的returncode不为<span class="number">0</span>的话，将触发CalledProcessError异常。在异常对象中，包 括进程的returncode信息。</span><br><span class="line"> </span><br><span class="line">check_output(*popenargs, **kwargs)</span><br><span class="line">与call()方法类似，以byte string的方式返回子进程的输出，如果子进程的返回值不是<span class="number">0</span>，它抛出CalledProcessError异常，这个异常中的returncode包含返回码，output属性包含已有的输出。</span><br><span class="line"> </span><br><span class="line">getstatusoutput(cmd)/getoutput(cmd)</span><br><span class="line">这两个函数仅仅在Unix下可用，它们在shell中执行指定的命令cmd，前者返回(status, output)，后者返回output。其中，这里的output包括子进程的stdout和stderr。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment"># subprocess.call('ls',shell=True)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">hello.py</span></span><br><span class="line"><span class="string">ok.py</span></span><br><span class="line"><span class="string">web</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># data=subprocess.call('ls',shell=True)</span></span><br><span class="line"><span class="comment"># print(data)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">hello.py</span></span><br><span class="line"><span class="string">ok.py</span></span><br><span class="line"><span class="string">web</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="comment"># subprocess.check_call('ls',shell=True)</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">hello.py</span></span><br><span class="line"><span class="string">ok.py</span></span><br><span class="line"><span class="string">web</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># data=subprocess.check_call('ls',shell=True)</span></span><br><span class="line"><span class="comment"># print(data)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">hello.py</span></span><br><span class="line"><span class="string">ok.py</span></span><br><span class="line"><span class="string">web</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 两个函数区别:只是如果子进程返回的returncode不为0的话，将触发CalledProcessError异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment"># subprocess.check_output('ls')#无结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data=subprocess.check_output('ls')</span></span><br><span class="line"><span class="comment"># print(data)  #b'hello.py\nok.py\nweb\n'</span></span><br></pre></td></tr></table></figure>
<h4 id="1-12-struct-模块"><a href="#1-12-struct-模块" class="headerlink" title="1.12 struct 模块"></a>1.12 struct 模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">l = struct.pack(<span class="string">'i'</span>,<span class="number">123</span>) <span class="comment">#将数字打包为4字节</span></span><br><span class="line">struct.unpack(<span class="string">'i'</span>,l) <span class="comment">#返回元组</span></span><br></pre></td></tr></table></figure>
<h4 id="1-13-partial模块"><a href="#1-13-partial模块" class="headerlink" title="1.13 partial模块"></a>1.13 partial模块</h4><p>为函数提供参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> partial</span><br><span class="line">func = partial(test,<span class="number">1</span>)</span><br><span class="line">func(<span class="number">3</span>)  <span class="comment">#4</span></span><br></pre></td></tr></table></figure>
<h4 id="1-14-optparse模块"><a href="#1-14-optparse模块" class="headerlink" title="1.14 optparse模块"></a>1.14 optparse模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> optparse</span><br><span class="line">x = optparse.OptionParser()</span><br><span class="line">x.add_option(<span class="string">'-s'</span>,<span class="string">'--s'</span>,dest=<span class="string">'server'</span>)</span><br><span class="line">x.add_option(<span class="string">'-P'</span>,<span class="string">'--port'</span>,dest=<span class="string">'port'</span>)</span><br><span class="line"></span><br><span class="line">options,args = x.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># options为形似字典的对象，储存绑定的参数</span></span><br><span class="line"><span class="comment"># args为列表，储存盈余的信息</span></span><br><span class="line"></span><br><span class="line">options.server <span class="comment">#返回server对应的参数</span></span><br></pre></td></tr></table></figure>
<h4 id="1-15-uuid"><a href="#1-15-uuid" class="headerlink" title="1.15 uuid"></a>1.15 uuid</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid </span><br><span class="line">uuid.uuid4()  生成随机数</span><br></pre></td></tr></table></figure>
<h4 id="1-16-concurrent"><a href="#1-16-concurrent" class="headerlink" title="1.16 concurrent"></a>1.16 concurrent</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExector</span><br><span class="line">import request</span><br><span class="line"></span><br><span class="line">def task(url):</span><br><span class="line">		response &#x3D; request.get(url)	</span><br><span class="line">		print(response)</span><br><span class="line">		return response</span><br><span class="line"></span><br><span class="line">def func(future,*args,**kwargs):</span><br><span class="line">		future 默认为task的返回值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool &#x3D; ThreadPoolExector(5)</span><br><span class="line">v &#x3D; pool.submit(task,url)</span><br><span class="line">v.add_done_callback(func,args)</span><br><span class="line"></span><br><span class="line">concurrent有参数xx</span><br></pre></td></tr></table></figure>
<h4 id="1-XX-iter的参数"><a href="#1-XX-iter的参数" class="headerlink" title="1.XX iter的参数"></a>1.XX iter的参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">12</span>,<span class="number">41</span>,<span class="number">25</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> l.pop()</span><br><span class="line"></span><br><span class="line">iiii = iter(test,<span class="number">41</span>)  <span class="number">41</span>为终止参数</span><br><span class="line">iiii.__next__()</span><br><span class="line">iiii.__next__()</span><br><span class="line">iiii.__next__() 返回<span class="number">41</span>时报错iterstop</span><br></pre></td></tr></table></figure>
<h2 id="六、面向对象"><a href="#六、面向对象" class="headerlink" title="六、面向对象"></a>六、面向对象</h2><p>面向对象<a href="https://www.cnblogs.com/linhaifeng/articles/6182264.html" target="_blank" rel="noopener">https://www.cnblogs.com/linhaifeng/articles/6182264.html</a></p>
<p><code>&lt;classname&gt;.__dict__</code> 返回属性字典</p>
<p>函数的输入输出要分开，类中函数只包含逻辑</p>
<p><strong>类中变量调用</strong></p>
<ol>
<li>点调用：在实例属性—》类属性中寻找</li>
<li>非点调用：在类外寻找</li>
</ol>
<p><strong>静态属性</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property将函数变为静态属性，调用时直接点调用静态属性即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yy</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> xx</span><br><span class="line"></span><br><span class="line">a = yy()</span><br><span class="line">print(a.test)</span><br></pre></td></tr></table></figure>
<p><strong>类方法</strong></p>
<p>与类绑定，不与实例绑定</p>
<p>不需要实例化类，可以直接使用</p>
<p>类方法不能调用实例属性，即不能使用self.xxx</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yy</span>:</span></span><br><span class="line">    tmp = <span class="number">1</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(cls)</span>:</span> <span class="comment">## cls为类名</span></span><br><span class="line">        <span class="keyword">return</span> cls.tmp</span><br><span class="line"></span><br><span class="line">print(yy.test())</span><br></pre></td></tr></table></figure>
<p><strong>静态方法</strong></p>
<p>不与类绑定，也不与实例绑定，只是类的工具包</p>
<p>实例无法调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yy</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">y.a</span><br></pre></td></tr></table></figure>
<p><strong>组合</strong></p>
<p>软件重用的重要方式除了继承之外还有另外一种方式，即：组合</p>
<p>组合指的是，在一个类中以另外一个类的对象作为数据属性，称为<strong>类的组合</strong></p>
<p>类与类之间的关联</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,addr)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.addr=addr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zhao_sheng</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s 正在招生'</span> %self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,price,period,school)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.price=price</span><br><span class="line">        self.period=period</span><br><span class="line">        self.school=school</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1=School(<span class="string">'oldboy'</span>,<span class="string">'北京'</span>)</span><br><span class="line">s2=School(<span class="string">'oldboy'</span>,<span class="string">'南京'</span>)</span><br><span class="line">s3=School(<span class="string">'oldboy'</span>,<span class="string">'东京'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># c1=Course('linux',10,'1h','oldboy 北京')</span></span><br><span class="line">c1=Course(<span class="string">'linux'</span>,<span class="number">10</span>,<span class="string">'1h'</span>,s1)</span><br><span class="line"></span><br><span class="line">print(c1.__dict__)</span><br><span class="line">print(c1.school.name)</span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>
<h3 id="1-三大特性"><a href="#1-三大特性" class="headerlink" title="1. 三大特性"></a>1. 三大特性</h3><p>继承、封装、多态</p>
<h4 id="1-1继承"><a href="#1-1继承" class="headerlink" title="1.1继承"></a>1.1继承</h4><p><a href="http://www.cnblogs.com/linhaifeng/articles/7340153.html#_label4" target="_blank" rel="noopener">继承与派生</a></p>
<p>当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好。</p>
<p>当类之间有很多相通的功能，提取这些共同的功能做成基类，用继承比较好。</p>
<p><strong>继承有两种含义</strong></p>
<p>含义一：继承基类的方法，并且做出自己的改变或拓展（代码重用）  —-》有害，代码之间存在耦合<br>含义二(接口继承)：声明某个子类兼容于某基类，定义一个接口类（父类中定义函数，但不实现，由子类实现，import abs, @abc.abstractmethod），子类继承接口类，并在实现接口中定义的方法</p>
<p>在python中根本就没有一个叫做interface的关键字，如果非要去模仿接口的概念<br>可以借助第三方模块：<a href="http://pypi.python.org/pypi/zope.interface" target="_blank" rel="noopener">http://pypi.python.org/pypi/zope.interface</a></p>
<p><strong>抽象类</strong></p>
<p>与java一样，python也有抽象类的概念但是同样需要借助模块实现，<strong>抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化</strong></p>
<p><strong>抽象类与接口</strong></p>
<p><em>抽象类的本质还是类，指的是一组类的相似性，包括数据属性（如all_type）和函数属性（如read、write），而接口只强调函数属性的相似性。</em></p>
<p>抽象类是一个介于类和接口直接的一个概念，同时具备类和接口的部分特性，可以用来实现归一化设计</p>
<p><strong>接口继承</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">All_file</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod ###接口类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disk</span><span class="params">(All_file)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'disk read'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'disk write'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cdrom</span><span class="params">(All_file)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'cdrom read'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'cdrom write'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mem</span><span class="params">(All_file)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'mem read'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'mem write'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">m1=Mem()</span><br><span class="line">m1.read()</span><br><span class="line">m1.write()</span><br></pre></td></tr></table></figure>
<p><strong>归一化设计</strong></p>
<p>接口继承实质上要求“作出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理是吸纳了特定接口的所有对象”—-这在程序设计上叫做归一化。</p>
<p><strong>派生</strong></p>
<p>当然子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了。</p>
<p><strong> 继承顺序</strong></p>
<p>在Java和C#中子类只能继承一个父类，而Python中子类可以同时继承多个父类，如A(B,C,D)</p>
<p>如果继承关系为非菱形结构，则会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性</p>
<p>如果继承关系为菱形结构，那么属性的查找方式有两种，分别是：深度优先和广度优先</p>
<p><img src="./image/5.png" alt=""></p>
<p><img src="./image/6.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'from A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'from B'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'from C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'from D'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'from E'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(D,E)</span>:</span></span><br><span class="line">    <span class="comment"># def test(self):</span></span><br><span class="line">    <span class="comment">#     print('from F')</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">f1=F()</span><br><span class="line">f1.test()</span><br><span class="line">print(F.__mro__) <span class="comment">#只有新式才有这个属性可以查看线性列表，经典类没有这个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新式类继承顺序:F-&gt;D-&gt;B-&gt;E-&gt;C-&gt;A</span></span><br><span class="line"><span class="comment">#经典类继承顺序:F-&gt;D-&gt;B-&gt;A-&gt;E-&gt;C</span></span><br><span class="line"><span class="comment">#python3中统一都是新式类</span></span><br><span class="line"><span class="comment">#pyhon2中才分新式类与经典类</span></span><br></pre></td></tr></table></figure>
<p> <strong>继承原理（python如何实现的继承）</strong></p>
<p>python到底是如何实现继承的，对于你定义的每一个类，python会计算出一个方法解析顺序(MRO)列表，这个MRO列表就是一个简单的所有基类的线性顺序列表，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; F.mro() #等同于F.__mro__</span><br><span class="line">[&lt;class &#39;__main__.F&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.E&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;]</span><br></pre></td></tr></table></figure>
<p>为了实现继承,python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。<br>而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:<br>1.子类会先于父类被检查<br>2.多个父类会根据它们在列表中的顺序被检查<br>3.如果对下一个类存在两个合法的选择,选择第一个父类</p>
<h4 id="1-2-子类中调用父类方法"><a href="#1-2-子类中调用父类方法" class="headerlink" title="1.2 子类中调用父类方法"></a>1.2 子类中调用父类方法</h4><p>需要先执行_<em>init_</em>()<br><strong>方法一</strong>：指名道姓，即父类名.父类方法()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">'Linhaifeng'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>:</span> <span class="comment">#定义交通工具类</span></span><br><span class="line">     Country=<span class="string">'China'</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,speed,load,power)</span>:</span></span><br><span class="line">         self.name=name</span><br><span class="line">         self.speed=speed</span><br><span class="line">         self.load=load</span><br><span class="line">         self.power=power</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">         print(<span class="string">'开动啦...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subway</span><span class="params">(Vehicle)</span>:</span> <span class="comment">#地铁</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,speed,load,power,line)</span>:</span></span><br><span class="line">        Vehicle.__init__(self,name,speed,load,power)</span><br><span class="line">        self.line=line</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'地铁%s号线欢迎您'</span> %self.line)</span><br><span class="line">        Vehicle.run(self)</span><br><span class="line"></span><br><span class="line">line13=Subway(<span class="string">'中国地铁'</span>,<span class="string">'180m/s'</span>,<span class="string">'1000人/箱'</span>,<span class="string">'电'</span>,<span class="number">13</span>)</span><br><span class="line">line13.run()</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong>：super()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>:</span> <span class="comment">#定义交通工具类</span></span><br><span class="line">     Country=<span class="string">'China'</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,speed,load,power)</span>:</span></span><br><span class="line">         self.name=name</span><br><span class="line">         self.speed=speed</span><br><span class="line">         self.load=load</span><br><span class="line">         self.power=power</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">         print(<span class="string">'开动啦...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subway</span><span class="params">(Vehicle)</span>:</span> <span class="comment">#地铁</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,speed,load,power,line)</span>:</span></span><br><span class="line">        <span class="comment">#super(Subway,self) 就相当于实例本身 在python3中super()等同于super(Subway,self)</span></span><br><span class="line">        super().__init__(name,speed,load,power)</span><br><span class="line">        self.line=line</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'地铁%s号线欢迎您'</span> %self.line)</span><br><span class="line">        super(Subway,self).run()</span><br><span class="line"></span><br><span class="line">line13=Subway(<span class="string">'中国地铁'</span>,<span class="string">'180m/s'</span>,<span class="string">'1000人/箱'</span>,<span class="string">'电'</span>,<span class="number">13</span>)</span><br><span class="line">line13.run()</span><br></pre></td></tr></table></figure>
<p><strong>二者使用哪一种都可以，但最好不要混合使用</strong> </p>
<p>即使没有直接继承关系，super仍然会按照mro继续往后查找<br>指名道姓与super()的区别</p>
<h3 id="1-2-多态"><a href="#1-2-多态" class="headerlink" title="1.2 多态"></a>1.2 多态</h3><p><a href="http://www.cnblogs.com/linhaifeng/articles/7340687.html" target="_blank" rel="noopener"><strong>http://www.cnblogs.com/linhaifeng/articles/7340687.html</strong></a></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p>
<p>比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同</p>
<h3 id="1-3-封装"><a href="#1-3-封装" class="headerlink" title="1.3 封装"></a>1.3 封装</h3><p><strong><a href="http://www.cnblogs.com/linhaifeng/articles/7340801.html" target="_blank" rel="noopener">http://www.cnblogs.com/linhaifeng/articles/7340801.html</a></strong></p>
<h4 id="x-python-OOP的常用术语"><a href="#x-python-OOP的常用术语" class="headerlink" title="x.python OOP的常用术语"></a>x.python OOP的常用术语</h4><p><strong>抽象/实现</strong></p>
<p>抽象指对现实世界问题和实体的本质表现,行为和特征建模,建立一个相关的子集,可以用于 绘程序结构,从而实现这种模型。抽象不仅包括这种模型的数据属性,还定义了这些数据的接口。</p>
<p>对某种抽象的实现就是对此数据及与之相关接口的现实化(realization)。现实化这个过程对于客户 程序应当是透明而且无关的。 </p>
<p><strong>封装/接口</strong></p>
<p>封装描述了对数据/信息进行隐藏的观念,它对数据属性提供接口和访问函数。通过任何客户端直接对数据的访问,无视接口,与封装性都是背道而驰的,除非程序员允许这些操作。作为实现的 一部分,客户端根本就不需要知道在封装之后,数据属性是如何组织的。在Python中,所有的类属性都是公开的,但名字可能被“混淆”了,以阻止未经授权的访问,但仅此而已,再没有其他预防措施了。这就需要在设计时,对数据提供相应的接口,以免客户程序通过不规范的操作来存取封装的数据属性。</p>
<p>注意：封装绝不是等于“把不想让别人看到、以后可能修改的东西用private隐藏起来”</p>
<p><strong>真正的封装是，经过深入的思考，做出良好的抽象，给出“完整且最小”的接口，并使得内部细节可以对外透明</strong></p>
<p><strong>（注意：对外透明</strong>的意思是<strong>，</strong>外部调用者可以顺利的得到自己想要的任何功能，<strong>完全意识不到内部细节的存在）</strong></p>
<p><strong>合成</strong></p>
<p>合成扩充了对类的 述,使得多个不同的类合成为一个大的类,来解决现实问题。合成 述了 一个异常复杂的系统,比如一个类由其它类组成,更小的组件也可能是其它的类,数据属性及行为, 所有这些合在一起,彼此是“有一个”的关系。</p>
<p><strong>派生/继承/继承结构</strong></p>
<p>派生描述了子类衍生出新的特性,新类保留已存类类型中所有需要的数据和行为,但允许修改或者其它的自定义操作,都不会修改原类的定义。<br>继承描述了子类属性从祖先类继承这样一种方式<br>继承结构表示多“代”派生,可以述成一个“族谱”,连续的子类,与祖先类都有关系。</p>
<p><strong>泛化/特化</strong></p>
<p>基于继承<br>泛化表示所有子类与其父类及祖先类有一样的特点。<br>特化描述所有子类的自定义,也就是,什么属性让它与其祖先类不同。</p>
<p><strong>多态与多态性</strong></p>
<p>多态指的是同一种事物的多种状态：水这种事物有多种不同的状态：冰，水蒸气</p>
<p>多态性的概念指出了对象如何通过他们共同的属性和动作来操作及访问,而不需考虑他们具体的类。</p>
<p>冰，水蒸气，都继承于水，它们都有一个同名的方法就是变成云，但是冰.变云(),与水蒸气.变云()是截然不同的过程，虽然调用的方法都一样</p>
<p><strong>自省/反射</strong></p>
<p>自省也称作反射，这个性质展示了某对象是如何在运行期取得自身信息的。如果传一个对象给你,你可以查出它有什么能力,这是一项强大的特性。如果Python不支持某种形式的自省功能,dir和type内建函数,将很难正常工作。还有那些特殊属性,像__dict__,__name__及__doc__<br>hasattr()   getattr()</p>
<h3 id="1-4-面向对象进阶"><a href="#1-4-面向对象进阶" class="headerlink" title="1.4 面向对象进阶"></a>1.4 面向对象进阶</h3><p><a href="https://www.cnblogs.com/linhaifeng/articles/6204014.html" target="_blank" rel="noopener">https://www.cnblogs.com/linhaifeng/articles/6204014.html</a></p>
<h4 id="1-4-1动态导入模块"><a href="#1-4-1动态导入模块" class="headerlink" title="1.4.1动态导入模块"></a>1.4.1动态导入模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">module_t = __import__(m1.t)  <span class="comment">## 无论通过点调用多少层，最后导入的实际上是m1</span></span><br><span class="line">module_t等价于 m1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">m = importlib.import_module(m1.t)</span><br><span class="line">m等价于m1.t</span><br></pre></td></tr></table></figure>
<p>导入包时，会自动执行<code>__init__.py</code>文件</p>
<h4 id="1-4-2-双下划线开头的attr方法"><a href="#1-4-2-双下划线开头的attr方法" class="headerlink" title="1.4.2 双下划线开头的attr方法"></a>1.4.2 双下划线开头的attr方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    x=<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,y)</span>:</span></span><br><span class="line">        self.y=y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'----&gt; from getattr:你找的属性不存在'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">'----&gt; from setattr'</span>)</span><br><span class="line">        <span class="comment"># self.key=value #这就无限递归了,你好好想想</span></span><br><span class="line">        <span class="comment"># self.__dict__[key]=value #应该使用它</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'----&gt; from delattr'</span>)</span><br><span class="line">        <span class="comment"># del self.item #无限递归了</span></span><br><span class="line">        self.__dict__.pop(item)</span><br><span class="line"></span><br><span class="line"><span class="comment">#__setattr__添加/修改属性会触发它的执行</span></span><br><span class="line">f1=Foo(<span class="number">10</span>)</span><br><span class="line">print(f1.__dict__) <span class="comment"># 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值</span></span><br><span class="line">f1.z=<span class="number">3</span></span><br><span class="line">print(f1.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#__delattr__删除属性的时候会触发</span></span><br><span class="line">f1.__dict__[<span class="string">'a'</span>]=<span class="number">3</span><span class="comment">#我们可以直接修改属性字典,来完成添加/修改属性的操作</span></span><br><span class="line"><span class="keyword">del</span> f1.a</span><br><span class="line">print(f1.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#__getattr__只有在使用点调用属性且属性不存在的时候才会触发</span></span><br><span class="line">f1.xxxxxx</span><br></pre></td></tr></table></figure>
<h4 id="1-4-3-getattribute"><a href="#1-4-3-getattribute" class="headerlink" title="1.4.3 __getattribute__"></a>1.4.3 <code>__getattribute__</code></h4><p>无论属性是否存在，都会触发<code>__getattribute__</code><br>当抛出AttributeError异常时，触发<code>__getattr__</code></p>
<h4 id="1-4-4-授权"><a href="#1-4-4-授权" class="headerlink" title="1.4.4 授权"></a>1.4.4 授权</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,filename,mode=<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>)</span>:</span></span><br><span class="line">        self.file=open(filename,mode,encoding=encoding)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self,line)</span>:</span></span><br><span class="line">        t=time.strftime(<span class="string">'%Y-%m-%d %T'</span>)</span><br><span class="line">        self.file.write(<span class="string">'%s %s'</span> %(t,line))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self.file,item)</span><br><span class="line"></span><br><span class="line">f1=FileHandle(<span class="string">'b.txt'</span>,<span class="string">'w+'</span>)</span><br><span class="line">f1.write(<span class="string">'你好啊'</span>)</span><br><span class="line">f1.seek(<span class="number">0</span>)</span><br><span class="line">print(f1.read())</span><br><span class="line">f1.close()</span><br></pre></td></tr></table></figure>
<h4 id="1-4-5-isinstance-obj-cls-和issubclass-sub-super"><a href="#1-4-5-isinstance-obj-cls-和issubclass-sub-super" class="headerlink" title="1.4.5 isinstance(obj,cls)和issubclass(sub,super)"></a>1.4.5 isinstance(obj,cls)和issubclass(sub,super)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">obj = Foo()</span><br><span class="line">isinstance(obj, Foo) <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(Foo)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">issubclass(Bar, Foo) <span class="comment">#true</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-6-setitem-getitem-delitem"><a href="#1-4-6-setitem-getitem-delitem" class="headerlink" title="1.4.6 __setitem__,__getitem__,__delitem__"></a>1.4.6 <code>__setitem__,__getitem__,__delitem__</code></h4><p>字典（中括号）方式触发的是item操作</p>
<p>点操作触发的是attr操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(self.__dict__[item])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.__dict__[key]=value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(<span class="string">'del obj[key]时,我执行'</span>)</span><br><span class="line">        self.__dict__.pop(key)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'del obj.key时,我执行'</span>)</span><br><span class="line">        self.__dict__.pop(item)</span><br><span class="line"></span><br><span class="line">f1=Foo(<span class="string">'sb'</span>)</span><br><span class="line">f1[<span class="string">'age'</span>]=<span class="number">18</span>    <span class="comment">##__setitem__</span></span><br><span class="line">f1[<span class="string">'age1'</span>]=<span class="number">19</span>	</span><br><span class="line"><span class="keyword">del</span> f1.age1		</span><br><span class="line"><span class="keyword">del</span> f1[<span class="string">'age'</span>]		</span><br><span class="line">f1[<span class="string">'name'</span>]=<span class="string">'alex'</span></span><br><span class="line">print(f1.__dict__)</span><br></pre></td></tr></table></figure>
<h4 id="1-4-7-str-repr-format"><a href="#1-4-7-str-repr-format" class="headerlink" title="1.4.7 __str__,__repr__,__format__"></a>1.4.7 <code>__str__,__repr__,__format__</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line">__author__ = <span class="string">'Linhaifeng'</span></span><br><span class="line">format_dict=&#123;</span><br><span class="line">    <span class="string">'nat'</span>:<span class="string">'&#123;obj.name&#125;-&#123;obj.addr&#125;-&#123;obj.type&#125;'</span>,<span class="comment">#学校名-学校地址-学校类型</span></span><br><span class="line">    <span class="string">'tna'</span>:<span class="string">'&#123;obj.type&#125;:&#123;obj.name&#125;:&#123;obj.addr&#125;'</span>,<span class="comment">#学校类型:学校名:学校地址</span></span><br><span class="line">    <span class="string">'tan'</span>:<span class="string">'&#123;obj.type&#125;/&#123;obj.addr&#125;/&#123;obj.name&#125;'</span>,<span class="comment">#学校类型/学校地址/学校名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,addr,type)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.addr=addr</span><br><span class="line">        self.type=type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'School(%s,%s)'</span> %(self.name,self.addr)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(%s,%s)'</span> %(self.name,self.addr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, format_spec)</span>:</span></span><br><span class="line">        <span class="comment"># if format_spec</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> format_spec <span class="keyword">or</span> format_spec <span class="keyword">not</span> <span class="keyword">in</span> format_dict:</span><br><span class="line">            format_spec=<span class="string">'nat'</span></span><br><span class="line">        fmt=format_dict[format_spec]</span><br><span class="line">        <span class="keyword">return</span> fmt.format(obj=self)</span><br><span class="line"></span><br><span class="line">s1=School(<span class="string">'oldboy1'</span>,<span class="string">'北京'</span>,<span class="string">'私立'</span>)</span><br><span class="line">print(<span class="string">'from repr: '</span>,repr(s1))</span><br><span class="line">print(<span class="string">'from str: '</span>,str(s1))</span><br><span class="line">print(s1)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">str函数或者print函数---&gt;obj.__str__()</span></span><br><span class="line"><span class="string">repr或者交互式解释器---&gt;obj.__repr__()</span></span><br><span class="line"><span class="string">如果__str__没有被定义,那么就会使用__repr__来代替输出</span></span><br><span class="line"><span class="string">注意:这俩方法的返回值必须是字符串,否则抛出异常</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(format(s1,<span class="string">'nat'</span>))</span><br><span class="line">print(format(s1,<span class="string">'tna'</span>))</span><br><span class="line">print(format(s1,<span class="string">'tan'</span>))</span><br><span class="line">print(format(s1,<span class="string">'asfdasdffd'</span>))</span><br></pre></td></tr></table></figure>
<p>自定义format</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">date_dic=&#123;</span><br><span class="line">    <span class="string">'ymd'</span>:<span class="string">'&#123;0.year&#125;:&#123;0.month&#125;:&#123;0.day&#125;'</span>,</span><br><span class="line">    <span class="string">'dmy'</span>:<span class="string">'&#123;0.day&#125;/&#123;0.month&#125;/&#123;0.year&#125;'</span>,</span><br><span class="line">    <span class="string">'mdy'</span>:<span class="string">'&#123;0.month&#125;-&#123;0.day&#125;-&#123;0.year&#125;'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,year,month,day)</span>:</span></span><br><span class="line">        self.year=year</span><br><span class="line">        self.month=month</span><br><span class="line">        self.day=day</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, format_spec)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> format_spec <span class="keyword">or</span> format_spec <span class="keyword">not</span> <span class="keyword">in</span> date_dic:</span><br><span class="line">            format_spec=<span class="string">'ymd'</span></span><br><span class="line">        fmt=date_dic[format_spec]</span><br><span class="line">        <span class="keyword">return</span> fmt.format(self)</span><br><span class="line"></span><br><span class="line">d1=Date(<span class="number">2016</span>,<span class="number">12</span>,<span class="number">29</span>)</span><br><span class="line">print(format(d1))</span><br><span class="line">print(<span class="string">'&#123;:mdy&#125;'</span>.format(d1))</span><br></pre></td></tr></table></figure>
<h4 id="1-4-8-slot"><a href="#1-4-8-slot" class="headerlink" title="1.4.8 __slot__"></a>1.4.8 <code>__slot__</code></h4><p>类的数据属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1.__slots__是什么:是一个类变量,变量值可以是列表,元组,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性)</span></span><br><span class="line"><span class="string">2.引子:使用点来访问属性本质就是在访问类或者对象的__dict__属性字典(类的字典是共享的,而每个实例的是独立的)</span></span><br><span class="line"><span class="string">3.为何使用__slots__:字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用__slots__取代实例的__dict__</span></span><br><span class="line"><span class="string">当你定义__slots__后,__slots__就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个</span></span><br><span class="line"><span class="string">字典,这跟元组或列表很类似。在__slots__中列出的属性名在内部被映射到这个数组的指定小标上。使用__slots__一个不好的地方就是我们不能再给</span></span><br><span class="line"><span class="string">实例添加新的属性了,只能使用在__slots__中定义的那些属性名。</span></span><br><span class="line"><span class="string">4.注意事项:__slots__的很多特性都依赖于普通的基于字典的实现。另外,定义了__slots__后的类不再 支持一些普通类特性了,比如多继承。大多数情况下,你应该</span></span><br><span class="line"><span class="string">只在那些经常被使用到 的用作数据结构的类上定义__slots__比如在程序中需要创建某个类的几百万个实例对象 。</span></span><br><span class="line"><span class="string">关于__slots__的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用__slots__可以达到这样的目的,但是这个并不是它的初衷。           更多的是用来作为一个内存优化工具。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    __slots__=<span class="string">'x'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.x=<span class="number">1</span></span><br><span class="line">f1.y=<span class="number">2</span><span class="comment">#报错</span></span><br><span class="line">print(f1.__slots__) <span class="comment">#f1不再有__dict__</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    __slots__=[<span class="string">'x'</span>,<span class="string">'y'</span>]</span><br><span class="line">    </span><br><span class="line">n=Bar()</span><br><span class="line">n.x,n.y=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">n.z=<span class="number">3</span><span class="comment">#报错</span></span><br><span class="line"></span><br><span class="line">__slots__使用</span><br></pre></td></tr></table></figure>
<h4 id="1-4-9-doc"><a href="#1-4-9-doc" class="headerlink" title="1.4.9 __doc__"></a>1.4.9 <code>__doc__</code></h4><p>无法继承给子类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="string">'我是描述信息'</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(Foo)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(Bar.__doc__) <span class="comment">#该属性无法继承给子类</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-10-module-和-class"><a href="#1-4-10-module-和-class" class="headerlink" title="1.4.10 __module__和__class__"></a>1.4.10 <code>__module__和__class__</code></h4><p><code>__module__</code>表示当前操作的对象在那个模块</p>
<p><code>__class__</code>  表示当前操作的对象的类是什么</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lib.aa <span class="keyword">import</span> C</span><br><span class="line"></span><br><span class="line">obj = C()</span><br><span class="line"><span class="keyword">print</span> obj.__module__  <span class="comment"># 输出 lib.aa，即：输出模块</span></span><br><span class="line"><span class="keyword">print</span> obj.__class__      <span class="comment"># 输出 lib.aa.C，即：输出类</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-11-del"><a href="#1-4-11-del" class="headerlink" title="1.4.11 __del__"></a>1.4.11 <code>__del__</code></h4><p>析构方法，当对象在内存中被释放时，自动触发执行。</p>
<p>注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义<code>__del__</code>,如果产生的对象的同时还会向操作系统发起系统调用，即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了<code>__del__</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'执行我啦'</span>)</span><br><span class="line"></span><br><span class="line">f1=Foo()</span><br><span class="line"><span class="keyword">del</span> f1</span><br><span class="line">print(<span class="string">'-------&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">执行我啦</span><br><span class="line">-------&gt;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-12-call"><a href="#1-4-12-call" class="headerlink" title="1.4.12 __call__"></a>1.4.12 <code>__call__</code></h4><p>对象后面加括号，触发执行。</p>
<p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <code>__call__</code>方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'__call__'</span>)</span><br><span class="line"></span><br><span class="line">obj = Foo() <span class="comment"># 执行 __init__</span></span><br><span class="line">obj()       <span class="comment"># 执行 __call__</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-13-迭代器协议"><a href="#1-4-13-迭代器协议" class="headerlink" title="1.4.13 迭代器协议"></a>1.4.13 迭代器协议</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,start,stop)</span>:</span></span><br><span class="line">        self.num=start</span><br><span class="line">        self.stop=stop</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.num &gt;= self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        n=self.num</span><br><span class="line">        self.num+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">f=Foo(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable,Iterator</span><br><span class="line">print(isinstance(f,Iterator))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Foo(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>斐波那契数列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a=<span class="number">0</span></span><br><span class="line">        self._b=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a,self._b=self._b,self._a + self._b</span><br><span class="line">        <span class="keyword">return</span> self._a</span><br><span class="line"></span><br><span class="line">f1=Fib()</span><br><span class="line"></span><br><span class="line">print(f1.__next__())</span><br><span class="line">print(next(f1))</span><br><span class="line">print(next(f1))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f1:</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'%s '</span> %i,end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-4-14-描述符（-get-set-delete-）"><a href="#1-4-14-描述符（-get-set-delete-）" class="headerlink" title="1.4.14 描述符（__get__,__set__,__delete__）"></a>1.4.14 描述符（<code>__get__,__set__,__delete__</code>）</h4><p>1 描述符是什么:描述符本质就是一个新式类,在这个新式类中,至少实现了<code>__get__(),__set__(),__delete__()</code>中的一个,这也被称为描述符协议<br><code>__get__()</code>:调用一个属性时,触发<br><code>__set__()</code>:为一个属性赋值时,触发<br><code>__delete__()</code>:采用del删除属性时,触发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="comment">#在python3中Foo是新式类,它实现了三种方法,这个类就被称作一个描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">定义一个描述符</span><br></pre></td></tr></table></figure>
<p>2 描述符是干什么的:描述符的作用是用来代理另外一个类的属性的(必须把描述符定义成这个类的类属性，不能定义到构造函数中)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'触发get'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'触发set'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'触发delete'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#包含这三个方法的新式类称为描述符,由这个类产生的实例进行属性的调用/赋值/删除,并不会触发这三个方法</span></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.name=<span class="string">'egon'</span></span><br><span class="line">f1.name</span><br><span class="line"><span class="keyword">del</span> f1.name</span><br><span class="line"><span class="comment">#疑问:何时,何地,会触发这三个方法的执行</span></span><br><span class="line"></span><br><span class="line">引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行</span><br></pre></td></tr></table></figure>
<p>描述符的使用<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#描述符Str</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'Str调用'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'Str设置...'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'Str删除...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#描述符Int</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'Int调用'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'Int设置...'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'Int删除...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    name=Str()</span><br><span class="line">    age=Int()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span> <span class="comment">#name被Str类代理,age被Int类代理,</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"><span class="comment">#何地？：定义成另外一个类的类属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#何时？：且看下列演示</span></span><br><span class="line"></span><br><span class="line">p1=People(<span class="string">'alex'</span>,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#描述符Str的使用</span></span><br><span class="line">p1.name</span><br><span class="line">p1.name=<span class="string">'egon'</span></span><br><span class="line"><span class="keyword">del</span> p1.name</span><br><span class="line"></span><br><span class="line"><span class="comment">#描述符Int的使用</span></span><br><span class="line">p1.age</span><br><span class="line">p1.age=<span class="number">18</span></span><br><span class="line"><span class="keyword">del</span> p1.age</span><br><span class="line"></span><br><span class="line"><span class="comment">#我们来瞅瞅到底发生了什么</span></span><br><span class="line">print(p1.__dict__)</span><br><span class="line">print(People.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#补充</span></span><br><span class="line">print(type(p1) == People) <span class="comment">#type(obj)其实是查看obj是由哪个类实例化来的</span></span><br><span class="line">print(type(p1).__dict__ == People.__dict__)</span><br></pre></td></tr></table></figure></p>
<p>3 描述符分两种<br>一 数据描述符:至少实现了<strong>get</strong>()和<strong>set</strong>()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 class Foo:</span><br><span class="line">2     def __set__(self, instance, value):</span><br><span class="line">3         print(&#39;set&#39;)</span><br><span class="line">4     def __get__(self, instance, owner):</span><br><span class="line">5         print(&#39;get&#39;)</span><br></pre></td></tr></table></figure>
<p>二 非数据描述符:没有实现<strong>set</strong>()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 class Foo:</span><br><span class="line">2     def __get__(self, instance, owner):</span><br><span class="line">3         print(&#39;get&#39;)</span><br></pre></td></tr></table></figure>
<p>4 注意事项:<br>一 描述符本身应该定义成新式类,被代理的类也应该是新式类<br>二 必须把描述符定义成这个类的类属性，不能为定义到构造函数中<br>三 要严格遵循该优先级,优先级由高到底分别是<br>1.类属性<br>2.数据描述符<br>3.实例属性<br>4.非数据描述符<br>5.找不到的属性触发<strong>getattr</strong>()</p>
<p><strong>类属性&gt;数据描述符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#描述符Str</span><br><span class="line">class Str:</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        print(&#39;Str调用&#39;)</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        print(&#39;Str设置...&#39;)</span><br><span class="line">    def __delete__(self, instance):</span><br><span class="line">        print(&#39;Str删除...&#39;)</span><br><span class="line"></span><br><span class="line">class People:</span><br><span class="line">    name&#x3D;Str()</span><br><span class="line">    def __init__(self,name,age): #name被Str类代理,age被Int类代理,</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#基于上面的演示,我们已经知道,在一个类中定义描述符它就是一个类属性,存在于类的属性字典中,而不是实例的属性字典</span><br><span class="line"></span><br><span class="line">#那既然描述符被定义成了一个类属性,直接通过类名也一定可以调用吧,没错</span><br><span class="line">People.name #恩,调用类属性name,本质就是在调用描述符Str,触发了__get__()</span><br><span class="line"></span><br><span class="line">People.name&#x3D;&#39;egon&#39; #那赋值呢,我去,并没有触发__set__()</span><br><span class="line">del People.name #赶紧试试del,我去,也没有触发__delete__()</span><br><span class="line">#结论:描述符对类没有作用--------&gt;傻逼到家的结论</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">原因:描述符在使用时被定义成另外一个类的类属性,因而类属性比二次加工的描述符伪装而来的类属性有更高的优先级</span><br><span class="line">People.name #恩,调用类属性name,找不到就去找描述符伪装的类属性name,触发了__get__()</span><br><span class="line"></span><br><span class="line">People.name&#x3D;&#39;egon&#39; #那赋值呢,直接赋值了一个类属性,它拥有更高的优先级,相当于覆盖了描述符,肯定不会触发描述符的__set__()</span><br><span class="line">del People.name #同上</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>
<p><strong>数据描述符&gt;实例属性</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#描述符Str</span><br><span class="line">class Str:</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        print(&#39;Str调用&#39;)</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        print(&#39;Str设置...&#39;)</span><br><span class="line">    def __delete__(self, instance):</span><br><span class="line">        print(&#39;Str删除...&#39;)</span><br><span class="line"></span><br><span class="line">class People:</span><br><span class="line">    name&#x3D;Str()</span><br><span class="line">    def __init__(self,name,age): #name被Str类代理,age被Int类代理,</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1&#x3D;People(&#39;egon&#39;,18)</span><br><span class="line"></span><br><span class="line">#如果描述符是一个数据描述符(即有__get__又有__set__),那么p1.name的调用与赋值都是触发描述符的操作,于p1本身无关了,相当于覆盖了实例的属性</span><br><span class="line">p1.name&#x3D;&#39;egonnnnnn&#39;</span><br><span class="line">p1.name</span><br><span class="line">print(p1.__dict__)#实例的属性字典中没有name,因为name是一个数据描述符,优先级高于实例属性,查看&#x2F;赋值&#x2F;删除都是跟描述符有关,与实例无关了</span><br><span class="line">del p1.name</span><br></pre></td></tr></table></figure><br><strong>实例属性&gt;非数据描述符 </strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def func(self):</span><br><span class="line">        print(&#39;我胡汉三又回来了&#39;)</span><br><span class="line">f1&#x3D;Foo()</span><br><span class="line">f1.func() #调用类的方法,也可以说是调用非数据描述符</span><br><span class="line">#函数是一个非数据描述符对象(一切皆对象么)</span><br><span class="line">print(dir(Foo.func))</span><br><span class="line">print(hasattr(Foo.func,&#39;__set__&#39;))</span><br><span class="line">print(hasattr(Foo.func,&#39;__get__&#39;))</span><br><span class="line">print(hasattr(Foo.func,&#39;__delete__&#39;))</span><br><span class="line">#有人可能会问,描述符不都是类么,函数怎么算也应该是一个对象啊,怎么就是描述符了</span><br><span class="line">#笨蛋哥,描述符是类没问题,描述符在应用的时候不都是实例化成一个类属性么</span><br><span class="line">#函数就是一个由非描述符类实例化得到的对象</span><br><span class="line">#没错，字符串也一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1.func&#x3D;&#39;这是实例属性啊&#39;</span><br><span class="line">print(f1.func)</span><br><span class="line"></span><br><span class="line">del f1.func #删掉了非数据</span><br><span class="line">f1.func()</span><br></pre></td></tr></table></figure>
<p><strong>再次验证：实例属性&gt;非数据描述符</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        print(&#39;set&#39;)</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        print(&#39;get&#39;)</span><br><span class="line">class Room:</span><br><span class="line">    name&#x3D;Foo()</span><br><span class="line">    def __init__(self,name,width,length):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.width&#x3D;width</span><br><span class="line">        self.length&#x3D;length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#name是一个数据描述符,因为name&#x3D;Foo()而Foo实现了get和set方法,因而比实例属性有更高的优先级</span><br><span class="line">#对实例的属性操作,触发的都是描述符的</span><br><span class="line">r1&#x3D;Room(&#39;厕所&#39;,1,1)</span><br><span class="line">r1.name</span><br><span class="line">r1.name&#x3D;&#39;厨房&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        print(&#39;get&#39;)</span><br><span class="line">class Room:</span><br><span class="line">    name&#x3D;Foo()</span><br><span class="line">    def __init__(self,name,width,length):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.width&#x3D;width</span><br><span class="line">        self.length&#x3D;length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#name是一个非数据描述符,因为name&#x3D;Foo()而Foo没有实现set方法,因而比实例属性有更低的优先级</span><br><span class="line">#对实例的属性操作,触发的都是实例自己的</span><br><span class="line">r1&#x3D;Room(&#39;厕所&#39;,1,1)</span><br><span class="line">r1.name</span><br><span class="line">r1.name&#x3D;&#39;厨房&#39;</span><br></pre></td></tr></table></figure><br><strong>非数据描述符&gt;找不到</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def func(self):</span><br><span class="line">        print(&#39;我胡汉三又回来了&#39;)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        print(&#39;找不到了当然是来找我啦&#39;,item)</span><br><span class="line">f1&#x3D;Foo()</span><br><span class="line"></span><br><span class="line">f1.xxxxxxxxxxx</span><br></pre></td></tr></table></figure></p>
<p>描述符的使用(类型检查)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typed</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,expected_type)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.expected_type=expected_type</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'get---&gt;'</span>,instance,owner)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'set---&gt;'</span>,instance,value)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value,self.expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected %s'</span> %str(self.expected_type))</span><br><span class="line">        instance.__dict__[self.name]=value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'delete---&gt;'</span>,instance)</span><br><span class="line">        instance.__dict__.pop(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    name=Typed(<span class="string">'name'</span>,str)</span><br><span class="line">    age=Typed(<span class="string">'name'</span>,int)</span><br><span class="line">    salary=Typed(<span class="string">'name'</span>,float)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,salary)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.salary=salary</span><br><span class="line"></span><br><span class="line">p1=People(<span class="number">123</span>,<span class="number">18</span>,<span class="number">3333.3</span>)</span><br><span class="line">p1=People(<span class="string">'egon'</span>,<span class="string">'18'</span>,<span class="number">3333.3</span>)</span><br><span class="line">p1=People(<span class="string">'egon'</span>,<span class="number">18</span>,<span class="number">3333</span>)</span><br><span class="line"></span><br><span class="line">大刀阔斧</span><br></pre></td></tr></table></figure>
<p>描述符+类装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typed</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,expected_type)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.expected_type=expected_type</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'get---&gt;'</span>,instance,owner)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'set---&gt;'</span>,instance,value)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value,self.expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected %s'</span> %str(self.expected_type))</span><br><span class="line">        instance.__dict__[self.name]=value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'delete---&gt;'</span>,instance)</span><br><span class="line">        instance.__dict__.pop(self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeassert</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'类的装饰器开始运行啦------&gt;'</span>,kwargs)</span><br><span class="line">        <span class="keyword">for</span> name,expected_type <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            setattr(cls,name,Typed(name,expected_type))</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"><span class="meta">@typeassert(name=str,age=int,salary=float) #有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,salary)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.salary=salary</span><br><span class="line"></span><br><span class="line">print(People.__dict__)</span><br><span class="line">p1=People(<span class="string">'egon'</span>,<span class="number">18</span>,<span class="number">3333.3</span>)</span><br><span class="line"></span><br><span class="line">刀光剑影</span><br></pre></td></tr></table></figure>
<p>property底层魔法的实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lazyproperty</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        self.func=func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'这是我们自己定制的静态属性,r1.area实际是要执行r1.area()'</span>)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> self.func(instance) <span class="comment">#此时你应该明白,到底是谁在为你做自动传递self的事情</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,width,length)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.width=width</span><br><span class="line">        self.length=length</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Lazyproperty #area=Lazyproperty(area) 相当于定义了一个类属性,即描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.width * self.length</span><br><span class="line"></span><br><span class="line">r1=Room(<span class="string">'alex'</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">print(r1.area)</span><br><span class="line"></span><br><span class="line">自己做一个@property</span><br></pre></td></tr></table></figure>
<p>延迟计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lazyproperty</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        self.func=func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'这是我们自己定制的静态属性,r1.area实际是要执行r1.area()'</span>)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'---&gt;'</span>)</span><br><span class="line">            value=self.func(instance)</span><br><span class="line">            setattr(instance,self.func.__name__,value) <span class="comment">#计算一次就缓存到实例的属性字典中</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,width,length)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.width=width</span><br><span class="line">        self.length=length</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Lazyproperty #area=Lazyproperty(area) 相当于'定义了一个类属性,即描述符'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.width * self.length</span><br><span class="line"></span><br><span class="line">r1=Room(<span class="string">'alex'</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">print(r1.area) <span class="comment">#先从自己的属性字典找,没有再去类的中找,然后出发了area的__get__方法</span></span><br><span class="line">print(r1.area) <span class="comment">#先从自己的属性字典找,找到了,是上次计算的结果,这样就不用每执行一次都去计算</span></span><br><span class="line"></span><br><span class="line">实现延迟计算功能</span><br></pre></td></tr></table></figure>
<h4 id="1-4-15-enter-exit"><a href="#1-4-15-enter-exit" class="headerlink" title="1.4.15 __enter__/__exit__"></a>1.4.15 <code>__enter__/__exit__</code></h4><p>我们知道在操作文件对象的时候可以这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 with open(&#39;a.txt&#39;) as f:</span><br><span class="line">2 　　&#39;代码块&#39;</span><br></pre></td></tr></table></figure>
<p>上述叫做上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象的类中声明<code>__enter__</code>和<code>__exit__</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Open</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量'</span>)</span><br><span class="line">        <span class="comment"># return self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'with中代码块执行完毕时执行我啊'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Open(<span class="string">'a.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'=====&gt;执行代码块'</span>)</span><br><span class="line">    <span class="comment"># print(f,f.name)</span></span><br><span class="line"></span><br><span class="line">上下文管理协议</span><br></pre></td></tr></table></figure>
<p><code>__exit__()</code>中的三个参数分别代表异常类型，异常值和追溯信息,with语句中代码块出现异常，则with后的代码都无法执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Open</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'with中代码块执行完毕时执行我啊'</span>)</span><br><span class="line">        print(exc_type)</span><br><span class="line">        print(exc_val)</span><br><span class="line">        print(exc_tb)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Open(<span class="string">'a.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'=====&gt;执行代码块'</span>)</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">'***着火啦,救火啊***'</span>)</span><br><span class="line">print(<span class="string">'0'</span>*<span class="number">100</span>) <span class="comment">#-------------------------------&gt;不会执行</span></span><br></pre></td></tr></table></figure>
<p>如果<code>__exit__()</code>返回值为True,那么异常会被清空，就好像啥都没发生一样，with后的语句正常执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Open</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'with中代码块执行完毕时执行我啊'</span>)</span><br><span class="line">        print(exc_type)</span><br><span class="line">        print(exc_val)</span><br><span class="line">        print(exc_tb)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Open(<span class="string">'a.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'=====&gt;执行代码块'</span>)</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">'***着火啦,救火啊***'</span>)</span><br><span class="line">print(<span class="string">'0'</span>*<span class="number">100</span>) <span class="comment">#-------------------------------&gt;会执行</span></span><br></pre></td></tr></table></figure>
<p>模拟open</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Open</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,filepath,mode=<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>)</span>:</span></span><br><span class="line">        self.filepath=filepath</span><br><span class="line">        self.mode=mode</span><br><span class="line">        self.encoding=encoding</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># print('enter')</span></span><br><span class="line">        self.f=open(self.filepath,mode=self.mode,encoding=self.encoding)</span><br><span class="line">        <span class="keyword">return</span> self.f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="comment"># print('exit')</span></span><br><span class="line">        self.f.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self.f,item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Open(<span class="string">'a.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f)</span><br><span class="line">    f.write(<span class="string">'aaaaaa'</span>)</span><br><span class="line">    f.wasdf <span class="comment">#抛出异常，交给__exit__处理</span></span><br><span class="line"></span><br><span class="line">练习：模拟Open</span><br></pre></td></tr></table></figure>
<h4 id="1-4-16-类的装饰器"><a href="#1-4-16-类的装饰器" class="headerlink" title="1.4.16 类的装饰器"></a>1.4.16 类的装饰器</h4><p>无参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">'类的装饰器开始运行啦------&gt;'</span>)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate #无参:People=decorate(People)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,salary)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.salary=salary</span><br><span class="line"></span><br><span class="line">p1=People(<span class="string">'egon'</span>,<span class="number">18</span>,<span class="number">3333.3</span>)</span><br></pre></td></tr></table></figure>
<p>带参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeassert</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'类的装饰器开始运行啦------&gt;'</span>,kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"><span class="meta">@typeassert(name=str,age=int,salary=float) #有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,salary)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.salary=salary</span><br><span class="line"></span><br><span class="line">p1=People(<span class="string">'egon'</span>,<span class="number">18</span>,<span class="number">3333.3</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-4-17-再看property"><a href="#1-4-17-再看property" class="headerlink" title="1.4.17 再看property"></a>1.4.17 再看property</h4><p>用法一</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'get的时候运行我啊'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @AAA.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">'set的时候运行我啊'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @AAA.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'delete的时候运行我啊'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#只有在属性AAA定义property后才能定义AAA.setter,AAA.deleter</span></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.AAA</span><br><span class="line">f1.AAA=<span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">del</span> f1.AAA</span><br><span class="line"></span><br><span class="line">用法一</span><br></pre></td></tr></table></figure>
<p>用法二</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'get的时候运行我啊'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_AAA</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">'set的时候运行我啊'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'delete的时候运行我啊'</span>)</span><br><span class="line">    AAA=property(get_AAA,set_AAA,delete_AAA) <span class="comment">#内置property三个参数与get,set,delete一一对应</span></span><br><span class="line"></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.AAA</span><br><span class="line">f1.AAA=<span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">del</span> f1.AAA</span><br><span class="line"></span><br><span class="line">用法二</span><br></pre></td></tr></table></figure>
<h4 id="1-4-18-元类-metaclass"><a href="#1-4-18-元类-metaclass" class="headerlink" title="1.4.18 元类 metaclass"></a>1.4.18 元类 metaclass</h4><p><a href="http://www.cnblogs.com/linhaifeng/articles/8029564.html" target="_blank" rel="noopener">http://www.cnblogs.com/linhaifeng/articles/8029564.html</a></p>
<p><img src="./image/7.png" alt=""></p>
<h5 id="class关键字创建类的流程分析"><a href="#class关键字创建类的流程分析" class="headerlink" title="class关键字创建类的流程分析"></a>class关键字创建类的流程分析</h5><p>上文我们基于python中一切皆为对象的概念分析出：我们用class关键字定义的类本身也是一个对象，负责产生该对象的类称之为元类（元类可以简称为类的类），内置的元类为type</p>
<p>class关键字在帮我们创建类时，必然帮我们调用了元类OldboyTeacher=type(…)，那调用type时传入的参数是什么呢？必然是类的关键组成部分，一个类有三大组成部分，分别是<br>1、类名class_name=’OldboyTeacher’<br>2、基类们class_bases=(object,)<br>3、类的名称空间class_dic，类的名称空间是执行类体代码而得到的<br>调用type时会依次传入以上三个参数<br>综上，class关键字帮我们创建一个类应该细分为以下四个过程<br><img src="./image/8.png" alt=""></p>
<p>自定义元类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mymeta</span><span class="params">(type)</span>:</span> <span class="comment">#只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span> <span class="comment">#self=&lt;class '__main__.OldboyTeacher'&gt;</span></span><br><span class="line">        <span class="comment">#1、调用__new__产生一个空对象obj</span></span><br><span class="line">        obj=self.__new__(self) <span class="comment"># 此处的self是类OldoyTeacher，必须传参，代表创建一个OldboyTeacher的对象obj</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#2、调用__init__初始化空对象obj</span></span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在初始化之后，obj.__dict__里就有值了</span></span><br><span class="line">        obj.__dict__=&#123;<span class="string">'_%s__%s'</span> %(self.__name__,k):v <span class="keyword">for</span> k,v <span class="keyword">in</span> obj.__dict__.items()&#125;</span><br><span class="line">        <span class="comment">#3、返回初始化好的对象obj</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldboyTeacher</span><span class="params">(object,metaclass=Mymeta)</span>:</span></span><br><span class="line">    school=<span class="string">'oldboy'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s says welcome to the oldboy to learn Python'</span> %self.name)</span><br><span class="line"></span><br><span class="line">t1=OldboyTeacher(<span class="string">'egon'</span>,<span class="number">18</span>)</span><br><span class="line">print(t1.__dict__) <span class="comment">#&#123;'_OldboyTeacher__name': 'egon', '_OldboyTeacher__age': 18&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="自定义元类控制类OldboyTeacher的调用"><a href="#自定义元类控制类OldboyTeacher的调用" class="headerlink" title="自定义元类控制类OldboyTeacher的调用"></a>自定义元类控制类OldboyTeacher的调用</h5><p>储备知识：<strong>call</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(self)</span><br><span class="line">        print(args)</span><br><span class="line">        print(kwargs)</span><br><span class="line"></span><br><span class="line">obj&#x3D;Foo()</span><br><span class="line">#1、要想让obj这个对象变成一个可调用的对象，需要在该对象的类中定义一个方法__call__方法，该方法会在调用对象时自动触发</span><br><span class="line">#2、调用obj的返回值就是__call__方法的返回值</span><br><span class="line">res&#x3D;obj(1,2,3,x&#x3D;1,y&#x3D;2)</span><br></pre></td></tr></table></figure></p>
<p>由上例得知，调用一个对象，就是触发对象所在类中的<strong>call</strong>方法的执行，如果把OldboyTeacher也当做一个对象，那么在OldboyTeacher这个对象的类中也必然存在一个<strong>call</strong>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(self) #&lt;class &#39;__main__.OldboyTeacher&#39;&gt;</span><br><span class="line">        print(args) #(&#39;egon&#39;, 18)</span><br><span class="line">        print(kwargs) #&#123;&#125;</span><br><span class="line">        return 123</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(object,metaclass&#x3D;Mymeta):</span><br><span class="line">    school&#x3D;&#39;oldboy&#39;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用OldboyTeacher就是在调用OldboyTeacher类中的__call__方法</span><br><span class="line"># 然后将OldboyTeacher传给self,溢出的位置参数传给*，溢出的关键字参数传给**</span><br><span class="line"># 调用OldboyTeacher的返回值就是调用__call__的返回值</span><br><span class="line">t1&#x3D;OldboyTeacher(&#39;egon&#39;,18)</span><br><span class="line">print(t1) #123</span><br></pre></td></tr></table></figure>
<p>默认地，调用t1=OldboyTeacher(‘egon’,18)会做三件事<br>1、产生一个空对象obj<br>2、调用<strong>init</strong>方法初始化对象obj<br>3、返回初始化好的obj<br>对应着，OldboyTeacher类中的<strong>call</strong>方法也应该做这三件事</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span><br><span class="line">    def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.OldboyTeacher&#39;&gt;</span><br><span class="line">        #1、调用__new__产生一个空对象obj</span><br><span class="line">        obj&#x3D;self.__new__(self) # 此处的self是类OldoyTeacher，必须传参，代表创建一个OldboyTeacher的对象obj</span><br><span class="line"></span><br><span class="line">        #2、调用__init__初始化空对象obj</span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line"></span><br><span class="line">        #3、返回初始化好的对象obj</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(object,metaclass&#x3D;Mymeta):</span><br><span class="line">    school&#x3D;&#39;oldboy&#39;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name)</span><br><span class="line"></span><br><span class="line">t1&#x3D;OldboyTeacher(&#39;egon&#39;,18)</span><br><span class="line">print(t1.__dict__) #&#123;&#39;name&#39;: &#39;egon&#39;, &#39;age&#39;: 18&#125;</span><br></pre></td></tr></table></figure>
<p>上例的<strong>call</strong>相当于一个模板，我们可以在该基础上改写<strong>call</strong>的逻辑从而控制调用OldboyTeacher的过程，比如将OldboyTeacher的对象的所有属性都变成私有的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span><br><span class="line">    def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.OldboyTeacher&#39;&gt;</span><br><span class="line">        #1、调用__new__产生一个空对象obj</span><br><span class="line">        obj&#x3D;self.__new__(self) # 此处的self是类OldoyTeacher，必须传参，代表创建一个OldboyTeacher的对象obj</span><br><span class="line"></span><br><span class="line">        #2、调用__init__初始化空对象obj</span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line"></span><br><span class="line">        # 在初始化之后，obj.__dict__里就有值了</span><br><span class="line">        obj.__dict__&#x3D;&#123;&#39;_%s__%s&#39; %(self.__name__,k):v for k,v in obj.__dict__.items()&#125;</span><br><span class="line">        #3、返回初始化好的对象obj</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(object,metaclass&#x3D;Mymeta):</span><br><span class="line">    school&#x3D;&#39;oldboy&#39;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name)</span><br><span class="line"></span><br><span class="line">t1&#x3D;OldboyTeacher(&#39;egon&#39;,18)</span><br><span class="line">print(t1.__dict__) #&#123;&#39;_OldboyTeacher__name&#39;: &#39;egon&#39;, &#39;_OldboyTeacher__age&#39;: 18&#125;</span><br></pre></td></tr></table></figure>
<p>上例中涉及到查找属性的问题，比如self.<strong>new</strong>，请看下一小节</p>
<h5 id="再看属性查找"><a href="#再看属性查找" class="headerlink" title="再看属性查找"></a>再看属性查找</h5><p>结合python继承的实现原理+元类重新看属性的查找应该是什么样子呢？？？<br>在学习完元类后，其实我们用class自定义的类也全都是对象（包括object类本身也是元类type的 一个实例，可以用type(object)查看），我们学习过继承的实现原理，如果把类当成对象去看，将下述继承应该说成是：对象OldboyTeacher继承对象Foo，对象Foo继承对象Bar，对象Bar继承对象object</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span><br><span class="line">    n&#x3D;444</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.OldboyTeacher&#39;&gt;</span><br><span class="line">        obj&#x3D;self.__new__(self)</span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">class Bar(object):</span><br><span class="line">    n&#x3D;333</span><br><span class="line"></span><br><span class="line">class Foo(Bar):</span><br><span class="line">    n&#x3D;222</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(Foo,metaclass&#x3D;Mymeta):</span><br><span class="line">    n&#x3D;111</span><br><span class="line"></span><br><span class="line">    school&#x3D;&#39;oldboy&#39;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(OldboyTeacher.n) #自下而上依次注释各个类中的n&#x3D;xxx，然后重新运行程序，发现n的查找顺序为OldboyTeacher-&gt;Foo-&gt;Bar-&gt;object-&gt;Mymeta-&gt;type</span><br></pre></td></tr></table></figure>
<p>于是属性查找应该分成两层，一层是对象层（基于c3算法的MRO）的查找，另外一个层则是类层（即元类层）的查找</p>
<p><img src="./image/9.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查找顺序：</span><br><span class="line">#1、先对象层：OldoyTeacher-&gt;Foo-&gt;Bar-&gt;object</span><br><span class="line">#2、然后元类层：Mymeta-&gt;type</span><br></pre></td></tr></table></figure>
<p>依据上述总结，我们来分析下元类Mymeta中<strong>call</strong>里的self.<strong>new</strong>的查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Mymeta(type): </span><br><span class="line">    n&#x3D;444</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs): #self&#x3D;&lt;class &#39;__main__.OldboyTeacher&#39;&gt;</span><br><span class="line">        obj&#x3D;self.__new__(self)</span><br><span class="line">        print(self.__new__ is object.__new__) #True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Bar(object):</span><br><span class="line">    n&#x3D;333</span><br><span class="line"></span><br><span class="line">    # def __new__(cls, *args, **kwargs):</span><br><span class="line">    #     print(&#39;Bar.__new__&#39;)</span><br><span class="line"></span><br><span class="line">class Foo(Bar):</span><br><span class="line">    n&#x3D;222</span><br><span class="line"></span><br><span class="line">    # def __new__(cls, *args, **kwargs):</span><br><span class="line">    #     print(&#39;Foo.__new__&#39;)</span><br><span class="line"></span><br><span class="line">class OldboyTeacher(Foo,metaclass&#x3D;Mymeta):</span><br><span class="line">    n&#x3D;111</span><br><span class="line"></span><br><span class="line">    school&#x3D;&#39;oldboy&#39;</span><br><span class="line"></span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">        self.age&#x3D;age</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&#39;%s says welcome to the oldboy to learn Python&#39; %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # def __new__(cls, *args, **kwargs):</span><br><span class="line">    #     print(&#39;OldboyTeacher.__new__&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OldboyTeacher(&#39;egon&#39;,18) #触发OldboyTeacher的类中的__call__方法的执行，进而执行self.__new__开始查找</span><br></pre></td></tr></table></figure>
<p>总结，Mymeta下的<code>__call__</code>里的<code>self.__new__</code>在OldboyTeacher、Foo、Bar里都没有找到<code>__new__</code>的情况下，会去找object里的<code>__new__</code>，而object下默认就有一个<code>__new__</code>，所以即便是之前的类均未实现<code>__new__</code>,也一定会在object中找到一个，根本不会、也根本没必要再去找元类Mymeta-&gt;type中查找<code>__new__</code></p>
<p>我们在元类的<strong>call</strong>中也可以用object.<strong>new</strong>(self)去造对象</p>
<p><img src="./image/10.png" alt=""></p>
<p><strong>但我们还是推荐在<code>__call__</code>中使用<code>self.__new__（self）</code>去创造空对象，因为这种方式会检索三个类OldboyTeacher-&gt;Foo-&gt;Bar,而<code>object.__new__</code>则是直接跨过了他们三个</strong></p>
<p>最后说明一点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mymeta</span><span class="params">(type)</span>:</span> <span class="comment">#只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span></span><br><span class="line">    n=<span class="number">444</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        obj=type.__new__(cls,*args,**kwargs) <span class="comment"># 必须按照这种传值方式</span></span><br><span class="line">        print(obj.__dict__)</span><br><span class="line">        <span class="comment"># return obj # 只有在返回值是type的对象时，才会触发下面的__init__</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,class_name,class_bases,class_dic)</span>:</span></span><br><span class="line">        print(<span class="string">'run。。。'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldboyTeacher</span><span class="params">(object,metaclass=Mymeta)</span>:</span> <span class="comment">#OldboyTeacher=Mymeta('OldboyTeacher',(object),&#123;...&#125;)</span></span><br><span class="line">    n=<span class="number">111</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">'oldboy'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s says welcome to the oldboy to learn Python'</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(type(Mymeta)) <span class="comment">#&lt;class 'type'&gt;</span></span><br><span class="line"><span class="comment"># 产生类OldboyTeacher的过程就是在调用Mymeta，而Mymeta也是type类的一个对象，那么Mymeta之所以可以调用，一定是在元类type中有一个__call__方法</span></span><br><span class="line"><span class="comment"># 该方法中同样需要做至少三件事：</span></span><br><span class="line"><span class="comment"># class type:</span></span><br><span class="line"><span class="comment">#     def __call__(self, *args, **kwargs): #self=&lt;class '__main__.Mymeta'&gt;</span></span><br><span class="line"><span class="comment">#         obj=self.__new__(self,*args,**kwargs) # 产生Mymeta的一个对象</span></span><br><span class="line"><span class="comment">#         self.__init__(obj,*args,**kwargs) </span></span><br><span class="line"><span class="comment">#         return obj</span></span><br></pre></td></tr></table></figure>
<h3 id="2-软件目录结构规范"><a href="#2-软件目录结构规范" class="headerlink" title="2. 软件目录结构规范"></a>2. 软件目录结构规范</h3><h4 id="为什么要设计好目录结构"><a href="#为什么要设计好目录结构" class="headerlink" title="为什么要设计好目录结构?"></a>为什么要设计好目录结构?</h4><p>“设计项目目录结构”，就和”代码编码风格”一样，属于个人风格问题。对于这种风格上的规范，一直都存在两种态度:</p>
<ol>
<li>一类同学认为，这种个人风格问题”无关紧要”。理由是能让程序work就好，风格问题根本不是问题。</li>
<li>另一类同学认为，规范化能更好的控制程序结构，让程序具有更高的可读性。</li>
</ol>
<p>我是比较偏向于后者的，因为我是前一类同学思想行为下的直接受害者。我曾经维护过一个非常不好读的项目，其实现的逻辑并不复杂，但是却耗费了我非常长的时间去理解它想表达的意思。从此我个人对于提高项目可读性、可维护性的要求就很高了。”项目目录结构”其实也是属于”可读性和可维护性”的范畴，我们设计一个层次清晰的目录结构，就是为了达到以下两点:</p>
<ol>
<li>可读性高: 不熟悉这个项目的代码的人，一眼就能看懂目录结构，知道程序启动脚本是哪个，测试目录在哪儿，配置文件在哪儿等等。从而非常快速的了解这个项目。</li>
<li>可维护性高: 定义好组织规则后，维护者就能很明确地知道，新增的哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，仍然能够组织良好。</li>
</ol>
<p>所以，我认为，保持一个层次清晰的目录结构是有必要的。更何况组织一个良好的工程目录，其实是一件很简单的事儿。</p>
<h4 id="目录组织方式"><a href="#目录组织方式" class="headerlink" title="目录组织方式"></a>目录组织方式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Foo</span><br><span class="line">|-- bin/             </span><br><span class="line">|   |-- <span class="comment">#执行文件，启动脚本，初始化脚本（小的脚本文件，相当于程序入口）</span></span><br><span class="line">|-- conf/</span><br><span class="line">|   |-- <span class="comment">#配置文件</span></span><br><span class="line">|-- db/</span><br><span class="line">|   |-- <span class="comment">#保存数据,可以细分</span></span><br><span class="line">|-- lib/</span><br><span class="line">|   |-- <span class="comment">#公共的类库</span></span><br><span class="line">|-- log/</span><br><span class="line">|   |-- <span class="comment">#日志信息，调试信息，报错信息</span></span><br><span class="line">|-- src/       <span class="comment">#core/</span></span><br><span class="line">|   |-- <span class="comment">#核心的逻辑</span></span><br></pre></td></tr></table></figure>
<p>关于如何组织一个较好的Python工程目录结构，已经有一些得到了共识的目录结构。在Stackoverflow的<a href="http://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application" target="_blank" rel="noopener">这个问题</a>上，能看到大家对Python目录结构的讨论。</p>
<p>这里面说的已经很好了，我也不打算重新造轮子列举各种不同的方式，这里面我说一下我的理解和体会。</p>
<p>假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Foo&#x2F;</span><br><span class="line">|-- bin&#x2F;</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- foo&#x2F;</span><br><span class="line">|   |-- tests&#x2F;</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- test_main.py</span><br><span class="line">|   |</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py</span><br><span class="line">|</span><br><span class="line">|-- docs&#x2F;</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure>
<p>简要解释一下:</p>
<ol>
<li><code>bin/</code>: 存放项目的一些可执行文件，当然你可以起名<code>script/</code>之类的也行。</li>
<li><code>foo/</code>: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录<code>tests/</code>存放单元测试代码； (3) 程序的入口最好命名为<code>main.py</code>。</li>
<li><code>docs/</code>: 存放一些文档。</li>
<li><code>setup.py</code>: 安装、部署、打包的脚本。</li>
<li><code>requirements.txt</code>: 存放软件依赖的外部Python包列表。</li>
<li><code>README</code>: 项目说明文件。</li>
</ol>
<p>除此之外，有一些方案给出了更加多的内容。比如<code>LICENSE.txt</code>,<code>ChangeLog.txt</code>文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考<a href="http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>下面，再简单讲一下我对这些目录的理解和个人要求吧。</p>
<h4 id="关于README的内容"><a href="#关于README的内容" class="headerlink" title="关于README的内容"></a>关于README的内容</h4><p><strong>这个我觉得是每个项目都应该有的一个文件</strong>，目的是能简要描述该项目的信息，让读者快速了解这个项目。</p>
<p>它需要说明以下几个事项:</p>
<ol>
<li>软件定位，软件的基本功能。</li>
<li>运行代码的方法: 安装环境、启动命令等。</li>
<li>简要的使用说明。</li>
<li>代码目录结构说明，更详细点可以说明软件的基本原理。</li>
<li>常见问题说明。</li>
</ol>
<p>我觉得有以上几点是比较好的一个<code>README</code>。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。</p>
<p>可以参考Redis源码中<a href="https://github.com/antirez/redis#what-is-redis" target="_blank" rel="noopener">Readme</a>的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。</p>
<h4 id="关于requirements-txt和setup-py"><a href="#关于requirements-txt和setup-py" class="headerlink" title="关于requirements.txt和setup.py"></a>关于requirements.txt和setup.py</h4><h4 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h4><p>一般来说，用<code>setup.py</code>来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">setuptools</a>来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，<strong>一个项目一定要有一个安装部署工具</strong>，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p>
<p>这个我是踩过坑的。</p>
<p>我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题:</p>
<ol>
<li>安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。</li>
<li>Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。</li>
<li>如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。</li>
<li>新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。</li>
</ol>
<p><code>setup.py</code>可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。</p>
<p>setuptools的<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">文档</a>比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: <a href="https://github.com/mitsuhiko/flask/blob/master/setup.py" target="_blank" rel="noopener">setup.py</a></p>
<p>当然，简单点自己写个安装脚本（<code>deploy.sh</code>）替代<code>setup.py</code>也未尝不可。</p>
<h4 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h4><p>这个文件存在的目的是:</p>
<ol>
<li>方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在<code>setup.py</code>安装依赖时漏掉软件包。</li>
<li>方便读者明确项目使用了哪些Python包。</li>
</ol>
<p>这个文件的格式是每一行包含一个包依赖的说明，通常是<code>flask&gt;=0.10</code>这种格式，要求是这个格式能被<code>pip</code>识别，这样就可以简单的通过 <code>pip install -r requirements.txt</code>来把所有Python包依赖都装好了。具体格式说明： <a href="https://pip.readthedocs.org/en/1.1/requirements.html" target="_blank" rel="noopener">点这里</a>。</p>
<h4 id="关于配置文件的使用方法"><a href="#关于配置文件的使用方法" class="headerlink" title="关于配置文件的使用方法"></a>关于配置文件的使用方法</h4><h4 id="注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。"><a href="#注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。" class="headerlink" title="注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。"></a>注意，在上面的目录结构中，没有将<code>conf.py</code>放在源码目录下，而是放在<code>docs/</code>目录下。</h4><p>很多项目对配置文件的使用做法是:</p>
<ol>
<li>配置文件写在一个或多个python文件中，比如此处的conf.py。</li>
<li>项目中哪个模块用到这个配置文件就直接通过<code>import conf</code>这种形式来在代码中使用配置。</li>
</ol>
<p>这种做法我不太赞同:</p>
<ol>
<li>这让单元测试变得困难（因为模块内部依赖了外部配置）</li>
<li>另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。</li>
<li>程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖<code>conf.py</code>这个文件。</li>
</ol>
<p>所以，我认为配置的使用，更好的方式是，</p>
<ol>
<li>模块的配置都是可以灵活配置的，不受外部配置文件的影响。</li>
<li>程序的配置也是可以灵活控制的。</li>
</ol>
<p>能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。</p>
<p>所以，不应当在代码中直接<code>import conf</code>来使用配置文件。上面目录结构中的<code>conf.py</code>，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给<code>main.py</code>启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的<code>conf.py</code>你可以换个类似的名字，比如<code>settings.py</code>。或者你也可以使用其他格式的内容来编写配置文件，比如<code>settings.yaml</code>之类的。</p>
<h2 id="七、异常处理"><a href="#七、异常处理" class="headerlink" title="七、异常处理"></a>七、异常处理</h2><p><a href="http://www.cnblogs.com/linhaifeng/articles/6232220.html" target="_blank" rel="noopener">http://www.cnblogs.com/linhaifeng/articles/6232220.html</a></p>
<p><strong>常用的异常种类</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x</span><br><span class="line">IOError 输入/输出异常；基本上是无法打开文件</span><br><span class="line">ImportError 无法引入模块或包；基本上是路径问题或名称错误</span><br><span class="line">IndentationError 语法错误（的子类） ；代码没有正确对齐</span><br><span class="line">IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[<span class="number">5</span>]</span><br><span class="line">KeyError 试图访问字典里不存在的键</span><br><span class="line">KeyboardInterrupt Ctrl+C被按下</span><br><span class="line">NameError 使用一个还未被赋予对象的变量</span><br><span class="line">SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）</span><br><span class="line">TypeError 传入对象类型与要求的不符合</span><br><span class="line">UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，</span><br><span class="line">导致你以为正在访问它</span><br><span class="line">ValueError 传入一个调用者不期望的值，即使值的类型是正确的</span><br></pre></td></tr></table></figure>
<p><strong>如果错误发生的条件是可预知的，我们需要用if进行处理：在错误发生之前进行预防</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AGE&#x3D;10</span><br><span class="line">while True:</span><br><span class="line">    age&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">    if age.isdigit(): #只有在age为字符串形式的整数时,下列代码才不会出错,该条件是可预知的</span><br><span class="line">        age&#x3D;int(age)</span><br><span class="line">        if age &#x3D;&#x3D; AGE:</span><br><span class="line">            print(&#39;you got it&#39;)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>
<p><strong>如果错误发生的条件是不可预知的，则需要用到try…except：在错误发生之后进行处理</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#基本语法为</span><br><span class="line">try:</span><br><span class="line">    被检测的代码块</span><br><span class="line">except 异常类型：</span><br><span class="line">    try中一旦检测到异常，就执行这个位置的逻辑</span><br><span class="line">#举例</span><br><span class="line">try:</span><br><span class="line">    f&#x3D;open(&#39;a.txt&#39;)</span><br><span class="line">    g&#x3D;(line.strip() for line in f)</span><br><span class="line">    print(next(g))</span><br><span class="line">    print(next(g))</span><br><span class="line">    print(next(g))</span><br><span class="line">    print(next(g))</span><br><span class="line">    print(next(g))</span><br><span class="line">except StopIteration:</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">#1 异常类只能用来处理指定的异常情况，如果非指定异常则无法处理。</span><br><span class="line">s1 &#x3D; &#39;hello&#39;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except IndexError as e: # 未捕获到异常，程序直接报错</span><br><span class="line">    print e</span><br><span class="line"></span><br><span class="line">#2 多分支</span><br><span class="line">s1 &#x3D; &#39;hello&#39;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except IndexError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except KeyError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#3 万能异常Exception</span><br><span class="line">s1 &#x3D; &#39;hello&#39;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#4 多分支异常与万能异常</span><br><span class="line">#4.1 如果你想要的效果是，无论出现什么异常，我们统一丢弃，或者使用同一段代码逻辑去处理他们，那么骚年，大胆的去做吧，只有一个Exception就足够了。</span><br><span class="line">#4.2 如果你想要的效果是，对于不同的异常我们需要定制不同的处理逻辑，那就需要用到多分支了。</span><br><span class="line"></span><br><span class="line">#5 也可以在多分支后来一个Exception</span><br><span class="line">s1 &#x3D; &#39;hello&#39;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except IndexError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except KeyError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#6 异常的其他机构</span><br><span class="line">s1 &#x3D; &#39;hello&#39;</span><br><span class="line">try:</span><br><span class="line">    int(s1)</span><br><span class="line">except IndexError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except KeyError as e:</span><br><span class="line">    print(e)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(e)</span><br><span class="line">#except Exception as e:</span><br><span class="line">#    print(e)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;try内代码块没有异常则执行我&#39;)</span><br><span class="line">finally:</span><br><span class="line">    print(&#39;无论异常与否,都会执行该模块,通常是进行清理工作&#39;)</span><br><span class="line"></span><br><span class="line">#7 主动触发异常</span><br><span class="line">try:</span><br><span class="line">    raise TypeError(&#39;类型错误&#39;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#8 自定义异常</span><br><span class="line">class EgonException(BaseException):</span><br><span class="line">    def __init__(self,msg):</span><br><span class="line">        self.msg&#x3D;msg</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.msg</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    raise EgonException(&#39;类型错误&#39;)</span><br><span class="line">except EgonException as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">#9 断言:assert 条件</span><br><span class="line">assert 1 &#x3D;&#x3D; 1  </span><br><span class="line">assert 1 &#x3D;&#x3D; 2</span><br><span class="line"></span><br><span class="line">#10 总结try..except</span><br><span class="line"></span><br><span class="line">1：把错误处理和真正的工作分开来</span><br><span class="line">2：代码更易组织，更清晰，复杂的工作任务更容易实现；</span><br><span class="line">3：毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了；</span><br></pre></td></tr></table></figure>
<p><a href="https://keelii.com/2018/09/24/socket-programming-in-python/" target="_blank" rel="noopener">https://keelii.com/2018/09/24/socket-programming-in-python/</a>(<a href="https://keelii.com/2018/09/24/socket-programming-in-python/" target="_blank" rel="noopener">Python 中的Socket 编程（指南）</a>)</p>
<h2 id="八、socket编程"><a href="#八、socket编程" class="headerlink" title="八、socket编程"></a>八、socket编程</h2><p><a href="https://www.cnblogs.com/linhaifeng/articles/6129246.html" target="_blank" rel="noopener">https://www.cnblogs.com/linhaifeng/articles/6129246.html</a></p>
<p>from socket import *</p>
<p>listen(5) :tcp—-》back_log</p>
<p>recv（）—-》等待内核态内存中的数据</p>
<p>send() —&gt;向内核态内存中发送数据</p>
<p>TCP双向连接，UDP不建立连接</p>
<h3 id="一-客户端-服务器架构"><a href="#一-客户端-服务器架构" class="headerlink" title="一 客户端/服务器架构"></a>一 客户端/服务器架构</h3><p>1.硬件C/S架构(打印机)</p>
<p>2.软件C/S架构</p>
<p>　　<em>互联网中处处是C/S架构</em></p>
<p>　　<em>如黄色网站是服务端，你的浏览器是客户端（B/S架构也是C/S架构的一种）</em></p>
<p>　　<em>腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频）</em></p>
<p>C/S架构与socket的关系：</p>
<p><em>我们学习socket就是为了完成C/S架构的开发</em></p>
<h3 id="二-osi七层"><a href="#二-osi七层" class="headerlink" title="二 osi七层"></a>二 osi七层</h3><p><strong>引子：</strong></p>
<p><em>须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的）</em></p>
<p><em>如果你要跟别人一起玩，那你就需要上网了，什么是互联网？</em></p>
<p><em>互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语</em></p>
<p><em>如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。</em></p>
<p><em>人们按照分工不同把互联网协议从逻辑上划分了层级，</em></p>
<p><a href="http://www.cnblogs.com/linhaifeng/articles/5937962.html" target="_blank" rel="noopener">详见网络通信原理：http://www.cnblogs.com/linhaifeng/articles/5937962.html</a></p>
<p><strong>为何学习socket一定要先学习互联网协议：</strong></p>
<p><em>1.首先：本节课程的目标就是教会你如何基于socket编程，来开发一款自己的C/S架构软件</em></p>
<p><em>2.其次：C/S架构的软件（软件属于应用层）是基于网络进行通信的</em></p>
<p><em>3.然后：网络的核心即一堆协议，协议即标准，你想开发一款基于网络通信的软件，就必须遵循这些标准。</em></p>
<p><em>4.最后：就让我们从这些标准开始研究，开启我们的socket编程之旅</em><img src="image/123.jpg" alt="img"><br>​                                                           图1</p>
<h3 id="三-socket层"><a href="#三-socket层" class="headerlink" title="三 socket层"></a>三 socket层</h3><p>在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。 </p>
<p><img src="image/124.jpg" alt="img"></p>
<p> 　　　　　　　　　　　　　　　　　　　<strong>图2</strong></p>
<h3 id="四-socket是什么"><a href="#四-socket是什么" class="headerlink" title="四 socket是什么"></a>四 socket是什么</h3><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序</span><br><span class="line"></span><br><span class="line">而程序的pid是同一台机器上不同进程或者线程的标识</span><br></pre></td></tr></table></figure>
<h3 id="五-套接字发展史及分类"><a href="#五-套接字发展史及分类" class="headerlink" title="五 套接字发展史及分类"></a>五 套接字发展史及分类</h3><p>套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 </p>
<p><strong><em>基于文件类型的套接字家族</em></strong></p>
<p>套接字家族的名字：AF_UNIX</p>
<p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</p>
<p><strong><em>基于网络类型的套接字家族</em></strong></p>
<p>套接字家族的名字：AF_INET</p>
<p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p>
<h3 id="六-套接字工作流程"><a href="#六-套接字工作流程" class="headerlink" title="六 套接字工作流程"></a>六 套接字工作流程</h3><p>​       一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。</p>
<p><img src="image/125.jpg" alt="img">      </p>
<p>​                                           图3       </p>
<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p>
<p>socket()模块函数用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 import socket</span><br><span class="line"> 2 socket.socket(socket_family,socket_type,protocal&#x3D;0)</span><br><span class="line"> 3 socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 0。</span><br><span class="line"> ## AF_UNIX  unix系统间通信（基于文件的传输），AF_INET 服务器之间通信（网络）</span><br><span class="line"> ## stream流套接字tcp，datagram数据包套接字udp</span><br><span class="line"> 4 </span><br><span class="line"> 5 获取tcp&#x2F;ip套接字</span><br><span class="line"> 6 tcpSock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"> 7 </span><br><span class="line"> 8 获取udp&#x2F;ip套接字</span><br><span class="line"> 9 udpSock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">10 </span><br><span class="line">11 由于 socket 模块中有太多的属性。我们在这里破例使用了&#39;from module import *&#39;语句。使用 &#39;from socket import *&#39;,我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。</span><br><span class="line">12 例如tcpSock &#x3D; socket(AF_INET, SOCK_STREAM)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">服务端套接字函数</span><br><span class="line">s.bind()    绑定(主机,端口号)到套接字</span><br><span class="line">s.listen()  开始TCP监听</span><br><span class="line">s.accept()  被动接受TCP客户的连接,(阻塞式)等待连接的到来</span><br><span class="line"></span><br><span class="line">客户端套接字函数</span><br><span class="line">s.connect()     主动初始化TCP服务器连接</span><br><span class="line">s.connect_ex()  connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</span><br><span class="line"></span><br><span class="line">公共用途的套接字函数</span><br><span class="line">s.recv()            接收TCP数据</span><br><span class="line">s.send()            发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)</span><br><span class="line">s.sendall()         发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)</span><br><span class="line">s.recvfrom()        接收UDP数据</span><br><span class="line">s.sendto()          发送UDP数据</span><br><span class="line">s.getpeername()     连接到当前套接字的远端的地址</span><br><span class="line">s.getsockname()     当前套接字的地址</span><br><span class="line">s.getsockopt()      返回指定套接字的参数</span><br><span class="line">s.setsockopt()      设置指定套接字的参数</span><br><span class="line">s.close()           关闭套接字</span><br><span class="line"></span><br><span class="line">面向锁的套接字方法</span><br><span class="line">s.setblocking()     设置套接字的阻塞与非阻塞模式</span><br><span class="line">s.settimeout()      设置阻塞套接字操作的超时时间</span><br><span class="line">s.gettimeout()      得到阻塞套接字操作的超时时间</span><br><span class="line"></span><br><span class="line">面向文件的套接字的函数</span><br><span class="line">s.fileno()          套接字的文件描述符</span><br><span class="line">s.makefile()        创建一个与该套接字相关的文件</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1：用打电话的流程快速描述socket通信</span><br><span class="line">2：服务端和客户端加上基于一次链接的循环通信</span><br><span class="line">3：客户端发送空，卡主，证明是从哪个位置卡的</span><br><span class="line">服务端：</span><br><span class="line">from socket import *</span><br><span class="line">phone&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">phone.bind((&#39;127.0.0.1&#39;,8081))</span><br><span class="line">phone.listen(5)</span><br><span class="line"></span><br><span class="line">conn,addr&#x3D;phone.accept()</span><br><span class="line">while True:</span><br><span class="line">    data&#x3D;conn.recv(1024)</span><br><span class="line">    print(&#39;server&#x3D;&#x3D;&#x3D;&gt;&#39;)</span><br><span class="line">    print(data)</span><br><span class="line">    conn.send(data.upper())</span><br><span class="line">conn.close()</span><br><span class="line">phone.close()</span><br><span class="line">客户端：</span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line">phone&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">phone.connect((&#39;127.0.0.1&#39;,8081))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">    phone.send(msg.encode(&#39;utf-8&#39;))</span><br><span class="line">    print(&#39;client&#x3D;&#x3D;&#x3D;&#x3D;&gt;&#39;)</span><br><span class="line">    data&#x3D;phone.recv(1024)</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line">说明卡的原因：缓冲区为空recv就卡住，引出原理图</span><br><span class="line"></span><br><span class="line">4.演示客户端断开链接，服务端的情况，提供解决方法</span><br><span class="line"></span><br><span class="line">5.演示服务端不能重复接受链接，而服务器都是正常运行不断来接受客户链接的</span><br><span class="line"></span><br><span class="line">6:简单演示udp</span><br><span class="line">服务端</span><br><span class="line">from socket import *</span><br><span class="line">phone&#x3D;socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">phone.bind((&#39;127.0.0.1&#39;,8082))</span><br><span class="line">while True:</span><br><span class="line">    msg,addr&#x3D;phone.recvfrom(1024)</span><br><span class="line">    phone.sendto(msg.upper(),addr)</span><br><span class="line">客户端</span><br><span class="line">from socket import *</span><br><span class="line">phone&#x3D;socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">while True:</span><br><span class="line">    msg&#x3D;input(&#39;&gt;&gt;: &#39;)</span><br><span class="line">    phone.sendto(msg.encode(&#39;utf-8&#39;),(&#39;127.0.0.1&#39;,8082))</span><br><span class="line">    msg,addr&#x3D;phone.recvfrom(1024)</span><br><span class="line">    print(msg)</span><br><span class="line"></span><br><span class="line">udp客户端可以并发演示</span><br><span class="line">udp客户端可以输入为空演示，说出recvfrom与recv的区别，暂且不提tcp流和udp报的概念，留到粘包去说</span><br></pre></td></tr></table></figure>
<h3 id="七-基于TCP的套接字"><a href="#七-基于TCP的套接字" class="headerlink" title="七 基于TCP的套接字"></a>七 基于TCP的套接字</h3><p><strong><em>tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端</em></strong></p>
<p><strong><em>tcp服务端</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 ss &#x3D; socket() #创建服务器套接字</span><br><span class="line">2 ss.bind()      #把地址绑定到套接字</span><br><span class="line">3 ss.listen()      #监听链接</span><br><span class="line">4 inf_loop:      #服务器无限循环</span><br><span class="line">5     cs &#x3D; ss.accept() #接受客户端链接</span><br><span class="line">6     comm_loop:         #通讯循环</span><br><span class="line">7         cs.recv()&#x2F;cs.send() #对话(接收与发送)</span><br><span class="line">8     cs.close()    #关闭客户端套接字</span><br><span class="line">9 ss.close()        #关闭服务器套接字(可选)</span><br></pre></td></tr></table></figure>
<p><strong><em>tcp客户端</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 cs &#x3D; socket()    # 创建客户套接字</span><br><span class="line">2 cs.connect()    # 尝试连接服务器</span><br><span class="line">3 comm_loop:        # 通讯循环</span><br><span class="line">4     cs.send()&#x2F;cs.recv()    # 对话(发送&#x2F;接收)</span><br><span class="line">5 cs.close()            # 关闭客户套接字</span><br></pre></td></tr></table></figure>
<p>socket通信流程与打电话流程类似，我们就以打电话为例来实现一个low版的套接字通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,9000)  #电话卡</span><br><span class="line">BUFSIZE&#x3D;1024                #收发消息的尺寸</span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机</span><br><span class="line">s.bind(ip_port) #手机插卡</span><br><span class="line">s.listen(5)     #手机待机</span><br><span class="line"></span><br><span class="line">conn,addr&#x3D;s.accept()            #手机接电话</span><br><span class="line"># print(conn)</span><br><span class="line"># print(addr)</span><br><span class="line">print(&#39;接到来自%s的电话&#39; %addr[0])</span><br><span class="line"></span><br><span class="line">msg&#x3D;conn.recv(BUFSIZE)             #听消息,听话</span><br><span class="line">print(msg,type(msg))</span><br><span class="line"></span><br><span class="line">conn.send(msg.upper())          #发消息,说话</span><br><span class="line"></span><br><span class="line">conn.close()                    #挂电话</span><br><span class="line"></span><br><span class="line">s.close()                       #手机关机</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,9000)</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.connect_ex(ip_port)           #拨电话</span><br><span class="line"></span><br><span class="line">s.send(&#39;linhaifeng nb&#39;.encode(&#39;utf-8&#39;))         #发消息,说话(只能发送字节类型)</span><br><span class="line"></span><br><span class="line">feedback&#x3D;s.recv(BUFSIZE)                           #收消息,听话</span><br><span class="line">print(feedback.decode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line">s.close()                                       #挂电话</span><br></pre></td></tr></table></figure>
<p>加上链接循环与通信循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8081)#电话卡</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机</span><br><span class="line">s.bind(ip_port) #手机插卡</span><br><span class="line">s.listen(5)     #手机待机</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:                         #新增接收链接循环,可以不停的接电话</span><br><span class="line">    conn,addr&#x3D;s.accept()            #手机接电话</span><br><span class="line">    # print(conn)</span><br><span class="line">    # print(addr)</span><br><span class="line">    print(&#39;接到来自%s的电话&#39; %addr[0])</span><br><span class="line">    while True:                         #新增通信循环,可以不断的通信,收发消息</span><br><span class="line">        msg&#x3D;conn.recv(BUFSIZE)             #听消息,听话</span><br><span class="line"></span><br><span class="line">        # if len(msg) &#x3D;&#x3D; 0:break        #如果不加,那么正在链接的客户端突然断开,recv便不再阻塞,死循环发生</span><br><span class="line"></span><br><span class="line">        print(msg,type(msg))</span><br><span class="line"></span><br><span class="line">        conn.send(msg.upper())          #发消息,说话</span><br><span class="line"></span><br><span class="line">    conn.close()                    #挂电话</span><br><span class="line"></span><br><span class="line">s.close()                       #手机关机</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8081)</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.connect_ex(ip_port)           #拨电话</span><br><span class="line"></span><br><span class="line">while True:                             #新增通信循环,客户端可以不断发收消息</span><br><span class="line">    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">    if len(msg) &#x3D;&#x3D; 0:continue</span><br><span class="line">    s.send(msg.encode(&#39;utf-8&#39;))         #发消息,说话(只能发送字节类型)</span><br><span class="line"></span><br><span class="line">    feedback&#x3D;s.recv(BUFSIZE)                           #收消息,听话</span><br><span class="line">    print(feedback.decode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line">s.close()                                       #挂电话</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<p>有的同学在重启服务端时可能会遇到</p>
<p><img src="image/126.png" alt="img"></p>
<p>这个是由于你的服务端仍然存在四次挥手的time_wait状态在占用地址（如果不懂，请深入研究1.tcp三次握手，四次挥手 2.syn洪水攻击 3.服务器高并发情况下会有大量的time_wait状态的优化方法）</p>
<p>解决方法：</p>
<p><strong>(1)重用端口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#加入一条socket配置，重用ip和端口</span><br><span class="line"></span><br><span class="line">phone&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">phone.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #就是它，在bind前加</span><br><span class="line">phone.bind((&#39;127.0.0.1&#39;,8080))</span><br></pre></td></tr></table></figure>
<p>(2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发现系统存在大量TIME_WAIT状态的连接，通过调整linux内核参数解决，</span><br><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">编辑文件，加入以下内容：</span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1</span><br><span class="line">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br><span class="line"> </span><br><span class="line">然后执行 &#x2F;sbin&#x2F;sysctl -p 让参数生效。</span><br><span class="line"> </span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>
<h3 id="八-基于UDP的套接字"><a href="#八-基于UDP的套接字" class="headerlink" title="八 基于UDP的套接字"></a>八 基于UDP的套接字</h3><p><strong><em>udp是无链接的，先启动哪一端都不会报错</em></strong></p>
<p>udp服务端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 ss &#x3D; socket()   #创建一个服务器的套接字</span><br><span class="line">2 ss.bind()       #绑定服务器套接字</span><br><span class="line">3 inf_loop:       #服务器无限循环</span><br><span class="line">4     cs &#x3D; ss.recvfrom()&#x2F;ss.sendto() # 对话(接收与发送)</span><br><span class="line">5 ss.close()                         # 关闭服务器套接字</span><br></pre></td></tr></table></figure>
<p>udp客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cs &#x3D; socket()   # 创建客户套接字</span><br><span class="line">comm_loop:      # 通讯循环</span><br><span class="line">    cs.sendto()&#x2F;cs.recvfrom()   # 对话(发送&#x2F;接收)</span><br><span class="line">cs.close()                      # 关闭客户套接字</span><br></pre></td></tr></table></figure>
<p><strong><em>udp套接字简单示例</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,9000)</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">udp_server_client&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">udp_server_client.bind(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg,addr&#x3D;udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    print(msg,addr)</span><br><span class="line"></span><br><span class="line">    udp_server_client.sendto(msg.upper(),addr)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,9000)</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">udp_server_client&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">    if not msg:continue</span><br><span class="line"></span><br><span class="line">    udp_server_client.sendto(msg.encode(&#39;utf-8&#39;),ip_port)</span><br><span class="line"></span><br><span class="line">    back_msg,addr&#x3D;udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    print(back_msg.decode(&#39;utf-8&#39;),addr)</span><br></pre></td></tr></table></figure>
<p><strong>qq聊天(由于udp无连接，所以可以同时多个客户端去跟服务端通信)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8081)</span><br><span class="line">udp_server_sock&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #买手机</span><br><span class="line">udp_server_sock.bind(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    qq_msg,addr&#x3D;udp_server_sock.recvfrom(1024)</span><br><span class="line">    print(&#39;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#39; %(addr[0],addr[1],qq_msg.decode(&#39;utf-8&#39;)))</span><br><span class="line">    back_msg&#x3D;input(&#39;回复消息: &#39;).strip()</span><br><span class="line"></span><br><span class="line">    udp_server_sock.sendto(back_msg.encode(&#39;utf-8&#39;),addr)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">udp_client_socket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic&#x3D;&#123;</span><br><span class="line">    &#39;狗哥alex&#39;:(&#39;127.0.0.1&#39;,8081),</span><br><span class="line">    &#39;瞎驴&#39;:(&#39;127.0.0.1&#39;,8081),</span><br><span class="line">    &#39;一棵树&#39;:(&#39;127.0.0.1&#39;,8081),</span><br><span class="line">    &#39;武大郎&#39;:(&#39;127.0.0.1&#39;,8081),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    qq_name&#x3D;input(&#39;请选择聊天对象: &#39;).strip()</span><br><span class="line">    while True:</span><br><span class="line">        msg&#x3D;input(&#39;请输入消息,回车发送: &#39;).strip()</span><br><span class="line">        if msg &#x3D;&#x3D; &#39;quit&#39;:break</span><br><span class="line">        if not msg or not qq_name or qq_name not in qq_name_dic:continue</span><br><span class="line">        udp_client_socket.sendto(msg.encode(&#39;utf-8&#39;),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr&#x3D;udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        print(&#39;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#39; %(addr[0],addr[1],back_msg.decode(&#39;utf-8&#39;)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">udp_client_socket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic&#x3D;&#123;</span><br><span class="line">    &#39;狗哥alex&#39;:(&#39;127.0.0.1&#39;,8081),</span><br><span class="line">    &#39;瞎驴&#39;:(&#39;127.0.0.1&#39;,8081),</span><br><span class="line">    &#39;一棵树&#39;:(&#39;127.0.0.1&#39;,8081),</span><br><span class="line">    &#39;武大郎&#39;:(&#39;127.0.0.1&#39;,8081),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    qq_name&#x3D;input(&#39;请选择聊天对象: &#39;).strip()</span><br><span class="line">    while True:</span><br><span class="line">        msg&#x3D;input(&#39;请输入消息,回车发送: &#39;).strip()</span><br><span class="line">        if msg &#x3D;&#x3D; &#39;quit&#39;:break</span><br><span class="line">        if not msg or not qq_name or qq_name not in qq_name_dic:continue</span><br><span class="line">        udp_client_socket.sendto(msg.encode(&#39;utf-8&#39;),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr&#x3D;udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        print(&#39;来自[%s:%s]的一条消息:\033[1;44m%s\033[0m&#39; %(addr[0],addr[1],back_msg.decode(&#39;utf-8&#39;)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>
<p>服务端运行结果</p>
<p><img src="image/127.png" alt="img"></p>
<p>客户端1运行结果</p>
<p><img src="image/128.png" alt="img"></p>
<p>客户端2运行结果</p>
<p><img src="image/129.png" alt="img"></p>
<p><strong><em>时间服务器</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line">from time import strftime</span><br><span class="line"></span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,9000)</span><br><span class="line">bufsize&#x3D;1024</span><br><span class="line"></span><br><span class="line">tcp_server&#x3D;socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">tcp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg,addr&#x3D;tcp_server.recvfrom(bufsize)</span><br><span class="line">    print(&#39;&#x3D;&#x3D;&#x3D;&gt;&#39;,msg)</span><br><span class="line">    </span><br><span class="line">    if not msg:</span><br><span class="line">        time_fmt&#x3D;&#39;%Y-%m-%d %X&#39;</span><br><span class="line">    else:</span><br><span class="line">        time_fmt&#x3D;msg.decode(&#39;utf-8&#39;)</span><br><span class="line">    back_msg&#x3D;strftime(time_fmt)</span><br><span class="line"></span><br><span class="line">    tcp_server.sendto(back_msg.encode(&#39;utf-8&#39;),addr)</span><br><span class="line"></span><br><span class="line">tcp_server.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,9000)</span><br><span class="line">bufsize&#x3D;1024</span><br><span class="line"></span><br><span class="line">tcp_client&#x3D;socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg&#x3D;input(&#39;请输入时间格式(例%Y %m %d)&gt;&gt;: &#39;).strip()</span><br><span class="line">    tcp_client.sendto(msg.encode(&#39;utf-8&#39;),ip_port)</span><br><span class="line"></span><br><span class="line">    data&#x3D;tcp_client.recv(bufsize)</span><br><span class="line"></span><br><span class="line">    print(data.decode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line">tcp_client.close()</span><br></pre></td></tr></table></figure>
<h3 id="九-粘包现象"><a href="#九-粘包现象" class="headerlink" title="九 粘包现象"></a>九 粘包现象</h3><p>让我们基于tcp先制作一个远程执行命令的程序（1：执行错误命令 2：执行ls 3：执行ifconfig）</p>
<p><strong>注意注意注意：</strong></p>
<p>res=subprocess.Popen(cmd.decode(‘utf-8’),<br>shell=True,<br>stderr=subprocess.PIPE,<br>stdout=subprocess.PIPE)</p>
<p>的结果的编码是以当前所在的系统为准的，如果是windows，那么<strong>res.stdout.read()读出的就是GBK编码的</strong>，在接收端需<strong>要用GBK解码</strong></p>
<p><strong>且只能从管道里读一次结果</strong></p>
<p>注意：命令ls -l ; lllllll ; pwd 的结果是既有正确stdout结果，又有错误stderr结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line"></span><br><span class="line">tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    conn,addr&#x3D;tcp_socket_server.accept()</span><br><span class="line">    print(&#39;客户端&#39;,addr)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        cmd&#x3D;conn.recv(BUFSIZE)</span><br><span class="line">        if len(cmd) &#x3D;&#x3D; 0:break</span><br><span class="line"></span><br><span class="line">        res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),shell&#x3D;True,</span><br><span class="line">                         stdout&#x3D;subprocess.PIPE,</span><br><span class="line">                         stdin&#x3D;subprocess.PIPE,</span><br><span class="line">                         stderr&#x3D;subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">        stderr&#x3D;act_res.stderr.read()</span><br><span class="line">        stdout&#x3D;act_res.stdout.read()</span><br><span class="line">        conn.send(stderr)</span><br><span class="line">        conn.send(stdout)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)</span><br><span class="line"></span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res&#x3D;s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">    if len(msg) &#x3D;&#x3D; 0:continue</span><br><span class="line">    if msg &#x3D;&#x3D; &#39;quit&#39;:break</span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(&#39;utf-8&#39;))</span><br><span class="line">    act_res&#x3D;s.recv(BUFSIZE)</span><br><span class="line"></span><br><span class="line">    print(act_res.decode(&#39;utf-8&#39;),end&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure>
<p>上述程序是基于tcp的socket，在运行时会发生粘包</p>
<p> 让我们再基于udp制作一个远程执行命令的程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line"></span><br><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,9003)</span><br><span class="line">bufsize&#x3D;1024</span><br><span class="line"></span><br><span class="line">udp_server&#x3D;socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">udp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    #收消息</span><br><span class="line">    cmd,addr&#x3D;udp_server.recvfrom(bufsize)</span><br><span class="line">    print(&#39;用户命令-----&gt;&#39;,cmd)</span><br><span class="line"></span><br><span class="line">    #逻辑处理</span><br><span class="line">    res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),shell&#x3D;True,stderr&#x3D;subprocess.PIPE,stdin&#x3D;subprocess.PIPE,stdout&#x3D;subprocess.PIPE)</span><br><span class="line">    stderr&#x3D;res.stderr.read()</span><br><span class="line">    stdout&#x3D;res.stdout.read()</span><br><span class="line"></span><br><span class="line">    #发消息</span><br><span class="line">    udp_server.sendto(stderr,addr)</span><br><span class="line">    udp_server.sendto(stdout,addr)</span><br><span class="line">udp_server.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from socket import *</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,9003)</span><br><span class="line">bufsize&#x3D;1024</span><br><span class="line"></span><br><span class="line">udp_client&#x3D;socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">    udp_client.sendto(msg.encode(&#39;utf-8&#39;),ip_port)</span><br><span class="line"></span><br><span class="line">    data,addr&#x3D;udp_client.recvfrom(bufsize)</span><br><span class="line">    print(data.decode(&#39;utf-8&#39;),end&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure>
<p>上述程序是基于udp的socket，在运行时永远不会发生粘包</p>
<h3 id="十-什么是粘包"><a href="#十-什么是粘包" class="headerlink" title="十 什么是粘包"></a>十 什么是粘包</h3><p>须知：只有TCP有粘包现象，UDP永远不会粘包，为何，且听我娓娓道来</p>
<p>首先需要掌握一个socket收发消息的原理</p>
<p><img src="image/130.png" alt="img"></p>
<p>发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。</p>
<p>例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束</p>
<p>所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。</p>
<p>此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</p>
<ol>
<li>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。</li>
<li>UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 <strong>即面向消息的通信是有消息保护边界的。</strong></li>
<li><strong>tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略</strong></li>
</ol>
<p>udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠</p>
<p>tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</p>
<p><strong><em>两种情况下会发生粘包。</em></strong></p>
<p>发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据量很小，会合到一起，产生粘包）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)</span><br><span class="line"></span><br><span class="line">tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr&#x3D;tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1&#x3D;conn.recv(10)</span><br><span class="line">data2&#x3D;conn.recv(10)</span><br><span class="line"></span><br><span class="line">print(&#39;-----&gt;&#39;,data1.decode(&#39;utf-8&#39;))</span><br><span class="line">print(&#39;-----&gt;&#39;,data2.decode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)</span><br><span class="line"></span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res&#x3D;s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(&#39;hello&#39;.encode(&#39;utf-8&#39;))</span><br><span class="line">s.send(&#39;feng&#39;.encode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>
<p>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)</span><br><span class="line"></span><br><span class="line">tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr&#x3D;tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1&#x3D;conn.recv(2) #一次没有收完整</span><br><span class="line">data2&#x3D;conn.recv(10)#下次收的时候,会先取旧的数据,然后取新的</span><br><span class="line"></span><br><span class="line">print(&#39;-----&gt;&#39;,data1.decode(&#39;utf-8&#39;))</span><br><span class="line">print(&#39;-----&gt;&#39;,data2.decode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket</span><br><span class="line">BUFSIZE&#x3D;1024</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)</span><br><span class="line"></span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res&#x3D;s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(&#39;hello feng&#39;.encode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>
<p><strong><em>拆包的发生情况</em></strong></p>
<p>当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。</p>
<p><strong><em>补充问题一：为何tcp是可靠传输，udp是不可靠传输</em></strong></p>
<p>基于tcp的数据传输请参考我的另一篇文章<a href="http://www.cnblogs.com/linhaifeng/articles/5937962.html，tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的" target="_blank" rel="noopener">http://www.cnblogs.com/linhaifeng/articles/5937962.html，tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的</a></p>
<p>而udp发送数据，对端是不会返回确认信息的，因此不可靠</p>
<p><strong><em>补充问题二：send(字节流)和recv(1024)及sendall</em></strong></p>
<p>recv里指定的1024意思是从缓存里一次拿出1024个字节的数据</p>
<p>send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失</p>
<h3 id="十一-解决粘包的low比处理方法"><a href="#十一-解决粘包的low比处理方法" class="headerlink" title="十一 解决粘包的low比处理方法"></a>十一 解决粘包的low比处理方法</h3><p>问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据</p>
<p>low版本的解决方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket,subprocess</span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)</span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"></span><br><span class="line">s.bind(ip_port)</span><br><span class="line">s.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    conn,addr&#x3D;s.accept()</span><br><span class="line">    print(&#39;客户端&#39;,addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg&#x3D;conn.recv(1024)</span><br><span class="line">        if not msg:break</span><br><span class="line">        res&#x3D;subprocess.Popen(msg.decode(&#39;utf-8&#39;),shell&#x3D;True,\</span><br><span class="line">                            stdin&#x3D;subprocess.PIPE,\</span><br><span class="line">                         stderr&#x3D;subprocess.PIPE,\</span><br><span class="line">                         stdout&#x3D;subprocess.PIPE)</span><br><span class="line">        err&#x3D;res.stderr.read()</span><br><span class="line">        if err:</span><br><span class="line">            ret&#x3D;err</span><br><span class="line">        else:</span><br><span class="line">            ret&#x3D;res.stdout.read()</span><br><span class="line">        data_length&#x3D;len(ret)</span><br><span class="line">        conn.send(str(data_length).encode(&#39;utf-8&#39;))</span><br><span class="line">        data&#x3D;conn.recv(1024).decode(&#39;utf-8&#39;)</span><br><span class="line">        if data &#x3D;&#x3D; &#39;recv_ready&#39;:</span><br><span class="line">            conn.sendall(ret)</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket,time</span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res&#x3D;s.connect_ex((&#39;127.0.0.1&#39;,8080))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">    if len(msg) &#x3D;&#x3D; 0:continue</span><br><span class="line">    if msg &#x3D;&#x3D; &#39;quit&#39;:break</span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(&#39;utf-8&#39;))</span><br><span class="line">    length&#x3D;int(s.recv(1024).decode(&#39;utf-8&#39;))</span><br><span class="line">    s.send(&#39;recv_ready&#39;.encode(&#39;utf-8&#39;))</span><br><span class="line">    send_size&#x3D;0</span><br><span class="line">    recv_size&#x3D;0</span><br><span class="line">    data&#x3D;b&#39;&#39;</span><br><span class="line">    while recv_size &lt; length:</span><br><span class="line">        data+&#x3D;s.recv(1024)</span><br><span class="line">        recv_size+&#x3D;len(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(data.decode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>
<p>为何low：</p>
<p>程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗</p>
<h3 id="十二-峰哥解决粘包的方法"><a href="#十二-峰哥解决粘包的方法" class="headerlink" title="十二 峰哥解决粘包的方法"></a>十二 峰哥解决粘包的方法</h3><p>为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据</p>
<p><strong>struct模块</strong> </p>
<p>该模块可以把一个类型，如数字，转成固定长度的bytes</p>
<p>>&gt;&gt; struct.pack(‘i’,1111111111111)</p>
<p>。。。。。。。。。</p>
<p>struct.error: ‘i’ format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围</p>
<p><img src="image/131.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json,struct</span><br><span class="line">#假设通过客户端上传1T:1073741824000的文件a.txt</span><br><span class="line"></span><br><span class="line">#为避免粘包,必须自定制报头</span><br><span class="line">header&#x3D;&#123;&#39;file_size&#39;:1073741824000,&#39;file_name&#39;:&#39;&#x2F;a&#x2F;b&#x2F;c&#x2F;d&#x2F;e&#x2F;a.txt&#39;,&#39;md5&#39;:&#39;8f6fbf8347faa4924a76856701edb0f3&#39;&#125; #1T数据,文件路径和md5值</span><br><span class="line"></span><br><span class="line">#为了该报头能传送,需要序列化并且转为bytes</span><br><span class="line">head_bytes&#x3D;bytes(json.dumps(header),encoding&#x3D;&#39;utf-8&#39;) #序列化并转成bytes,用于传输</span><br><span class="line"></span><br><span class="line">#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节</span><br><span class="line">head_len_bytes&#x3D;struct.pack(&#39;i&#39;,len(head_bytes)) #这4个字节里只包含了一个数字,该数字是报头的长度</span><br><span class="line"></span><br><span class="line">#客户端开始发送</span><br><span class="line">conn.send(head_len_bytes) #先发报头的长度,4个bytes</span><br><span class="line">conn.send(head_bytes) #再发报头的字节格式</span><br><span class="line">conn.sendall(文件内容) #然后发真实内容的字节格式</span><br><span class="line"></span><br><span class="line">#服务端开始接收</span><br><span class="line">head_len_bytes&#x3D;s.recv(4) #先收报头4个bytes,得到报头长度的字节格式</span><br><span class="line">x&#x3D;struct.unpack(&#39;i&#39;,head_len_bytes)[0] #提取报头的长度</span><br><span class="line"></span><br><span class="line">head_bytes&#x3D;s.recv(x) #按照报头长度x,收取报头的bytes格式</span><br><span class="line">header&#x3D;json.loads(json.dumps(header)) #提取报头</span><br><span class="line"></span><br><span class="line">#最后根据报头的内容提取真实的数据,比如</span><br><span class="line">real_data_len&#x3D;s.recv(header[&#39;file_size&#39;])</span><br><span class="line">s.recv(real_data_len)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">#http:&#x2F;&#x2F;www.cnblogs.com&#x2F;coser&#x2F;archive&#x2F;2011&#x2F;12&#x2F;17&#x2F;2291160.html</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import struct</span><br><span class="line">import binascii</span><br><span class="line">import ctypes</span><br><span class="line"></span><br><span class="line">values1 &#x3D; (1, &#39;abc&#39;.encode(&#39;utf-8&#39;), 2.7)</span><br><span class="line">values2 &#x3D; (&#39;defg&#39;.encode(&#39;utf-8&#39;),101)</span><br><span class="line">s1 &#x3D; struct.Struct(&#39;I3sf&#39;)</span><br><span class="line">s2 &#x3D; struct.Struct(&#39;4sI&#39;)</span><br><span class="line"></span><br><span class="line">print(s1.size,s2.size)</span><br><span class="line">prebuffer&#x3D;ctypes.create_string_buffer(s1.size+s2.size)</span><br><span class="line">print(&#39;Before : &#39;,binascii.hexlify(prebuffer))</span><br><span class="line"># t&#x3D;binascii.hexlify(&#39;asdfaf&#39;.encode(&#39;utf-8&#39;))</span><br><span class="line"># print(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1.pack_into(prebuffer,0,*values1)</span><br><span class="line">s2.pack_into(prebuffer,s1.size,*values2)</span><br><span class="line"></span><br><span class="line">print(&#39;After pack&#39;,binascii.hexlify(prebuffer))</span><br><span class="line">print(s1.unpack_from(prebuffer,0))</span><br><span class="line">print(s2.unpack_from(prebuffer,s1.size))</span><br><span class="line"></span><br><span class="line">s3&#x3D;struct.Struct(&#39;ii&#39;)</span><br><span class="line">s3.pack_into(prebuffer,0,123,123)</span><br><span class="line">print(&#39;After pack&#39;,binascii.hexlify(prebuffer))</span><br><span class="line">print(s3.unpack_from(prebuffer,0))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket,struct,json</span><br><span class="line">import subprocess</span><br><span class="line">phone&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加</span><br><span class="line"></span><br><span class="line">phone.bind((&#39;127.0.0.1&#39;,8080))</span><br><span class="line"></span><br><span class="line">phone.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    conn,addr&#x3D;phone.accept()</span><br><span class="line">    while True:</span><br><span class="line">        cmd&#x3D;conn.recv(1024)</span><br><span class="line">        if not cmd:break</span><br><span class="line">        print(&#39;cmd: %s&#39; %cmd)</span><br><span class="line"></span><br><span class="line">        res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),</span><br><span class="line">                             shell&#x3D;True,</span><br><span class="line">                             stdout&#x3D;subprocess.PIPE,</span><br><span class="line">                             stderr&#x3D;subprocess.PIPE)</span><br><span class="line">        err&#x3D;res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        if err:</span><br><span class="line">            back_msg&#x3D;err</span><br><span class="line">        else:</span><br><span class="line">            back_msg&#x3D;res.stdout.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(&#39;i&#39;,len(back_msg))) #先发back_msg的长度</span><br><span class="line">        conn.sendall(back_msg) #在发真实的内容</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">import socket,time,struct</span><br><span class="line"></span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res&#x3D;s.connect_ex((&#39;127.0.0.1&#39;,8080))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">    if len(msg) &#x3D;&#x3D; 0:continue</span><br><span class="line">    if msg &#x3D;&#x3D; &#39;quit&#39;:break</span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    l&#x3D;s.recv(4)</span><br><span class="line">    x&#x3D;struct.unpack(&#39;i&#39;,l)[0]</span><br><span class="line">    print(type(x),x)</span><br><span class="line">    # print(struct.unpack(&#39;I&#39;,l))</span><br><span class="line">    r_s&#x3D;0</span><br><span class="line">    data&#x3D;b&#39;&#39;</span><br><span class="line">    while r_s &lt; x:</span><br><span class="line">        r_d&#x3D;s.recv(1024)</span><br><span class="line">        data+&#x3D;r_d</span><br><span class="line">        r_s+&#x3D;len(r_d)</span><br><span class="line"></span><br><span class="line">    # print(data.decode(&#39;utf-8&#39;))</span><br><span class="line">    print(data.decode(&#39;gbk&#39;)) #windows默认gbk编码</span><br></pre></td></tr></table></figure>
<p>我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了）</p>
<p>发送时：<br>先发报头长度<br>再编码报头内容然后发送<br>最后发真实内容</p>
<p>接收时：<br>先手报头长度，用struct取出来<br>根据取出的长度收取报头内容，然后解码，反序列化<br>从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket,struct,json</span><br><span class="line">import subprocess</span><br><span class="line">phone&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加</span><br><span class="line"></span><br><span class="line">phone.bind((&#39;127.0.0.1&#39;,8080))</span><br><span class="line"></span><br><span class="line">phone.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    conn,addr&#x3D;phone.accept()</span><br><span class="line">    while True:</span><br><span class="line">        cmd&#x3D;conn.recv(1024)</span><br><span class="line">        if not cmd:break</span><br><span class="line">        print(&#39;cmd: %s&#39; %cmd)</span><br><span class="line"></span><br><span class="line">        res&#x3D;subprocess.Popen(cmd.decode(&#39;utf-8&#39;),</span><br><span class="line">                             shell&#x3D;True,</span><br><span class="line">                             stdout&#x3D;subprocess.PIPE,</span><br><span class="line">                             stderr&#x3D;subprocess.PIPE)</span><br><span class="line">        err&#x3D;res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        if err:</span><br><span class="line">            back_msg&#x3D;err</span><br><span class="line">        else:</span><br><span class="line">            back_msg&#x3D;res.stdout.read()</span><br><span class="line"></span><br><span class="line">        headers&#x3D;&#123;&#39;data_size&#39;:len(back_msg)&#125;</span><br><span class="line">        head_json&#x3D;json.dumps(headers)</span><br><span class="line">        head_json_bytes&#x3D;bytes(head_json,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(&#39;i&#39;,len(head_json_bytes))) #先发报头的长度</span><br><span class="line">        conn.send(head_json_bytes) #再发报头</span><br><span class="line">        conn.sendall(back_msg) #在发真实的内容</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from socket import *</span><br><span class="line">import struct,json</span><br><span class="line"></span><br><span class="line">ip_port&#x3D;(&#39;127.0.0.1&#39;,8080)</span><br><span class="line">client&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    cmd&#x3D;input(&#39;&gt;&gt;: &#39;)</span><br><span class="line">    if not cmd:continue</span><br><span class="line">    client.send(bytes(cmd,encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line">    head&#x3D;client.recv(4)</span><br><span class="line">    head_json_len&#x3D;struct.unpack(&#39;i&#39;,head)[0]</span><br><span class="line">    head_json&#x3D;json.loads(client.recv(head_json_len).decode(&#39;utf-8&#39;))</span><br><span class="line">    data_len&#x3D;head_json[&#39;data_size&#39;]</span><br><span class="line"></span><br><span class="line">    recv_size&#x3D;0</span><br><span class="line">    recv_data&#x3D;b&#39;&#39;</span><br><span class="line">    while recv_size &lt; data_len:</span><br><span class="line">        recv_data+&#x3D;client.recv(1024)</span><br><span class="line">        recv_size+&#x3D;len(recv_data)</span><br><span class="line"></span><br><span class="line">    print(recv_data.decode(&#39;utf-8&#39;))</span><br><span class="line">    #print(recv_data.decode(&#39;gbk&#39;)) #windows默认gbk编码</span><br></pre></td></tr></table></figure>
<p>FTP作业：上传下载文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">import subprocess</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class MYTCPServer:</span><br><span class="line">    address_family &#x3D; socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type &#x3D; socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address &#x3D; False</span><br><span class="line"></span><br><span class="line">    max_packet_size &#x3D; 8192</span><br><span class="line"></span><br><span class="line">    coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">    request_queue_size &#x3D; 5</span><br><span class="line"></span><br><span class="line">    server_dir&#x3D;&#39;file_upload&#39;</span><br><span class="line"></span><br><span class="line">    def __init__(self, server_address, bind_and_activate&#x3D;True):</span><br><span class="line">        &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span><br><span class="line">        self.server_address&#x3D;server_address</span><br><span class="line">        self.socket &#x3D; socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        if bind_and_activate:</span><br><span class="line">            try:</span><br><span class="line">                self.server_bind()</span><br><span class="line">                self.server_activate()</span><br><span class="line">            except:</span><br><span class="line">                self.server_close()</span><br><span class="line">                raise</span><br><span class="line"></span><br><span class="line">    def server_bind(self):</span><br><span class="line">        &quot;&quot;&quot;Called by constructor to bind the socket.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self.allow_reuse_address:</span><br><span class="line">            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">        self.socket.bind(self.server_address)</span><br><span class="line">        self.server_address &#x3D; self.socket.getsockname()</span><br><span class="line"></span><br><span class="line">    def server_activate(self):</span><br><span class="line">        &quot;&quot;&quot;Called by constructor to activate the server.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.socket.listen(self.request_queue_size)</span><br><span class="line"></span><br><span class="line">    def server_close(self):</span><br><span class="line">        &quot;&quot;&quot;Called to clean-up the server.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    def get_request(self):</span><br><span class="line">        &quot;&quot;&quot;Get the request and client address from the socket.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.socket.accept()</span><br><span class="line"></span><br><span class="line">    def close_request(self, request):</span><br><span class="line">        &quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</span><br><span class="line">        request.close()</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            self.conn,self.client_addr&#x3D;self.get_request()</span><br><span class="line">            print(&#39;from client &#39;,self.client_addr)</span><br><span class="line">            while True:</span><br><span class="line">                try:</span><br><span class="line">                    head_struct &#x3D; self.conn.recv(4)</span><br><span class="line">                    if not head_struct:break</span><br><span class="line"></span><br><span class="line">                    head_len &#x3D; struct.unpack(&#39;i&#39;, head_struct)[0]</span><br><span class="line">                    head_json &#x3D; self.conn.recv(head_len).decode(self.coding)</span><br><span class="line">                    head_dic &#x3D; json.loads(head_json)</span><br><span class="line"></span><br><span class="line">                    print(head_dic)</span><br><span class="line">                    #head_dic&#x3D;&#123;&#39;cmd&#39;:&#39;put&#39;,&#39;filename&#39;:&#39;a.txt&#39;,&#39;filesize&#39;:123123&#125;</span><br><span class="line">                    cmd&#x3D;head_dic[&#39;cmd&#39;]</span><br><span class="line">                    if hasattr(self,cmd):</span><br><span class="line">                        func&#x3D;getattr(self,cmd)</span><br><span class="line">                        func(head_dic)</span><br><span class="line">                except Exception:</span><br><span class="line">                    break</span><br><span class="line"></span><br><span class="line">    def put(self,args):</span><br><span class="line">        file_path&#x3D;os.path.normpath(os.path.join(</span><br><span class="line">            self.server_dir,</span><br><span class="line">            args[&#39;filename&#39;]</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        filesize&#x3D;args[&#39;filesize&#39;]</span><br><span class="line">        recv_size&#x3D;0</span><br><span class="line">        print(&#39;-----&gt;&#39;,file_path)</span><br><span class="line">        with open(file_path,&#39;wb&#39;) as f:</span><br><span class="line">            while recv_size &lt; filesize:</span><br><span class="line">                recv_data&#x3D;self.conn.recv(self.max_packet_size)</span><br><span class="line">                f.write(recv_data)</span><br><span class="line">                recv_size+&#x3D;len(recv_data)</span><br><span class="line">                print(&#39;recvsize:%s filesize:%s&#39; %(recv_size,filesize))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tcpserver1&#x3D;MYTCPServer((&#39;127.0.0.1&#39;,8080))</span><br><span class="line"></span><br><span class="line">tcpserver1.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#下列代码与本题无关</span><br><span class="line">class MYUDPServer:</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;UDP server class.&quot;&quot;&quot;</span><br><span class="line">    address_family &#x3D; socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type &#x3D; socket.SOCK_DGRAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address &#x3D; False</span><br><span class="line"></span><br><span class="line">    max_packet_size &#x3D; 8192</span><br><span class="line"></span><br><span class="line">    coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">    def get_request(self):</span><br><span class="line">        data, client_addr &#x3D; self.socket.recvfrom(self.max_packet_size)</span><br><span class="line">        return (data, self.socket), client_addr</span><br><span class="line"></span><br><span class="line">    def server_activate(self):</span><br><span class="line">        # No need to call listen() for UDP.</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def shutdown_request(self, request):</span><br><span class="line">        # No need to shutdown anything.</span><br><span class="line">        self.close_request(request)</span><br><span class="line"></span><br><span class="line">    def close_request(self, request):</span><br><span class="line">        # No need to close anything.</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MYTCPClient:</span><br><span class="line">    address_family &#x3D; socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type &#x3D; socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address &#x3D; False</span><br><span class="line"></span><br><span class="line">    max_packet_size &#x3D; 8192</span><br><span class="line"></span><br><span class="line">    coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">    request_queue_size &#x3D; 5</span><br><span class="line"></span><br><span class="line">    def __init__(self, server_address, connect&#x3D;True):</span><br><span class="line">        self.server_address&#x3D;server_address</span><br><span class="line">        self.socket &#x3D; socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        if connect:</span><br><span class="line">            try:</span><br><span class="line">                self.client_connect()</span><br><span class="line">            except:</span><br><span class="line">                self.client_close()</span><br><span class="line">                raise</span><br><span class="line"></span><br><span class="line">    def client_connect(self):</span><br><span class="line">        self.socket.connect(self.server_address)</span><br><span class="line"></span><br><span class="line">    def client_close(self):</span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            inp&#x3D;input(&quot;&gt;&gt;: &quot;).strip()</span><br><span class="line">            if not inp:continue</span><br><span class="line">            l&#x3D;inp.split()</span><br><span class="line">            cmd&#x3D;l[0]</span><br><span class="line">            if hasattr(self,cmd):</span><br><span class="line">                func&#x3D;getattr(self,cmd)</span><br><span class="line">                func(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def put(self,args):</span><br><span class="line">        cmd&#x3D;args[0]</span><br><span class="line">        filename&#x3D;args[1]</span><br><span class="line">        if not os.path.isfile(filename):</span><br><span class="line">            print(&#39;file:%s is not exists&#39; %filename)</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            filesize&#x3D;os.path.getsize(filename)</span><br><span class="line"></span><br><span class="line">        head_dic&#x3D;&#123;&#39;cmd&#39;:cmd,&#39;filename&#39;:os.path.basename(filename),&#39;filesize&#39;:filesize&#125;</span><br><span class="line">        print(head_dic)</span><br><span class="line">        head_json&#x3D;json.dumps(head_dic)</span><br><span class="line">        head_json_bytes&#x3D;bytes(head_json,encoding&#x3D;self.coding)</span><br><span class="line"></span><br><span class="line">        head_struct&#x3D;struct.pack(&#39;i&#39;,len(head_json_bytes))</span><br><span class="line">        self.socket.send(head_struct)</span><br><span class="line">        self.socket.send(head_json_bytes)</span><br><span class="line">        send_size&#x3D;0</span><br><span class="line">        with open(filename,&#39;rb&#39;) as f:</span><br><span class="line">            for line in f:</span><br><span class="line">                self.socket.send(line)</span><br><span class="line">                send_size+&#x3D;len(line)</span><br><span class="line">                print(send_size)</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;upload successful&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client&#x3D;MYTCPClient((&#39;127.0.0.1&#39;,8080))</span><br><span class="line"></span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure>
<h3 id="十三-认证客户端的链接合法性"><a href="#十三-认证客户端的链接合法性" class="headerlink" title="十三 认证客户端的链接合法性"></a>十三 认证客户端的链接合法性</h3><p>如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现</p>
<p>服务端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line">import hmac,os</span><br><span class="line"></span><br><span class="line">secret_key&#x3D;b&#39;linhaifeng bang bang bang&#39;</span><br><span class="line">def conn_auth(conn):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    认证客户端链接</span><br><span class="line">    :param conn:</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    print(&#39;开始验证新链接的合法性&#39;)</span><br><span class="line">    msg&#x3D;os.urandom(32)</span><br><span class="line">    conn.sendall(msg)</span><br><span class="line">    h&#x3D;hmac.new(secret_key,msg)</span><br><span class="line">    digest&#x3D;h.digest()</span><br><span class="line">    respone&#x3D;conn.recv(len(digest))</span><br><span class="line">    return hmac.compare_digest(respone,digest)</span><br><span class="line"></span><br><span class="line">def data_handler(conn,bufsize&#x3D;1024):</span><br><span class="line">    if not conn_auth(conn):</span><br><span class="line">        print(&#39;该链接不合法,关闭&#39;)</span><br><span class="line">        conn.close()</span><br><span class="line">        return</span><br><span class="line">    print(&#39;链接合法,开始通信&#39;)</span><br><span class="line">    while True:</span><br><span class="line">        data&#x3D;conn.recv(bufsize)</span><br><span class="line">        if not data:break</span><br><span class="line">        conn.sendall(data.upper())</span><br><span class="line"></span><br><span class="line">def server_handler(ip_port,bufsize,backlog&#x3D;5):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    只处理链接</span><br><span class="line">    :param ip_port:</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    tcp_socket_server&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_server.bind(ip_port)</span><br><span class="line">    tcp_socket_server.listen(backlog)</span><br><span class="line">    while True:</span><br><span class="line">        conn,addr&#x3D;tcp_socket_server.accept()</span><br><span class="line">        print(&#39;新连接[%s:%s]&#39; %(addr[0],addr[1]))</span><br><span class="line">        data_handler(conn,bufsize)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    ip_port&#x3D;(&#39;127.0.0.1&#39;,9999)</span><br><span class="line">    bufsize&#x3D;1024</span><br><span class="line">    server_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>
<p>客户端（合法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line">import hmac,os</span><br><span class="line"></span><br><span class="line">secret_key&#x3D;b&#39;linhaifeng bang bang bang&#39;</span><br><span class="line">def conn_auth(conn):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    验证客户端到服务器的链接</span><br><span class="line">    :param conn:</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    msg&#x3D;conn.recv(32)</span><br><span class="line">    h&#x3D;hmac.new(secret_key,msg)</span><br><span class="line">    digest&#x3D;h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line">def client_handler(ip_port,bufsize&#x3D;1024):</span><br><span class="line">    tcp_socket_client&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        data&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">        if not data:continue</span><br><span class="line">        if data &#x3D;&#x3D; &#39;quit&#39;:break</span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(&#39;utf-8&#39;))</span><br><span class="line">        respone&#x3D;tcp_socket_client.recv(bufsize)</span><br><span class="line">        print(respone.decode(&#39;utf-8&#39;))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    ip_port&#x3D;(&#39;127.0.0.1&#39;,9999)</span><br><span class="line">    bufsize&#x3D;1024</span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>
<p>客户端（非法，不知道加密）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line">def client_handler(ip_port,bufsize&#x3D;1024):</span><br><span class="line">    tcp_socket_client&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        data&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">        if not data:continue</span><br><span class="line">        if data &#x3D;&#x3D; &#39;quit&#39;:break</span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(&#39;utf-8&#39;))</span><br><span class="line">        respone&#x3D;tcp_socket_client.recv(bufsize)</span><br><span class="line">        print(respone.decode(&#39;utf-8&#39;))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    ip_port&#x3D;(&#39;127.0.0.1&#39;,9999)</span><br><span class="line">    bufsize&#x3D;1024</span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>
<p>客户端（非法，不知道secretkey）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Linhaifeng&#39;</span><br><span class="line">from socket import *</span><br><span class="line">import hmac,os</span><br><span class="line"></span><br><span class="line">secret_key&#x3D;b&#39;linhaifeng bang bang bang1111&#39;</span><br><span class="line">def conn_auth(conn):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    验证客户端到服务器的链接</span><br><span class="line">    :param conn:</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    msg&#x3D;conn.recv(32)</span><br><span class="line">    h&#x3D;hmac.new(secret_key,msg)</span><br><span class="line">    digest&#x3D;h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line">def client_handler(ip_port,bufsize&#x3D;1024):</span><br><span class="line">    tcp_socket_client&#x3D;socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        data&#x3D;input(&#39;&gt;&gt;: &#39;).strip()</span><br><span class="line">        if not data:continue</span><br><span class="line">        if data &#x3D;&#x3D; &#39;quit&#39;:break</span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(&#39;utf-8&#39;))</span><br><span class="line">        respone&#x3D;tcp_socket_client.recv(bufsize)</span><br><span class="line">        print(respone.decode(&#39;utf-8&#39;))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    ip_port&#x3D;(&#39;127.0.0.1&#39;,9999)</span><br><span class="line">    bufsize&#x3D;1024</span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>
<h3 id="十四-socketserver实现并发"><a href="#十四-socketserver实现并发" class="headerlink" title="十四 socketserver实现并发"></a>十四 socketserver实现并发</h3><p>基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环</p>
<p>socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题）</p>
<p>server类：</p>
<p><img src="image/132.png" alt="img"></p>
<p>request类：</p>
<p><img src="image/133.png" alt="img"></p>
<p>继承关系:</p>
<p><img src="image/134.png" alt="img"></p>
<p><img src="image/135.png" alt="img"></p>
<p> <img src="image/136.png" alt="img"></p>
<p>以下述代码为例，分析socketserver源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftpserver&#x3D;socketserver.ThreadingTCPServer((&#39;127.0.0.1&#39;,8080),FtpServer)</span><br><span class="line">ftpserver.serve_forever()</span><br></pre></td></tr></table></figure>
<p>查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer</p>
<ol>
<li>实例化得到ftpserver，先找类ThreadingTCPServer的<strong>init</strong>,在TCPServer中找到，进而执行server_bind,server_active</li>
<li>找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中</li>
<li>执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)</li>
<li>在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address)</li>
<li>上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish<em>request,触发我们自己定义的类的实例化，去找<em>_init</em></em>方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找….</li>
</ol>
<p>源码分析总结：</p>
<p>基于tcp的socketserver我们自己定义的类中的</p>
<ol>
<li>　　self.server即套接字对象</li>
<li>　　self.request即一个链接</li>
<li>　　self.client_address即客户端地址</li>
</ol>
<p>基于udp的socketserver我们自己定义的类中的</p>
<ol>
<li>　　self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b’adsf’, <socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_DGRAM, proto=0, laddr=('127.0.0.1', 8080)>)</li>
<li>　　self.client_address即客户端地址</li>
</ol>
<h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socketserver</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">import os</span><br><span class="line">class FtpServer(socketserver.BaseRequestHandler):</span><br><span class="line">    coding&#x3D;&#39;utf-8&#39;</span><br><span class="line">    server_dir&#x3D;&#39;file_upload&#39;</span><br><span class="line">    max_packet_size&#x3D;1024</span><br><span class="line">    BASE_DIR&#x3D;os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    def handle(self):</span><br><span class="line">        print(self.request)</span><br><span class="line">        while True:</span><br><span class="line">            data&#x3D;self.request.recv(4)</span><br><span class="line">            data_len&#x3D;struct.unpack(&#39;i&#39;,data)[0]</span><br><span class="line">            head_json&#x3D;self.request.recv(data_len).decode(self.coding)</span><br><span class="line">            head_dic&#x3D;json.loads(head_json)</span><br><span class="line">            # print(head_dic)</span><br><span class="line">            cmd&#x3D;head_dic[&#39;cmd&#39;]</span><br><span class="line">            if hasattr(self,cmd):</span><br><span class="line">                func&#x3D;getattr(self,cmd)</span><br><span class="line">                func(head_dic)</span><br><span class="line">    def put(self,args):</span><br><span class="line">        file_path &#x3D; os.path.normpath(os.path.join(</span><br><span class="line">            self.BASE_DIR,</span><br><span class="line">            self.server_dir,</span><br><span class="line">            args[&#39;filename&#39;]</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        filesize &#x3D; args[&#39;filesize&#39;]</span><br><span class="line">        recv_size &#x3D; 0</span><br><span class="line">        print(&#39;-----&gt;&#39;, file_path)</span><br><span class="line">        with open(file_path, &#39;wb&#39;) as f:</span><br><span class="line">            while recv_size &lt; filesize:</span><br><span class="line">                recv_data &#x3D; self.request.recv(self.max_packet_size)</span><br><span class="line">                f.write(recv_data)</span><br><span class="line">                recv_size +&#x3D; len(recv_data)</span><br><span class="line">                print(&#39;recvsize:%s filesize:%s&#39; % (recv_size, filesize))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ftpserver&#x3D;socketserver.ThreadingTCPServer((&#39;127.0.0.1&#39;,8080),FtpServer)</span><br><span class="line">ftpserver.serve_forever()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import json</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class MYTCPClient:</span><br><span class="line">    address_family &#x3D; socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type &#x3D; socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    allow_reuse_address &#x3D; False</span><br><span class="line"></span><br><span class="line">    max_packet_size &#x3D; 8192</span><br><span class="line"></span><br><span class="line">    coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">    request_queue_size &#x3D; 5</span><br><span class="line"></span><br><span class="line">    def __init__(self, server_address, connect&#x3D;True):</span><br><span class="line">        self.server_address&#x3D;server_address</span><br><span class="line">        self.socket &#x3D; socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        if connect:</span><br><span class="line">            try:</span><br><span class="line">                self.client_connect()</span><br><span class="line">            except:</span><br><span class="line">                self.client_close()</span><br><span class="line">                raise</span><br><span class="line"></span><br><span class="line">    def client_connect(self):</span><br><span class="line">        self.socket.connect(self.server_address)</span><br><span class="line"></span><br><span class="line">    def client_close(self):</span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            inp&#x3D;input(&quot;&gt;&gt;: &quot;).strip()</span><br><span class="line">            if not inp:continue</span><br><span class="line">            l&#x3D;inp.split()</span><br><span class="line">            cmd&#x3D;l[0]</span><br><span class="line">            if hasattr(self,cmd):</span><br><span class="line">                func&#x3D;getattr(self,cmd)</span><br><span class="line">                func(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def put(self,args):</span><br><span class="line">        cmd&#x3D;args[0]</span><br><span class="line">        filename&#x3D;args[1]</span><br><span class="line">        if not os.path.isfile(filename):</span><br><span class="line">            print(&#39;file:%s is not exists&#39; %filename)</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            filesize&#x3D;os.path.getsize(filename)</span><br><span class="line"></span><br><span class="line">        head_dic&#x3D;&#123;&#39;cmd&#39;:cmd,&#39;filename&#39;:os.path.basename(filename),&#39;filesize&#39;:filesize&#125;</span><br><span class="line">        print(head_dic)</span><br><span class="line">        head_json&#x3D;json.dumps(head_dic)</span><br><span class="line">        head_json_bytes&#x3D;bytes(head_json,encoding&#x3D;self.coding)</span><br><span class="line"></span><br><span class="line">        head_struct&#x3D;struct.pack(&#39;i&#39;,len(head_json_bytes))</span><br><span class="line">        self.socket.send(head_struct)</span><br><span class="line">        self.socket.send(head_json_bytes)</span><br><span class="line">        send_size&#x3D;0</span><br><span class="line">        with open(filename,&#39;rb&#39;) as f:</span><br><span class="line">            for line in f:</span><br><span class="line">                self.socket.send(line)</span><br><span class="line">                send_size+&#x3D;len(line)</span><br><span class="line">                print(send_size)</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;upload successful&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client&#x3D;MYTCPClient((&#39;127.0.0.1&#39;,8080))</span><br><span class="line"></span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure>
<p> <strong>补充：</strong></p>
<p>两个程序之间通信:管道</p>
<h2 id="九、并发"><a href="#九、并发" class="headerlink" title="九、并发"></a>九、并发</h2><p><a href="https://www.cnblogs.com/yuanchenqi/articles/5733873.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanchenqi/articles/5733873.html</a></p>
<h3 id="并发-amp-并行"><a href="#并发-amp-并行" class="headerlink" title="并发&amp;并行"></a>并发&amp;并行</h3><p>并发：系统具有处理多个任务（动作）的能力</p>
<p>并行：系统具有同时处理多个任务（动作）的能力</p>
<h3 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h3><p>同步：当进程执行到一个IO操作的时候——-等：同步</p>
<p>异步：当进程执行到一个IO操作的时候——-不等：等到数据接收成功，再回来处理</p>
<h3 id="python多进程"><a href="#python多进程" class="headerlink" title="python多进程"></a>python多进程</h3><p>多进程+协程</p>
<p>对于IO密集型任务，python多线程有用；对于计算密集型任务，不推荐多线程，可以使用多进程。</p>
<h3 id="python的GIL"><a href="#python的GIL" class="headerlink" title="python的GIL"></a>python的GIL</h3><p>In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p>
<p>上面的核心意思就是，<strong>无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行</strong></p>
<h2 id="十、python的线程与threading模块"><a href="#十、python的线程与threading模块" class="headerlink" title="十、python的线程与threading模块"></a>十、python的线程与threading模块</h2><h3 id="一-线程的两种调用方式"><a href="#一-线程的两种调用方式" class="headerlink" title="一 线程的两种调用方式"></a>一 线程的两种调用方式</h3><pre><code>  threading 模块建立在thread 模块之上。thread模块以低级、原始的方式来处理和控制线程，而threading 模块通过对thread进行二次封装，
</code></pre><p>提供了更方便的api来处理线程。</p>
<p><strong>直接调用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line">def sayhi(num): #定义每个线程要运行的函数</span><br><span class="line"> </span><br><span class="line">    print(&quot;running on number:%s&quot; %num)</span><br><span class="line"> </span><br><span class="line">    time.sleep(3)</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"> </span><br><span class="line">    t1 &#x3D; threading.Thread(target&#x3D;sayhi,args&#x3D;(1,)) #生成一个线程实例</span><br><span class="line">    t2 &#x3D; threading.Thread(target&#x3D;sayhi,args&#x3D;(2,)) #生成另一个线程实例</span><br><span class="line"> </span><br><span class="line">    t1.start() #启动线程</span><br><span class="line">    t2.start() #启动另一个线程</span><br><span class="line"> </span><br><span class="line">    print(t1.getName()) #获取线程名</span><br><span class="line">    print(t2.getName())</span><br></pre></td></tr></table></figure>
<p><strong>继承式调用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def __init__(self,num):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.num &#x3D; num</span><br><span class="line"></span><br><span class="line">    def run(self):#定义每个线程要运行的函数</span><br><span class="line"></span><br><span class="line">        print(&quot;running on number:%s&quot; %self.num)</span><br><span class="line"></span><br><span class="line">        time.sleep(3)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"></span><br><span class="line">    t1 &#x3D; MyThread(1)</span><br><span class="line">    t2 &#x3D; MyThread(2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    </span><br><span class="line">    print(&quot;ending......&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="二-threading-thread的实例方法"><a href="#二-threading-thread的实例方法" class="headerlink" title="二 threading.thread的实例方法"></a>二 threading.thread的实例方法</h3><h4 id="join-amp-Daemon方法"><a href="#join-amp-Daemon方法" class="headerlink" title="join&amp;Daemon方法"></a>join&amp;Daemon方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">from time import ctime,sleep</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def ListenMusic(name):</span><br><span class="line"></span><br><span class="line">        print (&quot;Begin listening to %s. %s&quot; %(name,ctime()))</span><br><span class="line">        sleep(3)</span><br><span class="line">        print(&quot;end listening %s&quot;%ctime())</span><br><span class="line"></span><br><span class="line">def RecordBlog(title):</span><br><span class="line"></span><br><span class="line">        print (&quot;Begin recording the %s! %s&quot; %(title,ctime()))</span><br><span class="line">        sleep(5)</span><br><span class="line">        print(&#39;end recording %s&#39;%ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads &#x3D; []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 &#x3D; threading.Thread(target&#x3D;ListenMusic,args&#x3D;(&#39;水手&#39;,))</span><br><span class="line">t2 &#x3D; threading.Thread(target&#x3D;RecordBlog,args&#x3D;(&#39;python线程&#39;,))</span><br><span class="line"></span><br><span class="line">threads.append(t1)</span><br><span class="line">threads.append(t2)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"></span><br><span class="line">    for t in threads:</span><br><span class="line">        #t.setDaemon(True) #注意:一定在start之前设置</span><br><span class="line">        t.start()</span><br><span class="line">        # t.join()</span><br><span class="line">    # t1.join()</span><br><span class="line">    t1.setDaemon(True)</span><br><span class="line"></span><br><span class="line">    #t2.join()########考虑这三种join位置下的结果？</span><br><span class="line">    print (&quot;all over %s&quot; %ctime())</span><br></pre></td></tr></table></figure>
<p>join()：在子线程完成运行之前，这个子线程的父线程将一直被阻塞。</p>
<p>daemon：无交互后台程序</p>
<p>setDaemon(True)：（使线程与主线程一起退出）</p>
<pre><code>     将线程声明为守护线程，必须在start() 方法调用之前设置， 如果不设置为守护线程程序会被无限挂起。这个方法基本和join是相反的。
     当我们在程序运行中，执行一个主线程，如果主线程又创建一个子线程，主线程和子线程 就分兵两路，分别运行，那么当主线程完成想退出时，会检验子线程是否完成。如果子线程未完成，则主线程会等待子线程完成后再退出。但是有时候我们需要的是只要主线程完成了，不管子线程是否完成，都要和主线程一起退出，这时就可以用etDaemon方法啦
</code></pre><h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># run():  线程被cpu调度后自动执行线程对象的run方法</span><br><span class="line"># start():启动线程活动。</span><br><span class="line"># isAlive(): 返回线程是否活动的。</span><br><span class="line"># getName(): 返回线程名。</span><br><span class="line"># setName(): 设置线程名。</span><br><span class="line"></span><br><span class="line">threading模块提供的一些方法：</span><br><span class="line"># threading.currentThread(): 返回当前的线程变量。</span><br><span class="line"># threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span><br><span class="line"># threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span><br></pre></td></tr></table></figure>
<h3 id="三-同步锁-Lock"><a href="#三-同步锁-Lock" class="headerlink" title="三 同步锁(Lock)"></a>三 同步锁(Lock)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def addNum():</span><br><span class="line">    global num #在每个线程中都获取这个全局变量</span><br><span class="line">    #num-&#x3D;1</span><br><span class="line"></span><br><span class="line">    temp&#x3D;num</span><br><span class="line">    #print(&#39;--get num:&#39;,num )</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    num &#x3D;temp-1 #对此公共变量进行-1操作</span><br><span class="line"></span><br><span class="line">num &#x3D; 100  #设定一个共享变量</span><br><span class="line">thread_list &#x3D; []</span><br><span class="line">for i in range(100):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;addNum)</span><br><span class="line">    t.start()</span><br><span class="line">    thread_list.append(t)</span><br><span class="line"></span><br><span class="line">for t in thread_list: #等待所有线程执行完毕</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line">print(&#39;final num:&#39;, num )</span><br></pre></td></tr></table></figure>
<p><strong>观察：time.sleep(0.1)  /0.001/0.0000001 结果分别是多少？</strong></p>
<p>多个线程都在同时操作同一个共享资源，所以造成了资源破坏，怎么办呢？(join会造成串行，失去所线程的意义)</p>
<p>我们可以通过同步锁来解决这种问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R&#x3D;threading.Lock()</span><br><span class="line">def sub():</span><br><span class="line">    global num</span><br><span class="line">    R.acquire()</span><br><span class="line">    temp&#x3D;num-1</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    num&#x3D;temp</span><br><span class="line">    R.release()</span><br></pre></td></tr></table></figure>
<h3 id="四-线程死锁和递归锁"><a href="#四-线程死锁和递归锁" class="headerlink" title="四 线程死锁和递归锁"></a>四 线程死锁和递归锁</h3><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去。下面是一个死锁的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading,time</span><br><span class="line"></span><br><span class="line">class myThread(threading.Thread):</span><br><span class="line">    def doA(self):</span><br><span class="line">        lockA.acquire()</span><br><span class="line">        print(self.name,&quot;gotlockA&quot;,time.ctime())</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        lockB.acquire()</span><br><span class="line">        print(self.name,&quot;gotlockB&quot;,time.ctime())</span><br><span class="line">        lockB.release()</span><br><span class="line">        lockA.release()</span><br><span class="line"></span><br><span class="line">    def doB(self):</span><br><span class="line">        lockB.acquire()</span><br><span class="line">        print(self.name,&quot;gotlockB&quot;,time.ctime())</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        lockA.acquire()</span><br><span class="line">        print(self.name,&quot;gotlockA&quot;,time.ctime())</span><br><span class="line">        lockA.release()</span><br><span class="line">        lockB.release()</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">    lockA&#x3D;threading.Lock()</span><br><span class="line">    lockB&#x3D;threading.Lock()</span><br><span class="line">    threads&#x3D;[]</span><br><span class="line">    for i in range(5):</span><br><span class="line">        threads.append(myThread())</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.start()</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.join()#等待线程结束，后面再讲。</span><br></pre></td></tr></table></figure>
<p>解决办法：使用递归锁，将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock&#x3D;threading.RLock()</span><br></pre></td></tr></table></figure>
<p>为了支持在<strong>同一线程中多次请求同一资源</strong>，python提供了“可重入锁”：threading.RLock。RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次acquire。直到一个线程所有的acquire都被release(count=0)，其他的线程才能获得资源。</p>
<p><strong>应用</strong></p>
<h3 id="同步条件-Event"><a href="#同步条件-Event" class="headerlink" title="同步条件(Event)"></a>同步条件(Event)</h3><p>An event is a simple synchronization object;the event represents an internal flag,</p>
<p>and threads can wait for the flag to be set, or set or clear the flag themselves.</p>
<p>event = threading.Event()</p>
<p># a client thread can wait for the flag to be set<br>event.wait()</p>
<p># a server thread can set or reset it<br>event.set()<br>event.clear()</p>
<p>If the flag is set, the wait method doesn’t do anything.<br>If the flag is cleared, wait will block until it becomes set again.<br>Any number of threads may wait for the same event.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading,time</span><br><span class="line">class Boss(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;BOSS：今晚大家都要加班到22:00。&quot;)</span><br><span class="line">        print(event.isSet())</span><br><span class="line">        event.set()</span><br><span class="line">        time.sleep(5)</span><br><span class="line">        print(&quot;BOSS：&lt;22:00&gt;可以下班了。&quot;)</span><br><span class="line">        print(event.isSet())</span><br><span class="line">        event.set()</span><br><span class="line">class Worker(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        event.wait()</span><br><span class="line">        print(&quot;Worker：哎……命苦啊！&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        event.clear()</span><br><span class="line">        event.wait()</span><br><span class="line">        print(&quot;Worker：OhYeah!&quot;)</span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    event&#x3D;threading.Event()</span><br><span class="line">    threads&#x3D;[]</span><br><span class="line">    for i in range(5):</span><br><span class="line">        threads.append(Worker())</span><br><span class="line">    threads.append(Boss())</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.start()</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.join()</span><br></pre></td></tr></table></figure>
<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量(Semaphore)"></a>信号量(Semaphore)</h3><pre><code>  信号量用来控制线程并发数的，BoundedSemaphore或Semaphore管理一个内置的计数 器，每当调用acquire()时-1，调用release()时+1。

  计数器不能小于0，当计数器为 0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。(类似于停车位的概念)

  BoundedSemaphore与Semaphore的唯一区别在于前者将在调用release()时检查计数器的值是否超过了计数器的初始值，如果超过了将抛出一个异常。
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading,time</span><br><span class="line">class myThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        if semaphore.acquire():</span><br><span class="line">            print(self.name)</span><br><span class="line">            time.sleep(5)</span><br><span class="line">            semaphore.release()</span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    semaphore&#x3D;threading.Semaphore(5)</span><br><span class="line">    thrs&#x3D;[]</span><br><span class="line">    for i in range(100):</span><br><span class="line">        thrs.append(myThread())</span><br><span class="line">    for t in thrs:</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<h3 id="多线程利器－－－队列-queue"><a href="#多线程利器－－－队列-queue" class="headerlink" title="多线程利器－－－队列(queue)"></a>多线程利器－－－队列(queue)</h3><h4 id="列表是不安全的数据结构"><a href="#列表是不安全的数据结构" class="headerlink" title="列表是不安全的数据结构"></a><strong>列表是不安全的数据结构</strong></h4><p><strong>思考：如何通过对列来完成上述功能？</strong></p>
<p>queue is especially useful in threaded programming when information must be exchanged safely between multiple threads.</p>
<h4 id="queue列队类的方法"><a href="#queue列队类的方法" class="headerlink" title="queue列队类的方法"></a>queue列队类的方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个“队列”对象</span><br><span class="line">import queue</span><br><span class="line">q &#x3D; queue.Queue(maxsize &#x3D; 10)</span><br><span class="line">Queue.Queue类即是一个队列的同步实现。队列长度可为无限或者有限。可通过Queue的构造函数的可选参数maxsize来设定队列长度。如果maxsize小于1就表示队列长度无限。</span><br><span class="line"></span><br><span class="line">将一个值放入队列中</span><br><span class="line">q.put(10)</span><br><span class="line">调用队列对象的put()方法在队尾插入一个项目。put()有两个参数，第一个item为必需的，为插入项目的值；第二个block为可选参数，默认为</span><br><span class="line">1。如果队列当前为空且block为1，put()方法就使调用线程暂停,直到空出一个数据单元。如果block为0，put方法将引发Full异常。</span><br><span class="line"></span><br><span class="line">将一个值从队列中取出</span><br><span class="line">q.get()</span><br><span class="line">调用队列对象的get()方法从队头删除并返回一个项目。可选参数为block，默认为True。如果队列为空且block为True，</span><br><span class="line">get()就使调用线程暂停，直至有项目可用。如果队列为空且block为False，队列将引发Empty异常。</span><br><span class="line"></span><br><span class="line">Python queue模块有三种队列及构造函数:</span><br><span class="line">1、Python Queue模块的FIFO队列先进先出。   class queue.Queue(maxsize)</span><br><span class="line">2、LIFO类似于堆，即先进后出。               class queue.LifoQueue(maxsize)</span><br><span class="line">3、还有一种是优先级队列级别越低越先出来。        class queue.PriorityQueue(maxsize)</span><br><span class="line">q.put([2,&quot;hello&quot;])   【&lt;级别&gt;，信息】</span><br><span class="line"></span><br><span class="line">此包中的常用方法(q &#x3D; Queue.Queue()):</span><br><span class="line">q.qsize() 返回队列的大小</span><br><span class="line">q.empty() 如果队列为空，返回True,反之False</span><br><span class="line">q.full() 如果队列满了，返回True,反之False</span><br><span class="line">q.full 与 maxsize 大小对应</span><br><span class="line">q.get([block[, timeout]]) 获取队列，timeout等待时间</span><br><span class="line">q.get_nowait() 相当q.get(False)</span><br><span class="line">非阻塞 q.put(item) 写入队列，timeout等待时间</span><br><span class="line">q.put_nowait(item) 相当q.put(item, False)</span><br><span class="line">q.task_done() 在完成一项工作之后，q.task_done() 函数向任务已经完成的队列发送一个信号</span><br><span class="line">q.join() 实际上意味着等到队列为空，再执行别的操作</span><br></pre></td></tr></table></figure>
<h4 id="task-done-amp-join"><a href="#task-done-amp-join" class="headerlink" title="task_done()&amp;join()"></a>task_done()&amp;join()</h4><p><a href="https://stackoverflow.com/questions/49637086/python-what-is-queue-task-done-used-for" target="_blank" rel="noopener">https://stackoverflow.com/questions/49637086/python-what-is-queue-task-done-used-for</a></p>
<p>If I give you a box of work assignments, do I care about when you’ve taken everything out of the box?</p>
<p>No. I care about when <strong>the work is done</strong>. Looking at an empty box doesn’t tell me that. You and 5 other guys might still be working on stuff you took out of the box.</p>
<p><code>Queue.task_done</code> lets workers say when a <em>task is done</em>. Someone waiting for all the work to be done with <code>Queue.join</code> will wait until enough <code>task_done</code> calls have been made, not when the queue is empty.</p>
<h4 id="生产者消费者模型："><a href="#生产者消费者模型：" class="headerlink" title="生产者消费者模型："></a><strong>生产者消费者模型：</strong></h4><p><strong>为什么要使用生产者和消费者模式</strong></p>
<p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</p>
<p><strong>什么是生产者消费者模式</strong></p>
<p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>这就像，在餐厅，厨师做好菜，不需要直接和客户交流，而是交给前台，而客户去饭菜也不需要不找厨师，直接去前台领取即可，这也是一个结耦的过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time,random</span><br><span class="line">import queue,threading</span><br><span class="line"></span><br><span class="line">q &#x3D; queue.Queue()</span><br><span class="line"></span><br><span class="line">def Producer(name):</span><br><span class="line">  count &#x3D; 0</span><br><span class="line">  while count &lt;10:</span><br><span class="line">    print(&quot;making........&quot;)</span><br><span class="line">    time.sleep(random.randrange(3))</span><br><span class="line">    q.put(count)</span><br><span class="line">    print(&#39;Producer %s has produced %s baozi..&#39; %(name, count))</span><br><span class="line">    count +&#x3D;1</span><br><span class="line">    #q.task_done()</span><br><span class="line">    #q.join()</span><br><span class="line">    print(&quot;ok......&quot;)</span><br><span class="line">def Consumer(name):</span><br><span class="line">  count &#x3D; 0</span><br><span class="line">  while count &lt;10:</span><br><span class="line">    time.sleep(random.randrange(4))</span><br><span class="line">    if not q.empty():</span><br><span class="line">        data &#x3D; q.get()</span><br><span class="line">        #q.task_done()</span><br><span class="line">        #q.join()</span><br><span class="line">        print(data)</span><br><span class="line">        print(&#39;\033[32;1mConsumer %s has eat %s baozi...\033[0m&#39; %(name, data))</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;-----no baozi anymore----&quot;)</span><br><span class="line">    count +&#x3D;1</span><br><span class="line"></span><br><span class="line">p1 &#x3D; threading.Thread(target&#x3D;Producer, args&#x3D;(&#39;A&#39;,))</span><br><span class="line">c1 &#x3D; threading.Thread(target&#x3D;Consumer, args&#x3D;(&#39;B&#39;,))</span><br><span class="line"># c2 &#x3D; threading.Thread(target&#x3D;Consumer, args&#x3D;(&#39;C&#39;,))</span><br><span class="line"># c3 &#x3D; threading.Thread(target&#x3D;Consumer, args&#x3D;(&#39;D&#39;,))</span><br><span class="line">p1.start()</span><br><span class="line">c1.start()</span><br><span class="line"># c2.start()</span><br><span class="line"># c3.start()</span><br></pre></td></tr></table></figure>
<h2 id="多进程模块-multiprocessing"><a href="#多进程模块-multiprocessing" class="headerlink" title="多进程模块 multiprocessing"></a>多进程模块 multiprocessing</h2><p><strong>十几个以内的多进程不用考虑资源消耗问题</strong></p>
<p>M<code>ultiprocessing</code> is a package that supports spawning processes using an API similar to the threading module. The <code>multiprocessing</code> package offers both local and remote concurrency,effectively side-stepping the <a href="https://docs.python.org/3.5/glossary.html#term-global-interpreter-lock" target="_blank" rel="noopener">Global Interpreter Lock</a> by using subprocesses instead of threads. Due to this, the <code>multiprocessing</code> module allows the programmer to fully leverage multiple processors on a given machine. It runs on both Unix and Windows.</p>
<p>由于GIL的存在，python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。</p>
<p>multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。</p>
<h3 id="一-进程的调用"><a href="#一-进程的调用" class="headerlink" title="一 进程的调用"></a>一 进程的调用</h3><h4 id="调用方式1"><a href="#调用方式1" class="headerlink" title="调用方式1"></a><strong>调用方式1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">def f(name):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&#39;hello&#39;, name,time.ctime())</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    p_list&#x3D;[]</span><br><span class="line">    for i in range(3):</span><br><span class="line">        p &#x3D; Process(target&#x3D;f, args&#x3D;(&#39;alvin&#39;,))</span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    for i in p_list:</span><br><span class="line">        p.join()</span><br><span class="line">    print(&#39;end&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="调用方式2"><a href="#调用方式2" class="headerlink" title="调用方式2"></a><strong>调用方式2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class MyProcess(Process):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(MyProcess, self).__init__()</span><br><span class="line">        #self.name &#x3D; name</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print (&#39;hello&#39;, self.name,time.ctime())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    p_list&#x3D;[]</span><br><span class="line">    for i in range(3):</span><br><span class="line">        p &#x3D; MyProcess()</span><br><span class="line">        p.start()</span><br><span class="line">        p_list.append(p)</span><br><span class="line"></span><br><span class="line">    for p in p_list:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(&#39;end&#39;)</span><br></pre></td></tr></table></figure>
<p>To show the individual process IDs involved, here is an expanded example:<br>子进程—-》父进程—-》pycharm进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">def info(title):</span><br><span class="line">  </span><br><span class="line">    print(&quot;title:&quot;,title)</span><br><span class="line">    print(&#39;parent process:&#39;, os.getppid())</span><br><span class="line">    print(&#39;process id:&#39;, os.getpid())</span><br><span class="line"></span><br><span class="line">def f(name):</span><br><span class="line">    info(&#39;function f&#39;)</span><br><span class="line">    print(&#39;hello&#39;, name)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    info(&#39;main process line&#39;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;------------------&quot;)</span><br><span class="line">    p &#x3D; Process(target&#x3D;info, args&#x3D;(&#39;yuan&#39;,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<h3 id="二-Process类"><a href="#二-Process类" class="headerlink" title="二 Process类"></a>二 Process类</h3><p><strong>构造方法：</strong></p>
<p>Process([group [, target [, name [, args [, kwargs]]]]])</p>
<p>　　group: 线程组，目前还没有实现，库引用中提示必须是None；<br>　　target: 要执行的方法；<br>　　name: 进程名；<br>　　args/kwargs: 要传入方法的参数。</p>
<p><strong>实例方法：</strong></p>
<p>　　is_alive()：返回进程是否在运行。</p>
<p>　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。</p>
<p>　　start()：进程准备就绪，等待CPU调度</p>
<p>　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。</p>
<p>　　terminate()：不管任务是否完成，立即停止工作进程</p>
<p><strong>属性：</strong></p>
<p>　　daemon：和线程的setDeamon功能一样</p>
<p>　　name：进程名字。</p>
<p>　　pid：进程号。</p>
<h3 id="三-进程间通讯"><a href="#三-进程间通讯" class="headerlink" title="三 进程间通讯　"></a>三 进程间通讯　</h3><h4 id="3-1-进程对列Queue"><a href="#3-1-进程对列Queue" class="headerlink" title="3.1 进程对列Queue"></a><strong>3.1 进程对列Queue</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">def f(q,n):</span><br><span class="line">    #q.put([123, 456, &#39;hello&#39;])</span><br><span class="line">    q.put(n*n+1)</span><br><span class="line">    print(&quot;son process&quot;,id(q))</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    q &#x3D; Queue()  #try: q&#x3D;queue.Queue()</span><br><span class="line">    print(&quot;main process&quot;,id(q))</span><br><span class="line"></span><br><span class="line">    for i in range(3):</span><br><span class="line">        p &#x3D; Process(target&#x3D;f, args&#x3D;(q,i))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    print(q.get())</span><br><span class="line">    print(q.get())</span><br><span class="line">    print(q.get())</span><br></pre></td></tr></table></figure>
<h4 id="3-2-管道"><a href="#3-2-管道" class="headerlink" title="3.2 管道"></a><strong>3.2 管道</strong></h4><p>The<code>Pipe()</code> function returns a pair of connection objects connected by a pipe which by default is duplex (two-way). For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process, Pipe</span><br><span class="line"></span><br><span class="line">def f(conn):</span><br><span class="line">    conn.send([12, &#123;&quot;name&quot;:&quot;yuan&quot;&#125;, &#39;hello&#39;])</span><br><span class="line">    response&#x3D;conn.recv()</span><br><span class="line">    print(&quot;response&quot;,response)</span><br><span class="line">    conn.close()</span><br><span class="line">    print(&quot;q_ID2:&quot;,id(child_conn))</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"></span><br><span class="line">    parent_conn, child_conn &#x3D; Pipe()</span><br><span class="line">    print(&quot;q_ID1:&quot;,id(child_conn))</span><br><span class="line">    p &#x3D; Process(target&#x3D;f, args&#x3D;(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())   # prints &quot;[42, None, &#39;hello&#39;]&quot;</span><br><span class="line">    parent_conn.send(&quot;儿子你好!&quot;)</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p>The two connection objects returned by <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Pipe" target="_blank" rel="noopener"><code>Pipe()</code></a> represent the two ends of the pipe. Each connection object has <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Connection.send" target="_blank" rel="noopener"><code>send()</code></a> and <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Connection.recv" target="_blank" rel="noopener"><code>recv()</code></a> methods (among others). Note that data in a pipe may become corrupted if two processes (or threads) try to read from or write to the <em>same</em> end of the pipe at the same time. Of course there is no risk of corruption from processes using different ends of the pipe at the same time.</p>
<h4 id="3-3-Managers-数据共享"><a href="#3-3-Managers-数据共享" class="headerlink" title="3.3 Managers(数据共享)"></a><strong>3.3 Managers</strong>(数据共享)</h4><p><strong>Queue和pipe只是实现了数据交互，并没实现数据共享，即一个进程去更改另一个进程的数据。</strong></p>
<p>A manager object returned by <code>Manager()</code> controls a server process which holds Python objects and allows other processes to manipulate them using proxies.</p>
<p>A manager returned by <code>Manager()</code> will support types <a href="https://docs.python.org/3.5/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>, <a href="https://docs.python.org/3.5/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.managers.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Lock" target="_blank" rel="noopener"><code>Lock</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.RLock" target="_blank" rel="noopener"><code>RLock</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Semaphore" target="_blank" rel="noopener"><code>Semaphore</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.BoundedSemaphore" target="_blank" rel="noopener"><code>BoundedSemaphore</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Condition" target="_blank" rel="noopener"><code>Condition</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Event" target="_blank" rel="noopener"><code>Event</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Barrier" target="_blank" rel="noopener"><code>Barrier</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Queue" target="_blank" rel="noopener"><code>Queue</code></a>, <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Value" target="_blank" rel="noopener"><code>Value</code></a> and <a href="https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.Array" target="_blank" rel="noopener"><code>Array</code></a>. For example：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process, Manager</span><br><span class="line"></span><br><span class="line">def f(d, l,n):</span><br><span class="line">    d[n] &#x3D; &#39;1&#39;</span><br><span class="line">    d[&#39;2&#39;] &#x3D; 2</span><br><span class="line">    d[0.25] &#x3D; None</span><br><span class="line">    l.append(n)</span><br><span class="line">    #print(l)</span><br><span class="line"></span><br><span class="line">    print(&quot;son process:&quot;,id(d),id(l))</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"></span><br><span class="line">    with Manager() as manager:</span><br><span class="line"></span><br><span class="line">        d &#x3D; manager.dict()</span><br><span class="line"></span><br><span class="line">        l &#x3D; manager.list(range(5))</span><br><span class="line"></span><br><span class="line">        print(&quot;main process:&quot;,id(d),id(l))</span><br><span class="line"></span><br><span class="line">        p_list &#x3D; []</span><br><span class="line"></span><br><span class="line">        for i in range(10):</span><br><span class="line">            p &#x3D; Process(target&#x3D;f, args&#x3D;(d,l,i))</span><br><span class="line">            p.start()</span><br><span class="line">            p_list.append(p)</span><br><span class="line"></span><br><span class="line">        for res in p_list:</span><br><span class="line">            res.join()</span><br><span class="line"></span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br></pre></td></tr></table></figure>
<h3 id="四-进程同步"><a href="#四-进程同步" class="headerlink" title="四 进程同步"></a>四 进程同步</h3><p>Without using the lock output from the different processes is liable to get all mixed up.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process, Lock</span><br><span class="line"></span><br><span class="line">def f(l, i):</span><br><span class="line">  </span><br><span class="line">    with l.acquire():</span><br><span class="line">        print(&#39;hello world %s&#39;%i)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    lock &#x3D; Lock()</span><br><span class="line"></span><br><span class="line">    for num in range(10):</span><br><span class="line">        Process(target&#x3D;f, args&#x3D;(lock, num)).start()</span><br></pre></td></tr></table></figure>
<h3 id="五-进程池"><a href="#五-进程池" class="headerlink" title="五 进程池"></a>五 进程池</h3><p>回调函数：<a href="https://www.zhihu.com/question/19801131" target="_blank" rel="noopener">https://www.zhihu.com/question/19801131</a></p>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<p>进程池中有两个方法：</p>
<ul>
<li>apply</li>
<li>apply_async</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from  multiprocessing import Process,Pool</span><br><span class="line">import time,os</span><br><span class="line"></span><br><span class="line">def Foo(i):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(i)</span><br><span class="line">    return i+100</span><br><span class="line"></span><br><span class="line">def Bar(arg):</span><br><span class="line"></span><br><span class="line">    print(os.getpid())</span><br><span class="line">    print(os.getppid())</span><br><span class="line">    print(&#39;logger:&#39;,arg)</span><br><span class="line"></span><br><span class="line">pool &#x3D; Pool(5)</span><br><span class="line"></span><br><span class="line">Bar(1)</span><br><span class="line">print(&quot;----------------&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    #pool.apply(func&#x3D;Foo, args&#x3D;(i,)) # 串行，平时不用</span><br><span class="line">    #pool.apply_async(func&#x3D;Foo, args&#x3D;(i,))</span><br><span class="line">    pool.apply_async(func&#x3D;Foo, args&#x3D;(i,),callback&#x3D;Bar) #callback回调函数</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join() # join和close的调用顺序是固定的</span><br><span class="line">print(&#39;end&#39;)</span><br></pre></td></tr></table></figure>
<h2 id="四-Python中的上下文管理器-contextlib模块"><a href="#四-Python中的上下文管理器-contextlib模块" class="headerlink" title="四 Python中的上下文管理器(contextlib模块)"></a>四 Python中的上下文管理器(<strong>contextlib模块</strong>)</h2><p><strong>上下文管理器的任务是：代码块执行前准备，代码块执行后收拾</strong></p>
<h3 id="1-如何使用上下文管理器："><a href="#1-如何使用上下文管理器：" class="headerlink" title="1 如何使用上下文管理器："></a><strong>1 如何使用上下文管理器：</strong></h3><p>如何打开一个文件，并写入”hello world”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename&#x3D;&quot;my.txt&quot;</span><br><span class="line">mode&#x3D;&quot;w&quot;</span><br><span class="line">f&#x3D;open(filename,mode)</span><br><span class="line">f.write(&quot;hello world&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>当发生异常时（如磁盘写满），就没有机会执行第5行。当然，我们可以采用try-finally语句块进行包装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">writer&#x3D;open(filename,mode)</span><br><span class="line">try:</span><br><span class="line">    writer.write(&quot;hello world&quot;)</span><br><span class="line">finally:</span><br><span class="line">    writer.close()</span><br></pre></td></tr></table></figure>
<p>当我们进行复杂的操作时，try-finally语句就会变得丑陋，采用with语句重写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(filename,mode) as writer:</span><br><span class="line">    writer.write(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>
<p>as指代了从open()函数返回的内容，并把它赋给了新值。with完成了try-finally的任务。</p>
<h3 id="2-自定义上下文管理器"><a href="#2-自定义上下文管理器" class="headerlink" title="2 自定义上下文管理器　　"></a><strong>2 自定义上下文管理器</strong>　　</h3><p>with语句的作用类似于try-finally，提供一种上下文机制。要应用with语句的类，其内部必须提供两个内置函数<strong>enter</strong>和<strong>exit</strong>。前者在主体代码执行前执行，后者在主体代码执行后执行。as后面的变量，是在<strong>enter</strong>函数中返回的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class echo():</span><br><span class="line">    def output(self):</span><br><span class="line">        print &quot;hello world&quot;</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print &quot;enter&quot;</span><br><span class="line">        return self  #可以返回任何希望返回的东西</span><br><span class="line">    def __exit__(self,exception_type,value,trackback):</span><br><span class="line">        print &quot;exit&quot;</span><br><span class="line">        if exception_type&#x3D;&#x3D;ValueError:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return Flase</span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt;with echo as e:</span><br><span class="line">    e.output()</span><br><span class="line">     </span><br><span class="line">输出：</span><br><span class="line">enter</span><br><span class="line">hello world</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>完备的<strong>exit</strong>函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def __exit__(self,exc_type,exc_value,exc_tb)</span><br></pre></td></tr></table></figure>
<p>其中，exc_type:异常类型；exc_value:异常值；exc_tb:异常追踪信息</p>
<p>当<strong>exit</strong>返回True时，异常不传播</p>
<h3 id="3-contextlib模块"><a href="#3-contextlib模块" class="headerlink" title="3 contextlib模块　　"></a>3 contextlib模块　　</h3><p>contextlib模块的作用是提供更易用的上下文管理器，它是通过Generator实现的。contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制，常用框架如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line">@contextmanager</span><br><span class="line">def make_context():</span><br><span class="line">    print &#39;enter&#39;</span><br><span class="line">    try:</span><br><span class="line">        yield &quot;ok&quot;</span><br><span class="line">    except RuntimeError,err:</span><br><span class="line">        print &#39;error&#39;,err</span><br><span class="line">    finally:</span><br><span class="line">        print &#39;exit&#39;</span><br><span class="line">         </span><br><span class="line">&gt;&gt;&gt;with make_context() as value:</span><br><span class="line">    print value</span><br><span class="line">     </span><br><span class="line">输出为：</span><br><span class="line">    enter</span><br><span class="line">    ok</span><br><span class="line">    exit</span><br></pre></td></tr></table></figure>
<p>其中，yield写入try-finally中是为了保证异常安全（能处理异常）as后的变量的值是由yield返回。yield前面的语句可看作代码块执行前操作，yield之后的操作可以看作在<strong>exit</strong>函数中的操作。</p>
<p>以线程锁为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@contextlib.contextmanager</span><br><span class="line">def loudLock():</span><br><span class="line">    print &#39;Locking&#39;</span><br><span class="line">    lock.acquire()</span><br><span class="line">    yield</span><br><span class="line">    print &#39;Releasing&#39;</span><br><span class="line">    lock.release()</span><br><span class="line"> </span><br><span class="line">with loudLock():</span><br><span class="line">    print &#39;Lock is locked: %s&#39; % lock.locked()</span><br><span class="line">    print &#39;Doing something that needs locking&#39;</span><br><span class="line"> </span><br><span class="line">#Output:</span><br><span class="line">#Locking</span><br><span class="line">#Lock is locked: True</span><br><span class="line">#Doing something that needs locking</span><br><span class="line">#Releasing</span><br></pre></td></tr></table></figure>
<h3 id="4-contextlib-nested-减少嵌套"><a href="#4-contextlib-nested-减少嵌套" class="headerlink" title="4 contextlib.nested:减少嵌套"></a><strong>4 contextlib.nested:减少嵌套</strong></h3><p><strong>对于：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(filename,mode) as reader:</span><br><span class="line">    with open(filename1,mode1) as writer:</span><br><span class="line">        writer.write(reader.read())</span><br></pre></td></tr></table></figure>
<p>可以通过contextlib.nested进行简化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with contextlib.nested(open(filename,mode),open(filename1,mode1)) as (reader,writer):</span><br><span class="line">    writer.write(reader.read())</span><br></pre></td></tr></table></figure>
<p>在python 2.7及以后，被一种新的语法取代：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(filename,mode) as reader,open(filename1,mode1) as writer:</span><br><span class="line">    writer.write(reader.read())</span><br></pre></td></tr></table></figure>
<h3 id="5-contextlib-closing"><a href="#5-contextlib-closing" class="headerlink" title="5 contextlib.closing()　"></a><strong>5 contextlib.closing()</strong>　</h3><p>file类直接支持上下文管理器API，但有些表示打开句柄的对象并不支持，如urllib.urlopen()返回的对象。还有些遗留类，使用close()方法而不支持上下文管理器API。为了确保关闭句柄，需要使用closing()为它创建一个上下文管理器（调用类的close方法）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'__init__'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'close()'</span></span><br><span class="line">     </span><br><span class="line"><span class="keyword">with</span> contextlib.closing(myclass()):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'ok'</span></span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">__init__</span><br><span class="line">ok</span><br><span class="line">close()</span><br></pre></td></tr></table></figure>
<h2 id="十一、协程"><a href="#十一、协程" class="headerlink" title="十一、协程"></a>十一、协程</h2><p>协程主要面向IO操作</p>
<p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>优点1: 协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，<strong>没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>优点2: <strong>不需要多线程的锁机制</strong>，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<h3 id="yield的简单实现"><a href="#yield的简单实现" class="headerlink" title="yield的简单实现"></a>yield的简单实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">def consumer(name):</span><br><span class="line">    print(&quot;---&gt;ready to eat baozi...&quot;)</span><br><span class="line">    while True:</span><br><span class="line">        new_baozi &#x3D; yield</span><br><span class="line">        print(&quot;[%s] is eating baozi %s&quot; % (name,new_baozi))</span><br><span class="line">        #time.sleep(1)</span><br><span class="line"></span><br><span class="line">def producer():</span><br><span class="line"></span><br><span class="line">    r &#x3D; con.__next__()</span><br><span class="line">    r &#x3D; con2.__next__()</span><br><span class="line">    n &#x3D; 0</span><br><span class="line">    while 1:</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print(&quot;\033[32;1m[producer]\033[0m is making baozi %s and %s&quot; %(n,n+1) )</span><br><span class="line">        con.send(n)</span><br><span class="line">        con2.send(n+1)</span><br><span class="line"></span><br><span class="line">        n +&#x3D;2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    con &#x3D; consumer(&quot;c1&quot;)</span><br><span class="line">    con2 &#x3D; consumer(&quot;c2&quot;)</span><br><span class="line">    p &#x3D; producer()</span><br></pre></td></tr></table></figure>
<h3 id="Greenlet"><a href="#Greenlet" class="headerlink" title="Greenlet"></a>Greenlet</h3><p>greenlet是一个用C实现的协程模块，相比与python自带的yield，它可以使你在任意函数之间随意切换，而不需把这个函数先声明为generator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def test1():</span><br><span class="line">    print(12)</span><br><span class="line">    gr2.switch()</span><br><span class="line">    print(34)</span><br><span class="line">    gr2.switch()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def test2():</span><br><span class="line">    print(56)</span><br><span class="line">    gr1.switch()</span><br><span class="line">    print(78)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">gr1 &#x3D; greenlet(test1)</span><br><span class="line">gr2 &#x3D; greenlet(test2)</span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure>
<h3 id="Gevent"><a href="#Gevent" class="headerlink" title="Gevent"></a>Gevent</h3><p>【<a href="https://softlns.github.io/2015/11/28/python-gevent/" target="_blank" rel="noopener">https://softlns.github.io/2015/11/28/python-gevent/</a>】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import gevent</span><br><span class="line">import requests,time</span><br><span class="line"></span><br><span class="line">start&#x3D;time.time()</span><br><span class="line"></span><br><span class="line">def f(url):</span><br><span class="line">    print(&#39;GET: %s&#39; % url)</span><br><span class="line">    resp &#x3D;requests.get(url)</span><br><span class="line">    data &#x3D; resp.text</span><br><span class="line">    print(&#39;%d bytes received from %s.&#39; % (len(data), url))</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line"></span><br><span class="line">        gevent.spawn(f, &#39;https:&#x2F;&#x2F;www.python.org&#x2F;&#39;),</span><br><span class="line">        gevent.spawn(f, &#39;https:&#x2F;&#x2F;www.yahoo.com&#x2F;&#39;),</span><br><span class="line">        gevent.spawn(f, &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;),</span><br><span class="line">        gevent.spawn(f, &#39;https:&#x2F;&#x2F;www.sina.com.cn&#x2F;&#39;),</span><br><span class="line"></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># f(&#39;https:&#x2F;&#x2F;www.python.org&#x2F;&#39;)</span><br><span class="line">#</span><br><span class="line"># f(&#39;https:&#x2F;&#x2F;www.yahoo.com&#x2F;&#39;)</span><br><span class="line">#</span><br><span class="line"># f(&#39;https:&#x2F;&#x2F;baidu.com&#x2F;&#39;)</span><br><span class="line">#</span><br><span class="line"># f(&#39;https:&#x2F;&#x2F;www.sina.com.cn&#x2F;&#39;)</span><br><span class="line"></span><br><span class="line">print(&quot;cost time:&quot;,time.time()-start)</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/yuanchenqi/articles/5722574.html" target="_blank" rel="noopener">http://www.cnblogs.com/yuanchenqi/articles/5722574.html</a></p>
<h2 id="十二、IO模型"><a href="#十二、IO模型" class="headerlink" title="十二、IO模型"></a>十二、IO模型</h2><h3 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h3><p>上节的问题：<br>协程：遇到IO操作就切换。<br>但什么时候切回去呢？怎么确定IO操作完了？</p>
<p>传统的编程是如下线性模式的：</p>
<p>开始—-&gt;代码块A—-&gt;代码块B—-&gt;代码块C—-&gt;代码块D—-&gt;……—-&gt;结束</p>
<p>每一个代码块里是完成各种各样事情的代码，但编程者知道代码块A,B,C,D…的执行顺序，唯一能够改变这个流程的是数据。输入不同的数据，根据条件语句判断，流程或许就改为A—-&gt;C—-&gt;E…—-&gt;结束。每一次程序运行顺序或许都不同，但它的控制流程是由输入数据和你编写的程序决定的。如果你知道这个程序当前的运行状态（包括输入数据和程序本身），那你就知道接下来甚至一直到结束它的运行流程。</p>
<p> 对于事件驱动型程序模型，它的流程大致如下：</p>
<p>开始—-&gt;初始化—-&gt;等待</p>
<p> 与上面传统编程模式不同，事件驱动程序在启动之后，就在那等待，等待什么呢？等待被事件触发。传统编程下也有“等待”的时候，比如在代码块D中，你定义了一个input()，需要用户输入数据。但这与下面的等待不同，传统编程的“等待”，比如input()，你作为程序编写者是知道或者强制用户输入某个东西的，或许是数字，或许是文件名称，如果用户输入错误，你还需要提醒他，并请他重新输入。事件驱动程序的等待则是完全不知道，也不强制用户输入或者干什么。只要某一事件发生，那程序就会做出相应的“反应”。这些事件包括：输入信息、鼠标、敲击键盘上某个键还有系统内部定时器触发。</p>
<h3 id="一、事件驱动模型介绍"><a href="#一、事件驱动模型介绍" class="headerlink" title="一、事件驱动模型介绍"></a>一、事件驱动模型介绍</h3><p>通常，我们写服务器处理模型的程序时，有以下几种模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）每收到一个请求，创建一个新的进程，来处理该请求； </span><br><span class="line">（2）每收到一个请求，创建一个新的线程，来处理该请求； </span><br><span class="line">（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I&#x2F;O方式来处理请求</span><br></pre></td></tr></table></figure>
<p>第三种就是协程、事件驱动的方式，一般普遍认为第（3）种方式是大多数网络服务器采用的方式 </p>
<p><strong>论事件驱动模型</strong> </p>
<p><img src="image/ContractedBlock-1558531626082.gif" alt="img"> 事件驱动之鼠标点击事件注册</p>
<p>在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？ 两种方式：</p>
<h4 id="1创建一个线程循环检测是否有鼠标点击"><a href="#1创建一个线程循环检测是否有鼠标点击" class="headerlink" title="1创建一个线程循环检测是否有鼠标点击"></a>1创建一个线程循环检测是否有鼠标点击</h4><p>​      那么这个方式有以下几个缺点：</p>
<ol>
<li>CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？</li>
<li>如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；</li>
<li>如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；<br>所以，该方式是非常不好的。</li>
</ol>
<h4 id="2-就是事件驱动模型"><a href="#2-就是事件驱动模型" class="headerlink" title="2 就是事件驱动模型"></a>2 就是事件驱动模型</h4><p>目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：</p>
<ol>
<li>有一个事件（消息）队列；</li>
<li>鼠标按下时，往这个队列中增加一个点击事件（消息）；</li>
<li>有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；</li>
<li>事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；<br><img src="image/20161012022913536" alt="这里写图片描述"><br><strong>事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理</strong>。另外两种常见的编程范式是（单线程）同步以及多线程编程。<br>　<br>让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了。<br><img src="image/20161012023013850" alt="这里写图片描述"></li>
</ol>
<p>最初的问题：怎么确定IO操作完了切回去呢？<strong>通过回调函数</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu.</span><br><span class="line">2.再说什么是事件驱动的程序。一个典型的事件驱动的程序，就是一个死循环，并以一个线程的形式存在，这个死循环包括两个部分，第一个部分是按照一定的条件接收并选择一个要处理的事件，第二个部分就是事件的处理过程。程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序会因查询事件队列失败而进入睡眠状态，从而释放cpu。</span><br><span class="line">3.事件驱动的程序，必定会直接或者间接拥有一个事件队列，用于存储未能及时处理的事件。</span><br><span class="line">4.事件驱动的程序的行为，完全受外部输入的事件控制，所以，事件驱动的系统中，存在大量这种程序，并以事件作为主要的通信方式。</span><br><span class="line">5.事件驱动的程序，还有一个最大的好处，就是可以按照一定的顺序处理队列中的事件，而这个顺序则是由事件的触发顺序决定的，这一特性往往被用于保证某些过程的原子化。</span><br><span class="line">6.目前windows,linux,nucleus,vxworks都是事件驱动的，只有一些单片机可能是非事件驱动的。</span><br></pre></td></tr></table></figure>
<p>注意，事件驱动的监听事件是由操作系统调用的cpu来完成的</p>
<h2 id="十三、IO多路复用"><a href="#十三、IO多路复用" class="headerlink" title="十三、IO多路复用"></a>十三、IO多路复用</h2><p>前面是用协程实现的IO阻塞自动切换，那么协程又是怎么实现的，在原理是是怎么实现的。如何去实现事件驱动的情况下IO的自动阻塞的切换，这个学名叫什么呢？ =&gt; IO多路复用<br>比如socketserver，多个客户端连接，单线程下实现并发效果，就叫多路复用。<br>　<br>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。 </p>
<blockquote>
<p>本文讨论的背景是Linux环境下的network IO。</p>
</blockquote>
<h3 id="1-IO模型前戏准备"><a href="#1-IO模型前戏准备" class="headerlink" title="1 IO模型前戏准备"></a><strong>1 IO模型前戏准备</strong></h3><p>在进行解释之前，首先要说明几个概念：</p>
<ol>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程的阻塞</li>
<li>文件描述符</li>
<li>缓存 I/O</li>
</ol>
<h4 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h4><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<br>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。<br>为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。<br>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。 </p>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换，这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。<br>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<p>保存处理机上下文，包括程序计数器和其他寄存器。</p>
<p>更新PCB信息。</p>
<p>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</p>
<p>选择另一个进程执行，并更新其PCB。</p>
<p>更新内存管理的数据结构。</p>
<p>恢复处理机上下文。<br>注：总而言之就是很耗资源的</p>
<h4 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p>
<h4 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h4><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h4 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h4><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。用户空间没法直接访问内核空间的，内核态到用户态的数据拷贝 </p>
<p>思考：为什么数据一定要先到内核区，直接到用户内存不是更直接吗？<br>内核不能信任任何用户空间的指针。必须对用户空间的指针指向的数据进行验证。如果只做验证不做拷贝的话，那么在随后的运行中要随时受到其它进／线程可能修改用户空间数据的威胁。所以必须做拷贝。</p>
<p>缓存 I/O 的缺点： </p>
<p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<p>​       同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，我先限定一下本文的上下文。<br>本文讨论的背景是Linux环境下的network IO。 </p>
<p>Stevens在文章中一共比较了五种IO Model：</p>
<ul>
<li><ul>
<li><ul>
<li>​    blocking IO</li>
<li>​    nonblocking IO</li>
<li>​    IO multiplexing</li>
<li>​    signal driven IO</li>
<li>​    asynchronous IO</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。<br>再说一下IO发生时涉及的对象和步骤。<br>      对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：<br> 1 等待数据准备 (Waiting for the data to be ready)<br> 2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)<br>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</p>
<h3 id="2-blocking-IO-（阻塞IO）"><a href="#2-blocking-IO-（阻塞IO）" class="headerlink" title="2 blocking IO （阻塞IO）"></a>2 blocking IO （阻塞IO）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="image/0_1280550787I2K8.gif" alt="img"></p>
<p>​      当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
<h3 id="3-non-blocking-IO（非阻塞IO）"><a href="#3-non-blocking-IO（非阻塞IO）" class="headerlink" title="3 non-blocking IO（非阻塞IO）"></a>3 non-blocking IO（非阻塞IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="image/0_128055089469yL.gif" alt="img"></p>
<p>​      从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。</p>
<p> 注意：</p>
<p>​      在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。<strong>即每次recvform系统调用之间，cpu的权限还在进程手中，这段时间是可以做其他事情的，</strong></p>
<p>​      也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
<h3 id="4-IO-multiplexing（IO多路复用）"><a href="#4-IO-multiplexing（IO多路复用）" class="headerlink" title="4  IO multiplexing（IO多路复用）"></a>4  IO multiplexing（IO多路复用）</h3><p>​      IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p>
<p><img src="image/0_1280551028YEeQ.gif" alt="img"></p>
<p>​      当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”select负责的所有socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<p>注意1：select函数返回结果中如果有文件可读了，那么进程就可以通过调用accept()或recv()来让kernel将位于内核中准备到的数据copy到用户区。</p>
<p>注意2: select的优势在于可以处理多个连接，不适用于单个连接</p>
<h3 id="5-Asynchronous-I-O（异步IO）"><a href="#5-Asynchronous-I-O（异步IO）" class="headerlink" title="5  Asynchronous I/O（异步IO）"></a><strong>5  Asynchronous I/O（异步IO）</strong></h3><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：</p>
<p><img src="image/0_1280551287S777.gif" alt="img"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>​      到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。<br>先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：<br>    <strong>A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes;    An asynchronous I/O operation does not cause the requesting process to be blocked;</strong><br>      两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<p>​       注意：由于咱们接下来要讲的select，poll，epoll都属于IO多路复用，而IO多路复用又属于同步的范畴，故，epoll只是一个伪异步而已。</p>
<p>各个IO Model的比较如图所示：</p>
<p><img src="image/0_1280551552NVgW.gif" alt="img"></p>
<p>​      经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<p>五种IO模型比较：</p>
<p>​      <img src="image/877318-20160731161330028-1449419644.png" alt="img"> </p>
<h3 id="6-select-poll-epoll-IO多路复用介绍"><a href="#6-select-poll-epoll-IO多路复用介绍" class="headerlink" title="6 select poll epoll IO多路复用介绍"></a>6 <strong>select poll epoll IO多路复用介绍</strong></h3><p><strong>首先列一下，sellect、poll、epoll三者的区别</strong></p>
<ul>
<li><p><strong>select</strong><br>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。<br><strong>select目前几乎在所有的平台上支持</strong><br>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。<br>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</p>
</li>
<li><p><strong>poll</strong><br>它和select在本质上没有多大差别，但是poll<strong>没有最大文件描述符数量的限制</strong>。<br>一般也不用它，相当于过渡阶段</p>
</li>
<li><p><strong>epoll</strong><br>直到Linux2.6才出现了由<strong>内核直接支持的实现方法</strong>，那就是epoll。被公认为Linux2.6下性能最好的多路I/O就绪通知方法。windows不支持 </p>
<p>没有最大文件描述符数量的限制。<br>比如100个连接，有两个活跃了，epoll会告诉用户这两个两个活跃了，直接取就ok了，而select是循环一遍。 </p>
<p>（了解）epoll可以<strong>同时支持水平触发和边缘触发</strong>（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。<br>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。 </p>
<p>所以市面上上见到的所谓的异步IO，比如nginx、Tornado、等，我们叫它异步IO，实际上是IO多路复用。</p>
</li>
</ul>
<p><strong>select与epoll</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I&#x2F;O操作的内核对象。</span><br><span class="line"># 不管是文件，还是套接字，还是管道，我们都可以把他们看作流。</span><br><span class="line"># 之后我们来讨论I&#x2F;O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假</span><br><span class="line"># 定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是</span><br><span class="line"># 服务器还没有把数据传回来），这时候该怎么办？</span><br><span class="line"># 阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干</span><br><span class="line"># （或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话</span><br><span class="line"># （假定一定能叫醒你）。</span><br><span class="line"># 非阻塞忙轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂</span><br><span class="line"># 个电话：“你到了没？”</span><br><span class="line"># 很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。</span><br><span class="line"># 大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，</span><br><span class="line"># 就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。</span><br><span class="line">#</span><br><span class="line"># 为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I&#x2F;O事件解释清楚。缓冲区的引入是为</span><br><span class="line"># 了减少频繁I&#x2F;O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进</span><br><span class="line"># 行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。</span><br><span class="line"># 假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。</span><br><span class="line"># 假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变</span><br><span class="line"># 到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。</span><br><span class="line"># 但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写</span><br><span class="line"># 入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候</span><br><span class="line"># 会产生一个I&#x2F;O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。</span><br><span class="line"># 假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从</span><br><span class="line"># 长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”</span><br><span class="line"># 也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告</span><br><span class="line"># 诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。</span><br><span class="line"># 这四个情形涵盖了四个I&#x2F;O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四</span><br><span class="line"># 个术语都是我生造的，仅为解释其原理而造）。这四个I&#x2F;O事件是进行阻塞同步的根本。（如果不能理解“同步”是</span><br><span class="line"># 什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</span><br><span class="line">#</span><br><span class="line"># 然后我们来说说阻塞I&#x2F;O的缺点。但是阻塞I&#x2F;O模式下，一个线程只能处理一个流的I&#x2F;O事件。如果想要同时处理多</span><br><span class="line"># 个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。</span><br><span class="line"># 于是再来考虑非阻塞忙轮询的I&#x2F;O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞</span><br><span class="line"># 模式再此不予讨论）：</span><br><span class="line"># while true &#123;</span><br><span class="line"># for i in stream[]; &#123;</span><br><span class="line"># if i has data</span><br><span class="line"># read until unavailable</span><br><span class="line"># &#125;</span><br><span class="line"># &#125;</span><br><span class="line"># 我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为</span><br><span class="line"># 如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I&#x2F;O事件的处理是阻</span><br><span class="line"># 塞或者唤醒，而非阻塞模式下则把I&#x2F;O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。</span><br><span class="line">#</span><br><span class="line"># 为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不</span><br><span class="line"># 过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I&#x2F;O事件，在空闲的时候，会把当前线程阻</span><br><span class="line"># 塞掉，当有一个或多个流有I&#x2F;O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可</span><br><span class="line"># 以把“忙”字去掉了）。代码长这样:</span><br><span class="line"># while true &#123;</span><br><span class="line"># select(streams[])</span><br><span class="line"># for i in streams[] &#123;</span><br><span class="line"># if i has data</span><br><span class="line"># read until unavailable</span><br><span class="line"># &#125;</span><br><span class="line"># &#125;</span><br><span class="line"># 于是，如果没有I&#x2F;O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知</span><br><span class="line"># 道了，有I&#x2F;O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，</span><br><span class="line"># 找出能读出数据，或者写入数据的流，对他们进行操作。</span><br><span class="line"># 但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次</span><br><span class="line"># 说了这么多，终于能好好解释epoll了</span><br><span class="line"># epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I&#x2F;O事件通知我</span><br><span class="line"># 们。此时我们对这些流的操作都是有意义的。</span><br><span class="line"># 在讨论epoll的实现细节之前，先把epoll的相关操作列出：</span><br><span class="line"># epoll_create 创建一个epoll对象，一般epollfd &#x3D; epoll_create()</span><br><span class="line"># epoll_ctl （epoll_add&#x2F;epoll_del的合体），往epoll对象中增加&#x2F;删除某一个流的某一个事件</span><br><span class="line"># 比如</span><br><span class="line"># epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);&#x2F;&#x2F;有缓冲区内有数据时epoll_wait返回</span><br><span class="line"># epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);&#x2F;&#x2F;缓冲区可写入时epoll_wait返回</span><br><span class="line"># epoll_wait(epollfd,...)等待直到注册的事件发生</span><br><span class="line"># （注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write&#x2F;read会返回-1，并设置errno&#x3D;EAGAIN。</span><br><span class="line"># 而epoll只关心缓冲区非满和缓冲区非空事件）。</span><br><span class="line"># 一个epoll模式的代码大概的样子是：</span><br><span class="line"># while true &#123;</span><br><span class="line"># active_stream[] &#x3D; epoll_wait(epollfd)</span><br><span class="line"># for i in active_stream[] &#123;</span><br><span class="line"># read or write till unavailable</span><br><span class="line"># &#125;</span><br><span class="line"># &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举个例子:</span><br><span class="line">#    select:</span><br><span class="line">#          班里三十个同学在考试,谁先做完想交卷都要通过按钮来活动,他按按钮作为老师的我桌子上的灯就会变红.</span><br><span class="line">#          一旦灯变红,我(select)我就可以知道有人交卷了,但是我并不知道谁交的,所以,我必须跟个傻子似的轮询</span><br><span class="line">#          地去问:嘿,是你要交卷吗?然后我就可以以这种效率极低地方式找到要交卷的学生,然后把它的卷子收上来.</span><br><span class="line">#</span><br><span class="line">#    epoll:</span><br><span class="line">#         这次再有人按按钮,我这不光灯会亮,上面还会显示要交卷学生的名字.这样我就可以直接去对应学生那收卷就</span><br><span class="line">#         好了.当然,同时可以有多人交卷.</span><br></pre></td></tr></table></figure>
<p><strong>IO多路复用的触发方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在linux的IO多路复用中有水平触发,边缘触发两种模式,这两种模式的区别如下:</span><br><span class="line">#</span><br><span class="line"># 水平触发:如果文件描述符已经就绪可以非阻塞的执行IO操作了,此时会触发通知.允许在任意时刻重复检测IO的状态,</span><br><span class="line"># 没有必要每次描述符就绪后尽可能多的执行IO.select,poll就属于水平触发.</span><br><span class="line">#</span><br><span class="line"># 边缘触发:如果文件描述符自上次状态改变后有新的IO活动到来,此时会触发通知.在收到一个IO事件通知后要尽可能</span><br><span class="line"># 多的执行IO操作,因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述</span><br><span class="line"># 符.信号驱动式IO就属于边缘触发.</span><br><span class="line">#</span><br><span class="line"># epoll既可以采用水平触发,也可以采用边缘触发.</span><br><span class="line">#</span><br><span class="line"># 大家可能还不能完全了解这两种模式的区别,我们可以举例说明:一个管道收到了1kb的数据,epoll会立即返回,此时</span><br><span class="line"># 读了512字节数据,然后再次调用epoll.这时如果是水平触发的,epoll会立即返回,因为有数据准备好了.如果是边</span><br><span class="line"># 缘触发的不会立即返回,因为此时虽然有数据可读但是已经触发了一次通知,在这次通知到现在还没有新的数据到来,</span><br><span class="line"># 直到有新的数据到来epoll才会返回,此时老的数据和新的数据都可以读取到(当然是需要这次你尽可能的多读取).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下面我们还从电子的角度来解释一下:</span><br><span class="line"># </span><br><span class="line">#     水平触发:也就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知.上面提到的只要</span><br><span class="line"># 有数据可读(描述符就绪)那么水平触发的epoll就立即返回.</span><br><span class="line"># </span><br><span class="line">#     边缘触发:只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据</span><br><span class="line"># 可读,但是没有新的IO活动到来,epoll也不会立即返回.</span><br></pre></td></tr></table></figure>
<h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a><strong>简单实例</strong></h3><p><strong>实例1(non-blocking IO)：</strong>     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import socket</span><br><span class="line">sk &#x3D; socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">sk.setsockopt</span><br><span class="line">sk.bind((&#39;127.0.0.1&#39;,6667))</span><br><span class="line">sk.listen(5)</span><br><span class="line">sk.setblocking(False)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print (&#39;waiting client connection .......&#39;)</span><br><span class="line">        connection,address &#x3D; sk.accept()   # 进程主动轮询</span><br><span class="line">        print(&quot;+++&quot;,address)</span><br><span class="line">        client_messge &#x3D; connection.recv(1024)</span><br><span class="line">        print(str(client_messge,&#39;utf8&#39;))</span><br><span class="line">        connection.close()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print (e)</span><br><span class="line">        time.sleep(4)</span><br><span class="line"></span><br><span class="line">#############################client</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import socket</span><br><span class="line">sk &#x3D; socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    sk.connect((&#39;127.0.0.1&#39;,6667))</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">    sk.sendall(bytes(&quot;hello&quot;,&quot;utf8&quot;))</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    break</span><br></pre></td></tr></table></figure>
<p>​      优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p>
<p>　　缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p>
<p>实例2(IO multiplexing):</p>
<p>在非阻塞实例中，轮询的主语是进程，而“后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。不过，这个监听的重任通过调用select等函数交给了内核去做。IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvfrom系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。</p>
<p><strong>实例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line">sk&#x3D;socket.socket()</span><br><span class="line">sk.bind((&quot;127.0.0.1&quot;,9904))</span><br><span class="line">sk.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    r,w,e&#x3D;select.select([sk,],[],[],5)</span><br><span class="line">    for i in r:</span><br><span class="line">        # conn,add&#x3D;i.accept()</span><br><span class="line">        #print(conn)</span><br><span class="line">        print(&quot;hello&quot;)</span><br><span class="line">    print(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)</span><br><span class="line">    </span><br><span class="line">#*************************client.py</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">sk&#x3D;socket.socket()</span><br><span class="line"></span><br><span class="line">sk.connect((&quot;127.0.0.1&quot;,9904))</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    inp&#x3D;input(&quot;&gt;&gt;&quot;).strip()</span><br><span class="line">    sk.send(inp.encode(&quot;utf8&quot;))</span><br><span class="line">    data&#x3D;sk.recv(1024)</span><br><span class="line">    print(data.decode(&quot;utf8&quot;))</span><br></pre></td></tr></table></figure>
<p>请思考：为什么不调用accept，会反复print？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select属于水平触发</span><br></pre></td></tr></table></figure>
<p><strong>实例3(server端并发聊天):</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#***********************server.py</span><br><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line">sk&#x3D;socket.socket()</span><br><span class="line">sk.bind((&quot;127.0.0.1&quot;,8801))</span><br><span class="line">sk.listen(5)</span><br><span class="line">inputs&#x3D;[sk,]</span><br><span class="line">while True:</span><br><span class="line">    r,w,e&#x3D;select.select(inputs,[],[],5)</span><br><span class="line">    print(len(r))</span><br><span class="line"></span><br><span class="line">    for obj in r:</span><br><span class="line">        if obj&#x3D;&#x3D;sk:</span><br><span class="line">            conn,add&#x3D;obj.accept()</span><br><span class="line">            print(conn)</span><br><span class="line">            inputs.append(conn)</span><br><span class="line">        else:</span><br><span class="line">            data_byte&#x3D;obj.recv(1024)</span><br><span class="line">            print(str(data_byte,&#39;utf8&#39;))</span><br><span class="line">            inp&#x3D;input(&#39;回答%s号客户&gt;&gt;&gt;&#39;%inputs.index(obj))</span><br><span class="line">            obj.sendall(bytes(inp,&#39;utf8&#39;))</span><br><span class="line"></span><br><span class="line">    print(&#39;&gt;&gt;&#39;,r)</span><br><span class="line"></span><br><span class="line">#***********************client.py</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line">sk&#x3D;socket.socket()</span><br><span class="line">sk.connect((&#39;127.0.0.1&#39;,8801))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    inp&#x3D;input(&quot;&gt;&gt;&gt;&gt;&quot;)</span><br><span class="line">    sk.sendall(bytes(inp,&quot;utf8&quot;))</span><br><span class="line">    data&#x3D;sk.recv(1024)</span><br><span class="line">    print(str(data,&#39;utf8&#39;))</span><br></pre></td></tr></table></figure>
<p>文件描述符其实就是咱们平时说的句柄，只不过文件描述符是linux中的概念。注意，我们的accept或recv调用时即向系统发出recvfrom请求</p>
<p>​    (1)  如果内核缓冲区没有数据－－－&gt;等待－－－&gt;数据到了内核缓冲区，转到用户进程缓冲区；</p>
<p>​    (2) 如果先用select监听到某个文件描述符对应的内核缓冲区有了数据，当我们再调用accept或recv时，直接将数据转到用户缓冲区。</p>
<p><img src="image/877318-20160817132355390-1351277519.png" alt="img"></p>
<p>思考1：开启5个client，分别按54321的顺序发送消息，那么server端是按什么顺序回消息的呢？</p>
<p>思考2:  如何在某一个client端退出后，不影响server端和其它客户端正常交流</p>
<p>linux：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if not data_byte:</span><br><span class="line">            inputs.remove(obj)</span><br><span class="line">            continue</span><br></pre></td></tr></table></figure>
<p>win</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">      data_byte&#x3D;obj.recv(1024)</span><br><span class="line">      print(str(data_byte,&#39;utf8&#39;))</span><br><span class="line">      inp&#x3D;input(&#39;回答%s号客户&gt;&gt;&gt;&#39;%inputs.index(obj))</span><br><span class="line">      obj.sendall(bytes(inp,&#39;utf8&#39;))</span><br><span class="line">except Exception:</span><br><span class="line">      inputs.remove(obj)</span><br></pre></td></tr></table></figure>
<h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p><strong>实例4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ &#x3D; &#39;Alex Li&#39;</span><br><span class="line"> </span><br><span class="line">import select</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line">import queue</span><br><span class="line"> </span><br><span class="line"># Create a TCP&#x2F;IP socket</span><br><span class="line">server &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.setblocking(False)</span><br><span class="line"> </span><br><span class="line"># Bind the socket to the port</span><br><span class="line">server_address &#x3D; (&#39;localhost&#39;, 10000)</span><br><span class="line">print(sys.stderr, &#39;starting up on %s port %s&#39; % server_address)</span><br><span class="line">server.bind(server_address)</span><br><span class="line"> </span><br><span class="line"># Listen for incoming connections</span><br><span class="line">server.listen(5)</span><br><span class="line"> </span><br><span class="line"># Sockets from which we expect to read</span><br><span class="line">inputs &#x3D; [ server ]</span><br><span class="line"> </span><br><span class="line"># Sockets to which we expect to write</span><br><span class="line">outputs &#x3D; [ ]</span><br><span class="line"> </span><br><span class="line">message_queues &#x3D; &#123;&#125;</span><br><span class="line">while inputs:</span><br><span class="line"> </span><br><span class="line">    # Wait for at least one of the sockets to be ready for processing</span><br><span class="line">    print( &#39;\nwaiting for the next event&#39;)</span><br><span class="line">    readable, writable, exceptional &#x3D; select.select(inputs, outputs, inputs)</span><br><span class="line">    # Handle inputs</span><br><span class="line">    for s in readable:</span><br><span class="line"> </span><br><span class="line">        if s is server:</span><br><span class="line">            # A &quot;readable&quot; server socket is ready to accept a connection</span><br><span class="line">            connection, client_address &#x3D; s.accept()</span><br><span class="line">            print(&#39;new connection from&#39;, client_address)</span><br><span class="line">            connection.setblocking(False)</span><br><span class="line">            inputs.append(connection)</span><br><span class="line"> </span><br><span class="line">            # Give the connection a queue for data we want to send</span><br><span class="line">            message_queues[connection] &#x3D; queue.Queue()</span><br><span class="line">        else:</span><br><span class="line">            data &#x3D; s.recv(1024)</span><br><span class="line">            if data:</span><br><span class="line">                # A readable client socket has data</span><br><span class="line">                print(sys.stderr, &#39;received &quot;%s&quot; from %s&#39; % (data, s.getpeername()) )</span><br><span class="line">                message_queues[s].put(data)</span><br><span class="line">                # Add output channel for response</span><br><span class="line">                if s not in outputs:</span><br><span class="line">                    outputs.append(s)</span><br><span class="line">            else:</span><br><span class="line">                # Interpret empty result as closed connection</span><br><span class="line">                print(&#39;closing&#39;, client_address, &#39;after reading no data&#39;)</span><br><span class="line">                # Stop listening for input on the connection</span><br><span class="line">                if s in outputs:</span><br><span class="line">                    outputs.remove(s)  #既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉</span><br><span class="line">                inputs.remove(s)    #inputs中也删除掉</span><br><span class="line">                s.close()           #把这个连接关闭掉</span><br><span class="line"> </span><br><span class="line">                # Remove message queue</span><br><span class="line">                del message_queues[s]</span><br><span class="line">    # Handle outputs</span><br><span class="line">    for s in writable:</span><br><span class="line">        try:</span><br><span class="line">            next_msg &#x3D; message_queues[s].get_nowait()</span><br><span class="line">        except queue.Empty:</span><br><span class="line">            # No messages waiting so stop checking for writability.</span><br><span class="line">            print(&#39;output queue for&#39;, s.getpeername(), &#39;is empty&#39;)</span><br><span class="line">            outputs.remove(s)</span><br><span class="line">        else:</span><br><span class="line">            print( &#39;sending &quot;%s&quot; to %s&#39; % (next_msg, s.getpeername()))</span><br><span class="line">            s.send(next_msg)</span><br><span class="line">    # Handle &quot;exceptional conditions&quot;</span><br><span class="line">    for s in exceptional:</span><br><span class="line">        print(&#39;handling exceptional condition for&#39;, s.getpeername() )</span><br><span class="line">        # Stop listening for input on the connection</span><br><span class="line">        inputs.remove(s)</span><br><span class="line">        if s in outputs:</span><br><span class="line">            outputs.remove(s)</span><br><span class="line">        s.close()</span><br><span class="line"> </span><br><span class="line">        # Remove message queue</span><br><span class="line">        del message_queues[s]</span><br></pre></td></tr></table></figure>
<p><strong>实例5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># select 模拟一个socket server，注意socket必须在非阻塞情况下才能实现IO多路复用。</span><br><span class="line"># 接下来通过例子了解select 是如何通过单进程实现同时处理多个非阻塞的socket连接的。</span><br><span class="line">#server端</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import select</span><br><span class="line">import socket</span><br><span class="line">import queue</span><br><span class="line"></span><br><span class="line">server &#x3D; socket.socket()</span><br><span class="line">server.bind((&#39;localhost&#39;,9000))</span><br><span class="line">server.listen(1000)</span><br><span class="line"></span><br><span class="line">server.setblocking(False)  # 设置成非阻塞模式，accept和recv都非阻塞</span><br><span class="line"># 这里如果直接 server.accept() ，如果没有连接会报错，所以有数据才调他们</span><br><span class="line"># BlockIOError：[WinError 10035] 无法立即完成一个非阻塞性套接字操作。</span><br><span class="line">msg_dic &#x3D; &#123;&#125;</span><br><span class="line">inputs &#x3D; [server,]  # 交给内核、select检测的列表。</span><br><span class="line"># 必须有一个值，让select检测，否则报错提供无效参数。</span><br><span class="line"># 没有其他连接之前，自己就是个socket，自己就是个连接，检测自己。活动了说明有链接</span><br><span class="line">outputs &#x3D; []  # 你往里面放什么，下一次就出来了</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    readable, writeable, exceptional &#x3D; select.select(inputs, outputs, inputs)  # 定义检测</span><br><span class="line">    #新来连接                                        检测列表         异常（断开）</span><br><span class="line">    # 异常的也是inputs是： 检测那些连接的存在异常</span><br><span class="line">    print(readable,writeable,exceptional)</span><br><span class="line">    for r in readable:</span><br><span class="line">        if r is server:  # 有数据，代表来了一个新连接</span><br><span class="line">            conn, addr &#x3D; server.accept()</span><br><span class="line">            print(&quot;来了个新连接&quot;,addr)</span><br><span class="line">            inputs.append(conn)  # 把连接加到检测列表里，如果这个连接活动了，就说明数据来了</span><br><span class="line">            # inputs &#x3D; [server.conn] # 【conn】只返回活动的连接，但怎么确定是谁活动了</span><br><span class="line">            # 如果server活动，则来了新连接，conn活动则来数据</span><br><span class="line">            msg_dic[conn] &#x3D; queue.Queue()  # 初始化一个队列，后面存要返回给这个客户端的数据</span><br><span class="line">        else:</span><br><span class="line">            try :</span><br><span class="line">                data &#x3D; r.recv(1024)  # 注意这里是r，而不是conn，多个连接的情况</span><br><span class="line">                print(&quot;收到数据&quot;,data)</span><br><span class="line">                # r.send(data) # 不能直接发，如果客户端不收，数据就没了</span><br><span class="line">                msg_dic[r].put(data)  # 往里面放数据</span><br><span class="line">                outputs.append(r)  # 放入返回的连接队列里</span><br><span class="line">            except ConnectionResetError as e:</span><br><span class="line">                print(&quot;客户端断开了&quot;,r)</span><br><span class="line">                if r in outputs:</span><br><span class="line">                    outputs.remove(r) #清理已断开的连接</span><br><span class="line">                inputs.remove(r) #清理已断开的连接</span><br><span class="line">                del msg_dic[r] ##清理已断开的连接</span><br><span class="line"></span><br><span class="line">    for w in writeable:  # 要返回给客户端的连接列表</span><br><span class="line">        data_to_client &#x3D; msg_dic[w].get()  # 在字典里取数据</span><br><span class="line">        w.send(data_to_client)  # 返回给客户端</span><br><span class="line">        outputs.remove(w)  # 删除这个数据，确保下次循环的时候不返回这个已经处理完的连接了。</span><br><span class="line"></span><br><span class="line">    for e in exceptional:  # 如果连接断开，删除连接相关数据</span><br><span class="line">        if e in outputs:</span><br><span class="line">            outputs.remove(e)</span><br><span class="line">        inputs.remove(e)</span><br><span class="line">        del msg_dic[e]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#*************************client</span><br><span class="line">import socket</span><br><span class="line">client &#x3D; socket.socket()</span><br><span class="line"></span><br><span class="line">client.connect((&#39;localhost&#39;, 9000))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    cmd &#x3D; input(&#39;&gt;&gt;&gt; &#39;).strip()</span><br><span class="line">    if len(cmd) &#x3D;&#x3D; 0 : continue</span><br><span class="line">    client.send(cmd.encode(&#39;utf-8&#39;))</span><br><span class="line">    data &#x3D; client.recv(1024)</span><br><span class="line">    print(data.decode())</span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>
<p><strong>实例6:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import selectors</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">sel &#x3D; selectors.DefaultSelector()</span><br><span class="line"></span><br><span class="line">def accept(sock, mask):</span><br><span class="line">    conn, addr &#x3D; sock.accept()  # Should be ready</span><br><span class="line">    print(&#39;accepted&#39;, conn, &#39;from&#39;, addr)</span><br><span class="line">    conn.setblocking(False)</span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line">def read(conn, mask):</span><br><span class="line">    data &#x3D; conn.recv(1000)  # Should be ready</span><br><span class="line">    if data:</span><br><span class="line">        print(&#39;echoing&#39;, repr(data), &#39;to&#39;, conn)</span><br><span class="line">        conn.send(data)  # Hope it won&#39;t block</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;closing&#39;, conn)</span><br><span class="line">        sel.unregister(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">sock &#x3D; socket.socket()</span><br><span class="line">sock.bind((&#39;localhost&#39;, 1234))</span><br><span class="line">sock.listen(100)</span><br><span class="line">sock.setblocking(False)</span><br><span class="line">sel.register(sock, selectors.EVENT_READ, accept)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    events &#x3D; sel.select()</span><br><span class="line">    for key, mask in events:</span><br><span class="line">        callback &#x3D; key.data</span><br><span class="line">        callback(key.fileobj, mask)</span><br></pre></td></tr></table></figure>
<p>注：本文最重要的参考文献是Richard Stevens的“<strong>UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking</strong> ”      <a href="http://mp.weixin.qq.com/s__biz=MzA4MjEyNTA5Mw==&amp;mid=2652563599&amp;idx=1&amp;sn=9781747e54d906c0c140228376e671ed&amp;scene=21#wecha" target="_blank" rel="noopener">http://mp.weixin.qq.com/s__biz=MzA4MjEyNTA5Mw==&amp;mid=2652563599&amp;idx=1&amp;sn=9781747e54d906c0c140228376e671ed&amp;scene=21#wecha</a> t_redirect</p>
<p><a href="https://pymotw.com/2/select/#module-select" target="_blank" rel="noopener">https://pymotw.com/2/select/#module-select</a></p>
<p><a href="http://blog.csdn.net/lingfengtengfei/article/details/12392449" target="_blank" rel="noopener">http://blog.csdn.net/lingfengtengfei/article/details/12392449</a></p>
<p><a href="http://www.jb51.net/article/37416.htm" target="_blank" rel="noopener">http://www.jb51.net/article/37416.htm</a></p>
<p><a href="https://pymotw.com/2/select/#module-select" target="_blank" rel="noopener">https://pymotw.com/2/select/#module-select</a> </p>
]]></content>
      <categories>
        <category>Python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
